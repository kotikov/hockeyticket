/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// node_modules/@stdlib/math-base-assert-is-nan/lib/main.js
var require_main = __commonJS({
  "node_modules/@stdlib/math-base-assert-is-nan/lib/main.js"(exports, module2) {
    "use strict";
    function isnan(x) {
      return x !== x;
    }
    module2.exports = isnan;
  }
});

// node_modules/@stdlib/math-base-assert-is-nan/lib/index.js
var require_lib = __commonJS({
  "node_modules/@stdlib/math-base-assert-is-nan/lib/index.js"(exports, module2) {
    "use strict";
    var isnan = require_main();
    module2.exports = isnan;
  }
});

// node_modules/@stdlib/constants-float64-pinf/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/@stdlib/constants-float64-pinf/lib/index.js"(exports, module2) {
    "use strict";
    var FLOAT64_PINF = Number.POSITIVE_INFINITY;
    module2.exports = FLOAT64_PINF;
  }
});

// node_modules/@stdlib/number-ctor/lib/number.js
var require_number = __commonJS({
  "node_modules/@stdlib/number-ctor/lib/number.js"(exports, module2) {
    "use strict";
    module2.exports = Number;
  }
});

// node_modules/@stdlib/number-ctor/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/@stdlib/number-ctor/lib/index.js"(exports, module2) {
    "use strict";
    var Number2 = require_number();
    module2.exports = Number2;
  }
});

// node_modules/@stdlib/constants-float64-ninf/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/@stdlib/constants-float64-ninf/lib/index.js"(exports, module2) {
    "use strict";
    var Number2 = require_lib3();
    var FLOAT64_NINF = Number2.NEGATIVE_INFINITY;
    module2.exports = FLOAT64_NINF;
  }
});

// node_modules/@stdlib/math-base-assert-is-infinite/lib/main.js
var require_main2 = __commonJS({
  "node_modules/@stdlib/math-base-assert-is-infinite/lib/main.js"(exports, module2) {
    "use strict";
    var PINF = require_lib2();
    var NINF = require_lib4();
    function isInfinite(x) {
      return x === PINF || x === NINF;
    }
    module2.exports = isInfinite;
  }
});

// node_modules/@stdlib/math-base-assert-is-infinite/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/@stdlib/math-base-assert-is-infinite/lib/index.js"(exports, module2) {
    "use strict";
    var isInfinite = require_main2();
    module2.exports = isInfinite;
  }
});

// node_modules/@stdlib/math-base-special-floor/lib/main.js
var require_main3 = __commonJS({
  "node_modules/@stdlib/math-base-special-floor/lib/main.js"(exports, module2) {
    "use strict";
    var floor = Math.floor;
    module2.exports = floor;
  }
});

// node_modules/@stdlib/math-base-special-floor/lib/index.js
var require_lib6 = __commonJS({
  "node_modules/@stdlib/math-base-special-floor/lib/index.js"(exports, module2) {
    "use strict";
    var floor = require_main3();
    module2.exports = floor;
  }
});

// node_modules/@stdlib/math-base-assert-is-integer/lib/is_integer.js
var require_is_integer = __commonJS({
  "node_modules/@stdlib/math-base-assert-is-integer/lib/is_integer.js"(exports, module2) {
    "use strict";
    var floor = require_lib6();
    function isInteger(x) {
      return floor(x) === x;
    }
    module2.exports = isInteger;
  }
});

// node_modules/@stdlib/math-base-assert-is-integer/lib/index.js
var require_lib7 = __commonJS({
  "node_modules/@stdlib/math-base-assert-is-integer/lib/index.js"(exports, module2) {
    "use strict";
    var isInteger = require_is_integer();
    module2.exports = isInteger;
  }
});

// node_modules/@stdlib/math-base-assert-is-even/lib/is_even.js
var require_is_even = __commonJS({
  "node_modules/@stdlib/math-base-assert-is-even/lib/is_even.js"(exports, module2) {
    "use strict";
    var isInteger = require_lib7();
    function isEven(x) {
      return isInteger(x / 2);
    }
    module2.exports = isEven;
  }
});

// node_modules/@stdlib/math-base-assert-is-even/lib/index.js
var require_lib8 = __commonJS({
  "node_modules/@stdlib/math-base-assert-is-even/lib/index.js"(exports, module2) {
    "use strict";
    var isEven = require_is_even();
    module2.exports = isEven;
  }
});

// node_modules/@stdlib/math-base-assert-is-odd/lib/is_odd.js
var require_is_odd = __commonJS({
  "node_modules/@stdlib/math-base-assert-is-odd/lib/is_odd.js"(exports, module2) {
    "use strict";
    var isEven = require_lib8();
    function isOdd(x) {
      if (x > 0) {
        return isEven(x - 1);
      }
      return isEven(x + 1);
    }
    module2.exports = isOdd;
  }
});

// node_modules/@stdlib/math-base-assert-is-odd/lib/index.js
var require_lib9 = __commonJS({
  "node_modules/@stdlib/math-base-assert-is-odd/lib/index.js"(exports, module2) {
    "use strict";
    var isOdd = require_is_odd();
    module2.exports = isOdd;
  }
});

// node_modules/@stdlib/math-base-special-sqrt/lib/main.js
var require_main4 = __commonJS({
  "node_modules/@stdlib/math-base-special-sqrt/lib/main.js"(exports, module2) {
    "use strict";
    var sqrt = Math.sqrt;
    module2.exports = sqrt;
  }
});

// node_modules/@stdlib/math-base-special-sqrt/lib/index.js
var require_lib10 = __commonJS({
  "node_modules/@stdlib/math-base-special-sqrt/lib/index.js"(exports, module2) {
    "use strict";
    var sqrt = require_main4();
    module2.exports = sqrt;
  }
});

// node_modules/@stdlib/math-base-special-abs/lib/main.js
var require_main5 = __commonJS({
  "node_modules/@stdlib/math-base-special-abs/lib/main.js"(exports, module2) {
    "use strict";
    function abs(x) {
      return Math.abs(x);
    }
    module2.exports = abs;
  }
});

// node_modules/@stdlib/math-base-special-abs/lib/index.js
var require_lib11 = __commonJS({
  "node_modules/@stdlib/math-base-special-abs/lib/index.js"(exports, module2) {
    "use strict";
    var abs = require_main5();
    module2.exports = abs;
  }
});

// node_modules/@stdlib/assert-has-symbol-support/lib/main.js
var require_main6 = __commonJS({
  "node_modules/@stdlib/assert-has-symbol-support/lib/main.js"(exports, module2) {
    "use strict";
    function hasSymbolSupport() {
      return typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
    }
    module2.exports = hasSymbolSupport;
  }
});

// node_modules/@stdlib/assert-has-symbol-support/lib/index.js
var require_lib12 = __commonJS({
  "node_modules/@stdlib/assert-has-symbol-support/lib/index.js"(exports, module2) {
    "use strict";
    var hasSymbolSupport = require_main6();
    module2.exports = hasSymbolSupport;
  }
});

// node_modules/@stdlib/assert-has-tostringtag-support/lib/main.js
var require_main7 = __commonJS({
  "node_modules/@stdlib/assert-has-tostringtag-support/lib/main.js"(exports, module2) {
    "use strict";
    var hasSymbols = require_lib12();
    var FLG = hasSymbols();
    function hasToStringTagSupport() {
      return FLG && typeof Symbol.toStringTag === "symbol";
    }
    module2.exports = hasToStringTagSupport;
  }
});

// node_modules/@stdlib/assert-has-tostringtag-support/lib/index.js
var require_lib13 = __commonJS({
  "node_modules/@stdlib/assert-has-tostringtag-support/lib/index.js"(exports, module2) {
    "use strict";
    var hasToStringTagSupport = require_main7();
    module2.exports = hasToStringTagSupport;
  }
});

// node_modules/@stdlib/utils-native-class/lib/tostring.js
var require_tostring = __commonJS({
  "node_modules/@stdlib/utils-native-class/lib/tostring.js"(exports, module2) {
    "use strict";
    var toStr = Object.prototype.toString;
    module2.exports = toStr;
  }
});

// node_modules/@stdlib/utils-native-class/lib/native_class.js
var require_native_class = __commonJS({
  "node_modules/@stdlib/utils-native-class/lib/native_class.js"(exports, module2) {
    "use strict";
    var toStr = require_tostring();
    function nativeClass(v) {
      return toStr.call(v);
    }
    module2.exports = nativeClass;
  }
});

// node_modules/@stdlib/assert-has-own-property/lib/main.js
var require_main8 = __commonJS({
  "node_modules/@stdlib/assert-has-own-property/lib/main.js"(exports, module2) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    function hasOwnProp(value, property) {
      if (value === void 0 || value === null) {
        return false;
      }
      return has.call(value, property);
    }
    module2.exports = hasOwnProp;
  }
});

// node_modules/@stdlib/assert-has-own-property/lib/index.js
var require_lib14 = __commonJS({
  "node_modules/@stdlib/assert-has-own-property/lib/index.js"(exports, module2) {
    "use strict";
    var hasOwnProp = require_main8();
    module2.exports = hasOwnProp;
  }
});

// node_modules/@stdlib/utils-native-class/lib/tostringtag.js
var require_tostringtag = __commonJS({
  "node_modules/@stdlib/utils-native-class/lib/tostringtag.js"(exports, module2) {
    "use strict";
    var toStrTag = typeof Symbol === "function" ? Symbol.toStringTag : "";
    module2.exports = toStrTag;
  }
});

// node_modules/@stdlib/utils-native-class/lib/polyfill.js
var require_polyfill = __commonJS({
  "node_modules/@stdlib/utils-native-class/lib/polyfill.js"(exports, module2) {
    "use strict";
    var hasOwnProp = require_lib14();
    var toStringTag = require_tostringtag();
    var toStr = require_tostring();
    function nativeClass(v) {
      var isOwn;
      var tag;
      var out;
      if (v === null || v === void 0) {
        return toStr.call(v);
      }
      tag = v[toStringTag];
      isOwn = hasOwnProp(v, toStringTag);
      try {
        v[toStringTag] = void 0;
      } catch (err) {
        return toStr.call(v);
      }
      out = toStr.call(v);
      if (isOwn) {
        v[toStringTag] = tag;
      } else {
        delete v[toStringTag];
      }
      return out;
    }
    module2.exports = nativeClass;
  }
});

// node_modules/@stdlib/utils-native-class/lib/index.js
var require_lib15 = __commonJS({
  "node_modules/@stdlib/utils-native-class/lib/index.js"(exports, module2) {
    "use strict";
    var hasToStringTag = require_lib13();
    var builtin = require_native_class();
    var polyfill = require_polyfill();
    var nativeClass;
    if (hasToStringTag()) {
      nativeClass = polyfill;
    } else {
      nativeClass = builtin;
    }
    module2.exports = nativeClass;
  }
});

// node_modules/@stdlib/assert-is-uint32array/lib/main.js
var require_main9 = __commonJS({
  "node_modules/@stdlib/assert-is-uint32array/lib/main.js"(exports, module2) {
    "use strict";
    var nativeClass = require_lib15();
    var hasUint32Array = typeof Uint32Array === "function";
    function isUint32Array(value) {
      return hasUint32Array && value instanceof Uint32Array || nativeClass(value) === "[object Uint32Array]";
    }
    module2.exports = isUint32Array;
  }
});

// node_modules/@stdlib/assert-is-uint32array/lib/index.js
var require_lib16 = __commonJS({
  "node_modules/@stdlib/assert-is-uint32array/lib/index.js"(exports, module2) {
    "use strict";
    var isUint32Array = require_main9();
    module2.exports = isUint32Array;
  }
});

// node_modules/@stdlib/constants-uint32-max/lib/index.js
var require_lib17 = __commonJS({
  "node_modules/@stdlib/constants-uint32-max/lib/index.js"(exports, module2) {
    "use strict";
    var UINT32_MAX = 4294967295;
    module2.exports = UINT32_MAX;
  }
});

// node_modules/@stdlib/assert-has-uint32array-support/lib/uint32array.js
var require_uint32array = __commonJS({
  "node_modules/@stdlib/assert-has-uint32array-support/lib/uint32array.js"(exports, module2) {
    "use strict";
    var main = typeof Uint32Array === "function" ? Uint32Array : null;
    module2.exports = main;
  }
});

// node_modules/@stdlib/assert-has-uint32array-support/lib/main.js
var require_main10 = __commonJS({
  "node_modules/@stdlib/assert-has-uint32array-support/lib/main.js"(exports, module2) {
    "use strict";
    var isUint32Array = require_lib16();
    var UINT32_MAX = require_lib17();
    var GlobalUint32Array = require_uint32array();
    function hasUint32ArraySupport() {
      var bool;
      var arr;
      if (typeof GlobalUint32Array !== "function") {
        return false;
      }
      try {
        arr = [1, 3.14, -3.14, UINT32_MAX + 1, UINT32_MAX + 2];
        arr = new GlobalUint32Array(arr);
        bool = isUint32Array(arr) && arr[0] === 1 && arr[1] === 3 && arr[2] === UINT32_MAX - 2 && arr[3] === 0 && arr[4] === 1;
      } catch (err) {
        bool = false;
      }
      return bool;
    }
    module2.exports = hasUint32ArraySupport;
  }
});

// node_modules/@stdlib/assert-has-uint32array-support/lib/index.js
var require_lib18 = __commonJS({
  "node_modules/@stdlib/assert-has-uint32array-support/lib/index.js"(exports, module2) {
    "use strict";
    var hasUint32ArraySupport = require_main10();
    module2.exports = hasUint32ArraySupport;
  }
});

// node_modules/@stdlib/array-uint32/lib/uint32array.js
var require_uint32array2 = __commonJS({
  "node_modules/@stdlib/array-uint32/lib/uint32array.js"(exports, module2) {
    "use strict";
    var ctor = typeof Uint32Array === "function" ? Uint32Array : void 0;
    module2.exports = ctor;
  }
});

// node_modules/@stdlib/array-uint32/lib/polyfill.js
var require_polyfill2 = __commonJS({
  "node_modules/@stdlib/array-uint32/lib/polyfill.js"(exports, module2) {
    "use strict";
    function polyfill() {
      throw new Error("not implemented");
    }
    module2.exports = polyfill;
  }
});

// node_modules/@stdlib/array-uint32/lib/index.js
var require_lib19 = __commonJS({
  "node_modules/@stdlib/array-uint32/lib/index.js"(exports, module2) {
    "use strict";
    var hasUint32ArraySupport = require_lib18();
    var builtin = require_uint32array2();
    var polyfill = require_polyfill2();
    var ctor;
    if (hasUint32ArraySupport()) {
      ctor = builtin;
    } else {
      ctor = polyfill;
    }
    module2.exports = ctor;
  }
});

// node_modules/@stdlib/assert-is-float64array/lib/main.js
var require_main11 = __commonJS({
  "node_modules/@stdlib/assert-is-float64array/lib/main.js"(exports, module2) {
    "use strict";
    var nativeClass = require_lib15();
    var hasFloat64Array = typeof Float64Array === "function";
    function isFloat64Array(value) {
      return hasFloat64Array && value instanceof Float64Array || nativeClass(value) === "[object Float64Array]";
    }
    module2.exports = isFloat64Array;
  }
});

// node_modules/@stdlib/assert-is-float64array/lib/index.js
var require_lib20 = __commonJS({
  "node_modules/@stdlib/assert-is-float64array/lib/index.js"(exports, module2) {
    "use strict";
    var isFloat64Array = require_main11();
    module2.exports = isFloat64Array;
  }
});

// node_modules/@stdlib/assert-has-float64array-support/lib/float64array.js
var require_float64array = __commonJS({
  "node_modules/@stdlib/assert-has-float64array-support/lib/float64array.js"(exports, module2) {
    "use strict";
    var main = typeof Float64Array === "function" ? Float64Array : null;
    module2.exports = main;
  }
});

// node_modules/@stdlib/assert-has-float64array-support/lib/main.js
var require_main12 = __commonJS({
  "node_modules/@stdlib/assert-has-float64array-support/lib/main.js"(exports, module2) {
    "use strict";
    var isFloat64Array = require_lib20();
    var GlobalFloat64Array = require_float64array();
    function hasFloat64ArraySupport() {
      var bool;
      var arr;
      if (typeof GlobalFloat64Array !== "function") {
        return false;
      }
      try {
        arr = new GlobalFloat64Array([1, 3.14, -3.14, NaN]);
        bool = isFloat64Array(arr) && arr[0] === 1 && arr[1] === 3.14 && arr[2] === -3.14 && arr[3] !== arr[3];
      } catch (err) {
        bool = false;
      }
      return bool;
    }
    module2.exports = hasFloat64ArraySupport;
  }
});

// node_modules/@stdlib/assert-has-float64array-support/lib/index.js
var require_lib21 = __commonJS({
  "node_modules/@stdlib/assert-has-float64array-support/lib/index.js"(exports, module2) {
    "use strict";
    var hasFloat64ArraySupport = require_main12();
    module2.exports = hasFloat64ArraySupport;
  }
});

// node_modules/@stdlib/array-float64/lib/float64array.js
var require_float64array2 = __commonJS({
  "node_modules/@stdlib/array-float64/lib/float64array.js"(exports, module2) {
    "use strict";
    var ctor = typeof Float64Array === "function" ? Float64Array : void 0;
    module2.exports = ctor;
  }
});

// node_modules/@stdlib/array-float64/lib/polyfill.js
var require_polyfill3 = __commonJS({
  "node_modules/@stdlib/array-float64/lib/polyfill.js"(exports, module2) {
    "use strict";
    function polyfill() {
      throw new Error("not implemented");
    }
    module2.exports = polyfill;
  }
});

// node_modules/@stdlib/array-float64/lib/index.js
var require_lib22 = __commonJS({
  "node_modules/@stdlib/array-float64/lib/index.js"(exports, module2) {
    "use strict";
    var hasFloat64ArraySupport = require_lib21();
    var builtin = require_float64array2();
    var polyfill = require_polyfill3();
    var ctor;
    if (hasFloat64ArraySupport()) {
      ctor = builtin;
    } else {
      ctor = polyfill;
    }
    module2.exports = ctor;
  }
});

// node_modules/@stdlib/assert-is-uint8array/lib/main.js
var require_main13 = __commonJS({
  "node_modules/@stdlib/assert-is-uint8array/lib/main.js"(exports, module2) {
    "use strict";
    var nativeClass = require_lib15();
    var hasUint8Array = typeof Uint8Array === "function";
    function isUint8Array(value) {
      return hasUint8Array && value instanceof Uint8Array || nativeClass(value) === "[object Uint8Array]";
    }
    module2.exports = isUint8Array;
  }
});

// node_modules/@stdlib/assert-is-uint8array/lib/index.js
var require_lib23 = __commonJS({
  "node_modules/@stdlib/assert-is-uint8array/lib/index.js"(exports, module2) {
    "use strict";
    var isUint8Array = require_main13();
    module2.exports = isUint8Array;
  }
});

// node_modules/@stdlib/constants-uint8-max/lib/index.js
var require_lib24 = __commonJS({
  "node_modules/@stdlib/constants-uint8-max/lib/index.js"(exports, module2) {
    "use strict";
    var UINT8_MAX = 255 | 0;
    module2.exports = UINT8_MAX;
  }
});

// node_modules/@stdlib/assert-has-uint8array-support/lib/uint8array.js
var require_uint8array = __commonJS({
  "node_modules/@stdlib/assert-has-uint8array-support/lib/uint8array.js"(exports, module2) {
    "use strict";
    var main = typeof Uint8Array === "function" ? Uint8Array : null;
    module2.exports = main;
  }
});

// node_modules/@stdlib/assert-has-uint8array-support/lib/main.js
var require_main14 = __commonJS({
  "node_modules/@stdlib/assert-has-uint8array-support/lib/main.js"(exports, module2) {
    "use strict";
    var isUint8Array = require_lib23();
    var UINT8_MAX = require_lib24();
    var GlobalUint8Array = require_uint8array();
    function hasUint8ArraySupport() {
      var bool;
      var arr;
      if (typeof GlobalUint8Array !== "function") {
        return false;
      }
      try {
        arr = [1, 3.14, -3.14, UINT8_MAX + 1, UINT8_MAX + 2];
        arr = new GlobalUint8Array(arr);
        bool = isUint8Array(arr) && arr[0] === 1 && arr[1] === 3 && arr[2] === UINT8_MAX - 2 && arr[3] === 0 && arr[4] === 1;
      } catch (err) {
        bool = false;
      }
      return bool;
    }
    module2.exports = hasUint8ArraySupport;
  }
});

// node_modules/@stdlib/assert-has-uint8array-support/lib/index.js
var require_lib25 = __commonJS({
  "node_modules/@stdlib/assert-has-uint8array-support/lib/index.js"(exports, module2) {
    "use strict";
    var hasUint8ArraySupport = require_main14();
    module2.exports = hasUint8ArraySupport;
  }
});

// node_modules/@stdlib/array-uint8/lib/uint8array.js
var require_uint8array2 = __commonJS({
  "node_modules/@stdlib/array-uint8/lib/uint8array.js"(exports, module2) {
    "use strict";
    var ctor = typeof Uint8Array === "function" ? Uint8Array : void 0;
    module2.exports = ctor;
  }
});

// node_modules/@stdlib/array-uint8/lib/polyfill.js
var require_polyfill4 = __commonJS({
  "node_modules/@stdlib/array-uint8/lib/polyfill.js"(exports, module2) {
    "use strict";
    function polyfill() {
      throw new Error("not implemented");
    }
    module2.exports = polyfill;
  }
});

// node_modules/@stdlib/array-uint8/lib/index.js
var require_lib26 = __commonJS({
  "node_modules/@stdlib/array-uint8/lib/index.js"(exports, module2) {
    "use strict";
    var hasUint8ArraySupport = require_lib25();
    var builtin = require_uint8array2();
    var polyfill = require_polyfill4();
    var ctor;
    if (hasUint8ArraySupport()) {
      ctor = builtin;
    } else {
      ctor = polyfill;
    }
    module2.exports = ctor;
  }
});

// node_modules/@stdlib/assert-is-uint16array/lib/main.js
var require_main15 = __commonJS({
  "node_modules/@stdlib/assert-is-uint16array/lib/main.js"(exports, module2) {
    "use strict";
    var nativeClass = require_lib15();
    var hasUint16Array = typeof Uint16Array === "function";
    function isUint16Array(value) {
      return hasUint16Array && value instanceof Uint16Array || nativeClass(value) === "[object Uint16Array]";
    }
    module2.exports = isUint16Array;
  }
});

// node_modules/@stdlib/assert-is-uint16array/lib/index.js
var require_lib27 = __commonJS({
  "node_modules/@stdlib/assert-is-uint16array/lib/index.js"(exports, module2) {
    "use strict";
    var isUint16Array = require_main15();
    module2.exports = isUint16Array;
  }
});

// node_modules/@stdlib/constants-uint16-max/lib/index.js
var require_lib28 = __commonJS({
  "node_modules/@stdlib/constants-uint16-max/lib/index.js"(exports, module2) {
    "use strict";
    var UINT16_MAX = 65535 | 0;
    module2.exports = UINT16_MAX;
  }
});

// node_modules/@stdlib/assert-has-uint16array-support/lib/uint16array.js
var require_uint16array = __commonJS({
  "node_modules/@stdlib/assert-has-uint16array-support/lib/uint16array.js"(exports, module2) {
    "use strict";
    var main = typeof Uint16Array === "function" ? Uint16Array : null;
    module2.exports = main;
  }
});

// node_modules/@stdlib/assert-has-uint16array-support/lib/main.js
var require_main16 = __commonJS({
  "node_modules/@stdlib/assert-has-uint16array-support/lib/main.js"(exports, module2) {
    "use strict";
    var isUint16Array = require_lib27();
    var UINT16_MAX = require_lib28();
    var GlobalUint16Array = require_uint16array();
    function hasUint16ArraySupport() {
      var bool;
      var arr;
      if (typeof GlobalUint16Array !== "function") {
        return false;
      }
      try {
        arr = [1, 3.14, -3.14, UINT16_MAX + 1, UINT16_MAX + 2];
        arr = new GlobalUint16Array(arr);
        bool = isUint16Array(arr) && arr[0] === 1 && arr[1] === 3 && arr[2] === UINT16_MAX - 2 && arr[3] === 0 && arr[4] === 1;
      } catch (err) {
        bool = false;
      }
      return bool;
    }
    module2.exports = hasUint16ArraySupport;
  }
});

// node_modules/@stdlib/assert-has-uint16array-support/lib/index.js
var require_lib29 = __commonJS({
  "node_modules/@stdlib/assert-has-uint16array-support/lib/index.js"(exports, module2) {
    "use strict";
    var hasUint16ArraySupport = require_main16();
    module2.exports = hasUint16ArraySupport;
  }
});

// node_modules/@stdlib/array-uint16/lib/uint16array.js
var require_uint16array2 = __commonJS({
  "node_modules/@stdlib/array-uint16/lib/uint16array.js"(exports, module2) {
    "use strict";
    var ctor = typeof Uint16Array === "function" ? Uint16Array : void 0;
    module2.exports = ctor;
  }
});

// node_modules/@stdlib/array-uint16/lib/polyfill.js
var require_polyfill5 = __commonJS({
  "node_modules/@stdlib/array-uint16/lib/polyfill.js"(exports, module2) {
    "use strict";
    function polyfill() {
      throw new Error("not implemented");
    }
    module2.exports = polyfill;
  }
});

// node_modules/@stdlib/array-uint16/lib/index.js
var require_lib30 = __commonJS({
  "node_modules/@stdlib/array-uint16/lib/index.js"(exports, module2) {
    "use strict";
    var hasUint16ArraySupport = require_lib29();
    var builtin = require_uint16array2();
    var polyfill = require_polyfill5();
    var ctor;
    if (hasUint16ArraySupport()) {
      ctor = builtin;
    } else {
      ctor = polyfill;
    }
    module2.exports = ctor;
  }
});

// node_modules/@stdlib/assert-is-little-endian/lib/ctors.js
var require_ctors = __commonJS({
  "node_modules/@stdlib/assert-is-little-endian/lib/ctors.js"(exports, module2) {
    "use strict";
    var Uint8Array2 = require_lib26();
    var Uint16Array2 = require_lib30();
    var ctors = {
      "uint16": Uint16Array2,
      "uint8": Uint8Array2
    };
    module2.exports = ctors;
  }
});

// node_modules/@stdlib/assert-is-little-endian/lib/main.js
var require_main17 = __commonJS({
  "node_modules/@stdlib/assert-is-little-endian/lib/main.js"(exports, module2) {
    "use strict";
    var ctors = require_ctors();
    var bool;
    function isLittleEndian() {
      var uint16view;
      var uint8view;
      uint16view = new ctors["uint16"](1);
      uint16view[0] = 4660;
      uint8view = new ctors["uint8"](uint16view.buffer);
      return uint8view[0] === 52;
    }
    bool = isLittleEndian();
    module2.exports = bool;
  }
});

// node_modules/@stdlib/assert-is-little-endian/lib/index.js
var require_lib31 = __commonJS({
  "node_modules/@stdlib/assert-is-little-endian/lib/index.js"(exports, module2) {
    "use strict";
    var IS_LITTLE_ENDIAN = require_main17();
    module2.exports = IS_LITTLE_ENDIAN;
  }
});

// node_modules/@stdlib/number-float64-base-to-words/lib/indices.js
var require_indices = __commonJS({
  "node_modules/@stdlib/number-float64-base-to-words/lib/indices.js"(exports, module2) {
    "use strict";
    var isLittleEndian = require_lib31();
    var indices;
    var HIGH;
    var LOW;
    if (isLittleEndian === true) {
      HIGH = 1;
      LOW = 0;
    } else {
      HIGH = 0;
      LOW = 1;
    }
    indices = {
      "HIGH": HIGH,
      "LOW": LOW
    };
    module2.exports = indices;
  }
});

// node_modules/@stdlib/number-float64-base-to-words/lib/to_words.js
var require_to_words = __commonJS({
  "node_modules/@stdlib/number-float64-base-to-words/lib/to_words.js"(exports, module2) {
    "use strict";
    var Uint32Array2 = require_lib19();
    var Float64Array2 = require_lib22();
    var indices = require_indices();
    var FLOAT64_VIEW = new Float64Array2(1);
    var UINT32_VIEW = new Uint32Array2(FLOAT64_VIEW.buffer);
    var HIGH = indices.HIGH;
    var LOW = indices.LOW;
    function toWords(out, x) {
      FLOAT64_VIEW[0] = x;
      out[0] = UINT32_VIEW[HIGH];
      out[1] = UINT32_VIEW[LOW];
      return out;
    }
    module2.exports = toWords;
  }
});

// node_modules/@stdlib/number-float64-base-to-words/lib/main.js
var require_main18 = __commonJS({
  "node_modules/@stdlib/number-float64-base-to-words/lib/main.js"(exports, module2) {
    "use strict";
    var fcn = require_to_words();
    function toWords(out, x) {
      if (arguments.length === 1) {
        return fcn([0, 0], out);
      }
      return fcn(out, x);
    }
    module2.exports = toWords;
  }
});

// node_modules/@stdlib/number-float64-base-to-words/lib/index.js
var require_lib32 = __commonJS({
  "node_modules/@stdlib/number-float64-base-to-words/lib/index.js"(exports, module2) {
    "use strict";
    var toWords = require_main18();
    module2.exports = toWords;
  }
});

// node_modules/@stdlib/number-float64-base-set-low-word/lib/low.js
var require_low = __commonJS({
  "node_modules/@stdlib/number-float64-base-set-low-word/lib/low.js"(exports, module2) {
    "use strict";
    var isLittleEndian = require_lib31();
    var LOW;
    if (isLittleEndian === true) {
      LOW = 0;
    } else {
      LOW = 1;
    }
    module2.exports = LOW;
  }
});

// node_modules/@stdlib/number-float64-base-set-low-word/lib/main.js
var require_main19 = __commonJS({
  "node_modules/@stdlib/number-float64-base-set-low-word/lib/main.js"(exports, module2) {
    "use strict";
    var Uint32Array2 = require_lib19();
    var Float64Array2 = require_lib22();
    var LOW = require_low();
    var FLOAT64_VIEW = new Float64Array2(1);
    var UINT32_VIEW = new Uint32Array2(FLOAT64_VIEW.buffer);
    function setLowWord(x, low) {
      FLOAT64_VIEW[0] = x;
      UINT32_VIEW[LOW] = low >>> 0;
      return FLOAT64_VIEW[0];
    }
    module2.exports = setLowWord;
  }
});

// node_modules/@stdlib/number-float64-base-set-low-word/lib/index.js
var require_lib33 = __commonJS({
  "node_modules/@stdlib/number-float64-base-set-low-word/lib/index.js"(exports, module2) {
    "use strict";
    var setLowWord = require_main19();
    module2.exports = setLowWord;
  }
});

// node_modules/@stdlib/number-uint32-base-to-int32/lib/main.js
var require_main20 = __commonJS({
  "node_modules/@stdlib/number-uint32-base-to-int32/lib/main.js"(exports, module2) {
    "use strict";
    function uint32ToInt32(x) {
      return x | 0;
    }
    module2.exports = uint32ToInt32;
  }
});

// node_modules/@stdlib/number-uint32-base-to-int32/lib/index.js
var require_lib34 = __commonJS({
  "node_modules/@stdlib/number-uint32-base-to-int32/lib/index.js"(exports, module2) {
    "use strict";
    var uint32ToInt32 = require_main20();
    module2.exports = uint32ToInt32;
  }
});

// node_modules/@stdlib/number-float64-base-get-high-word/lib/high.js
var require_high = __commonJS({
  "node_modules/@stdlib/number-float64-base-get-high-word/lib/high.js"(exports, module2) {
    "use strict";
    var isLittleEndian = require_lib31();
    var HIGH;
    if (isLittleEndian === true) {
      HIGH = 1;
    } else {
      HIGH = 0;
    }
    module2.exports = HIGH;
  }
});

// node_modules/@stdlib/number-float64-base-get-high-word/lib/main.js
var require_main21 = __commonJS({
  "node_modules/@stdlib/number-float64-base-get-high-word/lib/main.js"(exports, module2) {
    "use strict";
    var Uint32Array2 = require_lib19();
    var Float64Array2 = require_lib22();
    var HIGH = require_high();
    var FLOAT64_VIEW = new Float64Array2(1);
    var UINT32_VIEW = new Uint32Array2(FLOAT64_VIEW.buffer);
    function getHighWord(x) {
      FLOAT64_VIEW[0] = x;
      return UINT32_VIEW[HIGH];
    }
    module2.exports = getHighWord;
  }
});

// node_modules/@stdlib/number-float64-base-get-high-word/lib/index.js
var require_lib35 = __commonJS({
  "node_modules/@stdlib/number-float64-base-get-high-word/lib/index.js"(exports, module2) {
    "use strict";
    var getHighWord = require_main21();
    module2.exports = getHighWord;
  }
});

// node_modules/@stdlib/number-float64-base-from-words/lib/indices.js
var require_indices2 = __commonJS({
  "node_modules/@stdlib/number-float64-base-from-words/lib/indices.js"(exports, module2) {
    "use strict";
    var isLittleEndian = require_lib31();
    var indices;
    var HIGH;
    var LOW;
    if (isLittleEndian === true) {
      HIGH = 1;
      LOW = 0;
    } else {
      HIGH = 0;
      LOW = 1;
    }
    indices = {
      "HIGH": HIGH,
      "LOW": LOW
    };
    module2.exports = indices;
  }
});

// node_modules/@stdlib/number-float64-base-from-words/lib/main.js
var require_main22 = __commonJS({
  "node_modules/@stdlib/number-float64-base-from-words/lib/main.js"(exports, module2) {
    "use strict";
    var Uint32Array2 = require_lib19();
    var Float64Array2 = require_lib22();
    var indices = require_indices2();
    var FLOAT64_VIEW = new Float64Array2(1);
    var UINT32_VIEW = new Uint32Array2(FLOAT64_VIEW.buffer);
    var HIGH = indices.HIGH;
    var LOW = indices.LOW;
    function fromWords(high, low) {
      UINT32_VIEW[HIGH] = high;
      UINT32_VIEW[LOW] = low;
      return FLOAT64_VIEW[0];
    }
    module2.exports = fromWords;
  }
});

// node_modules/@stdlib/number-float64-base-from-words/lib/index.js
var require_lib36 = __commonJS({
  "node_modules/@stdlib/number-float64-base-from-words/lib/index.js"(exports, module2) {
    "use strict";
    var fromWords = require_main22();
    module2.exports = fromWords;
  }
});

// node_modules/@stdlib/math-base-special-copysign/lib/copysign.js
var require_copysign = __commonJS({
  "node_modules/@stdlib/math-base-special-copysign/lib/copysign.js"(exports, module2) {
    "use strict";
    var toWords = require_lib32();
    var getHighWord = require_lib35();
    var fromWords = require_lib36();
    var SIGN_MASK = 2147483648 >>> 0;
    var MAGNITUDE_MASK = 2147483647 | 0;
    var WORDS = [0, 0];
    function copysign(x, y) {
      var hx;
      var hy;
      toWords(WORDS, x);
      hx = WORDS[0];
      hx &= MAGNITUDE_MASK;
      hy = getHighWord(y);
      hy &= SIGN_MASK;
      hx |= hy;
      return fromWords(hx, WORDS[1]);
    }
    module2.exports = copysign;
  }
});

// node_modules/@stdlib/math-base-special-copysign/lib/index.js
var require_lib37 = __commonJS({
  "node_modules/@stdlib/math-base-special-copysign/lib/index.js"(exports, module2) {
    "use strict";
    var copysign = require_copysign();
    module2.exports = copysign;
  }
});

// node_modules/@stdlib/math-base-special-pow/lib/x_is_zero.js
var require_x_is_zero = __commonJS({
  "node_modules/@stdlib/math-base-special-pow/lib/x_is_zero.js"(exports, module2) {
    "use strict";
    var isOdd = require_lib9();
    var copysign = require_lib37();
    var NINF = require_lib4();
    var PINF = require_lib2();
    function pow(x, y) {
      if (y === NINF) {
        return PINF;
      }
      if (y === PINF) {
        return 0;
      }
      if (y > 0) {
        if (isOdd(y)) {
          return x;
        }
        return 0;
      }
      if (isOdd(y)) {
        return copysign(PINF, x);
      }
      return PINF;
    }
    module2.exports = pow;
  }
});

// node_modules/@stdlib/math-base-special-pow/lib/y_is_huge.js
var require_y_is_huge = __commonJS({
  "node_modules/@stdlib/math-base-special-pow/lib/y_is_huge.js"(exports, module2) {
    "use strict";
    var getHighWord = require_lib35();
    var ABS_MASK = 2147483647 | 0;
    var HIGH_MAX_NEAR_UNITY = 1072693247 | 0;
    var HUGE = 1e300;
    var TINY = 1e-300;
    function pow(x, y) {
      var ahx;
      var hx;
      hx = getHighWord(x);
      ahx = hx & ABS_MASK;
      if (ahx <= HIGH_MAX_NEAR_UNITY) {
        if (y < 0) {
          return HUGE * HUGE;
        }
        return TINY * TINY;
      }
      if (y > 0) {
        return HUGE * HUGE;
      }
      return TINY * TINY;
    }
    module2.exports = pow;
  }
});

// node_modules/@stdlib/math-base-special-pow/lib/y_is_infinite.js
var require_y_is_infinite = __commonJS({
  "node_modules/@stdlib/math-base-special-pow/lib/y_is_infinite.js"(exports, module2) {
    "use strict";
    var abs = require_lib11();
    var PINF = require_lib2();
    function pow(x, y) {
      if (x === -1) {
        return (x - x) / (x - x);
      }
      if (x === 1) {
        return 1;
      }
      if (abs(x) < 1 === (y === PINF)) {
        return 0;
      }
      return PINF;
    }
    module2.exports = pow;
  }
});

// node_modules/@stdlib/number-float64-base-set-high-word/lib/high.js
var require_high2 = __commonJS({
  "node_modules/@stdlib/number-float64-base-set-high-word/lib/high.js"(exports, module2) {
    "use strict";
    var isLittleEndian = require_lib31();
    var HIGH;
    if (isLittleEndian === true) {
      HIGH = 1;
    } else {
      HIGH = 0;
    }
    module2.exports = HIGH;
  }
});

// node_modules/@stdlib/number-float64-base-set-high-word/lib/main.js
var require_main23 = __commonJS({
  "node_modules/@stdlib/number-float64-base-set-high-word/lib/main.js"(exports, module2) {
    "use strict";
    var Uint32Array2 = require_lib19();
    var Float64Array2 = require_lib22();
    var HIGH = require_high2();
    var FLOAT64_VIEW = new Float64Array2(1);
    var UINT32_VIEW = new Uint32Array2(FLOAT64_VIEW.buffer);
    function setHighWord(x, high) {
      FLOAT64_VIEW[0] = x;
      UINT32_VIEW[HIGH] = high >>> 0;
      return FLOAT64_VIEW[0];
    }
    module2.exports = setHighWord;
  }
});

// node_modules/@stdlib/number-float64-base-set-high-word/lib/index.js
var require_lib38 = __commonJS({
  "node_modules/@stdlib/number-float64-base-set-high-word/lib/index.js"(exports, module2) {
    "use strict";
    var setHighWord = require_main23();
    module2.exports = setHighWord;
  }
});

// node_modules/@stdlib/constants-float64-exponent-bias/lib/index.js
var require_lib39 = __commonJS({
  "node_modules/@stdlib/constants-float64-exponent-bias/lib/index.js"(exports, module2) {
    "use strict";
    var FLOAT64_EXPONENT_BIAS = 1023 | 0;
    module2.exports = FLOAT64_EXPONENT_BIAS;
  }
});

// node_modules/@stdlib/math-base-special-pow/lib/polyval_l.js
var require_polyval_l = __commonJS({
  "node_modules/@stdlib/math-base-special-pow/lib/polyval_l.js"(exports, module2) {
    "use strict";
    function evalpoly(x) {
      if (x === 0) {
        return 0.5999999999999946;
      }
      return 0.5999999999999946 + x * (0.4285714285785502 + x * (0.33333332981837743 + x * (0.272728123808534 + x * (0.23066074577556175 + x * 0.20697501780033842))));
    }
    module2.exports = evalpoly;
  }
});

// node_modules/@stdlib/math-base-special-pow/lib/log2ax.js
var require_log2ax = __commonJS({
  "node_modules/@stdlib/math-base-special-pow/lib/log2ax.js"(exports, module2) {
    "use strict";
    var getHighWord = require_lib35();
    var setLowWord = require_lib33();
    var setHighWord = require_lib38();
    var BIAS = require_lib39();
    var polyvalL = require_polyval_l();
    var HIGH_SIGNIFICAND_MASK = 1048575 | 0;
    var HIGH_MIN_NORMAL_EXP = 1048576 | 0;
    var HIGH_BIASED_EXP_0 = 1072693248 | 0;
    var HIGH_BIASED_EXP_NEG_512 = 536870912 | 0;
    var HIGH_SIGNIFICAND_HALF = 524288 | 0;
    var HIGH_NUM_SIGNIFICAND_BITS = 20 | 0;
    var TWO53 = 9007199254740992;
    var CP = 0.9617966939259756;
    var CP_HI = 0.9617967009544373;
    var CP_LO = -7028461650952758e-24;
    var BP = [
      1,
      1.5
    ];
    var DP_HI = [
      0,
      0.5849624872207642
    ];
    var DP_LO = [
      0,
      1350039202129749e-23
    ];
    function log2ax(out, ax, ahx) {
      var tmp;
      var ss;
      var s2;
      var hs;
      var ls;
      var ht;
      var lt;
      var bp;
      var dp;
      var hp;
      var lp;
      var hz;
      var lz;
      var t1;
      var t2;
      var t;
      var r;
      var u;
      var v;
      var n;
      var j;
      var k;
      n = 0 | 0;
      if (ahx < HIGH_MIN_NORMAL_EXP) {
        ax *= TWO53;
        n -= 53 | 0;
        ahx = getHighWord(ax);
      }
      n += (ahx >> HIGH_NUM_SIGNIFICAND_BITS) - BIAS | 0;
      j = ahx & HIGH_SIGNIFICAND_MASK | 0;
      ahx = j | HIGH_BIASED_EXP_0 | 0;
      if (j <= 235662) {
        k = 0;
      } else if (j < 767610) {
        k = 1;
      } else {
        k = 0;
        n += 1 | 0;
        ahx -= HIGH_MIN_NORMAL_EXP;
      }
      ax = setHighWord(ax, ahx);
      bp = BP[k];
      u = ax - bp;
      v = 1 / (ax + bp);
      ss = u * v;
      hs = setLowWord(ss, 0);
      tmp = (ahx >> 1 | HIGH_BIASED_EXP_NEG_512) + HIGH_SIGNIFICAND_HALF;
      tmp += k << 18;
      ht = setHighWord(0, tmp);
      lt = ax - (ht - bp);
      ls = v * (u - hs * ht - hs * lt);
      s2 = ss * ss;
      r = s2 * s2 * polyvalL(s2);
      r += ls * (hs + ss);
      s2 = hs * hs;
      ht = 3 + s2 + r;
      ht = setLowWord(ht, 0);
      lt = r - (ht - 3 - s2);
      u = hs * ht;
      v = ls * ht + lt * ss;
      hp = u + v;
      hp = setLowWord(hp, 0);
      lp = v - (hp - u);
      hz = CP_HI * hp;
      lz = CP_LO * hp + lp * CP + DP_LO[k];
      dp = DP_HI[k];
      t = n;
      t1 = hz + lz + dp + t;
      t1 = setLowWord(t1, 0);
      t2 = lz - (t1 - t - dp - hz);
      out[0] = t1;
      out[1] = t2;
      return out;
    }
    module2.exports = log2ax;
  }
});

// node_modules/@stdlib/math-base-special-pow/lib/polyval_w.js
var require_polyval_w = __commonJS({
  "node_modules/@stdlib/math-base-special-pow/lib/polyval_w.js"(exports, module2) {
    "use strict";
    function evalpoly(x) {
      if (x === 0) {
        return 0.5;
      }
      return 0.5 + x * (-0.3333333333333333 + x * 0.25);
    }
    module2.exports = evalpoly;
  }
});

// node_modules/@stdlib/math-base-special-pow/lib/logx.js
var require_logx = __commonJS({
  "node_modules/@stdlib/math-base-special-pow/lib/logx.js"(exports, module2) {
    "use strict";
    var setLowWord = require_lib33();
    var polyvalW = require_polyval_w();
    var INV_LN2 = 1.4426950408889634;
    var INV_LN2_HI = 1.4426950216293335;
    var INV_LN2_LO = 19259629911266175e-24;
    function logx(out, ax) {
      var t2;
      var t1;
      var t;
      var w;
      var u;
      var v;
      t = ax - 1;
      w = t * t * polyvalW(t);
      u = INV_LN2_HI * t;
      v = t * INV_LN2_LO - w * INV_LN2;
      t1 = u + v;
      t1 = setLowWord(t1, 0);
      t2 = v - (t1 - u);
      out[0] = t1;
      out[1] = t2;
      return out;
    }
    module2.exports = logx;
  }
});

// node_modules/@stdlib/constants-float64-max-base2-exponent/lib/index.js
var require_lib40 = __commonJS({
  "node_modules/@stdlib/constants-float64-max-base2-exponent/lib/index.js"(exports, module2) {
    "use strict";
    var FLOAT64_MAX_BASE2_EXPONENT = 1023 | 0;
    module2.exports = FLOAT64_MAX_BASE2_EXPONENT;
  }
});

// node_modules/@stdlib/constants-float64-max-base2-exponent-subnormal/lib/index.js
var require_lib41 = __commonJS({
  "node_modules/@stdlib/constants-float64-max-base2-exponent-subnormal/lib/index.js"(exports, module2) {
    "use strict";
    var FLOAT64_MAX_BASE2_EXPONENT_SUBNORMAL = -1023 | 0;
    module2.exports = FLOAT64_MAX_BASE2_EXPONENT_SUBNORMAL;
  }
});

// node_modules/@stdlib/constants-float64-min-base2-exponent-subnormal/lib/index.js
var require_lib42 = __commonJS({
  "node_modules/@stdlib/constants-float64-min-base2-exponent-subnormal/lib/index.js"(exports, module2) {
    "use strict";
    var FLOAT64_MIN_BASE2_EXPONENT_SUBNORMAL = -1074 | 0;
    module2.exports = FLOAT64_MIN_BASE2_EXPONENT_SUBNORMAL;
  }
});

// node_modules/@stdlib/constants-float64-smallest-normal/lib/index.js
var require_lib43 = __commonJS({
  "node_modules/@stdlib/constants-float64-smallest-normal/lib/index.js"(exports, module2) {
    "use strict";
    var FLOAT64_SMALLEST_NORMAL = 22250738585072014e-324;
    module2.exports = FLOAT64_SMALLEST_NORMAL;
  }
});

// node_modules/@stdlib/number-float64-base-normalize/lib/normalize.js
var require_normalize = __commonJS({
  "node_modules/@stdlib/number-float64-base-normalize/lib/normalize.js"(exports, module2) {
    "use strict";
    var FLOAT64_SMALLEST_NORMAL = require_lib43();
    var isInfinite = require_lib5();
    var isnan = require_lib();
    var abs = require_lib11();
    var SCALAR = 4503599627370496;
    function normalize(out, x) {
      if (isnan(x) || isInfinite(x)) {
        out[0] = x;
        out[1] = 0;
        return out;
      }
      if (x !== 0 && abs(x) < FLOAT64_SMALLEST_NORMAL) {
        out[0] = x * SCALAR;
        out[1] = -52;
        return out;
      }
      out[0] = x;
      out[1] = 0;
      return out;
    }
    module2.exports = normalize;
  }
});

// node_modules/@stdlib/number-float64-base-normalize/lib/main.js
var require_main24 = __commonJS({
  "node_modules/@stdlib/number-float64-base-normalize/lib/main.js"(exports, module2) {
    "use strict";
    var fcn = require_normalize();
    function normalize(out, x) {
      if (arguments.length === 1) {
        return fcn([0, 0], out);
      }
      return fcn(out, x);
    }
    module2.exports = normalize;
  }
});

// node_modules/@stdlib/number-float64-base-normalize/lib/index.js
var require_lib44 = __commonJS({
  "node_modules/@stdlib/number-float64-base-normalize/lib/index.js"(exports, module2) {
    "use strict";
    var normalize = require_main24();
    module2.exports = normalize;
  }
});

// node_modules/@stdlib/constants-float64-high-word-exponent-mask/lib/index.js
var require_lib45 = __commonJS({
  "node_modules/@stdlib/constants-float64-high-word-exponent-mask/lib/index.js"(exports, module2) {
    "use strict";
    var FLOAT64_HIGH_WORD_EXPONENT_MASK = 2146435072;
    module2.exports = FLOAT64_HIGH_WORD_EXPONENT_MASK;
  }
});

// node_modules/@stdlib/number-float64-base-exponent/lib/main.js
var require_main25 = __commonJS({
  "node_modules/@stdlib/number-float64-base-exponent/lib/main.js"(exports, module2) {
    "use strict";
    var getHighWord = require_lib35();
    var EXP_MASK = require_lib45();
    var BIAS = require_lib39();
    function exponent(x) {
      var high = getHighWord(x);
      high = (high & EXP_MASK) >>> 20;
      return high - BIAS | 0;
    }
    module2.exports = exponent;
  }
});

// node_modules/@stdlib/number-float64-base-exponent/lib/index.js
var require_lib46 = __commonJS({
  "node_modules/@stdlib/number-float64-base-exponent/lib/index.js"(exports, module2) {
    "use strict";
    var exponent = require_main25();
    module2.exports = exponent;
  }
});

// node_modules/@stdlib/math-base-special-ldexp/lib/ldexp.js
var require_ldexp = __commonJS({
  "node_modules/@stdlib/math-base-special-ldexp/lib/ldexp.js"(exports, module2) {
    "use strict";
    var PINF = require_lib2();
    var NINF = require_lib4();
    var BIAS = require_lib39();
    var MAX_EXPONENT = require_lib40();
    var MAX_SUBNORMAL_EXPONENT = require_lib41();
    var MIN_SUBNORMAL_EXPONENT = require_lib42();
    var isnan = require_lib();
    var isInfinite = require_lib5();
    var copysign = require_lib37();
    var normalize = require_lib44();
    var floatExp = require_lib46();
    var toWords = require_lib32();
    var fromWords = require_lib36();
    var TWO52_INV = 2220446049250313e-31;
    var CLEAR_EXP_MASK = 2148532223 >>> 0;
    var FRAC = [0, 0];
    var WORDS = [0, 0];
    function ldexp(frac, exp) {
      var high;
      var m;
      if (frac === 0 || isnan(frac) || isInfinite(frac)) {
        return frac;
      }
      normalize(FRAC, frac);
      frac = FRAC[0];
      exp += FRAC[1];
      exp += floatExp(frac);
      if (exp < MIN_SUBNORMAL_EXPONENT) {
        return copysign(0, frac);
      }
      if (exp > MAX_EXPONENT) {
        if (frac < 0) {
          return NINF;
        }
        return PINF;
      }
      if (exp <= MAX_SUBNORMAL_EXPONENT) {
        exp += 52;
        m = TWO52_INV;
      } else {
        m = 1;
      }
      toWords(WORDS, frac);
      high = WORDS[0];
      high &= CLEAR_EXP_MASK;
      high |= exp + BIAS << 20;
      return m * fromWords(high, WORDS[1]);
    }
    module2.exports = ldexp;
  }
});

// node_modules/@stdlib/math-base-special-ldexp/lib/index.js
var require_lib47 = __commonJS({
  "node_modules/@stdlib/math-base-special-ldexp/lib/index.js"(exports, module2) {
    "use strict";
    var ldexp = require_ldexp();
    module2.exports = ldexp;
  }
});

// node_modules/@stdlib/constants-float64-ln-two/lib/index.js
var require_lib48 = __commonJS({
  "node_modules/@stdlib/constants-float64-ln-two/lib/index.js"(exports, module2) {
    "use strict";
    var LN2 = 0.6931471805599453;
    module2.exports = LN2;
  }
});

// node_modules/@stdlib/math-base-special-pow/lib/polyval_p.js
var require_polyval_p = __commonJS({
  "node_modules/@stdlib/math-base-special-pow/lib/polyval_p.js"(exports, module2) {
    "use strict";
    function evalpoly(x) {
      if (x === 0) {
        return 0.16666666666666602;
      }
      return 0.16666666666666602 + x * (-0.0027777777777015593 + x * (6613756321437934e-20 + x * (-16533902205465252e-22 + x * 41381367970572385e-24)));
    }
    module2.exports = evalpoly;
  }
});

// node_modules/@stdlib/math-base-special-pow/lib/pow2.js
var require_pow2 = __commonJS({
  "node_modules/@stdlib/math-base-special-pow/lib/pow2.js"(exports, module2) {
    "use strict";
    var getHighWord = require_lib35();
    var setHighWord = require_lib38();
    var setLowWord = require_lib33();
    var uint32ToInt32 = require_lib34();
    var ldexp = require_lib47();
    var LN2 = require_lib48();
    var BIAS = require_lib39();
    var polyvalP = require_polyval_p();
    var ABS_MASK = 2147483647 | 0;
    var HIGH_SIGNIFICAND_MASK = 1048575 | 0;
    var HIGH_MIN_NORMAL_EXP = 1048576 | 0;
    var HIGH_BIASED_EXP_NEG_1 = 1071644672 | 0;
    var HIGH_NUM_SIGNIFICAND_BITS = 20 | 0;
    var LN2_HI = 0.6931471824645996;
    var LN2_LO = -1904654299957768e-24;
    function pow2(j, hp, lp) {
      var tmp;
      var t1;
      var t;
      var r;
      var u;
      var v;
      var w;
      var z;
      var n;
      var i;
      var k;
      i = j & ABS_MASK | 0;
      k = (i >> HIGH_NUM_SIGNIFICAND_BITS) - BIAS | 0;
      n = 0;
      if (i > HIGH_BIASED_EXP_NEG_1) {
        n = j + (HIGH_MIN_NORMAL_EXP >> k + 1) >>> 0;
        k = ((n & ABS_MASK) >> HIGH_NUM_SIGNIFICAND_BITS) - BIAS | 0;
        tmp = (n & ~(HIGH_SIGNIFICAND_MASK >> k)) >>> 0;
        t = setHighWord(0, tmp);
        n = (n & HIGH_SIGNIFICAND_MASK | HIGH_MIN_NORMAL_EXP) >> HIGH_NUM_SIGNIFICAND_BITS - k >>> 0;
        if (j < 0) {
          n = -n;
        }
        hp -= t;
      }
      t = lp + hp;
      t = setLowWord(t, 0);
      u = t * LN2_HI;
      v = (lp - (t - hp)) * LN2 + t * LN2_LO;
      z = u + v;
      w = v - (z - u);
      t = z * z;
      t1 = z - t * polyvalP(t);
      r = z * t1 / (t1 - 2) - (w + z * w);
      z = 1 - (r - z);
      j = getHighWord(z);
      j = uint32ToInt32(j);
      j += n << HIGH_NUM_SIGNIFICAND_BITS >>> 0;
      if (j >> HIGH_NUM_SIGNIFICAND_BITS <= 0) {
        z = ldexp(z, n);
      } else {
        z = setHighWord(z, j);
      }
      return z;
    }
    module2.exports = pow2;
  }
});

// node_modules/@stdlib/math-base-special-pow/lib/pow.js
var require_pow = __commonJS({
  "node_modules/@stdlib/math-base-special-pow/lib/pow.js"(exports, module2) {
    "use strict";
    var isnan = require_lib();
    var isOdd = require_lib9();
    var isInfinite = require_lib5();
    var isInteger = require_lib7();
    var sqrt = require_lib10();
    var abs = require_lib11();
    var toWords = require_lib32();
    var setLowWord = require_lib33();
    var uint32ToInt32 = require_lib34();
    var NINF = require_lib4();
    var PINF = require_lib2();
    var xIsZero = require_x_is_zero();
    var yIsHuge = require_y_is_huge();
    var yIsInfinite = require_y_is_infinite();
    var log2ax = require_log2ax();
    var logx = require_logx();
    var pow2 = require_pow2();
    var ABS_MASK = 2147483647 | 0;
    var HIGH_MAX_NEAR_UNITY = 1072693247 | 0;
    var HIGH_BIASED_EXP_31 = 1105199104 | 0;
    var HIGH_BIASED_EXP_64 = 1139802112 | 0;
    var HIGH_BIASED_EXP_10 = 1083179008 | 0;
    var HIGH_BIASED_EXP_0 = 1072693248 | 0;
    var HIGH_1075 = 1083231232 | 0;
    var HIGH_NEG_1075 = 3230714880 >>> 0;
    var HIGH_NUM_NONSIGN_BITS = 31 | 0;
    var HUGE = 1e300;
    var TINY = 1e-300;
    var OVT = 8008566259537294e-32;
    var WORDS = [0 | 0, 0 | 0];
    var LOG_WORKSPACE = [0, 0];
    function pow(x, y) {
      var ahx;
      var ahy;
      var ax;
      var hx;
      var lx;
      var hy;
      var ly;
      var sx;
      var sy;
      var y1;
      var hp;
      var lp;
      var t;
      var z;
      var j;
      var i;
      if (isnan(x) || isnan(y)) {
        return NaN;
      }
      toWords(WORDS, y);
      hy = WORDS[0];
      ly = WORDS[1];
      if (ly === 0) {
        if (y === 0) {
          return 1;
        }
        if (y === 1) {
          return x;
        }
        if (y === -1) {
          return 1 / x;
        }
        if (y === 0.5) {
          return sqrt(x);
        }
        if (y === -0.5) {
          return 1 / sqrt(x);
        }
        if (y === 2) {
          return x * x;
        }
        if (y === 3) {
          return x * x * x;
        }
        if (y === 4) {
          x *= x;
          return x * x;
        }
        if (isInfinite(y)) {
          return yIsInfinite(x, y);
        }
      }
      toWords(WORDS, x);
      hx = WORDS[0];
      lx = WORDS[1];
      if (lx === 0) {
        if (hx === 0) {
          return xIsZero(x, y);
        }
        if (x === 1) {
          return 1;
        }
        if (x === -1 && isOdd(y)) {
          return -1;
        }
        if (isInfinite(x)) {
          if (x === NINF) {
            return pow(-0, -y);
          }
          if (y < 0) {
            return 0;
          }
          return PINF;
        }
      }
      if (x < 0 && isInteger(y) === false) {
        return (x - x) / (x - x);
      }
      ax = abs(x);
      ahx = hx & ABS_MASK | 0;
      ahy = hy & ABS_MASK | 0;
      sx = hx >>> HIGH_NUM_NONSIGN_BITS | 0;
      sy = hy >>> HIGH_NUM_NONSIGN_BITS | 0;
      if (sx && isOdd(y)) {
        sx = -1;
      } else {
        sx = 1;
      }
      if (ahy > HIGH_BIASED_EXP_31) {
        if (ahy > HIGH_BIASED_EXP_64) {
          return yIsHuge(x, y);
        }
        if (ahx < HIGH_MAX_NEAR_UNITY) {
          if (sy === 1) {
            return sx * HUGE * HUGE;
          }
          return sx * TINY * TINY;
        }
        if (ahx > HIGH_BIASED_EXP_0) {
          if (sy === 0) {
            return sx * HUGE * HUGE;
          }
          return sx * TINY * TINY;
        }
        t = logx(LOG_WORKSPACE, ax);
      } else {
        t = log2ax(LOG_WORKSPACE, ax, ahx);
      }
      y1 = setLowWord(y, 0);
      lp = (y - y1) * t[0] + y * t[1];
      hp = y1 * t[0];
      z = lp + hp;
      toWords(WORDS, z);
      j = uint32ToInt32(WORDS[0]);
      i = uint32ToInt32(WORDS[1]);
      if (j >= HIGH_BIASED_EXP_10) {
        if ((j - HIGH_BIASED_EXP_10 | i) !== 0) {
          return sx * HUGE * HUGE;
        }
        if (lp + OVT > z - hp) {
          return sx * HUGE * HUGE;
        }
      } else if ((j & ABS_MASK) >= HIGH_1075) {
        if ((j - HIGH_NEG_1075 | i) !== 0) {
          return sx * TINY * TINY;
        }
        if (lp <= z - hp) {
          return sx * TINY * TINY;
        }
      }
      z = pow2(j, hp, lp);
      return sx * z;
    }
    module2.exports = pow;
  }
});

// node_modules/@stdlib/math-base-special-pow/lib/index.js
var require_lib49 = __commonJS({
  "node_modules/@stdlib/math-base-special-pow/lib/index.js"(exports, module2) {
    "use strict";
    var pow = require_pow();
    module2.exports = pow;
  }
});

// node_modules/@stdlib/math-base-special-round/lib/round.js
var require_round = __commonJS({
  "node_modules/@stdlib/math-base-special-round/lib/round.js"(exports, module2) {
    "use strict";
    var round = Math.round;
    module2.exports = round;
  }
});

// node_modules/@stdlib/math-base-special-round/lib/index.js
var require_lib50 = __commonJS({
  "node_modules/@stdlib/math-base-special-round/lib/index.js"(exports, module2) {
    "use strict";
    var round = require_round();
    module2.exports = round;
  }
});

// node_modules/@stdlib/constants-float64-max-safe-integer/lib/index.js
var require_lib51 = __commonJS({
  "node_modules/@stdlib/constants-float64-max-safe-integer/lib/index.js"(exports, module2) {
    "use strict";
    var FLOAT64_MAX_SAFE_INTEGER = 9007199254740991;
    module2.exports = FLOAT64_MAX_SAFE_INTEGER;
  }
});

// node_modules/@stdlib/constants-float64-max-base10-exponent/lib/index.js
var require_lib52 = __commonJS({
  "node_modules/@stdlib/constants-float64-max-base10-exponent/lib/index.js"(exports, module2) {
    "use strict";
    var FLOAT64_MAX_BASE10_EXPONENT = 308 | 0;
    module2.exports = FLOAT64_MAX_BASE10_EXPONENT;
  }
});

// node_modules/@stdlib/constants-float64-min-base10-exponent/lib/index.js
var require_lib53 = __commonJS({
  "node_modules/@stdlib/constants-float64-min-base10-exponent/lib/index.js"(exports, module2) {
    "use strict";
    var FLOAT64_MIN_BASE10_EXPONENT = -308 | 0;
    module2.exports = FLOAT64_MIN_BASE10_EXPONENT;
  }
});

// node_modules/@stdlib/constants-float64-min-base10-exponent-subnormal/lib/index.js
var require_lib54 = __commonJS({
  "node_modules/@stdlib/constants-float64-min-base10-exponent-subnormal/lib/index.js"(exports, module2) {
    "use strict";
    var FLOAT64_MIN_BASE10_EXPONENT_SUBNORMAL = -324 | 0;
    module2.exports = FLOAT64_MIN_BASE10_EXPONENT_SUBNORMAL;
  }
});

// node_modules/@stdlib/math-base-special-roundn/lib/roundn.js
var require_roundn = __commonJS({
  "node_modules/@stdlib/math-base-special-roundn/lib/roundn.js"(exports, module2) {
    "use strict";
    var isnan = require_lib();
    var isInfinite = require_lib5();
    var pow = require_lib49();
    var abs = require_lib11();
    var round = require_lib50();
    var MAX_SAFE_INTEGER = require_lib51();
    var MAX_EXP = require_lib52();
    var MIN_EXP = require_lib53();
    var MIN_EXP_SUBNORMAL = require_lib54();
    var MAX_INT = MAX_SAFE_INTEGER + 1;
    var HUGE = 1e308;
    function roundn2(x, n) {
      var s;
      var y;
      if (isnan(x) || isnan(n) || isInfinite(n)) {
        return NaN;
      }
      if (isInfinite(x) || x === 0 || n < MIN_EXP_SUBNORMAL || abs(x) > MAX_INT && n <= 0) {
        return x;
      }
      if (n > MAX_EXP) {
        return 0 * x;
      }
      if (n < MIN_EXP) {
        s = pow(10, -(n + MAX_EXP));
        y = x * HUGE * s;
        if (isInfinite(y)) {
          return x;
        }
        return round(y) / HUGE / s;
      }
      s = pow(10, -n);
      y = x * s;
      if (isInfinite(y)) {
        return x;
      }
      return round(y) / s;
    }
    module2.exports = roundn2;
  }
});

// node_modules/@stdlib/math-base-special-roundn/lib/index.js
var require_lib55 = __commonJS({
  "node_modules/@stdlib/math-base-special-roundn/lib/index.js"(exports, module2) {
    "use strict";
    var roundn2 = require_roundn();
    module2.exports = roundn2;
  }
});

// node_modules/@stdlib/datasets-stopwords-en/data/words.json
var require_words = __commonJS({
  "node_modules/@stdlib/datasets-stopwords-en/data/words.json"(exports, module2) {
    module2.exports = [
      "a",
      "about",
      "above",
      "across",
      "actually",
      "after",
      "again",
      "against",
      "all",
      "almost",
      "alone",
      "along",
      "already",
      "also",
      "although",
      "always",
      "among",
      "an",
      "and",
      "another",
      "any",
      "anybody",
      "anyone",
      "anything",
      "anywhere",
      "are",
      "around",
      "as",
      "ask",
      "asked",
      "asking",
      "asks",
      "at",
      "away",
      "b",
      "be",
      "became",
      "because",
      "become",
      "becomes",
      "becoming",
      "been",
      "before",
      "behind",
      "being",
      "best",
      "better",
      "between",
      "both",
      "but",
      "by",
      "c",
      "came",
      "can",
      "certain",
      "certainly",
      "clearly",
      "come",
      "consider",
      "considering",
      "could",
      "d",
      "did",
      "different",
      "do",
      "does",
      "doing",
      "done",
      "down",
      "downwards",
      "during",
      "e",
      "each",
      "eg",
      "eight",
      "either",
      "enough",
      "even",
      "ever",
      "every",
      "everybody",
      "everyone",
      "everything",
      "everywhere",
      "ex",
      "exactly",
      "example",
      "except",
      "f",
      "fact",
      "facts",
      "far",
      "few",
      "first",
      "five",
      "for",
      "four",
      "from",
      "further",
      "g",
      "get",
      "gets",
      "given",
      "gives",
      "go",
      "going",
      "got",
      "h",
      "had",
      "has",
      "have",
      "having",
      "he",
      "her",
      "here",
      "herself",
      "him",
      "himself",
      "his",
      "how",
      "however",
      "i",
      "ie",
      "if",
      "in",
      "into",
      "is",
      "it",
      "its",
      "itself",
      "j",
      "just",
      "k",
      "keep",
      "keeps",
      "knew",
      "know",
      "known",
      "knows",
      "l",
      "last",
      "later",
      "least",
      "less",
      "let",
      "like",
      "likely",
      "m",
      "many",
      "may",
      "me",
      "might",
      "more",
      "most",
      "mostly",
      "much",
      "must",
      "my",
      "myself",
      "n",
      "necessary",
      "need",
      "needs",
      "never",
      "new",
      "next",
      "nine",
      "no",
      "nobody",
      "non",
      "not",
      "nothing",
      "now",
      "nowhere",
      "o",
      "of",
      "off",
      "often",
      "old",
      "on",
      "once",
      "one",
      "only",
      "or",
      "other",
      "others",
      "our",
      "out",
      "over",
      "p",
      "per",
      "perhaps",
      "please",
      "possible",
      "put",
      "q",
      "quite",
      "r",
      "rather",
      "really",
      "right",
      "s",
      "said",
      "same",
      "saw",
      "say",
      "says",
      "second",
      "see",
      "seem",
      "seemed",
      "seems",
      "seven",
      "several",
      "shall",
      "she",
      "should",
      "since",
      "six",
      "so",
      "some",
      "somebody",
      "someone",
      "something",
      "somewhere",
      "still",
      "such",
      "sure",
      "t",
      "take",
      "taken",
      "ten",
      "than",
      "that",
      "the",
      "their",
      "them",
      "then",
      "there",
      "therefore",
      "therein",
      "thereupon",
      "these",
      "they",
      "think",
      "third",
      "this",
      "those",
      "though",
      "three",
      "through",
      "thus",
      "to",
      "together",
      "too",
      "took",
      "toward",
      "two",
      "u",
      "under",
      "until",
      "up",
      "upon",
      "us",
      "use",
      "used",
      "uses",
      "v",
      "very",
      "w",
      "want",
      "wanted",
      "wants",
      "was",
      "way",
      "we",
      "well",
      "went",
      "were",
      "what",
      "when",
      "where",
      "whether",
      "which",
      "while",
      "who",
      "whole",
      "whose",
      "why",
      "will",
      "with",
      "within",
      "without",
      "would",
      "x",
      "y",
      "yet",
      "you",
      "your",
      "yours",
      "z"
    ];
  }
});

// node_modules/@stdlib/datasets-stopwords-en/lib/browser.js
var require_browser = __commonJS({
  "node_modules/@stdlib/datasets-stopwords-en/lib/browser.js"(exports, module2) {
    "use strict";
    var data = require_words();
    function stopwords2() {
      return data.slice();
    }
    module2.exports = stopwords2;
  }
});

// node_modules/@stdlib/utils-define-property/lib/define_property.js
var require_define_property = __commonJS({
  "node_modules/@stdlib/utils-define-property/lib/define_property.js"(exports, module2) {
    "use strict";
    var main = typeof Object.defineProperty === "function" ? Object.defineProperty : null;
    module2.exports = main;
  }
});

// node_modules/@stdlib/utils-define-property/lib/has_define_property_support.js
var require_has_define_property_support = __commonJS({
  "node_modules/@stdlib/utils-define-property/lib/has_define_property_support.js"(exports, module2) {
    "use strict";
    var defineProperty = require_define_property();
    function hasDefinePropertySupport() {
      try {
        defineProperty({}, "x", {});
        return true;
      } catch (err) {
        return false;
      }
    }
    module2.exports = hasDefinePropertySupport;
  }
});

// node_modules/@stdlib/utils-define-property/lib/builtin.js
var require_builtin = __commonJS({
  "node_modules/@stdlib/utils-define-property/lib/builtin.js"(exports, module2) {
    "use strict";
    var defineProperty = Object.defineProperty;
    module2.exports = defineProperty;
  }
});

// node_modules/@stdlib/utils-define-property/lib/polyfill.js
var require_polyfill6 = __commonJS({
  "node_modules/@stdlib/utils-define-property/lib/polyfill.js"(exports, module2) {
    "use strict";
    var objectProtoype = Object.prototype;
    var toStr = objectProtoype.toString;
    var defineGetter = objectProtoype.__defineGetter__;
    var defineSetter = objectProtoype.__defineSetter__;
    var lookupGetter = objectProtoype.__lookupGetter__;
    var lookupSetter = objectProtoype.__lookupSetter__;
    function defineProperty(obj, prop, descriptor) {
      var prototype;
      var hasValue;
      var hasGet;
      var hasSet;
      if (typeof obj !== "object" || obj === null || toStr.call(obj) === "[object Array]") {
        throw new TypeError("invalid argument. First argument must be an object. Value: `" + obj + "`.");
      }
      if (typeof descriptor !== "object" || descriptor === null || toStr.call(descriptor) === "[object Array]") {
        throw new TypeError("invalid argument. Property descriptor must be an object. Value: `" + descriptor + "`.");
      }
      hasValue = "value" in descriptor;
      if (hasValue) {
        if (lookupGetter.call(obj, prop) || lookupSetter.call(obj, prop)) {
          prototype = obj.__proto__;
          obj.__proto__ = objectProtoype;
          delete obj[prop];
          obj[prop] = descriptor.value;
          obj.__proto__ = prototype;
        } else {
          obj[prop] = descriptor.value;
        }
      }
      hasGet = "get" in descriptor;
      hasSet = "set" in descriptor;
      if (hasValue && (hasGet || hasSet)) {
        throw new Error("invalid argument. Cannot specify one or more accessors and a value or writable attribute in the property descriptor.");
      }
      if (hasGet && defineGetter) {
        defineGetter.call(obj, prop, descriptor.get);
      }
      if (hasSet && defineSetter) {
        defineSetter.call(obj, prop, descriptor.set);
      }
      return obj;
    }
    module2.exports = defineProperty;
  }
});

// node_modules/@stdlib/utils-define-property/lib/index.js
var require_lib56 = __commonJS({
  "node_modules/@stdlib/utils-define-property/lib/index.js"(exports, module2) {
    "use strict";
    var hasDefinePropertySupport = require_has_define_property_support();
    var builtin = require_builtin();
    var polyfill = require_polyfill6();
    var defineProperty;
    if (hasDefinePropertySupport()) {
      defineProperty = builtin;
    } else {
      defineProperty = polyfill;
    }
    module2.exports = defineProperty;
  }
});

// node_modules/@stdlib/utils-define-nonenumerable-read-only-property/lib/main.js
var require_main26 = __commonJS({
  "node_modules/@stdlib/utils-define-nonenumerable-read-only-property/lib/main.js"(exports, module2) {
    "use strict";
    var defineProperty = require_lib56();
    function setNonEnumerableReadOnly(obj, prop, value) {
      defineProperty(obj, prop, {
        "configurable": false,
        "enumerable": false,
        "writable": false,
        "value": value
      });
    }
    module2.exports = setNonEnumerableReadOnly;
  }
});

// node_modules/@stdlib/utils-define-nonenumerable-read-only-property/lib/index.js
var require_lib57 = __commonJS({
  "node_modules/@stdlib/utils-define-nonenumerable-read-only-property/lib/index.js"(exports, module2) {
    "use strict";
    var setNonEnumerableReadOnly = require_main26();
    module2.exports = setNonEnumerableReadOnly;
  }
});

// node_modules/@stdlib/assert-is-number/lib/primitive.js
var require_primitive = __commonJS({
  "node_modules/@stdlib/assert-is-number/lib/primitive.js"(exports, module2) {
    "use strict";
    function isNumber(value) {
      return typeof value === "number";
    }
    module2.exports = isNumber;
  }
});

// node_modules/@stdlib/assert-is-number/lib/tostring.js
var require_tostring2 = __commonJS({
  "node_modules/@stdlib/assert-is-number/lib/tostring.js"(exports, module2) {
    "use strict";
    var Number2 = require_lib3();
    var toString = Number2.prototype.toString;
    module2.exports = toString;
  }
});

// node_modules/@stdlib/assert-is-number/lib/try2serialize.js
var require_try2serialize = __commonJS({
  "node_modules/@stdlib/assert-is-number/lib/try2serialize.js"(exports, module2) {
    "use strict";
    var toString = require_tostring2();
    function test(value) {
      try {
        toString.call(value);
        return true;
      } catch (err) {
        return false;
      }
    }
    module2.exports = test;
  }
});

// node_modules/@stdlib/assert-is-number/lib/object.js
var require_object = __commonJS({
  "node_modules/@stdlib/assert-is-number/lib/object.js"(exports, module2) {
    "use strict";
    var hasToStringTag = require_lib13();
    var nativeClass = require_lib15();
    var Number2 = require_lib3();
    var test = require_try2serialize();
    var FLG = hasToStringTag();
    function isNumber(value) {
      if (typeof value === "object") {
        if (value instanceof Number2) {
          return true;
        }
        if (FLG) {
          return test(value);
        }
        return nativeClass(value) === "[object Number]";
      }
      return false;
    }
    module2.exports = isNumber;
  }
});

// node_modules/@stdlib/assert-is-number/lib/main.js
var require_main27 = __commonJS({
  "node_modules/@stdlib/assert-is-number/lib/main.js"(exports, module2) {
    "use strict";
    var isPrimitive = require_primitive();
    var isObject = require_object();
    function isNumber(value) {
      return isPrimitive(value) || isObject(value);
    }
    module2.exports = isNumber;
  }
});

// node_modules/@stdlib/assert-is-number/lib/index.js
var require_lib58 = __commonJS({
  "node_modules/@stdlib/assert-is-number/lib/index.js"(exports, module2) {
    "use strict";
    var setReadOnly = require_lib57();
    var isNumber = require_main27();
    var isPrimitive = require_primitive();
    var isObject = require_object();
    setReadOnly(isNumber, "isPrimitive", isPrimitive);
    setReadOnly(isNumber, "isObject", isObject);
    module2.exports = isNumber;
  }
});

// node_modules/@stdlib/assert-is-integer/lib/integer.js
var require_integer = __commonJS({
  "node_modules/@stdlib/assert-is-integer/lib/integer.js"(exports, module2) {
    "use strict";
    var PINF = require_lib2();
    var NINF = require_lib4();
    var isInt = require_lib7();
    function isInteger(value) {
      return value < PINF && value > NINF && isInt(value);
    }
    module2.exports = isInteger;
  }
});

// node_modules/@stdlib/assert-is-integer/lib/primitive.js
var require_primitive2 = __commonJS({
  "node_modules/@stdlib/assert-is-integer/lib/primitive.js"(exports, module2) {
    "use strict";
    var isNumber = require_lib58().isPrimitive;
    var isInt = require_integer();
    function isInteger(value) {
      return isNumber(value) && isInt(value);
    }
    module2.exports = isInteger;
  }
});

// node_modules/@stdlib/assert-is-integer/lib/object.js
var require_object2 = __commonJS({
  "node_modules/@stdlib/assert-is-integer/lib/object.js"(exports, module2) {
    "use strict";
    var isNumber = require_lib58().isObject;
    var isInt = require_integer();
    function isInteger(value) {
      return isNumber(value) && isInt(value.valueOf());
    }
    module2.exports = isInteger;
  }
});

// node_modules/@stdlib/assert-is-integer/lib/main.js
var require_main28 = __commonJS({
  "node_modules/@stdlib/assert-is-integer/lib/main.js"(exports, module2) {
    "use strict";
    var isPrimitive = require_primitive2();
    var isObject = require_object2();
    function isInteger(value) {
      return isPrimitive(value) || isObject(value);
    }
    module2.exports = isInteger;
  }
});

// node_modules/@stdlib/assert-is-integer/lib/index.js
var require_lib59 = __commonJS({
  "node_modules/@stdlib/assert-is-integer/lib/index.js"(exports, module2) {
    "use strict";
    var setReadOnly = require_lib57();
    var isInteger = require_main28();
    var isPrimitive = require_primitive2();
    var isObject = require_object2();
    setReadOnly(isInteger, "isPrimitive", isPrimitive);
    setReadOnly(isInteger, "isObject", isObject);
    module2.exports = isInteger;
  }
});

// node_modules/@stdlib/assert-is-nonnegative-integer/lib/primitive.js
var require_primitive3 = __commonJS({
  "node_modules/@stdlib/assert-is-nonnegative-integer/lib/primitive.js"(exports, module2) {
    "use strict";
    var isInteger = require_lib59().isPrimitive;
    function isNonNegativeInteger(value) {
      return isInteger(value) && value >= 0;
    }
    module2.exports = isNonNegativeInteger;
  }
});

// node_modules/@stdlib/assert-is-nonnegative-integer/lib/object.js
var require_object3 = __commonJS({
  "node_modules/@stdlib/assert-is-nonnegative-integer/lib/object.js"(exports, module2) {
    "use strict";
    var isInteger = require_lib59().isObject;
    function isNonNegativeInteger(value) {
      return isInteger(value) && value.valueOf() >= 0;
    }
    module2.exports = isNonNegativeInteger;
  }
});

// node_modules/@stdlib/assert-is-nonnegative-integer/lib/main.js
var require_main29 = __commonJS({
  "node_modules/@stdlib/assert-is-nonnegative-integer/lib/main.js"(exports, module2) {
    "use strict";
    var isPrimitive = require_primitive3();
    var isObject = require_object3();
    function isNonNegativeInteger(value) {
      return isPrimitive(value) || isObject(value);
    }
    module2.exports = isNonNegativeInteger;
  }
});

// node_modules/@stdlib/assert-is-nonnegative-integer/lib/index.js
var require_lib60 = __commonJS({
  "node_modules/@stdlib/assert-is-nonnegative-integer/lib/index.js"(exports, module2) {
    "use strict";
    var setReadOnly = require_lib57();
    var isNonNegativeInteger = require_main29();
    var isPrimitive = require_primitive3();
    var isObject = require_object3();
    setReadOnly(isNonNegativeInteger, "isPrimitive", isPrimitive);
    setReadOnly(isNonNegativeInteger, "isObject", isObject);
    module2.exports = isNonNegativeInteger;
  }
});

// node_modules/@stdlib/assert-is-positive-integer/lib/primitive.js
var require_primitive4 = __commonJS({
  "node_modules/@stdlib/assert-is-positive-integer/lib/primitive.js"(exports, module2) {
    "use strict";
    var isInteger = require_lib59().isPrimitive;
    function isPositiveInteger(value) {
      return isInteger(value) && value > 0;
    }
    module2.exports = isPositiveInteger;
  }
});

// node_modules/@stdlib/assert-is-positive-integer/lib/object.js
var require_object4 = __commonJS({
  "node_modules/@stdlib/assert-is-positive-integer/lib/object.js"(exports, module2) {
    "use strict";
    var isInteger = require_lib59().isObject;
    function isPositiveInteger(value) {
      return isInteger(value) && value.valueOf() > 0;
    }
    module2.exports = isPositiveInteger;
  }
});

// node_modules/@stdlib/assert-is-positive-integer/lib/main.js
var require_main30 = __commonJS({
  "node_modules/@stdlib/assert-is-positive-integer/lib/main.js"(exports, module2) {
    "use strict";
    var isPrimitive = require_primitive4();
    var isObject = require_object4();
    function isPositiveInteger(value) {
      return isPrimitive(value) || isObject(value);
    }
    module2.exports = isPositiveInteger;
  }
});

// node_modules/@stdlib/assert-is-positive-integer/lib/index.js
var require_lib61 = __commonJS({
  "node_modules/@stdlib/assert-is-positive-integer/lib/index.js"(exports, module2) {
    "use strict";
    var setReadOnly = require_lib57();
    var isPositiveInteger = require_main30();
    var isPrimitive = require_primitive4();
    var isObject = require_object4();
    setReadOnly(isPositiveInteger, "isPrimitive", isPrimitive);
    setReadOnly(isPositiveInteger, "isObject", isObject);
    module2.exports = isPositiveInteger;
  }
});

// node_modules/@stdlib/assert-is-array/lib/main.js
var require_main31 = __commonJS({
  "node_modules/@stdlib/assert-is-array/lib/main.js"(exports, module2) {
    "use strict";
    var nativeClass = require_lib15();
    var f;
    function isArray(value) {
      return nativeClass(value) === "[object Array]";
    }
    if (Array.isArray) {
      f = Array.isArray;
    } else {
      f = isArray;
    }
    module2.exports = f;
  }
});

// node_modules/@stdlib/assert-is-array/lib/index.js
var require_lib62 = __commonJS({
  "node_modules/@stdlib/assert-is-array/lib/index.js"(exports, module2) {
    "use strict";
    var isArray = require_main31();
    module2.exports = isArray;
  }
});

// node_modules/@stdlib/assert-tools-array-function/lib/arrayfcn.js
var require_arrayfcn = __commonJS({
  "node_modules/@stdlib/assert-tools-array-function/lib/arrayfcn.js"(exports, module2) {
    "use strict";
    var isArray = require_lib62();
    function arrayfcn(predicate) {
      if (typeof predicate !== "function") {
        throw new TypeError("invalid argument. Must provide a function. Value: `" + predicate + "`.");
      }
      return every;
      function every(value) {
        var len;
        var i;
        if (!isArray(value)) {
          return false;
        }
        len = value.length;
        if (len === 0) {
          return false;
        }
        for (i = 0; i < len; i++) {
          if (predicate(value[i]) === false) {
            return false;
          }
        }
        return true;
      }
    }
    module2.exports = arrayfcn;
  }
});

// node_modules/@stdlib/assert-tools-array-function/lib/index.js
var require_lib63 = __commonJS({
  "node_modules/@stdlib/assert-tools-array-function/lib/index.js"(exports, module2) {
    "use strict";
    var arrayfcn = require_arrayfcn();
    module2.exports = arrayfcn;
  }
});

// node_modules/@stdlib/assert-is-string/lib/primitive.js
var require_primitive5 = __commonJS({
  "node_modules/@stdlib/assert-is-string/lib/primitive.js"(exports, module2) {
    "use strict";
    function isString(value) {
      return typeof value === "string";
    }
    module2.exports = isString;
  }
});

// node_modules/@stdlib/assert-is-string/lib/valueof.js
var require_valueof = __commonJS({
  "node_modules/@stdlib/assert-is-string/lib/valueof.js"(exports, module2) {
    "use strict";
    var valueOf = String.prototype.valueOf;
    module2.exports = valueOf;
  }
});

// node_modules/@stdlib/assert-is-string/lib/try2valueof.js
var require_try2valueof = __commonJS({
  "node_modules/@stdlib/assert-is-string/lib/try2valueof.js"(exports, module2) {
    "use strict";
    var valueOf = require_valueof();
    function test(value) {
      try {
        valueOf.call(value);
        return true;
      } catch (err) {
        return false;
      }
    }
    module2.exports = test;
  }
});

// node_modules/@stdlib/assert-is-string/lib/object.js
var require_object5 = __commonJS({
  "node_modules/@stdlib/assert-is-string/lib/object.js"(exports, module2) {
    "use strict";
    var hasToStringTag = require_lib13();
    var nativeClass = require_lib15();
    var test = require_try2valueof();
    var FLG = hasToStringTag();
    function isString(value) {
      if (typeof value === "object") {
        if (value instanceof String) {
          return true;
        }
        if (FLG) {
          return test(value);
        }
        return nativeClass(value) === "[object String]";
      }
      return false;
    }
    module2.exports = isString;
  }
});

// node_modules/@stdlib/assert-is-string/lib/main.js
var require_main32 = __commonJS({
  "node_modules/@stdlib/assert-is-string/lib/main.js"(exports, module2) {
    "use strict";
    var isPrimitive = require_primitive5();
    var isObject = require_object5();
    function isString(value) {
      return isPrimitive(value) || isObject(value);
    }
    module2.exports = isString;
  }
});

// node_modules/@stdlib/assert-is-string/lib/index.js
var require_lib64 = __commonJS({
  "node_modules/@stdlib/assert-is-string/lib/index.js"(exports, module2) {
    "use strict";
    var setReadOnly = require_lib57();
    var isString = require_main32();
    var isPrimitive = require_primitive5();
    var isObject = require_object5();
    setReadOnly(isString, "isPrimitive", isPrimitive);
    setReadOnly(isString, "isObject", isObject);
    module2.exports = isString;
  }
});

// node_modules/@stdlib/assert-is-string-array/lib/index.js
var require_lib65 = __commonJS({
  "node_modules/@stdlib/assert-is-string-array/lib/index.js"(exports, module2) {
    "use strict";
    var setReadOnly = require_lib57();
    var arrayfun = require_lib63();
    var isString = require_lib64();
    var isStringArray = arrayfun(isString);
    setReadOnly(isStringArray, "primitives", arrayfun(isString.isPrimitive));
    setReadOnly(isStringArray, "objects", arrayfun(isString.isObject));
    module2.exports = isStringArray;
  }
});

// node_modules/@stdlib/utils-define-read-only-property/lib/main.js
var require_main33 = __commonJS({
  "node_modules/@stdlib/utils-define-read-only-property/lib/main.js"(exports, module2) {
    "use strict";
    var defineProperty = require_lib56();
    function setReadOnly(obj, prop, value) {
      defineProperty(obj, prop, {
        "configurable": false,
        "enumerable": true,
        "writable": false,
        "value": value
      });
    }
    module2.exports = setReadOnly;
  }
});

// node_modules/@stdlib/utils-define-read-only-property/lib/index.js
var require_lib66 = __commonJS({
  "node_modules/@stdlib/utils-define-read-only-property/lib/index.js"(exports, module2) {
    "use strict";
    var setReadOnly = require_main33();
    module2.exports = setReadOnly;
  }
});

// node_modules/@stdlib/constants-array-max-typed-array-length/lib/index.js
var require_lib67 = __commonJS({
  "node_modules/@stdlib/constants-array-max-typed-array-length/lib/index.js"(exports, module2) {
    "use strict";
    var MAX_TYPED_ARRAY_LENGTH = 9007199254740991;
    module2.exports = MAX_TYPED_ARRAY_LENGTH;
  }
});

// node_modules/@stdlib/assert-is-collection/lib/main.js
var require_main34 = __commonJS({
  "node_modules/@stdlib/assert-is-collection/lib/main.js"(exports, module2) {
    "use strict";
    var isInteger = require_lib7();
    var MAX_LENGTH = require_lib67();
    function isCollection(value) {
      return typeof value === "object" && value !== null && typeof value.length === "number" && isInteger(value.length) && value.length >= 0 && value.length <= MAX_LENGTH;
    }
    module2.exports = isCollection;
  }
});

// node_modules/@stdlib/assert-is-collection/lib/index.js
var require_lib68 = __commonJS({
  "node_modules/@stdlib/assert-is-collection/lib/index.js"(exports, module2) {
    "use strict";
    var isCollection = require_main34();
    module2.exports = isCollection;
  }
});

// node_modules/@stdlib/assert-is-nan/lib/primitive.js
var require_primitive6 = __commonJS({
  "node_modules/@stdlib/assert-is-nan/lib/primitive.js"(exports, module2) {
    "use strict";
    var isNumber = require_lib58().isPrimitive;
    var isNan = require_lib();
    function isnan(value) {
      return isNumber(value) && isNan(value);
    }
    module2.exports = isnan;
  }
});

// node_modules/@stdlib/assert-is-nan/lib/object.js
var require_object6 = __commonJS({
  "node_modules/@stdlib/assert-is-nan/lib/object.js"(exports, module2) {
    "use strict";
    var isNumber = require_lib58().isObject;
    var isNan = require_lib();
    function isnan(value) {
      return isNumber(value) && isNan(value.valueOf());
    }
    module2.exports = isnan;
  }
});

// node_modules/@stdlib/assert-is-nan/lib/main.js
var require_main35 = __commonJS({
  "node_modules/@stdlib/assert-is-nan/lib/main.js"(exports, module2) {
    "use strict";
    var isPrimitive = require_primitive6();
    var isObject = require_object6();
    function isnan(value) {
      return isPrimitive(value) || isObject(value);
    }
    module2.exports = isnan;
  }
});

// node_modules/@stdlib/assert-is-nan/lib/index.js
var require_lib69 = __commonJS({
  "node_modules/@stdlib/assert-is-nan/lib/index.js"(exports, module2) {
    "use strict";
    var setReadOnly = require_lib57();
    var isnan = require_main35();
    var isPrimitive = require_primitive6();
    var isObject = require_object6();
    setReadOnly(isnan, "isPrimitive", isPrimitive);
    setReadOnly(isnan, "isObject", isObject);
    module2.exports = isnan;
  }
});

// node_modules/@stdlib/assert-contains/lib/contains.js
var require_contains = __commonJS({
  "node_modules/@stdlib/assert-contains/lib/contains.js"(exports, module2) {
    "use strict";
    var isCollection = require_lib68();
    var isInteger = require_lib59().isPrimitive;
    var isString = require_lib64().isPrimitive;
    var isnan = require_lib69().isPrimitive;
    function contains(val, searchValue, position) {
      var len;
      var pos;
      var i;
      if (!isCollection(val) && !isString(val)) {
        throw new TypeError("invalid argument. First argument must be array-like. Value: `" + val + "`.");
      }
      if (arguments.length < 2) {
        throw new Error("insufficient input arguments. Must provide a search value.");
      }
      if (arguments.length > 2) {
        if (!isInteger(position)) {
          throw new TypeError("invalid argument. Third argument must be an integer. Value: `" + position + "`.");
        }
        pos = position;
        if (pos < 0) {
          pos = 0;
        }
      } else {
        pos = 0;
      }
      if (isString(val)) {
        if (!isString(searchValue)) {
          throw new TypeError("invalid argument. Second argument must be a string primitive. Value: `" + searchValue + "`.");
        }
        return val.indexOf(searchValue, pos) !== -1;
      }
      len = val.length;
      if (isnan(searchValue)) {
        for (i = pos; i < len; i++) {
          if (isnan(val[i])) {
            return true;
          }
        }
        return false;
      }
      for (i = pos; i < len; i++) {
        if (val[i] === searchValue) {
          return true;
        }
      }
      return false;
    }
    module2.exports = contains;
  }
});

// node_modules/@stdlib/assert-contains/lib/index.js
var require_lib70 = __commonJS({
  "node_modules/@stdlib/assert-contains/lib/index.js"(exports, module2) {
    "use strict";
    var contains = require_contains();
    module2.exports = contains;
  }
});

// node_modules/@stdlib/assert-is-boolean/lib/primitive.js
var require_primitive7 = __commonJS({
  "node_modules/@stdlib/assert-is-boolean/lib/primitive.js"(exports, module2) {
    "use strict";
    function isBoolean(value) {
      return typeof value === "boolean";
    }
    module2.exports = isBoolean;
  }
});

// node_modules/@stdlib/assert-is-boolean/lib/tostring.js
var require_tostring3 = __commonJS({
  "node_modules/@stdlib/assert-is-boolean/lib/tostring.js"(exports, module2) {
    "use strict";
    var toString = Boolean.prototype.toString;
    module2.exports = toString;
  }
});

// node_modules/@stdlib/assert-is-boolean/lib/try2serialize.js
var require_try2serialize2 = __commonJS({
  "node_modules/@stdlib/assert-is-boolean/lib/try2serialize.js"(exports, module2) {
    "use strict";
    var toString = require_tostring3();
    function test(value) {
      try {
        toString.call(value);
        return true;
      } catch (err) {
        return false;
      }
    }
    module2.exports = test;
  }
});

// node_modules/@stdlib/assert-is-boolean/lib/object.js
var require_object7 = __commonJS({
  "node_modules/@stdlib/assert-is-boolean/lib/object.js"(exports, module2) {
    "use strict";
    var hasToStringTag = require_lib13();
    var nativeClass = require_lib15();
    var test = require_try2serialize2();
    var FLG = hasToStringTag();
    function isBoolean(value) {
      if (typeof value === "object") {
        if (value instanceof Boolean) {
          return true;
        }
        if (FLG) {
          return test(value);
        }
        return nativeClass(value) === "[object Boolean]";
      }
      return false;
    }
    module2.exports = isBoolean;
  }
});

// node_modules/@stdlib/assert-is-boolean/lib/main.js
var require_main36 = __commonJS({
  "node_modules/@stdlib/assert-is-boolean/lib/main.js"(exports, module2) {
    "use strict";
    var isPrimitive = require_primitive7();
    var isObject = require_object7();
    function isBoolean(value) {
      return isPrimitive(value) || isObject(value);
    }
    module2.exports = isBoolean;
  }
});

// node_modules/@stdlib/assert-is-boolean/lib/index.js
var require_lib71 = __commonJS({
  "node_modules/@stdlib/assert-is-boolean/lib/index.js"(exports, module2) {
    "use strict";
    var setReadOnly = require_lib57();
    var isBoolean = require_main36();
    var isPrimitive = require_primitive7();
    var isObject = require_object7();
    setReadOnly(isBoolean, "isPrimitive", isPrimitive);
    setReadOnly(isBoolean, "isObject", isObject);
    module2.exports = isBoolean;
  }
});

// node_modules/@stdlib/nlp-tokenize/lib/abbreviations.json
var require_abbreviations = __commonJS({
  "node_modules/@stdlib/nlp-tokenize/lib/abbreviations.json"(exports, module2) {
    module2.exports = {
      "i.e.": ["i.e."],
      "I.e.": ["I.e."],
      "I.E.": ["I.E."],
      "e.g.": ["e.g."],
      "E.g.": ["E.g."],
      "E.G.": ["E.G."],
      "et al.": ["et al."],
      "etc.": ["etc."],
      "vs.": ["vs."],
      "A.S.A.P": ["A.S.A.P"],
      "E.T.A.": ["E.T.A."],
      "D.I.Y": ["D.I.Y"],
      "R.S.V.P": ["R.S.V.P"],
      "P.S.": ["P.S."],
      "B.Y.O.B": ["B.Y.O.B"],
      "Ms.": ["Ms."],
      "Mr.": ["Mr."],
      "Dr.": ["Dr."],
      "Prof.": ["Prof."],
      "Mrs.": ["Mrs."],
      "Messrs.": ["Messrs."],
      "Gov.": ["Gov."],
      "Gen.": ["Gen."],
      "Lt.": ["Lt."],
      "Col.": ["Col."],
      "Mt.": ["Mt."],
      "Bros.": ["Bros."],
      "Corp.": ["Corp."],
      "Co.": ["Co."],
      "co.": ["co."],
      "Inc.": ["Inc."],
      "Ltd.": ["Ltd."],
      "Rep.": ["Rep."],
      "Sen.": ["Sen."],
      "Jr.": ["Jr."],
      "Sr.": ["Sr."],
      "Ph.D.": ["Ph.D."],
      "J.D.": ["J.D."],
      "M.D.": ["M.D."],
      "Rev.": ["Rev."],
      "Adm.": ["Adm."],
      "St.": ["St."],
      "a.m.": ["a.m."],
      "p.m.": ["p.m."],
      "b.c.": ["b.c."],
      "B.C.": ["B.C."],
      "a.d.": ["a.d."],
      "A.D.": ["A.D."],
      "b.c.e.": ["b.c.e."],
      "B.C.E.": ["B.C.E."],
      "Jan.": ["Jan."],
      "Feb.": ["Feb."],
      "Mar.": ["Mar."],
      "Apr.": ["Apr."],
      "May.": ["May."],
      "Jun.": ["Jun."],
      "Jul.": ["Jul."],
      "Aug.": ["Aug."],
      "Sep.": ["Sep."],
      "Sept.": ["Sept."],
      "Oct.": ["Oct."],
      "Nov.": ["Nov."],
      "Dec.": ["Dec."],
      "Ala.": ["Ala."],
      "Ariz.": ["Ariz."],
      "Ark.": ["Ark."],
      "Calif.": ["Calif."],
      "Colo.": ["Colo."],
      "Conn.": ["Conn."],
      "Del.": ["Del."],
      "D.C.": ["D.C."],
      "Fla.": ["Fla."],
      "Ga.": ["Ga."],
      "Ill.": ["Ill."],
      "Ind.": ["Ind."],
      "Kans.": ["Kans."],
      "Kan.": ["Kan."],
      "Ky.": ["Ky."],
      "La.": ["La."],
      "Md.": ["Md."],
      "Mass.": ["Mass."],
      "Mich.": ["Mich."],
      "Minn.": ["Minn."],
      "Miss.": ["Miss."],
      "Mo.": ["Mo."],
      "Mont.": ["Mont."],
      "Nebr.": ["Nebr."],
      "Neb.": ["Neb."],
      "Nev.": ["Nev."],
      "N.H.": ["N.H."],
      "N.J.": ["N.J."],
      "N.M.": ["N.M."],
      "N.Y.": ["N.Y."],
      "N.C.": ["N.C."],
      "N.D.": ["N.D."],
      "Okla.": ["Okla."],
      "Ore.": ["Ore."],
      "Pa.": ["Pa."],
      "Tenn.": ["Tenn."],
      "Va.": ["Va."],
      "Wash.": ["Wash."],
      "Wis.": ["Wis."]
    };
  }
});

// node_modules/@stdlib/nlp-tokenize/lib/emojis.json
var require_emojis = __commonJS({
  "node_modules/@stdlib/nlp-tokenize/lib/emojis.json"(exports, module2) {
    module2.exports = {
      "^_^": ["^_^"],
      "=D": ["=D"],
      ";-p": [";-p"],
      ":O": [":O"],
      ":-/": [":-/"],
      xD: ["xD"],
      V_V: ["V_V"],
      ";(": [";("],
      "(:": ["(:"],
      '")': ['")'],
      ":Y": [":Y"],
      ":]": [":]"],
      ":3": [":3"],
      ":(": [":("],
      ":-)": [":-)"],
      "=3": ["=3"],
      ":))": [":))"],
      ":>": [":>"],
      ";p": [";p"],
      ":p": [":p"],
      "=[[": ["=[["],
      xDD: ["xDD"],
      "<333": ["<333"],
      "<33": ["<33"],
      ":P": [":P"],
      "o.O": ["o.O"],
      "<3": ["<3"],
      ";-)": [";-)"],
      ":)": [":)"],
      "-_-": ["-_-"],
      ":')": [":')"],
      o_O: ["o_O"],
      ";)": [";)"],
      "=]": ["=]"],
      "(=": ["(="],
      "-__-": ["-__-"],
      ":/": [":/"],
      ":0": [":0"],
      "(^_^)": ["(^_^)"],
      ";D": [";D"],
      o_o: ["o_o"],
      ":((": [":(("],
      "=)": ["=)"]
    };
  }
});

// node_modules/@stdlib/nlp-tokenize/lib/contractions.json
var require_contractions = __commonJS({
  "node_modules/@stdlib/nlp-tokenize/lib/contractions.json"(exports, module2) {
    module2.exports = {
      "'s": ["'s"],
      "'S": ["'S"],
      "ain't": ["ai", "n't"],
      aint: ["ai", "nt"],
      "Ain't": ["Ai", "n't"],
      "aren't": ["are", "n't"],
      arent: ["are", "nt"],
      "Aren't": ["Are", "n't"],
      "can't": ["ca", "n't"],
      cant: ["ca", "nt"],
      "Can't": ["Ca", "n't"],
      "can't've": ["ca", "n't", "'ve"],
      "'cause": ["'cause'"],
      cannot: ["can", "not"],
      Cannot: ["Can", "not"],
      "could've": ["could", "'ve"],
      couldve: ["could", "ve"],
      "Could've": ["Could", "'ve"],
      "couldn't": ["could", "n't"],
      couldnt: ["could", "nt"],
      "Couldn't": ["Could", "n't"],
      "couldn't've": ["could", "n't", "'ve"],
      couldntve: ["could", "nt", "ve"],
      "Couldn't've": ["Could", "n't", "'ve"],
      "didn't": ["did", "n't"],
      didnt: ["did", "nt"],
      "Didn't": ["Did", "n't"],
      "doesn't": ["does", "n't"],
      doesnt: ["does", "nt"],
      "Doesn't": ["Does", "n't"],
      "don't": ["do", "n't"],
      dont: ["do", "nt"],
      "Don't": ["Do", "n't"],
      "hadn't": ["had", "n't"],
      hadnt: ["had", "nt"],
      "Hadn't": ["Had", "n't"],
      "hadn't've": ["had", "n't", "'ve"],
      "hasn't": ["has", "n't"],
      hasnt: ["has", "nt"],
      "haven't": ["have", "n't"],
      havent: ["have", "nt"],
      "he'd": ["he", "'d"],
      hed: ["he", "d"],
      "he'd've": ["he", "'d", "'ve"],
      hedve: ["he", "d", "ve"],
      "he'll": ["he", "'ll"],
      "he'll've": ["he", "'ll", "'ve"],
      "he's": ["he", "'s"],
      hes: ["he", "s"],
      "how'd": ["how", "'d"],
      howd: ["how", "d"],
      "how'd'y": ["how", "'d", "'y"],
      "how'll": ["how", "'ll"],
      howll: ["how", "ll"],
      "how's": ["how", "'s"],
      hows: ["how", "s"],
      "I'd": ["I", "'d"],
      "I'd've": ["I", "'d", "'ve"],
      "I'll": ["I", "'ll"],
      "i'll": ["i", "'ll"],
      "I'll've": ["I", "'ll", "'ve"],
      "i'll've": ["i", "'ll", "'ve"],
      "I'm": ["I", "'m"],
      "i'm": ["i", "'m"],
      Im: ["I", "m"],
      im: ["i", "m"],
      "I'ma": ["I", "'ma"],
      "i'ma": ["i", "'ma"],
      "I've": ["I", "'ve"],
      "i've": ["i", "'ve"],
      "isn't": ["is", "n't"],
      isnt: ["is", "nt"],
      "Isn't": ["Is", "n't"],
      "It'd": ["It", "'d"],
      "it'd": ["it", "'d"],
      "it'd've": ["it", "'d", "'ve"],
      "it'll've": ["it", "'ll", "'ve"],
      "it'll": ["it", "'ll"],
      itll: ["it", "ll"],
      "it's": ["it", "'s"],
      "let's": ["let", "'s"],
      lets: ["let", "s"],
      "ma'am": ["ma'am"],
      "mayn't": ["may", "n't"],
      "mightn't": ["might", "n't"],
      "mightn't've": ["might", "n't", "'ve"],
      "might've": ["might", "'ve"],
      "mustn't": ["must", "n't"],
      "mustn't've": ["must", "n't", "'ve"],
      "must've": ["must", "'ve"],
      "needn't": ["need", "n't"],
      "needn't've": ["need", "n't", "'ve"],
      "not've": ["not", "'ve"],
      "o'clock": ["o'clock"],
      "oughtn't": ["ought", "n't"],
      "oughtn't've": ["ought", "n't", "'ve"],
      "so've": ["so", "'ve"],
      "so's": ["so", "'s"],
      "shan't": ["sha", "n't"],
      "sha'n't": ["sha'", "n't"],
      "shan't've": ["sha", "n't", "'ve"],
      "she'd": ["she", "'d"],
      "she'd've": ["she", "'d", "'ve"],
      "she'll": ["she", "'ll"],
      "she'll've": ["she", "'ll", "'ve"],
      "she's": ["she", "'s"],
      "should've": ["should", "'ve"],
      "shouldn't": ["should", "n't"],
      "shouldn't've": ["should", "n't", "'ve"],
      "that'd": ["that", "'d"],
      "that'd've": ["that", "'d", "'ve"],
      "that's": ["that", "'s"],
      thats: ["that", "s"],
      "there'd": ["there", "'d"],
      "there'd've": ["there", "'d", "'ve"],
      "there's": ["there", "'s"],
      "they'd": ["they", "'d"],
      "They'd": ["They", "'d"],
      "they'd've": ["they", "'d", "'ve"],
      "They'd've": ["They", "'d", "'ve"],
      "they'll": ["they", "'ll"],
      "They'll": ["They", "'ll"],
      "they'll've": ["they", "'ll", "'ve"],
      "They'll've": ["They", "'ll", "'ve"],
      "they're": ["they", "'re"],
      "They're": ["They", "'re"],
      "they've": ["they", "'ve"],
      "They've": ["They", "'ve"],
      "to've": ["to", "'ve"],
      "wasn't": ["was", "n't"],
      "we'd": ["we", "'d"],
      "We'd": ["We", "'d"],
      "we'd've": ["we", "'d", "'ve"],
      "we'll": ["we", "'ll"],
      "We'll": ["We", "'ll"],
      "we'll've": ["we", "'ll", "'ve"],
      "We'll've": ["We", "'ll", "'ve"],
      "we're": ["we", "'re"],
      "We're": ["We", "'re"],
      "we've": ["we", "'ve"],
      "We've": ["We", "'ve"],
      "weren't": ["were", "n't"],
      "what'll": ["what", "'ll"],
      "what'll've": ["what", "'ll", "'ve"],
      "what're": ["what", "'re"],
      "what's": ["what", "'s"],
      "what've": ["what", "'ve"],
      "when's": ["when", "'s"],
      "when've": ["when", "'ve"],
      "where'd": ["where", "'d"],
      "where's": ["where", "'s"],
      "where've": ["where", "'ve"],
      "who'd": ["who", "'d"],
      "who'll": ["who", "'ll"],
      "who'll've": ["who", "'ll'", "'ve'"],
      "who're": ["who", "'re"],
      "who's": ["who", "'s"],
      "who've": ["who", "'ve"],
      "why've": ["why", "'ve"],
      "why'll": ["why", "'ll"],
      "why're": ["why", "'re"],
      "why's": ["why", "'s"],
      "will've": ["will", "'ve"],
      "won't": ["wo", "n't"],
      wont: ["wo", "nt"],
      "won't've": ["wo", "n't", "'ve"],
      "would've": ["would", "'ve"],
      "wouldn't": ["would", "n't"],
      "wouldn't've": ["would", "n't", "'ve"],
      "y'all": ["y'", "all"],
      "y'all'd": ["y'", "all", "'d"],
      "y'all'd've": ["y'", "all", "'d", "'ve"],
      "y'all're": ["y'", "all", "'re'"],
      "y'all've": ["y'", "all", "ve"],
      "you'd": ["you", "'d"],
      "You'd": ["You", "'d"],
      "you'd've": ["you", "'d", "'ve"],
      "You'd've": ["You", "'d", "'ve"],
      "you'll": ["you", "'ll"],
      "You'll": ["You", "'ll"],
      "you'll've": ["you", "'ll", "'ve"],
      "You'll've": ["You", "'ll", "'ve"],
      "you're": ["you", "'re"],
      "You're": ["You", "'re"],
      "you've": ["you", "'ve"],
      "You've": ["You", "'ve"]
    };
  }
});

// node_modules/@stdlib/nlp-tokenize/lib/tokenize.js
var require_tokenize = __commonJS({
  "node_modules/@stdlib/nlp-tokenize/lib/tokenize.js"(exports, module2) {
    "use strict";
    var isBoolean = require_lib71().isPrimitive;
    var isString = require_lib64().isPrimitive;
    var hasOwnProp = require_lib14();
    var ABBRS = require_abbreviations();
    var EMOJIS = require_emojis();
    var CONTRACT = require_contractions();
    var REGEXP_PREFIXES = /^([,([{*<"'`.])/gi;
    var REGEXP_SUFFIXES = /([,.!?%*>:;"'`)\]}])$/gi;
    function extend(arr, ext) {
      var i;
      for (i = 0; i < ext.length; i++) {
        arr.push(ext[i]);
      }
      return arr;
    }
    function tokenizeSubstring(substr) {
      var prefixes = [];
      var suffixes = [];
      var match;
      var done;
      var res;
      do {
        if (!EMOJIS[substr] && !ABBRS[substr] && !CONTRACT[substr]) {
          match = substr.split(REGEXP_PREFIXES);
          if (match.length > 1) {
            prefixes.push(match[1]);
            substr = match[2];
          } else {
            match = substr.split(REGEXP_SUFFIXES);
            if (match.length > 1) {
              substr = match[0];
              suffixes.push(match[1]);
            } else {
              done = true;
            }
          }
        } else {
          done = true;
        }
      } while (!done);
      res = prefixes;
      res.push(substr);
      extend(res, suffixes);
      return res;
    }
    function tokenize(str, keepWhitespace) {
      var subtkns;
      var substrs;
      var tokens;
      var substr;
      var cache;
      var i;
      if (!isString(str)) {
        throw new TypeError("invalid argument. First argument must be a string primitive. Value: `" + str + "`.");
      }
      if (arguments.length > 1) {
        if (!isBoolean(keepWhitespace)) {
          throw new TypeError("invalid argument. Second argument must be a boolean primitive. Value: `" + keepWhitespace + "`.");
        }
      }
      if (!str) {
        return [];
      }
      if (keepWhitespace) {
        substrs = str.split(/(\s+)/);
      } else {
        substrs = str.split(/\s+/);
      }
      cache = {};
      tokens = [];
      for (i = 0; i < substrs.length; i++) {
        substr = substrs[i];
        if (hasOwnProp(cache, substr)) {
          extend(tokens, cache[substr]);
        } else {
          subtkns = tokenizeSubstring(substr);
          extend(tokens, subtkns);
          cache[substr] = subtkns;
        }
      }
      return tokens;
    }
    module2.exports = tokenize;
  }
});

// node_modules/@stdlib/nlp-tokenize/lib/index.js
var require_lib72 = __commonJS({
  "node_modules/@stdlib/nlp-tokenize/lib/index.js"(exports, module2) {
    "use strict";
    var tokenize = require_tokenize();
    module2.exports = tokenize;
  }
});

// node_modules/@stdlib/assert-is-int32array/lib/main.js
var require_main37 = __commonJS({
  "node_modules/@stdlib/assert-is-int32array/lib/main.js"(exports, module2) {
    "use strict";
    var nativeClass = require_lib15();
    var hasInt32Array = typeof Int32Array === "function";
    function isInt32Array(value) {
      return hasInt32Array && value instanceof Int32Array || nativeClass(value) === "[object Int32Array]";
    }
    module2.exports = isInt32Array;
  }
});

// node_modules/@stdlib/assert-is-int32array/lib/index.js
var require_lib73 = __commonJS({
  "node_modules/@stdlib/assert-is-int32array/lib/index.js"(exports, module2) {
    "use strict";
    var isInt32Array = require_main37();
    module2.exports = isInt32Array;
  }
});

// node_modules/@stdlib/constants-int32-max/lib/index.js
var require_lib74 = __commonJS({
  "node_modules/@stdlib/constants-int32-max/lib/index.js"(exports, module2) {
    "use strict";
    var INT32_MAX = 2147483647 | 0;
    module2.exports = INT32_MAX;
  }
});

// node_modules/@stdlib/constants-int32-min/lib/index.js
var require_lib75 = __commonJS({
  "node_modules/@stdlib/constants-int32-min/lib/index.js"(exports, module2) {
    "use strict";
    var INT32_MIN = -2147483648 | 0;
    module2.exports = INT32_MIN;
  }
});

// node_modules/@stdlib/assert-has-int32array-support/lib/int32array.js
var require_int32array = __commonJS({
  "node_modules/@stdlib/assert-has-int32array-support/lib/int32array.js"(exports, module2) {
    "use strict";
    var main = typeof Int32Array === "function" ? Int32Array : null;
    module2.exports = main;
  }
});

// node_modules/@stdlib/assert-has-int32array-support/lib/main.js
var require_main38 = __commonJS({
  "node_modules/@stdlib/assert-has-int32array-support/lib/main.js"(exports, module2) {
    "use strict";
    var isInt32Array = require_lib73();
    var INT32_MAX = require_lib74();
    var INT32_MIN = require_lib75();
    var GlobalInt32Array = require_int32array();
    function hasInt32ArraySupport() {
      var bool;
      var arr;
      if (typeof GlobalInt32Array !== "function") {
        return false;
      }
      try {
        arr = new GlobalInt32Array([1, 3.14, -3.14, INT32_MAX + 1]);
        bool = isInt32Array(arr) && arr[0] === 1 && arr[1] === 3 && arr[2] === -3 && arr[3] === INT32_MIN;
      } catch (err) {
        bool = false;
      }
      return bool;
    }
    module2.exports = hasInt32ArraySupport;
  }
});

// node_modules/@stdlib/assert-has-int32array-support/lib/index.js
var require_lib76 = __commonJS({
  "node_modules/@stdlib/assert-has-int32array-support/lib/index.js"(exports, module2) {
    "use strict";
    var hasInt32ArraySupport = require_main38();
    module2.exports = hasInt32ArraySupport;
  }
});

// node_modules/@stdlib/array-int32/lib/int32array.js
var require_int32array2 = __commonJS({
  "node_modules/@stdlib/array-int32/lib/int32array.js"(exports, module2) {
    "use strict";
    var ctor = typeof Int32Array === "function" ? Int32Array : void 0;
    module2.exports = ctor;
  }
});

// node_modules/@stdlib/array-int32/lib/polyfill.js
var require_polyfill7 = __commonJS({
  "node_modules/@stdlib/array-int32/lib/polyfill.js"(exports, module2) {
    "use strict";
    function polyfill() {
      throw new Error("not implemented");
    }
    module2.exports = polyfill;
  }
});

// node_modules/@stdlib/array-int32/lib/index.js
var require_lib77 = __commonJS({
  "node_modules/@stdlib/array-int32/lib/index.js"(exports, module2) {
    "use strict";
    var hasInt32ArraySupport = require_lib76();
    var builtin = require_int32array2();
    var polyfill = require_polyfill7();
    var ctor;
    if (hasInt32ArraySupport()) {
      ctor = builtin;
    } else {
      ctor = polyfill;
    }
    module2.exports = ctor;
  }
});

// node_modules/@stdlib/nlp-lda/lib/matrix.js
var require_matrix = __commonJS({
  "node_modules/@stdlib/nlp-lda/lib/matrix.js"(exports, module2) {
    "use strict";
    var Int32Array2 = require_lib77();
    var Float64Array2 = require_lib22();
    var setReadOnly = require_lib57();
    function matrix() {
      var dtype;
      var ndims;
      var shape;
      var data;
      var len;
      var mat;
      var i;
      if (arguments.length === 1) {
        shape = arguments[0];
      } else if (arguments.length === 2) {
        shape = arguments[0];
        dtype = arguments[1];
      }
      ndims = shape.length;
      len = 1;
      for (i = 0; i < ndims; i++) {
        len *= shape[i];
      }
      if (dtype === "int32") {
        data = new Int32Array2(len);
      } else {
        data = new Float64Array2(len);
      }
      mat = {};
      mat.dtype = dtype;
      mat.shape = shape;
      mat.strides = [shape[1], 1];
      mat.offset = 0;
      mat.ndims = shape.length;
      mat.length = data.length;
      mat.nbytes = data.byteLength;
      mat.data = data;
      setReadOnly(mat, "get", get);
      setReadOnly(mat, "set", set);
      return mat;
      function get(i2, j) {
        var idx = this.offset + i2 * this.strides[0] + j * this.strides[1];
        return this.data[idx];
      }
      function set(i2, j, v) {
        i2 = this.offset + i2 * this.strides[0] + j * this.strides[1];
        if (i2 >= 0) {
          this.data[i2] = v;
        }
        return this;
      }
    }
    module2.exports = matrix;
  }
});

// node_modules/@stdlib/nlp-lda/lib/get_thetas.js
var require_get_thetas = __commonJS({
  "node_modules/@stdlib/nlp-lda/lib/get_thetas.js"(exports, module2) {
    "use strict";
    var matrix = require_matrix();
    function getThetas() {
      var Theta;
      var val;
      var d;
      var k;
      Theta = matrix([this.D, this.K]);
      for (d = 0; d < this.D; d++) {
        for (k = 0; k < this.K; k++) {
          val = (this.nd.get(d, k) + this.alpha) / (this.ndSum[d] + this.K * this.alpha);
          Theta.set(d, k, val);
        }
      }
      return Theta;
    }
    module2.exports = getThetas;
  }
});

// node_modules/@stdlib/assert-is-positive-number/lib/primitive.js
var require_primitive8 = __commonJS({
  "node_modules/@stdlib/assert-is-positive-number/lib/primitive.js"(exports, module2) {
    "use strict";
    var isNumber = require_lib58().isPrimitive;
    function isPositiveNumber(value) {
      return isNumber(value) && value > 0;
    }
    module2.exports = isPositiveNumber;
  }
});

// node_modules/@stdlib/assert-is-positive-number/lib/object.js
var require_object8 = __commonJS({
  "node_modules/@stdlib/assert-is-positive-number/lib/object.js"(exports, module2) {
    "use strict";
    var isNumber = require_lib58().isObject;
    function isPositiveNumber(value) {
      return isNumber(value) && value.valueOf() > 0;
    }
    module2.exports = isPositiveNumber;
  }
});

// node_modules/@stdlib/assert-is-positive-number/lib/main.js
var require_main39 = __commonJS({
  "node_modules/@stdlib/assert-is-positive-number/lib/main.js"(exports, module2) {
    "use strict";
    var isPrimitive = require_primitive8();
    var isObject = require_object8();
    function isPositiveNumber(value) {
      return isPrimitive(value) || isObject(value);
    }
    module2.exports = isPositiveNumber;
  }
});

// node_modules/@stdlib/assert-is-positive-number/lib/index.js
var require_lib78 = __commonJS({
  "node_modules/@stdlib/assert-is-positive-number/lib/index.js"(exports, module2) {
    "use strict";
    var setReadOnly = require_lib57();
    var isPositiveNumber = require_main39();
    var isPrimitive = require_primitive8();
    var isObject = require_object8();
    setReadOnly(isPositiveNumber, "isPrimitive", isPrimitive);
    setReadOnly(isPositiveNumber, "isObject", isObject);
    module2.exports = isPositiveNumber;
  }
});

// node_modules/@stdlib/assert-is-object/lib/main.js
var require_main40 = __commonJS({
  "node_modules/@stdlib/assert-is-object/lib/main.js"(exports, module2) {
    "use strict";
    var isArray = require_lib62();
    function isObject(value) {
      return typeof value === "object" && value !== null && !isArray(value);
    }
    module2.exports = isObject;
  }
});

// node_modules/@stdlib/assert-is-object/lib/index.js
var require_lib79 = __commonJS({
  "node_modules/@stdlib/assert-is-object/lib/index.js"(exports, module2) {
    "use strict";
    var isObject = require_main40();
    module2.exports = isObject;
  }
});

// node_modules/@stdlib/utils-type-of/lib/fixtures/re.js
var require_re = __commonJS({
  "node_modules/@stdlib/utils-type-of/lib/fixtures/re.js"(exports, module2) {
    "use strict";
    var RE = /./;
    module2.exports = RE;
  }
});

// node_modules/@stdlib/utils-global/lib/codegen.js
var require_codegen = __commonJS({
  "node_modules/@stdlib/utils-global/lib/codegen.js"(exports, module2) {
    "use strict";
    function getGlobal() {
      return new Function("return this;")();
    }
    module2.exports = getGlobal;
  }
});

// node_modules/@stdlib/utils-global/lib/self.js
var require_self = __commonJS({
  "node_modules/@stdlib/utils-global/lib/self.js"(exports, module2) {
    "use strict";
    var obj = typeof self === "object" ? self : null;
    module2.exports = obj;
  }
});

// node_modules/@stdlib/utils-global/lib/window.js
var require_window = __commonJS({
  "node_modules/@stdlib/utils-global/lib/window.js"(exports, module2) {
    "use strict";
    var obj = typeof window === "object" ? window : null;
    module2.exports = obj;
  }
});

// node_modules/@stdlib/utils-global/lib/global.js
var require_global = __commonJS({
  "node_modules/@stdlib/utils-global/lib/global.js"(exports, module2) {
    "use strict";
    var obj = typeof global === "object" ? global : null;
    module2.exports = obj;
  }
});

// node_modules/@stdlib/utils-global/lib/main.js
var require_main41 = __commonJS({
  "node_modules/@stdlib/utils-global/lib/main.js"(exports, module2) {
    "use strict";
    var isBoolean = require_lib71().isPrimitive;
    var getThis = require_codegen();
    var Self = require_self();
    var Win = require_window();
    var Global = require_global();
    function getGlobal(codegen) {
      if (arguments.length) {
        if (!isBoolean(codegen)) {
          throw new TypeError("invalid argument. Must provide a boolean primitive. Value: `" + codegen + "`.");
        }
        if (codegen) {
          return getThis();
        }
      }
      if (Self) {
        return Self;
      }
      if (Win) {
        return Win;
      }
      if (Global) {
        return Global;
      }
      throw new Error("unexpected error. Unable to resolve global object.");
    }
    module2.exports = getGlobal;
  }
});

// node_modules/@stdlib/utils-global/lib/index.js
var require_lib80 = __commonJS({
  "node_modules/@stdlib/utils-global/lib/index.js"(exports, module2) {
    "use strict";
    var getGlobal = require_main41();
    module2.exports = getGlobal;
  }
});

// node_modules/@stdlib/utils-type-of/lib/fixtures/nodelist.js
var require_nodelist = __commonJS({
  "node_modules/@stdlib/utils-type-of/lib/fixtures/nodelist.js"(exports, module2) {
    "use strict";
    var getGlobal = require_lib80();
    var root = getGlobal();
    var nodeList = root.document && root.document.childNodes;
    module2.exports = nodeList;
  }
});

// node_modules/@stdlib/utils-type-of/lib/fixtures/typedarray.js
var require_typedarray = __commonJS({
  "node_modules/@stdlib/utils-type-of/lib/fixtures/typedarray.js"(exports, module2) {
    "use strict";
    var typedarray = Int8Array;
    module2.exports = typedarray;
  }
});

// node_modules/@stdlib/utils-type-of/lib/check.js
var require_check = __commonJS({
  "node_modules/@stdlib/utils-type-of/lib/check.js"(exports, module2) {
    "use strict";
    var RE = require_re();
    var nodeList = require_nodelist();
    var typedarray = require_typedarray();
    function check() {
      if (typeof RE === "function" || typeof typedarray === "object" || typeof nodeList === "function") {
        return true;
      }
      return false;
    }
    module2.exports = check;
  }
});

// node_modules/@stdlib/regexp-function-name/lib/main.js
var require_main42 = __commonJS({
  "node_modules/@stdlib/regexp-function-name/lib/main.js"(exports, module2) {
    "use strict";
    function reFunctionName() {
      return /^\s*function\s*([^(]*)/i;
    }
    module2.exports = reFunctionName;
  }
});

// node_modules/@stdlib/regexp-function-name/lib/regexp.js
var require_regexp = __commonJS({
  "node_modules/@stdlib/regexp-function-name/lib/regexp.js"(exports, module2) {
    "use strict";
    var reFunctionName = require_main42();
    var RE_FUNCTION_NAME = reFunctionName();
    module2.exports = RE_FUNCTION_NAME;
  }
});

// node_modules/@stdlib/regexp-function-name/lib/index.js
var require_lib81 = __commonJS({
  "node_modules/@stdlib/regexp-function-name/lib/index.js"(exports, module2) {
    "use strict";
    var setReadOnly = require_lib57();
    var reFunctionName = require_main42();
    var REGEXP = require_regexp();
    setReadOnly(reFunctionName, "REGEXP", REGEXP);
    module2.exports = reFunctionName;
  }
});

// node_modules/@stdlib/assert-is-object-like/lib/main.js
var require_main43 = __commonJS({
  "node_modules/@stdlib/assert-is-object-like/lib/main.js"(exports, module2) {
    "use strict";
    function isObjectLike(value) {
      return value !== null && typeof value === "object";
    }
    module2.exports = isObjectLike;
  }
});

// node_modules/@stdlib/assert-is-object-like/lib/index.js
var require_lib82 = __commonJS({
  "node_modules/@stdlib/assert-is-object-like/lib/index.js"(exports, module2) {
    "use strict";
    var setReadOnly = require_lib57();
    var arrayfun = require_lib63();
    var isObjectLike = require_main43();
    setReadOnly(isObjectLike, "isObjectLikeArray", arrayfun(isObjectLike));
    module2.exports = isObjectLike;
  }
});

// node_modules/@stdlib/assert-is-buffer/lib/main.js
var require_main44 = __commonJS({
  "node_modules/@stdlib/assert-is-buffer/lib/main.js"(exports, module2) {
    "use strict";
    var isObjectLike = require_lib82();
    function isBuffer(value) {
      return isObjectLike(value) && (value._isBuffer || value.constructor && typeof value.constructor.isBuffer === "function" && value.constructor.isBuffer(value));
    }
    module2.exports = isBuffer;
  }
});

// node_modules/@stdlib/assert-is-buffer/lib/index.js
var require_lib83 = __commonJS({
  "node_modules/@stdlib/assert-is-buffer/lib/index.js"(exports, module2) {
    "use strict";
    var isBuffer = require_main44();
    module2.exports = isBuffer;
  }
});

// node_modules/@stdlib/utils-constructor-name/lib/main.js
var require_main45 = __commonJS({
  "node_modules/@stdlib/utils-constructor-name/lib/main.js"(exports, module2) {
    "use strict";
    var nativeClass = require_lib15();
    var RE = require_lib81().REGEXP;
    var isBuffer = require_lib83();
    function constructorName(v) {
      var match;
      var name;
      var ctor;
      name = nativeClass(v).slice(8, -1);
      if ((name === "Object" || name === "Error") && v.constructor) {
        ctor = v.constructor;
        if (typeof ctor.name === "string") {
          return ctor.name;
        }
        match = RE.exec(ctor.toString());
        if (match) {
          return match[1];
        }
      }
      if (isBuffer(v)) {
        return "Buffer";
      }
      return name;
    }
    module2.exports = constructorName;
  }
});

// node_modules/@stdlib/utils-constructor-name/lib/index.js
var require_lib84 = __commonJS({
  "node_modules/@stdlib/utils-constructor-name/lib/index.js"(exports, module2) {
    "use strict";
    var constructorName = require_main45();
    module2.exports = constructorName;
  }
});

// node_modules/@stdlib/utils-type-of/lib/typeof.js
var require_typeof = __commonJS({
  "node_modules/@stdlib/utils-type-of/lib/typeof.js"(exports, module2) {
    "use strict";
    var ctorName = require_lib84();
    function typeOf(v) {
      var type;
      if (v === null) {
        return "null";
      }
      type = typeof v;
      if (type === "object") {
        return ctorName(v).toLowerCase();
      }
      return type;
    }
    module2.exports = typeOf;
  }
});

// node_modules/@stdlib/utils-type-of/lib/polyfill.js
var require_polyfill8 = __commonJS({
  "node_modules/@stdlib/utils-type-of/lib/polyfill.js"(exports, module2) {
    "use strict";
    var ctorName = require_lib84();
    function typeOf(v) {
      return ctorName(v).toLowerCase();
    }
    module2.exports = typeOf;
  }
});

// node_modules/@stdlib/utils-type-of/lib/index.js
var require_lib85 = __commonJS({
  "node_modules/@stdlib/utils-type-of/lib/index.js"(exports, module2) {
    "use strict";
    var usePolyfill = require_check();
    var typeOf = require_typeof();
    var polyfill = require_polyfill8();
    var main = usePolyfill() ? polyfill : typeOf;
    module2.exports = main;
  }
});

// node_modules/@stdlib/assert-is-function/lib/main.js
var require_main46 = __commonJS({
  "node_modules/@stdlib/assert-is-function/lib/main.js"(exports, module2) {
    "use strict";
    var typeOf = require_lib85();
    function isFunction(value) {
      return typeOf(value) === "function";
    }
    module2.exports = isFunction;
  }
});

// node_modules/@stdlib/assert-is-function/lib/index.js
var require_lib86 = __commonJS({
  "node_modules/@stdlib/assert-is-function/lib/index.js"(exports, module2) {
    "use strict";
    var isFunction = require_main46();
    module2.exports = isFunction;
  }
});

// node_modules/@stdlib/utils-get-prototype-of/lib/native.js
var require_native = __commonJS({
  "node_modules/@stdlib/utils-get-prototype-of/lib/native.js"(exports, module2) {
    "use strict";
    var getProto = Object.getPrototypeOf;
    module2.exports = getProto;
  }
});

// node_modules/@stdlib/utils-get-prototype-of/lib/proto.js
var require_proto = __commonJS({
  "node_modules/@stdlib/utils-get-prototype-of/lib/proto.js"(exports, module2) {
    "use strict";
    function getProto(obj) {
      return obj.__proto__;
    }
    module2.exports = getProto;
  }
});

// node_modules/@stdlib/utils-get-prototype-of/lib/polyfill.js
var require_polyfill9 = __commonJS({
  "node_modules/@stdlib/utils-get-prototype-of/lib/polyfill.js"(exports, module2) {
    "use strict";
    var nativeClass = require_lib15();
    var getProto = require_proto();
    function getPrototypeOf(obj) {
      var proto = getProto(obj);
      if (proto || proto === null) {
        return proto;
      }
      if (nativeClass(obj.constructor) === "[object Function]") {
        return obj.constructor.prototype;
      }
      if (obj instanceof Object) {
        return Object.prototype;
      }
      return null;
    }
    module2.exports = getPrototypeOf;
  }
});

// node_modules/@stdlib/utils-get-prototype-of/lib/detect.js
var require_detect = __commonJS({
  "node_modules/@stdlib/utils-get-prototype-of/lib/detect.js"(exports, module2) {
    "use strict";
    var isFunction = require_lib86();
    var builtin = require_native();
    var polyfill = require_polyfill9();
    var getProto;
    if (isFunction(Object.getPrototypeOf)) {
      getProto = builtin;
    } else {
      getProto = polyfill;
    }
    module2.exports = getProto;
  }
});

// node_modules/@stdlib/utils-get-prototype-of/lib/get_prototype_of.js
var require_get_prototype_of = __commonJS({
  "node_modules/@stdlib/utils-get-prototype-of/lib/get_prototype_of.js"(exports, module2) {
    "use strict";
    var getProto = require_detect();
    function getPrototypeOf(value) {
      if (value === null || value === void 0) {
        return null;
      }
      value = Object(value);
      return getProto(value);
    }
    module2.exports = getPrototypeOf;
  }
});

// node_modules/@stdlib/utils-get-prototype-of/lib/index.js
var require_lib87 = __commonJS({
  "node_modules/@stdlib/utils-get-prototype-of/lib/index.js"(exports, module2) {
    "use strict";
    var getPrototype = require_get_prototype_of();
    module2.exports = getPrototype;
  }
});

// node_modules/@stdlib/assert-is-plain-object/lib/main.js
var require_main47 = __commonJS({
  "node_modules/@stdlib/assert-is-plain-object/lib/main.js"(exports, module2) {
    "use strict";
    var isObject = require_lib79();
    var isFunction = require_lib86();
    var getPrototypeOf = require_lib87();
    var hasOwnProp = require_lib14();
    var nativeClass = require_lib15();
    var objectPrototype = Object.prototype;
    function ownProps(obj) {
      var key;
      for (key in obj) {
        if (!hasOwnProp(obj, key)) {
          return false;
        }
      }
      return true;
    }
    function isPlainObject(value) {
      var proto;
      if (!isObject(value)) {
        return false;
      }
      proto = getPrototypeOf(value);
      if (!proto) {
        return true;
      }
      return !hasOwnProp(value, "constructor") && hasOwnProp(proto, "constructor") && isFunction(proto.constructor) && nativeClass(proto.constructor) === "[object Function]" && hasOwnProp(proto, "isPrototypeOf") && isFunction(proto.isPrototypeOf) && (proto === objectPrototype || ownProps(value));
    }
    module2.exports = isPlainObject;
  }
});

// node_modules/@stdlib/assert-is-plain-object/lib/index.js
var require_lib88 = __commonJS({
  "node_modules/@stdlib/assert-is-plain-object/lib/index.js"(exports, module2) {
    "use strict";
    var isPlainObject = require_main47();
    module2.exports = isPlainObject;
  }
});

// node_modules/@stdlib/nlp-lda/lib/validate.js
var require_validate = __commonJS({
  "node_modules/@stdlib/nlp-lda/lib/validate.js"(exports, module2) {
    "use strict";
    var isPositive = require_lib78().isPrimitive;
    var isObject = require_lib88();
    var hasOwnProp = require_lib14();
    function validate(opts, options) {
      if (!isObject(options)) {
        return new TypeError("invalid argument. Options must be an object. Value: `" + options + "`.");
      }
      if (hasOwnProp(options, "alpha")) {
        opts.alpha = options.alpha;
        if (!isPositive(opts.alpha)) {
          return new TypeError("invalid option. `alpha` option must be a positive number. Option: `" + opts.alpha + "`.");
        }
      }
      if (hasOwnProp(options, "beta")) {
        opts.beta = options.beta;
        if (!isPositive(opts.beta)) {
          return new TypeError("invalid option. `beta` option must be a positive number. Option: `" + opts.beta + "`.");
        }
      }
      return null;
    }
    module2.exports = validate;
  }
});

// node_modules/@stdlib/nlp-lda/lib/get_phis.js
var require_get_phis = __commonJS({
  "node_modules/@stdlib/nlp-lda/lib/get_phis.js"(exports, module2) {
    "use strict";
    var matrix = require_matrix();
    function getPhis() {
      var Phi;
      var val;
      var k;
      var w;
      Phi = matrix([this.K, this.W]);
      for (k = 0; k < this.K; k++) {
        for (w = 0; w < this.W; w++) {
          val = (this.nw.get(w, k) + this.beta) / (this.nwSum[k] + this.W * this.beta);
          Phi.set(k, w, val);
        }
      }
      return Phi;
    }
    module2.exports = getPhis;
  }
});

// node_modules/@stdlib/utils-define-nonenumerable-read-only-accessor/lib/main.js
var require_main48 = __commonJS({
  "node_modules/@stdlib/utils-define-nonenumerable-read-only-accessor/lib/main.js"(exports, module2) {
    "use strict";
    var defineProperty = require_lib56();
    function setNonEnumerableReadOnlyAccessor(obj, prop, getter) {
      defineProperty(obj, prop, {
        "configurable": false,
        "enumerable": false,
        "get": getter
      });
    }
    module2.exports = setNonEnumerableReadOnlyAccessor;
  }
});

// node_modules/@stdlib/utils-define-nonenumerable-read-only-accessor/lib/index.js
var require_lib89 = __commonJS({
  "node_modules/@stdlib/utils-define-nonenumerable-read-only-accessor/lib/index.js"(exports, module2) {
    "use strict";
    var setNonEnumerableReadOnlyAccessor = require_main48();
    module2.exports = setNonEnumerableReadOnlyAccessor;
  }
});

// node_modules/@stdlib/utils-define-nonenumerable-read-write-accessor/lib/main.js
var require_main49 = __commonJS({
  "node_modules/@stdlib/utils-define-nonenumerable-read-write-accessor/lib/main.js"(exports, module2) {
    "use strict";
    var defineProperty = require_lib56();
    function setNonEnumerableReadWriteAccessor(obj, prop, getter, setter) {
      defineProperty(obj, prop, {
        "configurable": false,
        "enumerable": false,
        "get": getter,
        "set": setter
      });
    }
    module2.exports = setNonEnumerableReadWriteAccessor;
  }
});

// node_modules/@stdlib/utils-define-nonenumerable-read-write-accessor/lib/index.js
var require_lib90 = __commonJS({
  "node_modules/@stdlib/utils-define-nonenumerable-read-write-accessor/lib/index.js"(exports, module2) {
    "use strict";
    var setNonEnumerableReadWriteAccessor = require_main49();
    module2.exports = setNonEnumerableReadWriteAccessor;
  }
});

// node_modules/@stdlib/assert-has-function-name-support/lib/foo.js
var require_foo = __commonJS({
  "node_modules/@stdlib/assert-has-function-name-support/lib/foo.js"(exports, module2) {
    "use strict";
    function foo() {
    }
    module2.exports = foo;
  }
});

// node_modules/@stdlib/assert-has-function-name-support/lib/main.js
var require_main50 = __commonJS({
  "node_modules/@stdlib/assert-has-function-name-support/lib/main.js"(exports, module2) {
    "use strict";
    var foo = require_foo();
    function hasFunctionNameSupport() {
      return foo.name === "foo";
    }
    module2.exports = hasFunctionNameSupport;
  }
});

// node_modules/@stdlib/assert-has-function-name-support/lib/index.js
var require_lib91 = __commonJS({
  "node_modules/@stdlib/assert-has-function-name-support/lib/index.js"(exports, module2) {
    "use strict";
    var hasFunctionNameSupport = require_main50();
    module2.exports = hasFunctionNameSupport;
  }
});

// node_modules/@stdlib/utils-function-name/lib/function_name.js
var require_function_name = __commonJS({
  "node_modules/@stdlib/utils-function-name/lib/function_name.js"(exports, module2) {
    "use strict";
    var isFunction = require_lib86();
    var hasFunctionNameSupport = require_lib91();
    var RE = require_lib81().REGEXP;
    var isFunctionNameSupported = hasFunctionNameSupport();
    function functionName(fcn) {
      if (isFunction(fcn) === false) {
        throw new TypeError("invalid argument. Must provide a function. Value: `" + fcn + "`.");
      }
      if (isFunctionNameSupported) {
        return fcn.name;
      }
      return RE.exec(fcn.toString())[1];
    }
    module2.exports = functionName;
  }
});

// node_modules/@stdlib/utils-function-name/lib/index.js
var require_lib92 = __commonJS({
  "node_modules/@stdlib/utils-function-name/lib/index.js"(exports, module2) {
    "use strict";
    var functionName = require_function_name();
    module2.exports = functionName;
  }
});

// node_modules/@stdlib/assert-is-int8array/lib/main.js
var require_main51 = __commonJS({
  "node_modules/@stdlib/assert-is-int8array/lib/main.js"(exports, module2) {
    "use strict";
    var nativeClass = require_lib15();
    var hasInt8Array = typeof Int8Array === "function";
    function isInt8Array(value) {
      return hasInt8Array && value instanceof Int8Array || nativeClass(value) === "[object Int8Array]";
    }
    module2.exports = isInt8Array;
  }
});

// node_modules/@stdlib/assert-is-int8array/lib/index.js
var require_lib93 = __commonJS({
  "node_modules/@stdlib/assert-is-int8array/lib/index.js"(exports, module2) {
    "use strict";
    var isInt8Array = require_main51();
    module2.exports = isInt8Array;
  }
});

// node_modules/@stdlib/constants-int8-max/lib/index.js
var require_lib94 = __commonJS({
  "node_modules/@stdlib/constants-int8-max/lib/index.js"(exports, module2) {
    "use strict";
    var INT8_MAX = 127 | 0;
    module2.exports = INT8_MAX;
  }
});

// node_modules/@stdlib/constants-int8-min/lib/index.js
var require_lib95 = __commonJS({
  "node_modules/@stdlib/constants-int8-min/lib/index.js"(exports, module2) {
    "use strict";
    var INT8_MIN = -128 | 0;
    module2.exports = INT8_MIN;
  }
});

// node_modules/@stdlib/assert-has-int8array-support/lib/int8array.js
var require_int8array = __commonJS({
  "node_modules/@stdlib/assert-has-int8array-support/lib/int8array.js"(exports, module2) {
    "use strict";
    var main = typeof Int8Array === "function" ? Int8Array : null;
    module2.exports = main;
  }
});

// node_modules/@stdlib/assert-has-int8array-support/lib/main.js
var require_main52 = __commonJS({
  "node_modules/@stdlib/assert-has-int8array-support/lib/main.js"(exports, module2) {
    "use strict";
    var isInt8Array = require_lib93();
    var INT8_MAX = require_lib94();
    var INT8_MIN = require_lib95();
    var GlobalInt8Array = require_int8array();
    function hasInt8ArraySupport() {
      var bool;
      var arr;
      if (typeof GlobalInt8Array !== "function") {
        return false;
      }
      try {
        arr = new GlobalInt8Array([1, 3.14, -3.14, INT8_MAX + 1]);
        bool = isInt8Array(arr) && arr[0] === 1 && arr[1] === 3 && arr[2] === -3 && arr[3] === INT8_MIN;
      } catch (err) {
        bool = false;
      }
      return bool;
    }
    module2.exports = hasInt8ArraySupport;
  }
});

// node_modules/@stdlib/assert-has-int8array-support/lib/index.js
var require_lib96 = __commonJS({
  "node_modules/@stdlib/assert-has-int8array-support/lib/index.js"(exports, module2) {
    "use strict";
    var hasInt8ArraySupport = require_main52();
    module2.exports = hasInt8ArraySupport;
  }
});

// node_modules/@stdlib/array-int8/lib/int8array.js
var require_int8array2 = __commonJS({
  "node_modules/@stdlib/array-int8/lib/int8array.js"(exports, module2) {
    "use strict";
    var ctor = typeof Int8Array === "function" ? Int8Array : void 0;
    module2.exports = ctor;
  }
});

// node_modules/@stdlib/array-int8/lib/polyfill.js
var require_polyfill10 = __commonJS({
  "node_modules/@stdlib/array-int8/lib/polyfill.js"(exports, module2) {
    "use strict";
    function polyfill() {
      throw new Error("not implemented");
    }
    module2.exports = polyfill;
  }
});

// node_modules/@stdlib/array-int8/lib/index.js
var require_lib97 = __commonJS({
  "node_modules/@stdlib/array-int8/lib/index.js"(exports, module2) {
    "use strict";
    var hasInt8ArraySupport = require_lib96();
    var builtin = require_int8array2();
    var polyfill = require_polyfill10();
    var ctor;
    if (hasInt8ArraySupport()) {
      ctor = builtin;
    } else {
      ctor = polyfill;
    }
    module2.exports = ctor;
  }
});

// node_modules/@stdlib/assert-is-uint8clampedarray/lib/main.js
var require_main53 = __commonJS({
  "node_modules/@stdlib/assert-is-uint8clampedarray/lib/main.js"(exports, module2) {
    "use strict";
    var nativeClass = require_lib15();
    var hasUint8ClampedArray = typeof Uint8ClampedArray === "function";
    function isUint8ClampedArray(value) {
      return hasUint8ClampedArray && value instanceof Uint8ClampedArray || nativeClass(value) === "[object Uint8ClampedArray]";
    }
    module2.exports = isUint8ClampedArray;
  }
});

// node_modules/@stdlib/assert-is-uint8clampedarray/lib/index.js
var require_lib98 = __commonJS({
  "node_modules/@stdlib/assert-is-uint8clampedarray/lib/index.js"(exports, module2) {
    "use strict";
    var isUint8ClampedArray = require_main53();
    module2.exports = isUint8ClampedArray;
  }
});

// node_modules/@stdlib/assert-has-uint8clampedarray-support/lib/uint8clampedarray.js
var require_uint8clampedarray = __commonJS({
  "node_modules/@stdlib/assert-has-uint8clampedarray-support/lib/uint8clampedarray.js"(exports, module2) {
    "use strict";
    var main = typeof Uint8ClampedArray === "function" ? Uint8ClampedArray : null;
    module2.exports = main;
  }
});

// node_modules/@stdlib/assert-has-uint8clampedarray-support/lib/main.js
var require_main54 = __commonJS({
  "node_modules/@stdlib/assert-has-uint8clampedarray-support/lib/main.js"(exports, module2) {
    "use strict";
    var isUint8ClampedArray = require_lib98();
    var GlobalUint8ClampedArray = require_uint8clampedarray();
    function hasUint8ClampedArraySupport() {
      var bool;
      var arr;
      if (typeof GlobalUint8ClampedArray !== "function") {
        return false;
      }
      try {
        arr = new GlobalUint8ClampedArray([-1, 0, 1, 3.14, 4.99, 255, 256]);
        bool = isUint8ClampedArray(arr) && arr[0] === 0 && arr[1] === 0 && arr[2] === 1 && arr[3] === 3 && arr[4] === 5 && arr[5] === 255 && arr[6] === 255;
      } catch (err) {
        bool = false;
      }
      return bool;
    }
    module2.exports = hasUint8ClampedArraySupport;
  }
});

// node_modules/@stdlib/assert-has-uint8clampedarray-support/lib/index.js
var require_lib99 = __commonJS({
  "node_modules/@stdlib/assert-has-uint8clampedarray-support/lib/index.js"(exports, module2) {
    "use strict";
    var hasUint8ClampedArraySupport = require_main54();
    module2.exports = hasUint8ClampedArraySupport;
  }
});

// node_modules/@stdlib/array-uint8c/lib/uint8clampedarray.js
var require_uint8clampedarray2 = __commonJS({
  "node_modules/@stdlib/array-uint8c/lib/uint8clampedarray.js"(exports, module2) {
    "use strict";
    var ctor = typeof Uint8ClampedArray === "function" ? Uint8ClampedArray : void 0;
    module2.exports = ctor;
  }
});

// node_modules/@stdlib/array-uint8c/lib/polyfill.js
var require_polyfill11 = __commonJS({
  "node_modules/@stdlib/array-uint8c/lib/polyfill.js"(exports, module2) {
    "use strict";
    function polyfill() {
      throw new Error("not implemented");
    }
    module2.exports = polyfill;
  }
});

// node_modules/@stdlib/array-uint8c/lib/index.js
var require_lib100 = __commonJS({
  "node_modules/@stdlib/array-uint8c/lib/index.js"(exports, module2) {
    "use strict";
    var hasUint8ClampedArraySupport = require_lib99();
    var builtin = require_uint8clampedarray2();
    var polyfill = require_polyfill11();
    var ctor;
    if (hasUint8ClampedArraySupport()) {
      ctor = builtin;
    } else {
      ctor = polyfill;
    }
    module2.exports = ctor;
  }
});

// node_modules/@stdlib/assert-is-int16array/lib/main.js
var require_main55 = __commonJS({
  "node_modules/@stdlib/assert-is-int16array/lib/main.js"(exports, module2) {
    "use strict";
    var nativeClass = require_lib15();
    var hasInt16Array = typeof Int16Array === "function";
    function isInt16Array(value) {
      return hasInt16Array && value instanceof Int16Array || nativeClass(value) === "[object Int16Array]";
    }
    module2.exports = isInt16Array;
  }
});

// node_modules/@stdlib/assert-is-int16array/lib/index.js
var require_lib101 = __commonJS({
  "node_modules/@stdlib/assert-is-int16array/lib/index.js"(exports, module2) {
    "use strict";
    var isInt16Array = require_main55();
    module2.exports = isInt16Array;
  }
});

// node_modules/@stdlib/constants-int16-max/lib/index.js
var require_lib102 = __commonJS({
  "node_modules/@stdlib/constants-int16-max/lib/index.js"(exports, module2) {
    "use strict";
    var INT16_MAX = 32767 | 0;
    module2.exports = INT16_MAX;
  }
});

// node_modules/@stdlib/constants-int16-min/lib/index.js
var require_lib103 = __commonJS({
  "node_modules/@stdlib/constants-int16-min/lib/index.js"(exports, module2) {
    "use strict";
    var INT16_MIN = -32768 | 0;
    module2.exports = INT16_MIN;
  }
});

// node_modules/@stdlib/assert-has-int16array-support/lib/int16array.js
var require_int16array = __commonJS({
  "node_modules/@stdlib/assert-has-int16array-support/lib/int16array.js"(exports, module2) {
    "use strict";
    var main = typeof Int16Array === "function" ? Int16Array : null;
    module2.exports = main;
  }
});

// node_modules/@stdlib/assert-has-int16array-support/lib/main.js
var require_main56 = __commonJS({
  "node_modules/@stdlib/assert-has-int16array-support/lib/main.js"(exports, module2) {
    "use strict";
    var isInt16Array = require_lib101();
    var INT16_MAX = require_lib102();
    var INT16_MIN = require_lib103();
    var GlobalInt16Array = require_int16array();
    function hasInt16ArraySupport() {
      var bool;
      var arr;
      if (typeof GlobalInt16Array !== "function") {
        return false;
      }
      try {
        arr = new GlobalInt16Array([1, 3.14, -3.14, INT16_MAX + 1]);
        bool = isInt16Array(arr) && arr[0] === 1 && arr[1] === 3 && arr[2] === -3 && arr[3] === INT16_MIN;
      } catch (err) {
        bool = false;
      }
      return bool;
    }
    module2.exports = hasInt16ArraySupport;
  }
});

// node_modules/@stdlib/assert-has-int16array-support/lib/index.js
var require_lib104 = __commonJS({
  "node_modules/@stdlib/assert-has-int16array-support/lib/index.js"(exports, module2) {
    "use strict";
    var hasInt16ArraySupport = require_main56();
    module2.exports = hasInt16ArraySupport;
  }
});

// node_modules/@stdlib/array-int16/lib/int16array.js
var require_int16array2 = __commonJS({
  "node_modules/@stdlib/array-int16/lib/int16array.js"(exports, module2) {
    "use strict";
    var ctor = typeof Int16Array === "function" ? Int16Array : void 0;
    module2.exports = ctor;
  }
});

// node_modules/@stdlib/array-int16/lib/polyfill.js
var require_polyfill12 = __commonJS({
  "node_modules/@stdlib/array-int16/lib/polyfill.js"(exports, module2) {
    "use strict";
    function polyfill() {
      throw new Error("not implemented");
    }
    module2.exports = polyfill;
  }
});

// node_modules/@stdlib/array-int16/lib/index.js
var require_lib105 = __commonJS({
  "node_modules/@stdlib/array-int16/lib/index.js"(exports, module2) {
    "use strict";
    var hasInt16ArraySupport = require_lib104();
    var builtin = require_int16array2();
    var polyfill = require_polyfill12();
    var ctor;
    if (hasInt16ArraySupport()) {
      ctor = builtin;
    } else {
      ctor = polyfill;
    }
    module2.exports = ctor;
  }
});

// node_modules/@stdlib/assert-is-float32array/lib/main.js
var require_main57 = __commonJS({
  "node_modules/@stdlib/assert-is-float32array/lib/main.js"(exports, module2) {
    "use strict";
    var nativeClass = require_lib15();
    var hasFloat32Array = typeof Float32Array === "function";
    function isFloat32Array(value) {
      return hasFloat32Array && value instanceof Float32Array || nativeClass(value) === "[object Float32Array]";
    }
    module2.exports = isFloat32Array;
  }
});

// node_modules/@stdlib/assert-is-float32array/lib/index.js
var require_lib106 = __commonJS({
  "node_modules/@stdlib/assert-is-float32array/lib/index.js"(exports, module2) {
    "use strict";
    var isFloat32Array = require_main57();
    module2.exports = isFloat32Array;
  }
});

// node_modules/@stdlib/assert-has-float32array-support/lib/float32array.js
var require_float32array = __commonJS({
  "node_modules/@stdlib/assert-has-float32array-support/lib/float32array.js"(exports, module2) {
    "use strict";
    var main = typeof Float32Array === "function" ? Float32Array : null;
    module2.exports = main;
  }
});

// node_modules/@stdlib/assert-has-float32array-support/lib/main.js
var require_main58 = __commonJS({
  "node_modules/@stdlib/assert-has-float32array-support/lib/main.js"(exports, module2) {
    "use strict";
    var isFloat32Array = require_lib106();
    var PINF = require_lib2();
    var GlobalFloat32Array = require_float32array();
    function hasFloat32ArraySupport() {
      var bool;
      var arr;
      if (typeof GlobalFloat32Array !== "function") {
        return false;
      }
      try {
        arr = new GlobalFloat32Array([1, 3.14, -3.14, 5e40]);
        bool = isFloat32Array(arr) && arr[0] === 1 && arr[1] === 3.140000104904175 && arr[2] === -3.140000104904175 && arr[3] === PINF;
      } catch (err) {
        bool = false;
      }
      return bool;
    }
    module2.exports = hasFloat32ArraySupport;
  }
});

// node_modules/@stdlib/assert-has-float32array-support/lib/index.js
var require_lib107 = __commonJS({
  "node_modules/@stdlib/assert-has-float32array-support/lib/index.js"(exports, module2) {
    "use strict";
    var hasFloat32ArraySupport = require_main58();
    module2.exports = hasFloat32ArraySupport;
  }
});

// node_modules/@stdlib/array-float32/lib/float32array.js
var require_float32array2 = __commonJS({
  "node_modules/@stdlib/array-float32/lib/float32array.js"(exports, module2) {
    "use strict";
    var ctor = typeof Float32Array === "function" ? Float32Array : void 0;
    module2.exports = ctor;
  }
});

// node_modules/@stdlib/array-float32/lib/polyfill.js
var require_polyfill13 = __commonJS({
  "node_modules/@stdlib/array-float32/lib/polyfill.js"(exports, module2) {
    "use strict";
    function polyfill() {
      throw new Error("not implemented");
    }
    module2.exports = polyfill;
  }
});

// node_modules/@stdlib/array-float32/lib/index.js
var require_lib108 = __commonJS({
  "node_modules/@stdlib/array-float32/lib/index.js"(exports, module2) {
    "use strict";
    var hasFloat32ArraySupport = require_lib107();
    var builtin = require_float32array2();
    var polyfill = require_polyfill13();
    var ctor;
    if (hasFloat32ArraySupport()) {
      ctor = builtin;
    } else {
      ctor = polyfill;
    }
    module2.exports = ctor;
  }
});

// node_modules/@stdlib/assert-is-typed-array/lib/ctors.js
var require_ctors2 = __commonJS({
  "node_modules/@stdlib/assert-is-typed-array/lib/ctors.js"(exports, module2) {
    "use strict";
    var Int8Array2 = require_lib97();
    var Uint8Array2 = require_lib26();
    var Uint8ClampedArray2 = require_lib100();
    var Int16Array2 = require_lib105();
    var Uint16Array2 = require_lib30();
    var Int32Array2 = require_lib77();
    var Uint32Array2 = require_lib19();
    var Float32Array2 = require_lib108();
    var Float64Array2 = require_lib22();
    var CTORS = [
      Float64Array2,
      Float32Array2,
      Int32Array2,
      Uint32Array2,
      Int16Array2,
      Uint16Array2,
      Int8Array2,
      Uint8Array2,
      Uint8ClampedArray2
    ];
    module2.exports = CTORS;
  }
});

// node_modules/@stdlib/assert-is-typed-array/lib/names.json
var require_names = __commonJS({
  "node_modules/@stdlib/assert-is-typed-array/lib/names.json"(exports, module2) {
    module2.exports = [
      "Int8Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "Int16Array",
      "Uint16Array",
      "Int32Array",
      "Uint32Array",
      "Float32Array",
      "Float64Array"
    ];
  }
});

// node_modules/@stdlib/assert-is-typed-array/lib/main.js
var require_main59 = __commonJS({
  "node_modules/@stdlib/assert-is-typed-array/lib/main.js"(exports, module2) {
    "use strict";
    var ctorName = require_lib84();
    var fcnName = require_lib92();
    var getPrototypeOf = require_lib87();
    var hasFloat64ArraySupport = require_lib21();
    var Float64Array2 = require_lib22();
    var CTORS = require_ctors2();
    var NAMES = require_names();
    var TypedArray = hasFloat64ArraySupport() ? getPrototypeOf(Float64Array2) : Dummy;
    TypedArray = fcnName(TypedArray) === "TypedArray" ? TypedArray : Dummy;
    function Dummy() {
    }
    function isTypedArray(value) {
      var v;
      var i;
      if (typeof value !== "object" || value === null) {
        return false;
      }
      if (value instanceof TypedArray) {
        return true;
      }
      for (i = 0; i < CTORS.length; i++) {
        if (value instanceof CTORS[i]) {
          return true;
        }
      }
      while (value) {
        v = ctorName(value);
        for (i = 0; i < NAMES.length; i++) {
          if (NAMES[i] === v) {
            return true;
          }
        }
        value = getPrototypeOf(value);
      }
      return false;
    }
    module2.exports = isTypedArray;
  }
});

// node_modules/@stdlib/assert-is-typed-array/lib/index.js
var require_lib109 = __commonJS({
  "node_modules/@stdlib/assert-is-typed-array/lib/index.js"(exports, module2) {
    "use strict";
    var isTypedArray = require_main59();
    module2.exports = isTypedArray;
  }
});

// node_modules/@stdlib/assert-instance-of/lib/main.js
var require_main60 = __commonJS({
  "node_modules/@stdlib/assert-instance-of/lib/main.js"(exports, module2) {
    "use strict";
    function instanceOf(value, constructor) {
      if (typeof constructor !== "function") {
        throw new TypeError("invalid argument. `constructor` argument must be callable. Value: `" + constructor + "`.");
      }
      return value instanceof constructor;
    }
    module2.exports = instanceOf;
  }
});

// node_modules/@stdlib/assert-instance-of/lib/index.js
var require_lib110 = __commonJS({
  "node_modules/@stdlib/assert-instance-of/lib/index.js"(exports, module2) {
    "use strict";
    var instanceOf = require_main60();
    module2.exports = instanceOf;
  }
});

// node_modules/@stdlib/array-to-json/lib/ctors.js
var require_ctors3 = __commonJS({
  "node_modules/@stdlib/array-to-json/lib/ctors.js"(exports, module2) {
    "use strict";
    var Int8Array2 = require_lib97();
    var Uint8Array2 = require_lib26();
    var Uint8ClampedArray2 = require_lib100();
    var Int16Array2 = require_lib105();
    var Uint16Array2 = require_lib30();
    var Int32Array2 = require_lib77();
    var Uint32Array2 = require_lib19();
    var Float32Array2 = require_lib108();
    var Float64Array2 = require_lib22();
    var CTORS = [
      [Float64Array2, "Float64Array"],
      [Float32Array2, "Float32Array"],
      [Int32Array2, "Int32Array"],
      [Uint32Array2, "Uint32Array"],
      [Int16Array2, "Int16Array"],
      [Uint16Array2, "Uint16Array"],
      [Int8Array2, "Int8Array"],
      [Uint8Array2, "Uint8Array"],
      [Uint8ClampedArray2, "Uint8ClampedArray"]
    ];
    module2.exports = CTORS;
  }
});

// node_modules/@stdlib/array-to-json/lib/type.js
var require_type = __commonJS({
  "node_modules/@stdlib/array-to-json/lib/type.js"(exports, module2) {
    "use strict";
    var instanceOf = require_lib110();
    var ctorName = require_lib84();
    var getPrototypeOf = require_lib87();
    var CTORS = require_ctors3();
    function typeName(arr) {
      var v;
      var i;
      for (i = 0; i < CTORS.length; i++) {
        if (instanceOf(arr, CTORS[i][0])) {
          return CTORS[i][1];
        }
      }
      while (arr) {
        v = ctorName(arr);
        for (i = 0; i < CTORS.length; i++) {
          if (v === CTORS[i][1]) {
            return CTORS[i][1];
          }
        }
        arr = getPrototypeOf(arr);
      }
    }
    module2.exports = typeName;
  }
});

// node_modules/@stdlib/array-to-json/lib/to_json.js
var require_to_json = __commonJS({
  "node_modules/@stdlib/array-to-json/lib/to_json.js"(exports, module2) {
    "use strict";
    var isTypedArray = require_lib109();
    var typeName = require_type();
    function toJSON(arr) {
      var out;
      var i;
      if (!isTypedArray(arr)) {
        throw new TypeError("invalid argument. Must provide a typed array. Value: `" + arr + "`.");
      }
      out = {};
      out.type = typeName(arr);
      out.data = [];
      for (i = 0; i < arr.length; i++) {
        out.data.push(arr[i]);
      }
      return out;
    }
    module2.exports = toJSON;
  }
});

// node_modules/@stdlib/array-to-json/lib/index.js
var require_lib111 = __commonJS({
  "node_modules/@stdlib/array-to-json/lib/index.js"(exports, module2) {
    "use strict";
    var toJSON = require_to_json();
    module2.exports = toJSON;
  }
});

// node_modules/@stdlib/random-base-randu/lib/defaults.json
var require_defaults = __commonJS({
  "node_modules/@stdlib/random-base-randu/lib/defaults.json"(exports, module2) {
    module2.exports = {
      name: "mt19937",
      copy: true
    };
  }
});

// node_modules/@stdlib/blas-base-gcopy/lib/main.js
var require_main61 = __commonJS({
  "node_modules/@stdlib/blas-base-gcopy/lib/main.js"(exports, module2) {
    "use strict";
    var M = 8;
    function gcopy(N, x, strideX, y, strideY) {
      var ix;
      var iy;
      var m;
      var i;
      if (N <= 0) {
        return y;
      }
      if (strideX === 1 && strideY === 1) {
        m = N % M;
        if (m > 0) {
          for (i = 0; i < m; i++) {
            y[i] = x[i];
          }
        }
        if (N < M) {
          return y;
        }
        for (i = m; i < N; i += M) {
          y[i] = x[i];
          y[i + 1] = x[i + 1];
          y[i + 2] = x[i + 2];
          y[i + 3] = x[i + 3];
          y[i + 4] = x[i + 4];
          y[i + 5] = x[i + 5];
          y[i + 6] = x[i + 6];
          y[i + 7] = x[i + 7];
        }
        return y;
      }
      if (strideX < 0) {
        ix = (1 - N) * strideX;
      } else {
        ix = 0;
      }
      if (strideY < 0) {
        iy = (1 - N) * strideY;
      } else {
        iy = 0;
      }
      for (i = 0; i < N; i++) {
        y[iy] = x[ix];
        ix += strideX;
        iy += strideY;
      }
      return y;
    }
    module2.exports = gcopy;
  }
});

// node_modules/@stdlib/blas-base-gcopy/lib/ndarray.js
var require_ndarray = __commonJS({
  "node_modules/@stdlib/blas-base-gcopy/lib/ndarray.js"(exports, module2) {
    "use strict";
    var M = 8;
    function gcopy(N, x, strideX, offsetX, y, strideY, offsetY) {
      var ix;
      var iy;
      var m;
      var i;
      if (N <= 0) {
        return y;
      }
      ix = offsetX;
      iy = offsetY;
      if (strideX === 1 && strideY === 1) {
        m = N % M;
        if (m > 0) {
          for (i = 0; i < m; i++) {
            y[iy] = x[ix];
            ix += strideX;
            iy += strideY;
          }
        }
        if (N < M) {
          return y;
        }
        for (i = m; i < N; i += M) {
          y[iy] = x[ix];
          y[iy + 1] = x[ix + 1];
          y[iy + 2] = x[ix + 2];
          y[iy + 3] = x[ix + 3];
          y[iy + 4] = x[ix + 4];
          y[iy + 5] = x[ix + 5];
          y[iy + 6] = x[ix + 6];
          y[iy + 7] = x[ix + 7];
          ix += M;
          iy += M;
        }
        return y;
      }
      for (i = 0; i < N; i++) {
        y[iy] = x[ix];
        ix += strideX;
        iy += strideY;
      }
      return y;
    }
    module2.exports = gcopy;
  }
});

// node_modules/@stdlib/blas-base-gcopy/lib/index.js
var require_lib112 = __commonJS({
  "node_modules/@stdlib/blas-base-gcopy/lib/index.js"(exports, module2) {
    "use strict";
    var setReadOnly = require_lib57();
    var gcopy = require_main61();
    var ndarray = require_ndarray();
    setReadOnly(gcopy, "ndarray", ndarray);
    module2.exports = gcopy;
  }
});

// node_modules/@stdlib/random-base-minstd/lib/rand_int32.js
var require_rand_int32 = __commonJS({
  "node_modules/@stdlib/random-base-minstd/lib/rand_int32.js"(exports, module2) {
    "use strict";
    var INT32_MAX = require_lib74();
    var floor = require_lib6();
    var MAX = INT32_MAX - 1;
    function randint32() {
      var v = floor(1 + MAX * Math.random());
      return v | 0;
    }
    module2.exports = randint32;
  }
});

// node_modules/@stdlib/random-base-minstd/lib/factory.js
var require_factory = __commonJS({
  "node_modules/@stdlib/random-base-minstd/lib/factory.js"(exports, module2) {
    "use strict";
    var setReadOnly = require_lib57();
    var setReadOnlyAccessor = require_lib89();
    var setReadWriteAccessor = require_lib90();
    var hasOwnProp = require_lib14();
    var isObject = require_lib88();
    var isBoolean = require_lib71().isPrimitive;
    var isCollection = require_lib68();
    var isPositiveInteger = require_lib61().isPrimitive;
    var isInt32Array = require_lib73();
    var INT32_MAX = require_lib74();
    var Int32Array2 = require_lib77();
    var gcopy = require_lib112();
    var typedarray2json = require_lib111();
    var randint32 = require_rand_int32();
    var NORMALIZATION_CONSTANT = INT32_MAX - 1 | 0;
    var MAX_SEED = INT32_MAX - 1 | 0;
    var A = 16807 | 0;
    var STATE_ARRAY_VERSION = 1;
    var NUM_STATE_SECTIONS = 2;
    var STATE_SECTION_OFFSET = 2;
    var SEED_SECTION_OFFSET = 4;
    var STATE_FIXED_LENGTH = 5;
    function verifyState(state, FLG) {
      var s1;
      if (FLG) {
        s1 = "option";
      } else {
        s1 = "argument";
      }
      if (state.length < STATE_FIXED_LENGTH + 1) {
        return new RangeError("invalid " + s1 + ". `state` array has insufficient length.");
      }
      if (state[0] !== STATE_ARRAY_VERSION) {
        return new RangeError("invalid " + s1 + ". `state` array has an incompatible schema version. Expected: " + STATE_ARRAY_VERSION + ". Actual: " + state[0] + ".");
      }
      if (state[1] !== NUM_STATE_SECTIONS) {
        return new RangeError("invalid " + s1 + ". `state` array has an incompatible number of sections. Expected: " + NUM_STATE_SECTIONS + ". Actual: " + state[1] + ".");
      }
      if (state[STATE_SECTION_OFFSET] !== 1) {
        return new RangeError("invalid " + s1 + ". `state` array has an incompatible state length. Expected: " + 1 .toString() + ". Actual: " + state[STATE_SECTION_OFFSET] + ".");
      }
      if (state[SEED_SECTION_OFFSET] !== state.length - STATE_FIXED_LENGTH) {
        return new RangeError("invalid " + s1 + ". `state` array length is incompatible with seed section length. Expected: " + (state.length - STATE_FIXED_LENGTH) + ". Actual: " + state[SEED_SECTION_OFFSET] + ".");
      }
      return null;
    }
    function factory(options) {
      var STATE;
      var state;
      var opts;
      var seed;
      var slen;
      var err;
      opts = {};
      if (arguments.length) {
        if (!isObject(options)) {
          throw new TypeError("invalid argument. Options argument must be an object. Value: `" + options + "`.");
        }
        if (hasOwnProp(options, "copy")) {
          opts.copy = options.copy;
          if (!isBoolean(options.copy)) {
            throw new TypeError("invalid option. `copy` option must be a boolean. Option: `" + options.copy + "`.");
          }
        }
        if (hasOwnProp(options, "state")) {
          state = options.state;
          opts.state = true;
          if (!isInt32Array(state)) {
            throw new TypeError("invalid option. `state` option must be an Int32Array. Option: `" + state + "`.");
          }
          err = verifyState(state, true);
          if (err) {
            throw err;
          }
          if (opts.copy === false) {
            STATE = state;
          } else {
            STATE = new Int32Array2(state.length);
            gcopy(state.length, state, 1, STATE, 1);
          }
          state = new Int32Array2(STATE.buffer, STATE.byteOffset + (STATE_SECTION_OFFSET + 1) * STATE.BYTES_PER_ELEMENT, 1);
          seed = new Int32Array2(STATE.buffer, STATE.byteOffset + (SEED_SECTION_OFFSET + 1) * STATE.BYTES_PER_ELEMENT, state[SEED_SECTION_OFFSET]);
        }
        if (seed === void 0) {
          if (hasOwnProp(options, "seed")) {
            seed = options.seed;
            opts.seed = true;
            if (isPositiveInteger(seed)) {
              if (seed > MAX_SEED) {
                throw new RangeError("invalid option. `seed` option must be a positive integer less than the maximum signed 32-bit integer. Option: `" + seed + "`.");
              }
              seed |= 0;
            } else if (isCollection(seed) && seed.length > 0) {
              slen = seed.length;
              STATE = new Int32Array2(STATE_FIXED_LENGTH + slen);
              STATE[0] = STATE_ARRAY_VERSION;
              STATE[1] = NUM_STATE_SECTIONS;
              STATE[STATE_SECTION_OFFSET] = 1;
              STATE[SEED_SECTION_OFFSET] = slen;
              gcopy.ndarray(slen, seed, 1, 0, STATE, 1, SEED_SECTION_OFFSET + 1);
              state = new Int32Array2(STATE.buffer, STATE.byteOffset + (STATE_SECTION_OFFSET + 1) * STATE.BYTES_PER_ELEMENT, 1);
              seed = new Int32Array2(STATE.buffer, STATE.byteOffset + (SEED_SECTION_OFFSET + 1) * STATE.BYTES_PER_ELEMENT, slen);
              state[0] = seed[0];
            } else {
              throw new TypeError("invalid option. `seed` option must be either a positive integer less than the maximum signed 32-bit integer or an array-like object containing integer values less than the maximum signed 32-bit integer. Option: `" + seed + "`.");
            }
          } else {
            seed = randint32() | 0;
          }
        }
      } else {
        seed = randint32() | 0;
      }
      if (state === void 0) {
        STATE = new Int32Array2(STATE_FIXED_LENGTH + 1);
        STATE[0] = STATE_ARRAY_VERSION;
        STATE[1] = NUM_STATE_SECTIONS;
        STATE[STATE_SECTION_OFFSET] = 1;
        STATE[SEED_SECTION_OFFSET] = 1;
        STATE[SEED_SECTION_OFFSET + 1] = seed;
        state = new Int32Array2(STATE.buffer, STATE.byteOffset + (STATE_SECTION_OFFSET + 1) * STATE.BYTES_PER_ELEMENT, 1);
        seed = new Int32Array2(STATE.buffer, STATE.byteOffset + (SEED_SECTION_OFFSET + 1) * STATE.BYTES_PER_ELEMENT, 1);
        state[0] = seed[0];
      }
      setReadOnly(minstd, "NAME", "minstd");
      setReadOnlyAccessor(minstd, "seed", getSeed);
      setReadOnlyAccessor(minstd, "seedLength", getSeedLength);
      setReadWriteAccessor(minstd, "state", getState, setState);
      setReadOnlyAccessor(minstd, "stateLength", getStateLength);
      setReadOnlyAccessor(minstd, "byteLength", getStateSize);
      setReadOnly(minstd, "toJSON", toJSON);
      setReadOnly(minstd, "MIN", 1);
      setReadOnly(minstd, "MAX", INT32_MAX - 1);
      setReadOnly(minstd, "normalized", normalized);
      setReadOnly(normalized, "NAME", minstd.NAME);
      setReadOnlyAccessor(normalized, "seed", getSeed);
      setReadOnlyAccessor(normalized, "seedLength", getSeedLength);
      setReadWriteAccessor(normalized, "state", getState, setState);
      setReadOnlyAccessor(normalized, "stateLength", getStateLength);
      setReadOnlyAccessor(normalized, "byteLength", getStateSize);
      setReadOnly(normalized, "toJSON", toJSON);
      setReadOnly(normalized, "MIN", (minstd.MIN - 1) / NORMALIZATION_CONSTANT);
      setReadOnly(normalized, "MAX", (minstd.MAX - 1) / NORMALIZATION_CONSTANT);
      return minstd;
      function getSeed() {
        var len = STATE[SEED_SECTION_OFFSET];
        return gcopy(len, seed, 1, new Int32Array2(len), 1);
      }
      function getSeedLength() {
        return STATE[SEED_SECTION_OFFSET];
      }
      function getStateLength() {
        return STATE.length;
      }
      function getStateSize() {
        return STATE.byteLength;
      }
      function getState() {
        var len = STATE.length;
        return gcopy(len, STATE, 1, new Int32Array2(len), 1);
      }
      function setState(s) {
        var err2;
        if (!isInt32Array(s)) {
          throw new TypeError("invalid argument. Must provide an Int32Array. Value: `" + s + "`.");
        }
        err2 = verifyState(s, false);
        if (err2) {
          throw err2;
        }
        if (opts.copy === false) {
          if (opts.state && s.length === STATE.length) {
            gcopy(s.length, s, 1, STATE, 1);
          } else {
            STATE = s;
            opts.state = true;
          }
        } else {
          if (s.length !== STATE.length) {
            STATE = new Int32Array2(s.length);
          }
          gcopy(s.length, s, 1, STATE, 1);
        }
        state = new Int32Array2(STATE.buffer, STATE.byteOffset + (STATE_SECTION_OFFSET + 1) * STATE.BYTES_PER_ELEMENT, 1);
        seed = new Int32Array2(STATE.buffer, STATE.byteOffset + (SEED_SECTION_OFFSET + 1) * STATE.BYTES_PER_ELEMENT, STATE[SEED_SECTION_OFFSET]);
      }
      function toJSON() {
        var out = {};
        out.type = "PRNG";
        out.name = minstd.NAME;
        out.state = typedarray2json(STATE);
        out.params = [];
        return out;
      }
      function minstd() {
        var s = state[0] | 0;
        s = A * s % INT32_MAX | 0;
        state[0] = s;
        return s | 0;
      }
      function normalized() {
        return (minstd() - 1) / NORMALIZATION_CONSTANT;
      }
    }
    module2.exports = factory;
  }
});

// node_modules/@stdlib/random-base-minstd/lib/main.js
var require_main62 = __commonJS({
  "node_modules/@stdlib/random-base-minstd/lib/main.js"(exports, module2) {
    "use strict";
    var factory = require_factory();
    var randint32 = require_rand_int32();
    var minstd = factory({
      "seed": randint32()
    });
    module2.exports = minstd;
  }
});

// node_modules/@stdlib/random-base-minstd/lib/index.js
var require_lib113 = __commonJS({
  "node_modules/@stdlib/random-base-minstd/lib/index.js"(exports, module2) {
    "use strict";
    var setReadOnly = require_lib57();
    var minstd = require_main62();
    var factory = require_factory();
    setReadOnly(minstd, "factory", factory);
    module2.exports = minstd;
  }
});

// node_modules/@stdlib/random-base-minstd-shuffle/lib/create_table.js
var require_create_table = __commonJS({
  "node_modules/@stdlib/random-base-minstd-shuffle/lib/create_table.js"(exports, module2) {
    "use strict";
    var isnan = require_lib();
    var NUM_WARMUPS = 8;
    function createTable(rand, table, N) {
      var v;
      var i;
      for (i = 0; i < NUM_WARMUPS; i++) {
        v = rand();
        if (isnan(v)) {
          throw new Error("unexpected error. PRNG returned `NaN`.");
        }
      }
      for (i = N - 1; i >= 0; i--) {
        table[i] = rand();
      }
      return table;
    }
    module2.exports = createTable;
  }
});

// node_modules/@stdlib/random-base-minstd-shuffle/lib/rand_int32.js
var require_rand_int322 = __commonJS({
  "node_modules/@stdlib/random-base-minstd-shuffle/lib/rand_int32.js"(exports, module2) {
    "use strict";
    var INT32_MAX = require_lib74();
    var floor = require_lib6();
    var MAX = INT32_MAX - 1;
    function randint32() {
      var v = floor(1 + MAX * Math.random());
      return v | 0;
    }
    module2.exports = randint32;
  }
});

// node_modules/@stdlib/random-base-minstd-shuffle/lib/factory.js
var require_factory2 = __commonJS({
  "node_modules/@stdlib/random-base-minstd-shuffle/lib/factory.js"(exports, module2) {
    "use strict";
    var setReadOnly = require_lib57();
    var setReadOnlyAccessor = require_lib89();
    var setReadWriteAccessor = require_lib90();
    var hasOwnProp = require_lib14();
    var isObject = require_lib88();
    var isBoolean = require_lib71().isPrimitive;
    var isCollection = require_lib68();
    var isPositiveInteger = require_lib61().isPrimitive;
    var isInt32Array = require_lib73();
    var gcopy = require_lib112();
    var floor = require_lib6();
    var Int32Array2 = require_lib77();
    var INT32_MAX = require_lib74();
    var typedarray2json = require_lib111();
    var createTable = require_create_table();
    var randint32 = require_rand_int322();
    var NORMALIZATION_CONSTANT = INT32_MAX - 1 | 0;
    var MAX_SEED = INT32_MAX - 1 | 0;
    var A = 16807 | 0;
    var TABLE_LENGTH = 32;
    var STATE_ARRAY_VERSION = 1;
    var NUM_STATE_SECTIONS = 3;
    var TABLE_SECTION_OFFSET = 2;
    var STATE_SECTION_OFFSET = TABLE_LENGTH + 3;
    var SEED_SECTION_OFFSET = TABLE_LENGTH + 6;
    var STATE_FIXED_LENGTH = TABLE_LENGTH + 7;
    var SHUFFLE_STATE = STATE_SECTION_OFFSET + 1;
    var PRNG_STATE = STATE_SECTION_OFFSET + 2;
    function verifyState(state, FLG) {
      var s1;
      if (FLG) {
        s1 = "option";
      } else {
        s1 = "argument";
      }
      if (state.length < STATE_FIXED_LENGTH + 1) {
        return new RangeError("invalid " + s1 + ". `state` array has insufficient length.");
      }
      if (state[0] !== STATE_ARRAY_VERSION) {
        return new RangeError("invalid " + s1 + ". `state` array has an incompatible schema version. Expected: " + STATE_ARRAY_VERSION + ". Actual: " + state[0] + ".");
      }
      if (state[1] !== NUM_STATE_SECTIONS) {
        return new RangeError("invalid " + s1 + ". `state` array has an incompatible number of sections. Expected: " + NUM_STATE_SECTIONS + ". Actual: " + state[1] + ".");
      }
      if (state[TABLE_SECTION_OFFSET] !== TABLE_LENGTH) {
        return new RangeError("invalid " + s1 + ". `state` array has an incompatible table length. Expected: " + TABLE_LENGTH + ". Actual: " + state[TABLE_SECTION_OFFSET] + ".");
      }
      if (state[STATE_SECTION_OFFSET] !== 2) {
        return new RangeError("invalid " + s1 + ". `state` array has an incompatible state length. Expected: " + 2 .toString() + ". Actual: " + state[STATE_SECTION_OFFSET] + ".");
      }
      if (state[SEED_SECTION_OFFSET] !== state.length - STATE_FIXED_LENGTH) {
        return new RangeError("invalid " + s1 + ". `state` array length is incompatible with seed section length. Expected: " + (state.length - STATE_FIXED_LENGTH) + ". Actual: " + state[SEED_SECTION_OFFSET] + ".");
      }
      return null;
    }
    function factory(options) {
      var STATE;
      var state;
      var opts;
      var seed;
      var slen;
      var err;
      opts = {};
      if (arguments.length) {
        if (!isObject(options)) {
          throw new TypeError("invalid argument. Options argument must be an object. Value: `" + options + "`.");
        }
        if (hasOwnProp(options, "copy")) {
          opts.copy = options.copy;
          if (!isBoolean(options.copy)) {
            throw new TypeError("invalid option. `copy` option must be a boolean. Option: `" + options.copy + "`.");
          }
        }
        if (hasOwnProp(options, "state")) {
          state = options.state;
          opts.state = true;
          if (!isInt32Array(state)) {
            throw new TypeError("invalid option. `state` option must be an Int32Array. Option: `" + state + "`.");
          }
          err = verifyState(state, true);
          if (err) {
            throw err;
          }
          if (opts.copy === false) {
            STATE = state;
          } else {
            STATE = new Int32Array2(state.length);
            gcopy(state.length, state, 1, STATE, 1);
          }
          state = new Int32Array2(STATE.buffer, STATE.byteOffset + (TABLE_SECTION_OFFSET + 1) * STATE.BYTES_PER_ELEMENT, TABLE_LENGTH);
          seed = new Int32Array2(STATE.buffer, STATE.byteOffset + (SEED_SECTION_OFFSET + 1) * STATE.BYTES_PER_ELEMENT, state[SEED_SECTION_OFFSET]);
        }
        if (seed === void 0) {
          if (hasOwnProp(options, "seed")) {
            seed = options.seed;
            opts.seed = true;
            if (isPositiveInteger(seed)) {
              if (seed > MAX_SEED) {
                throw new RangeError("invalid option. `seed` option must be a positive integer less than the maximum signed 32-bit integer. Option: `" + seed + "`.");
              }
              seed |= 0;
            } else if (isCollection(seed) && seed.length > 0) {
              slen = seed.length;
              STATE = new Int32Array2(STATE_FIXED_LENGTH + slen);
              STATE[0] = STATE_ARRAY_VERSION;
              STATE[1] = NUM_STATE_SECTIONS;
              STATE[TABLE_SECTION_OFFSET] = TABLE_LENGTH;
              STATE[STATE_SECTION_OFFSET] = 2;
              STATE[PRNG_STATE] = seed[0];
              STATE[SEED_SECTION_OFFSET] = slen;
              gcopy.ndarray(slen, seed, 1, 0, STATE, 1, SEED_SECTION_OFFSET + 1);
              state = new Int32Array2(STATE.buffer, STATE.byteOffset + (TABLE_SECTION_OFFSET + 1) * STATE.BYTES_PER_ELEMENT, TABLE_LENGTH);
              seed = new Int32Array2(STATE.buffer, STATE.byteOffset + (SEED_SECTION_OFFSET + 1) * STATE.BYTES_PER_ELEMENT, slen);
              state = createTable(minstd, state, TABLE_LENGTH);
              STATE[SHUFFLE_STATE] = state[0];
            } else {
              throw new TypeError("invalid option. `seed` option must be either a positive integer less than the maximum signed 32-bit integer or an array-like object containing integer values less than the maximum signed 32-bit integer. Option: `" + seed + "`.");
            }
          } else {
            seed = randint32() | 0;
          }
        }
      } else {
        seed = randint32() | 0;
      }
      if (state === void 0) {
        STATE = new Int32Array2(STATE_FIXED_LENGTH + 1);
        STATE[0] = STATE_ARRAY_VERSION;
        STATE[1] = NUM_STATE_SECTIONS;
        STATE[TABLE_SECTION_OFFSET] = TABLE_LENGTH;
        STATE[STATE_SECTION_OFFSET] = 2;
        STATE[PRNG_STATE] = seed;
        STATE[SEED_SECTION_OFFSET] = 1;
        STATE[SEED_SECTION_OFFSET + 1] = seed;
        state = new Int32Array2(STATE.buffer, STATE.byteOffset + (TABLE_SECTION_OFFSET + 1) * STATE.BYTES_PER_ELEMENT, TABLE_LENGTH);
        seed = new Int32Array2(STATE.buffer, STATE.byteOffset + (SEED_SECTION_OFFSET + 1) * STATE.BYTES_PER_ELEMENT, 1);
        state = createTable(minstd, state, TABLE_LENGTH);
        STATE[SHUFFLE_STATE] = state[0];
      }
      setReadOnly(minstdShuffle, "NAME", "minstd-shuffle");
      setReadOnlyAccessor(minstdShuffle, "seed", getSeed);
      setReadOnlyAccessor(minstdShuffle, "seedLength", getSeedLength);
      setReadWriteAccessor(minstdShuffle, "state", getState, setState);
      setReadOnlyAccessor(minstdShuffle, "stateLength", getStateLength);
      setReadOnlyAccessor(minstdShuffle, "byteLength", getStateSize);
      setReadOnly(minstdShuffle, "toJSON", toJSON);
      setReadOnly(minstdShuffle, "MIN", 1);
      setReadOnly(minstdShuffle, "MAX", INT32_MAX - 1);
      setReadOnly(minstdShuffle, "normalized", normalized);
      setReadOnly(normalized, "NAME", minstdShuffle.NAME);
      setReadOnlyAccessor(normalized, "seed", getSeed);
      setReadOnlyAccessor(normalized, "seedLength", getSeedLength);
      setReadWriteAccessor(normalized, "state", getState, setState);
      setReadOnlyAccessor(normalized, "stateLength", getStateLength);
      setReadOnlyAccessor(normalized, "byteLength", getStateSize);
      setReadOnly(normalized, "toJSON", toJSON);
      setReadOnly(normalized, "MIN", (minstdShuffle.MIN - 1) / NORMALIZATION_CONSTANT);
      setReadOnly(normalized, "MAX", (minstdShuffle.MAX - 1) / NORMALIZATION_CONSTANT);
      return minstdShuffle;
      function getSeed() {
        var len = STATE[SEED_SECTION_OFFSET];
        return gcopy(len, seed, 1, new Int32Array2(len), 1);
      }
      function getSeedLength() {
        return STATE[SEED_SECTION_OFFSET];
      }
      function getStateLength() {
        return STATE.length;
      }
      function getStateSize() {
        return STATE.byteLength;
      }
      function getState() {
        var len = STATE.length;
        return gcopy(len, STATE, 1, new Int32Array2(len), 1);
      }
      function setState(s) {
        var err2;
        if (!isInt32Array(s)) {
          throw new TypeError("invalid argument. Must provide an Int32Array. Value: `" + s + "`.");
        }
        err2 = verifyState(s, false);
        if (err2) {
          throw err2;
        }
        if (opts.copy === false) {
          if (opts.state && s.length === STATE.length) {
            gcopy(s.length, s, 1, STATE, 1);
          } else {
            STATE = s;
            opts.state = true;
          }
        } else {
          if (s.length !== STATE.length) {
            STATE = new Int32Array2(s.length);
          }
          gcopy(s.length, s, 1, STATE, 1);
        }
        state = new Int32Array2(STATE.buffer, STATE.byteOffset + (TABLE_SECTION_OFFSET + 1) * STATE.BYTES_PER_ELEMENT, TABLE_LENGTH);
        seed = new Int32Array2(STATE.buffer, STATE.byteOffset + (SEED_SECTION_OFFSET + 1) * STATE.BYTES_PER_ELEMENT, STATE[SEED_SECTION_OFFSET]);
      }
      function toJSON() {
        var out = {};
        out.type = "PRNG";
        out.name = minstdShuffle.NAME;
        out.state = typedarray2json(STATE);
        out.params = [];
        return out;
      }
      function minstd() {
        var s = STATE[PRNG_STATE] | 0;
        s = A * s % INT32_MAX | 0;
        STATE[PRNG_STATE] = s;
        return s | 0;
      }
      function minstdShuffle() {
        var s;
        var i;
        s = STATE[SHUFFLE_STATE];
        i = floor(TABLE_LENGTH * (s / INT32_MAX));
        s = state[i];
        STATE[SHUFFLE_STATE] = s;
        state[i] = minstd();
        return s;
      }
      function normalized() {
        return (minstdShuffle() - 1) / NORMALIZATION_CONSTANT;
      }
    }
    module2.exports = factory;
  }
});

// node_modules/@stdlib/random-base-minstd-shuffle/lib/main.js
var require_main63 = __commonJS({
  "node_modules/@stdlib/random-base-minstd-shuffle/lib/main.js"(exports, module2) {
    "use strict";
    var factory = require_factory2();
    var randint32 = require_rand_int322();
    var minstd = factory({
      "seed": randint32()
    });
    module2.exports = minstd;
  }
});

// node_modules/@stdlib/random-base-minstd-shuffle/lib/index.js
var require_lib114 = __commonJS({
  "node_modules/@stdlib/random-base-minstd-shuffle/lib/index.js"(exports, module2) {
    "use strict";
    var setReadOnly = require_lib57();
    var minstd = require_main63();
    var factory = require_factory2();
    setReadOnly(minstd, "factory", factory);
    module2.exports = minstd;
  }
});

// node_modules/@stdlib/math-base-assert-is-positive-zero/lib/main.js
var require_main64 = __commonJS({
  "node_modules/@stdlib/math-base-assert-is-positive-zero/lib/main.js"(exports, module2) {
    "use strict";
    var PINF = require_lib2();
    function isPositiveZero(x) {
      return x === 0 && 1 / x === PINF;
    }
    module2.exports = isPositiveZero;
  }
});

// node_modules/@stdlib/math-base-assert-is-positive-zero/lib/index.js
var require_lib115 = __commonJS({
  "node_modules/@stdlib/math-base-assert-is-positive-zero/lib/index.js"(exports, module2) {
    "use strict";
    var isPositiveZero = require_main64();
    module2.exports = isPositiveZero;
  }
});

// node_modules/@stdlib/math-base-special-max/lib/max.js
var require_max = __commonJS({
  "node_modules/@stdlib/math-base-special-max/lib/max.js"(exports, module2) {
    "use strict";
    var isPositiveZero = require_lib115();
    var isnan = require_lib();
    var NINF = require_lib4();
    var PINF = require_lib2();
    function max(x, y) {
      var len;
      var m;
      var v;
      var i;
      len = arguments.length;
      if (len === 2) {
        if (isnan(x) || isnan(y)) {
          return NaN;
        }
        if (x === PINF || y === PINF) {
          return PINF;
        }
        if (x === y && x === 0) {
          if (isPositiveZero(x)) {
            return x;
          }
          return y;
        }
        if (x > y) {
          return x;
        }
        return y;
      }
      m = NINF;
      for (i = 0; i < len; i++) {
        v = arguments[i];
        if (isnan(v) || v === PINF) {
          return v;
        }
        if (v > m) {
          m = v;
        } else if (v === m && v === 0 && isPositiveZero(v)) {
          m = v;
        }
      }
      return m;
    }
    module2.exports = max;
  }
});

// node_modules/@stdlib/math-base-special-max/lib/index.js
var require_lib116 = __commonJS({
  "node_modules/@stdlib/math-base-special-max/lib/index.js"(exports, module2) {
    "use strict";
    var max = require_max();
    module2.exports = max;
  }
});

// node_modules/@stdlib/math-base-special-uimul/lib/main.js
var require_main65 = __commonJS({
  "node_modules/@stdlib/math-base-special-uimul/lib/main.js"(exports, module2) {
    "use strict";
    var LOW_WORD_MASK = 65535 >>> 0;
    function uimul(a, b) {
      var lbits;
      var mbits;
      var ha;
      var hb;
      var la;
      var lb;
      a >>>= 0;
      b >>>= 0;
      ha = a >>> 16 >>> 0;
      hb = b >>> 16 >>> 0;
      la = (a & LOW_WORD_MASK) >>> 0;
      lb = (b & LOW_WORD_MASK) >>> 0;
      lbits = la * lb >>> 0;
      mbits = ha * lb + la * hb << 16 >>> 0;
      return lbits + mbits >>> 0;
    }
    module2.exports = uimul;
  }
});

// node_modules/@stdlib/math-base-special-uimul/lib/index.js
var require_lib117 = __commonJS({
  "node_modules/@stdlib/math-base-special-uimul/lib/index.js"(exports, module2) {
    "use strict";
    var uimul = require_main65();
    module2.exports = uimul;
  }
});

// node_modules/@stdlib/random-base-mt19937/lib/rand_uint32.js
var require_rand_uint32 = __commonJS({
  "node_modules/@stdlib/random-base-mt19937/lib/rand_uint32.js"(exports, module2) {
    "use strict";
    var UINT32_MAX = require_lib17();
    var floor = require_lib6();
    var MAX = UINT32_MAX - 1;
    function randuint32() {
      var v = floor(1 + MAX * Math.random());
      return v >>> 0;
    }
    module2.exports = randuint32;
  }
});

// node_modules/@stdlib/random-base-mt19937/lib/factory.js
var require_factory3 = __commonJS({
  "node_modules/@stdlib/random-base-mt19937/lib/factory.js"(exports, module2) {
    "use strict";
    var setReadOnly = require_lib57();
    var setReadOnlyAccessor = require_lib89();
    var setReadWriteAccessor = require_lib90();
    var hasOwnProp = require_lib14();
    var isObject = require_lib88();
    var isCollection = require_lib68();
    var isUint32Array = require_lib16();
    var isBoolean = require_lib71().isPrimitive;
    var isPositiveInteger = require_lib61().isPrimitive;
    var FLOAT64_MAX_SAFE_INTEGER = require_lib51();
    var UINT32_MAX = require_lib17();
    var Uint32Array2 = require_lib19();
    var max = require_lib116();
    var uimul = require_lib117();
    var gcopy = require_lib112();
    var typedarray2json = require_lib111();
    var randuint32 = require_rand_uint32();
    var N = 624;
    var M = 397;
    var MAX_SEED = UINT32_MAX >>> 0;
    var SEED_ARRAY_INIT_STATE = 19650218 >>> 0;
    var UPPER_MASK = 2147483648 >>> 0;
    var LOWER_MASK = 2147483647 >>> 0;
    var KNUTH_MULTIPLIER = 1812433253 >>> 0;
    var MAGIC_MULTIPLIER_1 = 1664525 >>> 0;
    var MAGIC_MULTIPLIER_2 = 1566083941 >>> 0;
    var TEMPERING_COEFFICIENT_1 = 2636928640 >>> 0;
    var TEMPERING_COEFFICIENT_2 = 4022730752 >>> 0;
    var MATRIX_A = 2567483615 >>> 0;
    var MAG01 = [0 >>> 0, MATRIX_A >>> 0];
    var FLOAT64_NORMALIZATION_CONSTANT = 1 / (FLOAT64_MAX_SAFE_INTEGER + 1);
    var TWO_26 = 67108864 >>> 0;
    var TWO_32 = 2147483648 >>> 0;
    var ONE = 1 >>> 0;
    var MAX_NORMALIZED = FLOAT64_MAX_SAFE_INTEGER * FLOAT64_NORMALIZATION_CONSTANT;
    var STATE_ARRAY_VERSION = 1;
    var NUM_STATE_SECTIONS = 3;
    var STATE_SECTION_OFFSET = 2;
    var OTHER_SECTION_OFFSET = N + 3;
    var SEED_SECTION_OFFSET = N + 5;
    var STATE_FIXED_LENGTH = N + 6;
    function verifyState(state, FLG) {
      var s1;
      if (FLG) {
        s1 = "option";
      } else {
        s1 = "argument";
      }
      if (state.length < STATE_FIXED_LENGTH + 1) {
        return new RangeError("invalid " + s1 + ". `state` array has insufficient length.");
      }
      if (state[0] !== STATE_ARRAY_VERSION) {
        return new RangeError("invalid " + s1 + ". `state` array has an incompatible schema version. Expected: " + STATE_ARRAY_VERSION + ". Actual: " + state[0] + ".");
      }
      if (state[1] !== NUM_STATE_SECTIONS) {
        return new RangeError("invalid " + s1 + ". `state` array has an incompatible number of sections. Expected: " + NUM_STATE_SECTIONS + ". Actual: " + state[1] + ".");
      }
      if (state[STATE_SECTION_OFFSET] !== N) {
        return new RangeError("invalid " + s1 + ". `state` array has an incompatible state length. Expected: " + N + ". Actual: " + state[STATE_SECTION_OFFSET] + ".");
      }
      if (state[OTHER_SECTION_OFFSET] !== 1) {
        return new RangeError("invalid " + s1 + ". `state` array has an incompatible section length. Expected: " + 1 .toString() + ". Actual: " + state[OTHER_SECTION_OFFSET] + ".");
      }
      if (state[SEED_SECTION_OFFSET] !== state.length - STATE_FIXED_LENGTH) {
        return new RangeError("invalid " + s1 + ". `state` array length is incompatible with seed section length. Expected: " + (state.length - STATE_FIXED_LENGTH) + ". Actual: " + state[SEED_SECTION_OFFSET] + ".");
      }
      return null;
    }
    function createState(state, N2, s) {
      var i;
      state[0] = s >>> 0;
      for (i = 1; i < N2; i++) {
        s = state[i - 1] >>> 0;
        s = (s ^ s >>> 30) >>> 0;
        state[i] = uimul(s, KNUTH_MULTIPLIER) + i >>> 0;
      }
      return state;
    }
    function initState(state, N2, seed, M2) {
      var s;
      var i;
      var j;
      var k;
      i = 1;
      j = 0;
      for (k = max(N2, M2); k > 0; k--) {
        s = state[i - 1] >>> 0;
        s = (s ^ s >>> 30) >>> 0;
        s = uimul(s, MAGIC_MULTIPLIER_1) >>> 0;
        state[i] = (state[i] >>> 0 ^ s) + seed[j] + j >>> 0;
        i += 1;
        j += 1;
        if (i >= N2) {
          state[0] = state[N2 - 1];
          i = 1;
        }
        if (j >= M2) {
          j = 0;
        }
      }
      for (k = N2 - 1; k > 0; k--) {
        s = state[i - 1] >>> 0;
        s = (s ^ s >>> 30) >>> 0;
        s = uimul(s, MAGIC_MULTIPLIER_2) >>> 0;
        state[i] = (state[i] >>> 0 ^ s) - i >>> 0;
        i += 1;
        if (i >= N2) {
          state[0] = state[N2 - 1];
          i = 1;
        }
      }
      state[0] = TWO_32;
      return state;
    }
    function twist(state) {
      var w;
      var i;
      var j;
      var k;
      k = N - M;
      for (i = 0; i < k; i++) {
        w = state[i] & UPPER_MASK | state[i + 1] & LOWER_MASK;
        state[i] = state[i + M] ^ w >>> 1 ^ MAG01[w & ONE];
      }
      j = N - 1;
      for (; i < j; i++) {
        w = state[i] & UPPER_MASK | state[i + 1] & LOWER_MASK;
        state[i] = state[i - k] ^ w >>> 1 ^ MAG01[w & ONE];
      }
      w = state[j] & UPPER_MASK | state[0] & LOWER_MASK;
      state[j] = state[M - 1] ^ w >>> 1 ^ MAG01[w & ONE];
      return state;
    }
    function factory(options) {
      var STATE;
      var state;
      var opts;
      var seed;
      var slen;
      var err;
      opts = {};
      if (arguments.length) {
        if (!isObject(options)) {
          throw new TypeError("invalid argument. Options argument must be an object. Value: `" + options + "`.");
        }
        if (hasOwnProp(options, "copy")) {
          opts.copy = options.copy;
          if (!isBoolean(options.copy)) {
            throw new TypeError("invalid option. `copy` option must be a boolean. Option: `" + options.copy + "`.");
          }
        }
        if (hasOwnProp(options, "state")) {
          state = options.state;
          opts.state = true;
          if (!isUint32Array(state)) {
            throw new TypeError("invalid option. `state` option must be a Uint32Array. Option: `" + state + "`.");
          }
          err = verifyState(state, true);
          if (err) {
            throw err;
          }
          if (opts.copy === false) {
            STATE = state;
          } else {
            STATE = new Uint32Array2(state.length);
            gcopy(state.length, state, 1, STATE, 1);
          }
          state = new Uint32Array2(STATE.buffer, STATE.byteOffset + (STATE_SECTION_OFFSET + 1) * STATE.BYTES_PER_ELEMENT, N);
          seed = new Uint32Array2(STATE.buffer, STATE.byteOffset + (SEED_SECTION_OFFSET + 1) * STATE.BYTES_PER_ELEMENT, state[SEED_SECTION_OFFSET]);
        }
        if (seed === void 0) {
          if (hasOwnProp(options, "seed")) {
            seed = options.seed;
            opts.seed = true;
            if (isPositiveInteger(seed)) {
              if (seed > MAX_SEED) {
                throw new RangeError("invalid option. `seed` option must be a positive integer less than or equal to the maximum unsigned 32-bit integer. Option: `" + seed + "`.");
              }
              seed >>>= 0;
            } else if (isCollection(seed) === false || seed.length < 1) {
              throw new TypeError("invalid option. `seed` option must be either a positive integer less than or equal to the maximum unsigned 32-bit integer or an array-like object containing integer values less than or equal to the maximum unsigned 32-bit integer. Option: `" + seed + "`.");
            } else if (seed.length === 1) {
              seed = seed[0];
              if (!isPositiveInteger(seed)) {
                throw new TypeError("invalid option. `seed` option must be either a positive integer less than or equal to the maximum unsigned 32-bit integer or an array-like object containing integer values less than or equal to the maximum unsigned 32-bit integer. Option: `" + seed + "`.");
              }
              if (seed > MAX_SEED) {
                throw new RangeError("invalid option. `seed` option must be either a positive integer less than or equal to the maximum unsigned 32-bit integer or an array-like object containing integer values less than or equal to the maximum unsigned 32-bit integer. Option: `" + seed + "`.");
              }
              seed >>>= 0;
            } else {
              slen = seed.length;
              STATE = new Uint32Array2(STATE_FIXED_LENGTH + slen);
              STATE[0] = STATE_ARRAY_VERSION;
              STATE[1] = NUM_STATE_SECTIONS;
              STATE[STATE_SECTION_OFFSET] = N;
              STATE[OTHER_SECTION_OFFSET] = 1;
              STATE[OTHER_SECTION_OFFSET + 1] = N;
              STATE[SEED_SECTION_OFFSET] = slen;
              gcopy.ndarray(slen, seed, 1, 0, STATE, 1, SEED_SECTION_OFFSET + 1);
              state = new Uint32Array2(STATE.buffer, STATE.byteOffset + (STATE_SECTION_OFFSET + 1) * STATE.BYTES_PER_ELEMENT, N);
              seed = new Uint32Array2(STATE.buffer, STATE.byteOffset + (SEED_SECTION_OFFSET + 1) * STATE.BYTES_PER_ELEMENT, slen);
              state = createState(state, N, SEED_ARRAY_INIT_STATE);
              state = initState(state, N, seed, slen);
            }
          } else {
            seed = randuint32() >>> 0;
          }
        }
      } else {
        seed = randuint32() >>> 0;
      }
      if (state === void 0) {
        STATE = new Uint32Array2(STATE_FIXED_LENGTH + 1);
        STATE[0] = STATE_ARRAY_VERSION;
        STATE[1] = NUM_STATE_SECTIONS;
        STATE[STATE_SECTION_OFFSET] = N;
        STATE[OTHER_SECTION_OFFSET] = 1;
        STATE[OTHER_SECTION_OFFSET + 1] = N;
        STATE[SEED_SECTION_OFFSET] = 1;
        STATE[SEED_SECTION_OFFSET + 1] = seed;
        state = new Uint32Array2(STATE.buffer, STATE.byteOffset + (STATE_SECTION_OFFSET + 1) * STATE.BYTES_PER_ELEMENT, N);
        seed = new Uint32Array2(STATE.buffer, STATE.byteOffset + (SEED_SECTION_OFFSET + 1) * STATE.BYTES_PER_ELEMENT, 1);
        state = createState(state, N, seed);
      }
      setReadOnly(mt19937, "NAME", "mt19937");
      setReadOnlyAccessor(mt19937, "seed", getSeed);
      setReadOnlyAccessor(mt19937, "seedLength", getSeedLength);
      setReadWriteAccessor(mt19937, "state", getState, setState);
      setReadOnlyAccessor(mt19937, "stateLength", getStateLength);
      setReadOnlyAccessor(mt19937, "byteLength", getStateSize);
      setReadOnly(mt19937, "toJSON", toJSON);
      setReadOnly(mt19937, "MIN", 1);
      setReadOnly(mt19937, "MAX", UINT32_MAX);
      setReadOnly(mt19937, "normalized", normalized);
      setReadOnly(normalized, "NAME", mt19937.NAME);
      setReadOnlyAccessor(normalized, "seed", getSeed);
      setReadOnlyAccessor(normalized, "seedLength", getSeedLength);
      setReadWriteAccessor(normalized, "state", getState, setState);
      setReadOnlyAccessor(normalized, "stateLength", getStateLength);
      setReadOnlyAccessor(normalized, "byteLength", getStateSize);
      setReadOnly(normalized, "toJSON", toJSON);
      setReadOnly(normalized, "MIN", 0);
      setReadOnly(normalized, "MAX", MAX_NORMALIZED);
      return mt19937;
      function getSeed() {
        var len = STATE[SEED_SECTION_OFFSET];
        return gcopy(len, seed, 1, new Uint32Array2(len), 1);
      }
      function getSeedLength() {
        return STATE[SEED_SECTION_OFFSET];
      }
      function getStateLength() {
        return STATE.length;
      }
      function getStateSize() {
        return STATE.byteLength;
      }
      function getState() {
        var len = STATE.length;
        return gcopy(len, STATE, 1, new Uint32Array2(len), 1);
      }
      function setState(s) {
        var err2;
        if (!isUint32Array(s)) {
          throw new TypeError("invalid argument. Must provide a Uint32Array. Value: `" + s + "`.");
        }
        err2 = verifyState(s, false);
        if (err2) {
          throw err2;
        }
        if (opts.copy === false) {
          if (opts.state && s.length === STATE.length) {
            gcopy(s.length, s, 1, STATE, 1);
          } else {
            STATE = s;
            opts.state = true;
          }
        } else {
          if (s.length !== STATE.length) {
            STATE = new Uint32Array2(s.length);
          }
          gcopy(s.length, s, 1, STATE, 1);
        }
        state = new Uint32Array2(STATE.buffer, STATE.byteOffset + (STATE_SECTION_OFFSET + 1) * STATE.BYTES_PER_ELEMENT, N);
        seed = new Uint32Array2(STATE.buffer, STATE.byteOffset + (SEED_SECTION_OFFSET + 1) * STATE.BYTES_PER_ELEMENT, STATE[SEED_SECTION_OFFSET]);
      }
      function toJSON() {
        var out = {};
        out.type = "PRNG";
        out.name = mt19937.NAME;
        out.state = typedarray2json(STATE);
        out.params = [];
        return out;
      }
      function mt19937() {
        var r;
        var i;
        i = STATE[OTHER_SECTION_OFFSET + 1];
        if (i >= N) {
          state = twist(state);
          i = 0;
        }
        r = state[i];
        STATE[OTHER_SECTION_OFFSET + 1] = i + 1;
        r ^= r >>> 11;
        r ^= r << 7 & TEMPERING_COEFFICIENT_1;
        r ^= r << 15 & TEMPERING_COEFFICIENT_2;
        r ^= r >>> 18;
        return r >>> 0;
      }
      function normalized() {
        var x = mt19937() >>> 5;
        var y = mt19937() >>> 6;
        return (x * TWO_26 + y) * FLOAT64_NORMALIZATION_CONSTANT;
      }
    }
    module2.exports = factory;
  }
});

// node_modules/@stdlib/random-base-mt19937/lib/main.js
var require_main66 = __commonJS({
  "node_modules/@stdlib/random-base-mt19937/lib/main.js"(exports, module2) {
    "use strict";
    var factory = require_factory3();
    var randuint32 = require_rand_uint32();
    var mt19937 = factory({
      "seed": randuint32()
    });
    module2.exports = mt19937;
  }
});

// node_modules/@stdlib/random-base-mt19937/lib/index.js
var require_lib118 = __commonJS({
  "node_modules/@stdlib/random-base-mt19937/lib/index.js"(exports, module2) {
    "use strict";
    var setReadOnly = require_lib57();
    var mt19937 = require_main66();
    var factory = require_factory3();
    setReadOnly(mt19937, "factory", factory);
    module2.exports = mt19937;
  }
});

// node_modules/@stdlib/random-base-randu/lib/prngs.js
var require_prngs = __commonJS({
  "node_modules/@stdlib/random-base-randu/lib/prngs.js"(exports, module2) {
    "use strict";
    var prngs = {};
    prngs["minstd"] = require_lib113();
    prngs["minstd-shuffle"] = require_lib114();
    prngs["mt19937"] = require_lib118();
    module2.exports = prngs;
  }
});

// node_modules/@stdlib/random-base-randu/lib/factory.js
var require_factory4 = __commonJS({
  "node_modules/@stdlib/random-base-randu/lib/factory.js"(exports, module2) {
    "use strict";
    var setReadOnly = require_lib57();
    var setReadOnlyAccessor = require_lib89();
    var setReadWriteAccessor = require_lib90();
    var isObject = require_lib88();
    var isBoolean = require_lib71().isPrimitive;
    var hasOwnProp = require_lib14();
    var typedarray2json = require_lib111();
    var defaults = require_defaults();
    var PRNGS = require_prngs();
    function factory(options) {
      var opts;
      var rand;
      var prng;
      opts = {
        "name": defaults.name,
        "copy": defaults.copy
      };
      if (arguments.length) {
        if (!isObject(options)) {
          throw new TypeError("invalid argument. Must provide an object. Value: `" + options + "`.");
        }
        if (hasOwnProp(options, "name")) {
          opts.name = options.name;
        }
        if (hasOwnProp(options, "state")) {
          opts.state = options.state;
          if (opts.state === void 0) {
            throw new TypeError("invalid option. `state` option cannot be undefined. Option: `" + opts.state + "`.");
          }
        } else if (hasOwnProp(options, "seed")) {
          opts.seed = options.seed;
          if (opts.seed === void 0) {
            throw new TypeError("invalid option. `seed` option cannot be undefined. Option: `" + opts.seed + "`.");
          }
        }
        if (hasOwnProp(options, "copy")) {
          opts.copy = options.copy;
          if (!isBoolean(opts.copy)) {
            throw new TypeError("invalid option. `copy` option must be a boolean. Option: `" + opts.copy + "`.");
          }
        }
      }
      prng = PRNGS[opts.name];
      if (prng === void 0) {
        throw new Error("invalid option. Unrecognized/unsupported PRNG. Option: `" + opts.name + "`.");
      }
      if (opts.state === void 0) {
        if (opts.seed === void 0) {
          rand = prng.factory();
        } else {
          rand = prng.factory({
            "seed": opts.seed
          });
        }
      } else {
        rand = prng.factory({
          "state": opts.state,
          "copy": opts.copy
        });
      }
      setReadOnly(uniform, "NAME", "randu");
      setReadOnlyAccessor(uniform, "seed", getSeed);
      setReadOnlyAccessor(uniform, "seedLength", getSeedLength);
      setReadWriteAccessor(uniform, "state", getState, setState);
      setReadOnlyAccessor(uniform, "stateLength", getStateLength);
      setReadOnlyAccessor(uniform, "byteLength", getStateSize);
      setReadOnly(uniform, "toJSON", toJSON);
      setReadOnly(uniform, "PRNG", rand);
      setReadOnly(uniform, "MIN", rand.normalized.MIN);
      setReadOnly(uniform, "MAX", rand.normalized.MAX);
      return uniform;
      function getSeed() {
        return rand.seed;
      }
      function getSeedLength() {
        return rand.seedLength;
      }
      function getStateLength() {
        return rand.stateLength;
      }
      function getStateSize() {
        return rand.byteLength;
      }
      function getState() {
        return rand.state;
      }
      function setState(s) {
        rand.state = s;
      }
      function toJSON() {
        var out = {};
        out.type = "PRNG";
        out.name = uniform.NAME + "-" + rand.NAME;
        out.state = typedarray2json(rand.state);
        out.params = [];
        return out;
      }
      function uniform() {
        return rand.normalized();
      }
    }
    module2.exports = factory;
  }
});

// node_modules/@stdlib/random-base-randu/lib/main.js
var require_main67 = __commonJS({
  "node_modules/@stdlib/random-base-randu/lib/main.js"(exports, module2) {
    "use strict";
    var factory = require_factory4();
    var randu = factory();
    module2.exports = randu;
  }
});

// node_modules/@stdlib/random-base-randu/lib/index.js
var require_lib119 = __commonJS({
  "node_modules/@stdlib/random-base-randu/lib/index.js"(exports, module2) {
    "use strict";
    var setReadOnly = require_lib57();
    var randu = require_main67();
    var factory = require_factory4();
    setReadOnly(randu, "factory", factory);
    module2.exports = randu;
  }
});

// node_modules/@stdlib/nlp-lda/lib/init.js
var require_init = __commonJS({
  "node_modules/@stdlib/nlp-lda/lib/init.js"(exports, module2) {
    "use strict";
    var randu = require_lib119();
    var floor = require_lib6();
    function init() {
      var topic;
      var newz;
      var len;
      var wt;
      var d;
      var i;
      this.z = [];
      for (d = 0; d < this.D; d++) {
        this.z.push([]);
        len = this.w[d].length;
        for (i = 0; i < len; i++) {
          newz = floor(randu() * this.K);
          this.z[d].push(newz);
        }
        this.ndSum[d] = len;
        for (i = 0; i < len; i++) {
          wt = this.w[d][i];
          topic = this.z[d][i];
          this.nw.set(wt, topic, this.nw.get(wt, topic) + 1);
          this.nd.set(d, topic, this.nd.get(d, topic) + 1);
          this.nwSum[topic] = this.nwSum[topic] + 1;
        }
      }
    }
    module2.exports = init;
  }
});

// node_modules/@stdlib/nlp-lda/lib/avg_matrix.js
var require_avg_matrix = __commonJS({
  "node_modules/@stdlib/nlp-lda/lib/avg_matrix.js"(exports, module2) {
    "use strict";
    var matrix = require_matrix();
    function avgMatrix(A, B, weight) {
      var propA;
      var propB;
      var nrow;
      var ncol;
      var val;
      var C;
      var i;
      var j;
      nrow = A.shape[0];
      ncol = A.shape[1];
      C = matrix([nrow, ncol]);
      propA = (weight - 1) / weight;
      propB = 1 / weight;
      for (i = 0; i < nrow; i++) {
        for (j = 0; j < ncol; j++) {
          val = propA * A.get(i, j) + propB * B.get(i, j);
          C.set(i, j, val);
        }
      }
      return C;
    }
    module2.exports = avgMatrix;
  }
});

// node_modules/@stdlib/nlp-lda/lib/fit.js
var require_fit = __commonJS({
  "node_modules/@stdlib/nlp-lda/lib/fit.js"(exports, module2) {
    "use strict";
    var isPositiveInteger = require_lib61();
    var randu = require_lib119();
    var avgMatrix = require_avg_matrix();
    function fit(iter, burnin, thin) {
      var kalpha;
      var wbeta;
      var topic;
      var theta;
      var prob;
      var word;
      var phi;
      var len;
      var nt;
      var d;
      var i;
      var j;
      var u;
      var w;
      if (!isPositiveInteger(iter)) {
        throw new TypeError("invalid argument. First argument must be a positive integer. Value: `" + iter + "`.");
      }
      if (!isPositiveInteger(burnin)) {
        throw new TypeError("invalid argument. Second argument must be a positive integer. Value: `" + burnin + "`.");
      }
      if (!isPositiveInteger(thin)) {
        throw new TypeError("invalid argument. Third argument must be a positive integer. Value: `" + thin + "`.");
      }
      wbeta = this.W * this.beta;
      kalpha = this.K * this.alpha;
      for (i = 0; i < iter; i++) {
        for (d = 0; d < this.D; d++) {
          for (w = 0; w < this.ndSum[d]; w++) {
            word = this.w[d][w];
            topic = this.z[d][w];
            this.nw.set(word, topic, this.nw.get(word, topic) - 1);
            this.nd.set(d, topic, this.nd.get(d, topic) - 1);
            this.ndSum[d] -= 1;
            this.nwSum[topic] -= 1;
            prob = [];
            for (j = 0; j < this.K; j++) {
              prob.push((this.nw.get(word, j) + this.beta) / (this.nwSum[j] + wbeta) * (this.nd.get(d, j) + this.alpha) / (this.ndSum[d] + kalpha));
            }
            for (j = 1; j < this.K; j++) {
              prob[j] += prob[j - 1];
            }
            u = prob[this.K - 1] * randu();
            topic = 0;
            for (nt = 0; nt < this.K; nt++) {
              if (prob[nt] > u) {
                topic = nt;
                break;
              }
            }
            this.nw.set(word, topic, this.nw.get(word, topic) + 1);
            this.nd.set(d, topic, this.nd.get(d, topic) + 1);
            this.nwSum[topic] += 1;
            this.ndSum[d] += 1;
            this.z[d][w] = topic;
          }
        }
        if (i % thin === 0 && i > burnin) {
          phi = this.getPhis();
          theta = this.getThetas();
          this.phiList.push(phi);
          this.thetaList.push(theta);
          len = this.phiList.length;
          if (len === 1) {
            this.avgPhi = phi;
          } else {
            this.avgPhi = avgMatrix(this.avgPhi, phi, len);
          }
          len = this.thetaList.length;
          if (len === 1) {
            this.avgTheta = theta;
          } else {
            this.avgTheta = avgMatrix(this.avgTheta, theta, len);
          }
        }
      }
    }
    module2.exports = fit;
  }
});

// node_modules/@stdlib/nlp-lda/lib/lda.js
var require_lda = __commonJS({
  "node_modules/@stdlib/nlp-lda/lib/lda.js"(exports, module2) {
    "use strict";
    var isNonNegativeInteger = require_lib60();
    var isPositiveInteger = require_lib61();
    var isStringArray = require_lib65();
    var setReadOnly = require_lib66();
    var contains = require_lib70();
    var tokenize = require_lib72();
    var Int32Array2 = require_lib77();
    var matrix = require_matrix();
    var getThetas = require_get_thetas();
    var validate = require_validate();
    var getPhis = require_get_phis();
    var init = require_init();
    var fit = require_fit();
    function findIndex(vocab, searchVal) {
      var i;
      for (i = 0; i < vocab.length; i++) {
        if (vocab[i] === searchVal) {
          return i;
        }
      }
      return -1;
    }
    function lda2(documents, K, options) {
      var target;
      var vocab;
      var model;
      var alpha;
      var beta;
      var opts;
      var err;
      var pos;
      var nd;
      var it;
      var wd;
      var D;
      var d;
      var i;
      var j;
      var W;
      var w;
      if (!isStringArray(documents)) {
        throw new TypeError("invalid argument. First argument must be a string array. Value: `" + documents + "`.");
      }
      if (!isPositiveInteger(K)) {
        throw new TypeError("invalid argument. Number of topics `K` must be a positive integer. Value: `" + K + "`.");
      }
      opts = {};
      if (arguments.length > 2) {
        err = validate(opts, options);
        if (err) {
          throw err;
        }
      }
      D = documents.length;
      alpha = opts.alpha || 50 / K;
      beta = opts.beta || 0.1;
      vocab = [];
      w = [];
      pos = 0;
      for (d = 0; d < D; d++) {
        w.push([]);
        wd = tokenize(documents[d]);
        nd = wd.length;
        for (i = 0; i < nd; i++) {
          target = wd[i];
          it = findIndex(vocab, target);
          if (it === -1) {
            vocab.push(target);
            w[d].push(pos);
            pos += 1;
          } else {
            w[d].push(it);
          }
        }
      }
      W = vocab.length;
      model = {};
      setReadOnly(model, "K", K);
      setReadOnly(model, "D", D);
      setReadOnly(model, "W", W);
      setReadOnly(model, "alpha", alpha);
      setReadOnly(model, "beta", beta);
      setReadOnly(model, "init", init);
      setReadOnly(model, "fit", fit);
      setReadOnly(model, "getPhis", getPhis);
      setReadOnly(model, "getThetas", getThetas);
      setReadOnly(model, "getTerms", getTerms);
      model.nwSum = new Int32Array2(K);
      model.ndSum = new Int32Array2(D);
      model.nw = matrix([W, K], "int32");
      model.nd = matrix([D, K], "int32");
      model.phiList = [];
      model.thetaList = [];
      model.w = w;
      model.init();
      return model;
      function getTerms(k, no) {
        var skip;
        var phi;
        var ret;
        var max;
        var mid;
        var i2;
        if (!isNonNegativeInteger(k) || k >= K) {
          throw new TypeError("invalid argument. First argument must be a nonnegative integer smaller than the total number of topics. Value: `" + k + "`.");
        }
        if (no) {
          if (!isPositiveInteger(no)) {
            throw new TypeError("invalid argument. Second argument must be a positive integer. Value: `" + no + "`.");
          }
        } else {
          no = 10;
        }
        ret = [];
        skip = [];
        for (i2 = 0; i2 < no; i2++) {
          max = 0;
          for (j = 0; j < this.W; j++) {
            phi = this.avgPhi.get(k, j);
            if (phi > max && !contains(skip, j)) {
              max = phi;
              mid = j;
            }
          }
          skip.push(mid);
          ret.push({
            "word": vocab[mid],
            "prob": max
          });
        }
        return ret;
      }
    }
    module2.exports = lda2;
  }
});

// node_modules/@stdlib/nlp-lda/lib/index.js
var require_lib120 = __commonJS({
  "node_modules/@stdlib/nlp-lda/lib/index.js"(exports, module2) {
    "use strict";
    var lda2 = require_lda();
    module2.exports = lda2;
  }
});

// node_modules/@stdlib/string-ends-with/lib/ends_with.js
var require_ends_with = __commonJS({
  "node_modules/@stdlib/string-ends-with/lib/ends_with.js"(exports, module2) {
    "use strict";
    var isInteger = require_lib59().isPrimitive;
    var isString = require_lib64().isPrimitive;
    function endsWith(str, search, len) {
      var idx;
      var i;
      if (!isString(str)) {
        throw new TypeError("invalid argument. First argument must be a string primitive. Value: `" + str + "`.");
      }
      if (!isString(search)) {
        throw new TypeError("invalid argument. Second argument must be a string primitive. Value: `" + search + "`.");
      }
      if (arguments.length > 2) {
        if (!isInteger(len)) {
          throw new TypeError("invalid argument. Third argument must be an integer. Value: `" + len + "`.");
        }
        if (len === 0) {
          return search.length === 0;
        }
        if (len < 0) {
          idx = str.length + len;
        } else {
          idx = len;
        }
      } else {
        idx = str.length;
      }
      if (search.length === 0) {
        return true;
      }
      idx -= search.length;
      if (idx < 0) {
        return false;
      }
      for (i = 0; i < search.length; i++) {
        if (str.charCodeAt(idx + i) !== search.charCodeAt(i)) {
          return false;
        }
      }
      return true;
    }
    module2.exports = endsWith;
  }
});

// node_modules/@stdlib/string-ends-with/lib/index.js
var require_lib121 = __commonJS({
  "node_modules/@stdlib/string-ends-with/lib/index.js"(exports, module2) {
    "use strict";
    var endsWith = require_ends_with();
    module2.exports = endsWith;
  }
});

// node_modules/@stdlib/string-lowercase/lib/lowercase.js
var require_lowercase = __commonJS({
  "node_modules/@stdlib/string-lowercase/lib/lowercase.js"(exports, module2) {
    "use strict";
    var isString = require_lib64().isPrimitive;
    function lowercase(str) {
      if (!isString(str)) {
        throw new TypeError("invalid argument. Must provide a primitive string. Value: `" + str + "`.");
      }
      return str.toLowerCase();
    }
    module2.exports = lowercase;
  }
});

// node_modules/@stdlib/string-lowercase/lib/index.js
var require_lib122 = __commonJS({
  "node_modules/@stdlib/string-lowercase/lib/index.js"(exports, module2) {
    "use strict";
    var lowercase = require_lowercase();
    module2.exports = lowercase;
  }
});

// node_modules/@stdlib/utils-escape-regexp-string/lib/main.js
var require_main68 = __commonJS({
  "node_modules/@stdlib/utils-escape-regexp-string/lib/main.js"(exports, module2) {
    "use strict";
    var isString = require_lib64().isPrimitive;
    var RE_CHARS = /[-\/\\^$*+?.()|[\]{}]/g;
    function rescape(str) {
      var len;
      var s;
      var i;
      if (!isString(str)) {
        throw new TypeError("invalid argument. Must provide a regular expression string. Value: `" + str + "`.");
      }
      if (str[0] === "/") {
        len = str.length;
        for (i = len - 1; i >= 0; i--) {
          if (str[i] === "/") {
            break;
          }
        }
      }
      if (i === void 0 || i <= 0) {
        return str.replace(RE_CHARS, "\\$&");
      }
      s = str.substring(1, i);
      s = s.replace(RE_CHARS, "\\$&");
      str = str[0] + s + str.substring(i);
      return str;
    }
    module2.exports = rescape;
  }
});

// node_modules/@stdlib/utils-escape-regexp-string/lib/index.js
var require_lib123 = __commonJS({
  "node_modules/@stdlib/utils-escape-regexp-string/lib/index.js"(exports, module2) {
    "use strict";
    var rescape = require_main68();
    module2.exports = rescape;
  }
});

// node_modules/@stdlib/assert-is-regexp/lib/exec.js
var require_exec = __commonJS({
  "node_modules/@stdlib/assert-is-regexp/lib/exec.js"(exports, module2) {
    "use strict";
    var exec = RegExp.prototype.exec;
    module2.exports = exec;
  }
});

// node_modules/@stdlib/assert-is-regexp/lib/try2exec.js
var require_try2exec = __commonJS({
  "node_modules/@stdlib/assert-is-regexp/lib/try2exec.js"(exports, module2) {
    "use strict";
    var exec = require_exec();
    function test(value) {
      try {
        exec.call(value);
        return true;
      } catch (err) {
        return false;
      }
    }
    module2.exports = test;
  }
});

// node_modules/@stdlib/assert-is-regexp/lib/main.js
var require_main69 = __commonJS({
  "node_modules/@stdlib/assert-is-regexp/lib/main.js"(exports, module2) {
    "use strict";
    var hasToStringTag = require_lib13();
    var nativeClass = require_lib15();
    var test = require_try2exec();
    var FLG = hasToStringTag();
    function isRegExp(value) {
      if (typeof value === "object") {
        if (value instanceof RegExp) {
          return true;
        }
        if (FLG) {
          return test(value);
        }
        return nativeClass(value) === "[object RegExp]";
      }
      return false;
    }
    module2.exports = isRegExp;
  }
});

// node_modules/@stdlib/assert-is-regexp/lib/index.js
var require_lib124 = __commonJS({
  "node_modules/@stdlib/assert-is-regexp/lib/index.js"(exports, module2) {
    "use strict";
    var isRegExp = require_main69();
    module2.exports = isRegExp;
  }
});

// node_modules/@stdlib/string-replace/lib/replace.js
var require_replace = __commonJS({
  "node_modules/@stdlib/string-replace/lib/replace.js"(exports, module2) {
    "use strict";
    var rescape = require_lib123();
    var isFunction = require_lib86();
    var isString = require_lib64().isPrimitive;
    var isRegExp = require_lib124();
    function replace(str, search, newval) {
      if (!isString(str)) {
        throw new TypeError("invalid argument. First argument must be a string primitive. Value: `" + str + "`.");
      }
      if (isString(search)) {
        search = rescape(search);
        search = new RegExp(search, "g");
      } else if (!isRegExp(search)) {
        throw new TypeError("invalid argument. Second argument must be a string primitive or regular expression. Value: `" + search + "`.");
      }
      if (!isString(newval) && !isFunction(newval)) {
        throw new TypeError("invalid argument. Third argument must be a string primitive or replacement function. Value: `" + newval + "`.");
      }
      return str.replace(search, newval);
    }
    module2.exports = replace;
  }
});

// node_modules/@stdlib/string-replace/lib/index.js
var require_lib125 = __commonJS({
  "node_modules/@stdlib/string-replace/lib/index.js"(exports, module2) {
    "use strict";
    var replace = require_replace();
    module2.exports = replace;
  }
});

// node_modules/@stdlib/nlp-porter-stemmer/lib/main.js
var require_main70 = __commonJS({
  "node_modules/@stdlib/nlp-porter-stemmer/lib/main.js"(exports, module2) {
    "use strict";
    var isString = require_lib64().isPrimitive;
    var endsWith = require_lib121();
    var lowercase = require_lib122();
    var replace = require_lib125();
    var step2list = {
      "ational": "ate",
      "tional": "tion",
      "enci": "ence",
      "anci": "ance",
      "izer": "ize",
      "bli": "ble",
      "alli": "al",
      "entli": "ent",
      "eli": "e",
      "ousli": "ous",
      "ization": "ize",
      "ation": "ate",
      "ator": "ate",
      "alism": "al",
      "iveness": "ive",
      "fulness": "ful",
      "ousness": "ous",
      "aliti": "al",
      "iviti": "ive",
      "biliti": "ble",
      "logi": "log"
    };
    var step3list = {
      "icate": "ic",
      "ative": "",
      "alize": "al",
      "iciti": "ic",
      "ical": "ic",
      "ful": "",
      "ness": ""
    };
    var c = "[^aeiou]";
    var v = "[aeiouy]";
    var C = c + "[^aeiouy]*";
    var V = v + "[aeiou]*";
    var RE_CV = new RegExp("^" + C + v + "[^aeiouwxy]$");
    var mgr0 = "^(" + C + ")?" + V + C;
    var RE_MGR0 = new RegExp(mgr0);
    var meq1 = "^(" + C + ")?" + V + C + "(" + V + ")?$";
    var RE_MEQ1 = new RegExp(meq1);
    var mgr1 = "^(" + C + ")?" + V + C + V + C;
    var RE_MGR1 = new RegExp(mgr1);
    var sV = "^(" + C + ")?" + v;
    var RE_SV = new RegExp(sV);
    var RE_STEP1A = /^(.+?)(ss|i)es$/;
    var RE2_STEP1A = /^(.+?)([^s])s$/;
    var RE_STEP1B = /^(.+?)eed$/;
    var RE2_STEP1B = /^(.+?)(ed|ing)$/;
    var RE_STEP1C = /^(.+?)y$/;
    var RE_STEP2 = /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;
    var RE_STEP3 = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/;
    var RE_STEP4 = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;
    var RE2_STEP4 = /^(.+?)(s|t)(ion)$/;
    var RE_STEP5 = /^(.+?)e$/;
    var RE_LAST = /.$/;
    var RE_ATBLIZ = /(at|bl|iz)$/;
    var RE_DOUBLE = new RegExp("([^aeiouylsz])\\1$");
    function porterStemmer2(word) {
      var firstch;
      var suffix;
      var stem;
      var fp;
      if (!isString(word)) {
        throw new TypeError("invalid argument. First argument must be a string primitive. Value: `" + word + "`.");
      }
      if (word.length < 3) {
        return word;
      }
      word = lowercase(word);
      firstch = word[0];
      if (firstch === "y") {
        word = firstch.toUpperCase() + word.substr(1);
      }
      if (RE_STEP1A.test(word)) {
        word = replace(word, RE_STEP1A, "$1$2");
      } else if (RE2_STEP1A.test(word)) {
        word = replace(word, RE2_STEP1A, "$1$2");
      }
      if (RE_STEP1B.test(word)) {
        fp = RE_STEP1B.exec(word);
        if (RE_MGR0.test(fp[1])) {
          word = replace(word, RE_LAST, "");
        }
      } else if (RE2_STEP1B.test(word)) {
        fp = RE2_STEP1B.exec(word);
        stem = fp[1];
        if (RE_SV.test(stem)) {
          word = stem;
          if (RE_ATBLIZ.test(word)) {
            word += "e";
          } else if (RE_DOUBLE.test(word)) {
            word = replace(word, RE_LAST, "");
          } else if (RE_CV.test(word)) {
            word += "e";
          }
        }
      }
      if (RE_STEP1C.test(word)) {
        fp = RE_STEP1C.exec(word);
        stem = fp[1];
        if (RE_SV.test(stem)) {
          word = stem + "i";
        }
      }
      if (RE_STEP2.test(word)) {
        fp = RE_STEP2.exec(word);
        stem = fp[1];
        suffix = fp[2];
        if (RE_MGR0.test(stem)) {
          word = stem + step2list[suffix];
        }
      }
      if (RE_STEP3.test(word)) {
        fp = RE_STEP3.exec(word);
        stem = fp[1];
        suffix = fp[2];
        if (RE_MGR0.test(stem)) {
          word = stem + step3list[suffix];
        }
      }
      if (RE_STEP4.test(word)) {
        fp = RE_STEP4.exec(word);
        stem = fp[1];
        if (RE_MGR1.test(stem)) {
          word = stem;
        }
      } else if (RE2_STEP4.test(word)) {
        fp = RE2_STEP4.exec(word);
        stem = fp[1] + fp[2];
        if (RE_MGR1.test(stem)) {
          word = stem;
        }
      }
      if (RE_STEP5.test(word)) {
        fp = RE_STEP5.exec(word);
        stem = fp[1];
        if (RE_MGR1.test(stem) || RE_MEQ1.test(stem) && !RE_CV.test(stem)) {
          word = stem;
        }
      }
      if (endsWith(word, "ll") && RE_MGR1.test(word)) {
        word = replace(word, RE_LAST, "");
      }
      if (firstch === "y") {
        word = firstch.toLowerCase() + word.substr(1);
      }
      return word;
    }
    module2.exports = porterStemmer2;
  }
});

// node_modules/@stdlib/nlp-porter-stemmer/lib/index.js
var require_lib126 = __commonJS({
  "node_modules/@stdlib/nlp-porter-stemmer/lib/index.js"(exports, module2) {
    "use strict";
    var porterStemmer2 = require_main70();
    module2.exports = porterStemmer2;
  }
});

// node_modules/braces/lib/utils.js
var require_utils = __commonJS({
  "node_modules/braces/lib/utils.js"(exports) {
    "use strict";
    exports.isInteger = (num) => {
      if (typeof num === "number") {
        return Number.isInteger(num);
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isInteger(Number(num));
      }
      return false;
    };
    exports.find = (node, type) => node.nodes.find((node2) => node2.type === type);
    exports.exceedsLimit = (min, max, step = 1, limit) => {
      if (limit === false)
        return false;
      if (!exports.isInteger(min) || !exports.isInteger(max))
        return false;
      return (Number(max) - Number(min)) / Number(step) >= limit;
    };
    exports.escapeNode = (block, n = 0, type) => {
      let node = block.nodes[n];
      if (!node)
        return;
      if (type && node.type === type || node.type === "open" || node.type === "close") {
        if (node.escaped !== true) {
          node.value = "\\" + node.value;
          node.escaped = true;
        }
      }
    };
    exports.encloseBrace = (node) => {
      if (node.type !== "brace")
        return false;
      if (node.commas >> 0 + node.ranges >> 0 === 0) {
        node.invalid = true;
        return true;
      }
      return false;
    };
    exports.isInvalidBrace = (block) => {
      if (block.type !== "brace")
        return false;
      if (block.invalid === true || block.dollar)
        return true;
      if (block.commas >> 0 + block.ranges >> 0 === 0) {
        block.invalid = true;
        return true;
      }
      if (block.open !== true || block.close !== true) {
        block.invalid = true;
        return true;
      }
      return false;
    };
    exports.isOpenOrClose = (node) => {
      if (node.type === "open" || node.type === "close") {
        return true;
      }
      return node.open === true || node.close === true;
    };
    exports.reduce = (nodes) => nodes.reduce((acc, node) => {
      if (node.type === "text")
        acc.push(node.value);
      if (node.type === "range")
        node.type = "text";
      return acc;
    }, []);
    exports.flatten = (...args) => {
      const result = [];
      const flat = (arr) => {
        for (let i = 0; i < arr.length; i++) {
          let ele = arr[i];
          Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);
        }
        return result;
      };
      flat(args);
      return result;
    };
  }
});

// node_modules/braces/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/braces/lib/stringify.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = (ast, options = {}) => {
      let stringify = (node, parent = {}) => {
        let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
        let invalidNode = node.invalid === true && options.escapeInvalid === true;
        let output = "";
        if (node.value) {
          if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
            return "\\" + node.value;
          }
          return node.value;
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes) {
          for (let child of node.nodes) {
            output += stringify(child);
          }
        }
        return output;
      };
      return stringify(ast);
    };
  }
});

// node_modules/is-number/index.js
var require_is_number = __commonJS({
  "node_modules/is-number/index.js"(exports, module2) {
    "use strict";
    module2.exports = function(num) {
      if (typeof num === "number") {
        return num - num === 0;
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
      }
      return false;
    };
  }
});

// node_modules/to-regex-range/index.js
var require_to_regex_range = __commonJS({
  "node_modules/to-regex-range/index.js"(exports, module2) {
    "use strict";
    var isNumber = require_is_number();
    var toRegexRange = (min, max, options) => {
      if (isNumber(min) === false) {
        throw new TypeError("toRegexRange: expected the first argument to be a number");
      }
      if (max === void 0 || min === max) {
        return String(min);
      }
      if (isNumber(max) === false) {
        throw new TypeError("toRegexRange: expected the second argument to be a number.");
      }
      let opts = { relaxZeros: true, ...options };
      if (typeof opts.strictZeros === "boolean") {
        opts.relaxZeros = opts.strictZeros === false;
      }
      let relax = String(opts.relaxZeros);
      let shorthand = String(opts.shorthand);
      let capture = String(opts.capture);
      let wrap = String(opts.wrap);
      let cacheKey = min + ":" + max + "=" + relax + shorthand + capture + wrap;
      if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
        return toRegexRange.cache[cacheKey].result;
      }
      let a = Math.min(min, max);
      let b = Math.max(min, max);
      if (Math.abs(a - b) === 1) {
        let result = min + "|" + max;
        if (opts.capture) {
          return `(${result})`;
        }
        if (opts.wrap === false) {
          return result;
        }
        return `(?:${result})`;
      }
      let isPadded = hasPadding(min) || hasPadding(max);
      let state = { min, max, a, b };
      let positives = [];
      let negatives = [];
      if (isPadded) {
        state.isPadded = isPadded;
        state.maxLen = String(state.max).length;
      }
      if (a < 0) {
        let newMin = b < 0 ? Math.abs(b) : 1;
        negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
        a = state.a = 0;
      }
      if (b >= 0) {
        positives = splitToPatterns(a, b, state, opts);
      }
      state.negatives = negatives;
      state.positives = positives;
      state.result = collatePatterns(negatives, positives, opts);
      if (opts.capture === true) {
        state.result = `(${state.result})`;
      } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
        state.result = `(?:${state.result})`;
      }
      toRegexRange.cache[cacheKey] = state;
      return state.result;
    };
    function collatePatterns(neg, pos, options) {
      let onlyNegative = filterPatterns(neg, pos, "-", false, options) || [];
      let onlyPositive = filterPatterns(pos, neg, "", false, options) || [];
      let intersected = filterPatterns(neg, pos, "-?", true, options) || [];
      let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
      return subpatterns.join("|");
    }
    function splitToRanges(min, max) {
      let nines = 1;
      let zeros = 1;
      let stop = countNines(min, nines);
      let stops = new Set([max]);
      while (min <= stop && stop <= max) {
        stops.add(stop);
        nines += 1;
        stop = countNines(min, nines);
      }
      stop = countZeros(max + 1, zeros) - 1;
      while (min < stop && stop <= max) {
        stops.add(stop);
        zeros += 1;
        stop = countZeros(max + 1, zeros) - 1;
      }
      stops = [...stops];
      stops.sort(compare);
      return stops;
    }
    function rangeToPattern(start, stop, options) {
      if (start === stop) {
        return { pattern: start, count: [], digits: 0 };
      }
      let zipped = zip(start, stop);
      let digits = zipped.length;
      let pattern = "";
      let count = 0;
      for (let i = 0; i < digits; i++) {
        let [startDigit, stopDigit] = zipped[i];
        if (startDigit === stopDigit) {
          pattern += startDigit;
        } else if (startDigit !== "0" || stopDigit !== "9") {
          pattern += toCharacterClass(startDigit, stopDigit, options);
        } else {
          count++;
        }
      }
      if (count) {
        pattern += options.shorthand === true ? "\\d" : "[0-9]";
      }
      return { pattern, count: [count], digits };
    }
    function splitToPatterns(min, max, tok, options) {
      let ranges = splitToRanges(min, max);
      let tokens = [];
      let start = min;
      let prev;
      for (let i = 0; i < ranges.length; i++) {
        let max2 = ranges[i];
        let obj = rangeToPattern(String(start), String(max2), options);
        let zeros = "";
        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
          if (prev.count.length > 1) {
            prev.count.pop();
          }
          prev.count.push(obj.count[0]);
          prev.string = prev.pattern + toQuantifier(prev.count);
          start = max2 + 1;
          continue;
        }
        if (tok.isPadded) {
          zeros = padZeros(max2, tok, options);
        }
        obj.string = zeros + obj.pattern + toQuantifier(obj.count);
        tokens.push(obj);
        start = max2 + 1;
        prev = obj;
      }
      return tokens;
    }
    function filterPatterns(arr, comparison, prefix, intersection, options) {
      let result = [];
      for (let ele of arr) {
        let { string } = ele;
        if (!intersection && !contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
        if (intersection && contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
      }
      return result;
    }
    function zip(a, b) {
      let arr = [];
      for (let i = 0; i < a.length; i++)
        arr.push([a[i], b[i]]);
      return arr;
    }
    function compare(a, b) {
      return a > b ? 1 : b > a ? -1 : 0;
    }
    function contains(arr, key, val) {
      return arr.some((ele) => ele[key] === val);
    }
    function countNines(min, len) {
      return Number(String(min).slice(0, -len) + "9".repeat(len));
    }
    function countZeros(integer, zeros) {
      return integer - integer % Math.pow(10, zeros);
    }
    function toQuantifier(digits) {
      let [start = 0, stop = ""] = digits;
      if (stop || start > 1) {
        return `{${start + (stop ? "," + stop : "")}}`;
      }
      return "";
    }
    function toCharacterClass(a, b, options) {
      return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
    }
    function hasPadding(str) {
      return /^-?(0+)\d/.test(str);
    }
    function padZeros(value, tok, options) {
      if (!tok.isPadded) {
        return value;
      }
      let diff = Math.abs(tok.maxLen - String(value).length);
      let relax = options.relaxZeros !== false;
      switch (diff) {
        case 0:
          return "";
        case 1:
          return relax ? "0?" : "0";
        case 2:
          return relax ? "0{0,2}" : "00";
        default: {
          return relax ? `0{0,${diff}}` : `0{${diff}}`;
        }
      }
    }
    toRegexRange.cache = {};
    toRegexRange.clearCache = () => toRegexRange.cache = {};
    module2.exports = toRegexRange;
  }
});

// node_modules/fill-range/index.js
var require_fill_range = __commonJS({
  "node_modules/fill-range/index.js"(exports, module2) {
    "use strict";
    var util = require("util");
    var toRegexRange = require_to_regex_range();
    var isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    var transform = (toNumber) => {
      return (value) => toNumber === true ? Number(value) : String(value);
    };
    var isValidValue = (value) => {
      return typeof value === "number" || typeof value === "string" && value !== "";
    };
    var isNumber = (num) => Number.isInteger(+num);
    var zeros = (input) => {
      let value = `${input}`;
      let index = -1;
      if (value[0] === "-")
        value = value.slice(1);
      if (value === "0")
        return false;
      while (value[++index] === "0")
        ;
      return index > 0;
    };
    var stringify = (start, end, options) => {
      if (typeof start === "string" || typeof end === "string") {
        return true;
      }
      return options.stringify === true;
    };
    var pad = (input, maxLength, toNumber) => {
      if (maxLength > 0) {
        let dash = input[0] === "-" ? "-" : "";
        if (dash)
          input = input.slice(1);
        input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
      }
      if (toNumber === false) {
        return String(input);
      }
      return input;
    };
    var toMaxLen = (input, maxLength) => {
      let negative = input[0] === "-" ? "-" : "";
      if (negative) {
        input = input.slice(1);
        maxLength--;
      }
      while (input.length < maxLength)
        input = "0" + input;
      return negative ? "-" + input : input;
    };
    var toSequence = (parts, options) => {
      parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      let prefix = options.capture ? "" : "?:";
      let positives = "";
      let negatives = "";
      let result;
      if (parts.positives.length) {
        positives = parts.positives.join("|");
      }
      if (parts.negatives.length) {
        negatives = `-(${prefix}${parts.negatives.join("|")})`;
      }
      if (positives && negatives) {
        result = `${positives}|${negatives}`;
      } else {
        result = positives || negatives;
      }
      if (options.wrap) {
        return `(${prefix}${result})`;
      }
      return result;
    };
    var toRange = (a, b, isNumbers, options) => {
      if (isNumbers) {
        return toRegexRange(a, b, { wrap: false, ...options });
      }
      let start = String.fromCharCode(a);
      if (a === b)
        return start;
      let stop = String.fromCharCode(b);
      return `[${start}-${stop}]`;
    };
    var toRegex = (start, end, options) => {
      if (Array.isArray(start)) {
        let wrap = options.wrap === true;
        let prefix = options.capture ? "" : "?:";
        return wrap ? `(${prefix}${start.join("|")})` : start.join("|");
      }
      return toRegexRange(start, end, options);
    };
    var rangeError = (...args) => {
      return new RangeError("Invalid range arguments: " + util.inspect(...args));
    };
    var invalidRange = (start, end, options) => {
      if (options.strictRanges === true)
        throw rangeError([start, end]);
      return [];
    };
    var invalidStep = (step, options) => {
      if (options.strictRanges === true) {
        throw new TypeError(`Expected step "${step}" to be a number`);
      }
      return [];
    };
    var fillNumbers = (start, end, step = 1, options = {}) => {
      let a = Number(start);
      let b = Number(end);
      if (!Number.isInteger(a) || !Number.isInteger(b)) {
        if (options.strictRanges === true)
          throw rangeError([start, end]);
        return [];
      }
      if (a === 0)
        a = 0;
      if (b === 0)
        b = 0;
      let descending = a > b;
      let startString = String(start);
      let endString = String(end);
      let stepString = String(step);
      step = Math.max(Math.abs(step), 1);
      let padded = zeros(startString) || zeros(endString) || zeros(stepString);
      let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
      let toNumber = padded === false && stringify(start, end, options) === false;
      let format = options.transform || transform(toNumber);
      if (options.toRegex && step === 1) {
        return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
      }
      let parts = { negatives: [], positives: [] };
      let push = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
      let range = [];
      let index = 0;
      while (descending ? a >= b : a <= b) {
        if (options.toRegex === true && step > 1) {
          push(a);
        } else {
          range.push(pad(format(a, index), maxLen, toNumber));
        }
        a = descending ? a - step : a + step;
        index++;
      }
      if (options.toRegex === true) {
        return step > 1 ? toSequence(parts, options) : toRegex(range, null, { wrap: false, ...options });
      }
      return range;
    };
    var fillLetters = (start, end, step = 1, options = {}) => {
      if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
        return invalidRange(start, end, options);
      }
      let format = options.transform || ((val) => String.fromCharCode(val));
      let a = `${start}`.charCodeAt(0);
      let b = `${end}`.charCodeAt(0);
      let descending = a > b;
      let min = Math.min(a, b);
      let max = Math.max(a, b);
      if (options.toRegex && step === 1) {
        return toRange(min, max, false, options);
      }
      let range = [];
      let index = 0;
      while (descending ? a >= b : a <= b) {
        range.push(format(a, index));
        a = descending ? a - step : a + step;
        index++;
      }
      if (options.toRegex === true) {
        return toRegex(range, null, { wrap: false, options });
      }
      return range;
    };
    var fill = (start, end, step, options = {}) => {
      if (end == null && isValidValue(start)) {
        return [start];
      }
      if (!isValidValue(start) || !isValidValue(end)) {
        return invalidRange(start, end, options);
      }
      if (typeof step === "function") {
        return fill(start, end, 1, { transform: step });
      }
      if (isObject(step)) {
        return fill(start, end, 0, step);
      }
      let opts = { ...options };
      if (opts.capture === true)
        opts.wrap = true;
      step = step || opts.step || 1;
      if (!isNumber(step)) {
        if (step != null && !isObject(step))
          return invalidStep(step, opts);
        return fill(start, end, 1, step);
      }
      if (isNumber(start) && isNumber(end)) {
        return fillNumbers(start, end, step, opts);
      }
      return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
    };
    module2.exports = fill;
  }
});

// node_modules/braces/lib/compile.js
var require_compile = __commonJS({
  "node_modules/braces/lib/compile.js"(exports, module2) {
    "use strict";
    var fill = require_fill_range();
    var utils = require_utils();
    var compile = (ast, options = {}) => {
      let walk = (node, parent = {}) => {
        let invalidBlock = utils.isInvalidBrace(parent);
        let invalidNode = node.invalid === true && options.escapeInvalid === true;
        let invalid = invalidBlock === true || invalidNode === true;
        let prefix = options.escapeInvalid === true ? "\\" : "";
        let output = "";
        if (node.isOpen === true) {
          return prefix + node.value;
        }
        if (node.isClose === true) {
          return prefix + node.value;
        }
        if (node.type === "open") {
          return invalid ? prefix + node.value : "(";
        }
        if (node.type === "close") {
          return invalid ? prefix + node.value : ")";
        }
        if (node.type === "comma") {
          return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes && node.ranges > 0) {
          let args = utils.reduce(node.nodes);
          let range = fill(...args, { ...options, wrap: false, toRegex: true });
          if (range.length !== 0) {
            return args.length > 1 && range.length > 1 ? `(${range})` : range;
          }
        }
        if (node.nodes) {
          for (let child of node.nodes) {
            output += walk(child, node);
          }
        }
        return output;
      };
      return walk(ast);
    };
    module2.exports = compile;
  }
});

// node_modules/braces/lib/expand.js
var require_expand = __commonJS({
  "node_modules/braces/lib/expand.js"(exports, module2) {
    "use strict";
    var fill = require_fill_range();
    var stringify = require_stringify();
    var utils = require_utils();
    var append = (queue = "", stash = "", enclose = false) => {
      let result = [];
      queue = [].concat(queue);
      stash = [].concat(stash);
      if (!stash.length)
        return queue;
      if (!queue.length) {
        return enclose ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;
      }
      for (let item of queue) {
        if (Array.isArray(item)) {
          for (let value of item) {
            result.push(append(value, stash, enclose));
          }
        } else {
          for (let ele of stash) {
            if (enclose === true && typeof ele === "string")
              ele = `{${ele}}`;
            result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
          }
        }
      }
      return utils.flatten(result);
    };
    var expand = (ast, options = {}) => {
      let rangeLimit = options.rangeLimit === void 0 ? 1e3 : options.rangeLimit;
      let walk = (node, parent = {}) => {
        node.queue = [];
        let p = parent;
        let q = parent.queue;
        while (p.type !== "brace" && p.type !== "root" && p.parent) {
          p = p.parent;
          q = p.queue;
        }
        if (node.invalid || node.dollar) {
          q.push(append(q.pop(), stringify(node, options)));
          return;
        }
        if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
          q.push(append(q.pop(), ["{}"]));
          return;
        }
        if (node.nodes && node.ranges > 0) {
          let args = utils.reduce(node.nodes);
          if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
            throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
          }
          let range = fill(...args, options);
          if (range.length === 0) {
            range = stringify(node, options);
          }
          q.push(append(q.pop(), range));
          node.nodes = [];
          return;
        }
        let enclose = utils.encloseBrace(node);
        let queue = node.queue;
        let block = node;
        while (block.type !== "brace" && block.type !== "root" && block.parent) {
          block = block.parent;
          queue = block.queue;
        }
        for (let i = 0; i < node.nodes.length; i++) {
          let child = node.nodes[i];
          if (child.type === "comma" && node.type === "brace") {
            if (i === 1)
              queue.push("");
            queue.push("");
            continue;
          }
          if (child.type === "close") {
            q.push(append(q.pop(), queue, enclose));
            continue;
          }
          if (child.value && child.type !== "open") {
            queue.push(append(queue.pop(), child.value));
            continue;
          }
          if (child.nodes) {
            walk(child, node);
          }
        }
        return queue;
      };
      return utils.flatten(walk(ast));
    };
    module2.exports = expand;
  }
});

// node_modules/braces/lib/constants.js
var require_constants = __commonJS({
  "node_modules/braces/lib/constants.js"(exports, module2) {
    "use strict";
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      CHAR_0: "0",
      CHAR_9: "9",
      CHAR_UPPERCASE_A: "A",
      CHAR_LOWERCASE_A: "a",
      CHAR_UPPERCASE_Z: "Z",
      CHAR_LOWERCASE_Z: "z",
      CHAR_LEFT_PARENTHESES: "(",
      CHAR_RIGHT_PARENTHESES: ")",
      CHAR_ASTERISK: "*",
      CHAR_AMPERSAND: "&",
      CHAR_AT: "@",
      CHAR_BACKSLASH: "\\",
      CHAR_BACKTICK: "`",
      CHAR_CARRIAGE_RETURN: "\r",
      CHAR_CIRCUMFLEX_ACCENT: "^",
      CHAR_COLON: ":",
      CHAR_COMMA: ",",
      CHAR_DOLLAR: "$",
      CHAR_DOT: ".",
      CHAR_DOUBLE_QUOTE: '"',
      CHAR_EQUAL: "=",
      CHAR_EXCLAMATION_MARK: "!",
      CHAR_FORM_FEED: "\f",
      CHAR_FORWARD_SLASH: "/",
      CHAR_HASH: "#",
      CHAR_HYPHEN_MINUS: "-",
      CHAR_LEFT_ANGLE_BRACKET: "<",
      CHAR_LEFT_CURLY_BRACE: "{",
      CHAR_LEFT_SQUARE_BRACKET: "[",
      CHAR_LINE_FEED: "\n",
      CHAR_NO_BREAK_SPACE: "\xA0",
      CHAR_PERCENT: "%",
      CHAR_PLUS: "+",
      CHAR_QUESTION_MARK: "?",
      CHAR_RIGHT_ANGLE_BRACKET: ">",
      CHAR_RIGHT_CURLY_BRACE: "}",
      CHAR_RIGHT_SQUARE_BRACKET: "]",
      CHAR_SEMICOLON: ";",
      CHAR_SINGLE_QUOTE: "'",
      CHAR_SPACE: " ",
      CHAR_TAB: "	",
      CHAR_UNDERSCORE: "_",
      CHAR_VERTICAL_LINE: "|",
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
    };
  }
});

// node_modules/braces/lib/parse.js
var require_parse = __commonJS({
  "node_modules/braces/lib/parse.js"(exports, module2) {
    "use strict";
    var stringify = require_stringify();
    var {
      MAX_LENGTH,
      CHAR_BACKSLASH,
      CHAR_BACKTICK,
      CHAR_COMMA,
      CHAR_DOT,
      CHAR_LEFT_PARENTHESES,
      CHAR_RIGHT_PARENTHESES,
      CHAR_LEFT_CURLY_BRACE,
      CHAR_RIGHT_CURLY_BRACE,
      CHAR_LEFT_SQUARE_BRACKET,
      CHAR_RIGHT_SQUARE_BRACKET,
      CHAR_DOUBLE_QUOTE,
      CHAR_SINGLE_QUOTE,
      CHAR_NO_BREAK_SPACE,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE
    } = require_constants();
    var parse = (input, options = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      let opts = options || {};
      let max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      if (input.length > max) {
        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
      }
      let ast = { type: "root", input, nodes: [] };
      let stack = [ast];
      let block = ast;
      let prev = ast;
      let brackets = 0;
      let length = input.length;
      let index = 0;
      let depth = 0;
      let value;
      let memo = {};
      const advance = () => input[index++];
      const push = (node) => {
        if (node.type === "text" && prev.type === "dot") {
          prev.type = "text";
        }
        if (prev && prev.type === "text" && node.type === "text") {
          prev.value += node.value;
          return;
        }
        block.nodes.push(node);
        node.parent = block;
        node.prev = prev;
        prev = node;
        return node;
      };
      push({ type: "bos" });
      while (index < length) {
        block = stack[stack.length - 1];
        value = advance();
        if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
          continue;
        }
        if (value === CHAR_BACKSLASH) {
          push({ type: "text", value: (options.keepEscaping ? value : "") + advance() });
          continue;
        }
        if (value === CHAR_RIGHT_SQUARE_BRACKET) {
          push({ type: "text", value: "\\" + value });
          continue;
        }
        if (value === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          let closed = true;
          let next;
          while (index < length && (next = advance())) {
            value += next;
            if (next === CHAR_LEFT_SQUARE_BRACKET) {
              brackets++;
              continue;
            }
            if (next === CHAR_BACKSLASH) {
              value += advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              brackets--;
              if (brackets === 0) {
                break;
              }
            }
          }
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_PARENTHESES) {
          block = push({ type: "paren", nodes: [] });
          stack.push(block);
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_RIGHT_PARENTHESES) {
          if (block.type !== "paren") {
            push({ type: "text", value });
            continue;
          }
          block = stack.pop();
          push({ type: "text", value });
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
          let open = value;
          let next;
          if (options.keepQuotes !== true) {
            value = "";
          }
          while (index < length && (next = advance())) {
            if (next === CHAR_BACKSLASH) {
              value += next + advance();
              continue;
            }
            if (next === open) {
              if (options.keepQuotes === true)
                value += next;
              break;
            }
            value += next;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_CURLY_BRACE) {
          depth++;
          let dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
          let brace = {
            type: "brace",
            open: true,
            close: false,
            dollar,
            depth,
            commas: 0,
            ranges: 0,
            nodes: []
          };
          block = push(brace);
          stack.push(block);
          push({ type: "open", value });
          continue;
        }
        if (value === CHAR_RIGHT_CURLY_BRACE) {
          if (block.type !== "brace") {
            push({ type: "text", value });
            continue;
          }
          let type = "close";
          block = stack.pop();
          block.close = true;
          push({ type, value });
          depth--;
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_COMMA && depth > 0) {
          if (block.ranges > 0) {
            block.ranges = 0;
            let open = block.nodes.shift();
            block.nodes = [open, { type: "text", value: stringify(block) }];
          }
          push({ type: "comma", value });
          block.commas++;
          continue;
        }
        if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
          let siblings = block.nodes;
          if (depth === 0 || siblings.length === 0) {
            push({ type: "text", value });
            continue;
          }
          if (prev.type === "dot") {
            block.range = [];
            prev.value += value;
            prev.type = "range";
            if (block.nodes.length !== 3 && block.nodes.length !== 5) {
              block.invalid = true;
              block.ranges = 0;
              prev.type = "text";
              continue;
            }
            block.ranges++;
            block.args = [];
            continue;
          }
          if (prev.type === "range") {
            siblings.pop();
            let before = siblings[siblings.length - 1];
            before.value += prev.value + value;
            prev = before;
            block.ranges--;
            continue;
          }
          push({ type: "dot", value });
          continue;
        }
        push({ type: "text", value });
      }
      do {
        block = stack.pop();
        if (block.type !== "root") {
          block.nodes.forEach((node) => {
            if (!node.nodes) {
              if (node.type === "open")
                node.isOpen = true;
              if (node.type === "close")
                node.isClose = true;
              if (!node.nodes)
                node.type = "text";
              node.invalid = true;
            }
          });
          let parent = stack[stack.length - 1];
          let index2 = parent.nodes.indexOf(block);
          parent.nodes.splice(index2, 1, ...block.nodes);
        }
      } while (stack.length > 0);
      push({ type: "eos" });
      return ast;
    };
    module2.exports = parse;
  }
});

// node_modules/braces/index.js
var require_braces = __commonJS({
  "node_modules/braces/index.js"(exports, module2) {
    "use strict";
    var stringify = require_stringify();
    var compile = require_compile();
    var expand = require_expand();
    var parse = require_parse();
    var braces = (input, options = {}) => {
      let output = [];
      if (Array.isArray(input)) {
        for (let pattern of input) {
          let result = braces.create(pattern, options);
          if (Array.isArray(result)) {
            output.push(...result);
          } else {
            output.push(result);
          }
        }
      } else {
        output = [].concat(braces.create(input, options));
      }
      if (options && options.expand === true && options.nodupes === true) {
        output = [...new Set(output)];
      }
      return output;
    };
    braces.parse = (input, options = {}) => parse(input, options);
    braces.stringify = (input, options = {}) => {
      if (typeof input === "string") {
        return stringify(braces.parse(input, options), options);
      }
      return stringify(input, options);
    };
    braces.compile = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      return compile(input, options);
    };
    braces.expand = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      let result = expand(input, options);
      if (options.noempty === true) {
        result = result.filter(Boolean);
      }
      if (options.nodupes === true) {
        result = [...new Set(result)];
      }
      return result;
    };
    braces.create = (input, options = {}) => {
      if (input === "" || input.length < 3) {
        return [input];
      }
      return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);
    };
    module2.exports = braces;
  }
});

// node_modules/picomatch/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/picomatch/lib/constants.js"(exports, module2) {
    "use strict";
    var path = require("path");
    var WIN_SLASH = "\\\\/";
    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    var DOT_LITERAL = "\\.";
    var PLUS_LITERAL = "\\+";
    var QMARK_LITERAL = "\\?";
    var SLASH_LITERAL = "\\/";
    var ONE_CHAR = "(?=.)";
    var QMARK = "[^/]";
    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    var NO_DOT = `(?!${DOT_LITERAL})`;
    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    var STAR = `${QMARK}*?`;
    var POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    };
    var WINDOWS_CHARS = {
      ...POSIX_CHARS,
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
    };
    var POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      CHAR_0: 48,
      CHAR_9: 57,
      CHAR_UPPERCASE_A: 65,
      CHAR_LOWERCASE_A: 97,
      CHAR_UPPERCASE_Z: 90,
      CHAR_LOWERCASE_Z: 122,
      CHAR_LEFT_PARENTHESES: 40,
      CHAR_RIGHT_PARENTHESES: 41,
      CHAR_ASTERISK: 42,
      CHAR_AMPERSAND: 38,
      CHAR_AT: 64,
      CHAR_BACKWARD_SLASH: 92,
      CHAR_CARRIAGE_RETURN: 13,
      CHAR_CIRCUMFLEX_ACCENT: 94,
      CHAR_COLON: 58,
      CHAR_COMMA: 44,
      CHAR_DOT: 46,
      CHAR_DOUBLE_QUOTE: 34,
      CHAR_EQUAL: 61,
      CHAR_EXCLAMATION_MARK: 33,
      CHAR_FORM_FEED: 12,
      CHAR_FORWARD_SLASH: 47,
      CHAR_GRAVE_ACCENT: 96,
      CHAR_HASH: 35,
      CHAR_HYPHEN_MINUS: 45,
      CHAR_LEFT_ANGLE_BRACKET: 60,
      CHAR_LEFT_CURLY_BRACE: 123,
      CHAR_LEFT_SQUARE_BRACKET: 91,
      CHAR_LINE_FEED: 10,
      CHAR_NO_BREAK_SPACE: 160,
      CHAR_PERCENT: 37,
      CHAR_PLUS: 43,
      CHAR_QUESTION_MARK: 63,
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      CHAR_RIGHT_CURLY_BRACE: 125,
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      CHAR_SEMICOLON: 59,
      CHAR_SINGLE_QUOTE: 39,
      CHAR_SPACE: 32,
      CHAR_TAB: 9,
      CHAR_UNDERSCORE: 95,
      CHAR_VERTICAL_LINE: 124,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      SEP: path.sep,
      extglobChars(chars) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      globChars(win32) {
        return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  }
});

// node_modules/picomatch/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/picomatch/lib/utils.js"(exports) {
    "use strict";
    var path = require("path");
    var win32 = process.platform === "win32";
    var {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants2();
    exports.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
    exports.isRegexChar = (str) => str.length === 1 && exports.hasRegexChars(str);
    exports.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
    exports.removeBackslashes = (str) => {
      return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
        return match === "\\" ? "" : match;
      });
    };
    exports.supportsLookbehinds = () => {
      const segs = process.version.slice(1).split(".").map(Number);
      if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
        return true;
      }
      return false;
    };
    exports.isWindows = (options) => {
      if (options && typeof options.windows === "boolean") {
        return options.windows;
      }
      return win32 === true || path.sep === "\\";
    };
    exports.escapeLast = (input, char, lastIdx) => {
      const idx = input.lastIndexOf(char, lastIdx);
      if (idx === -1)
        return input;
      if (input[idx - 1] === "\\")
        return exports.escapeLast(input, char, idx - 1);
      return `${input.slice(0, idx)}\\${input.slice(idx)}`;
    };
    exports.removePrefix = (input, state = {}) => {
      let output = input;
      if (output.startsWith("./")) {
        output = output.slice(2);
        state.prefix = "./";
      }
      return output;
    };
    exports.wrapOutput = (input, state = {}, options = {}) => {
      const prepend = options.contains ? "" : "^";
      const append = options.contains ? "" : "$";
      let output = `${prepend}(?:${input})${append}`;
      if (state.negated === true) {
        output = `(?:^(?!${output}).*$)`;
      }
      return output;
    };
  }
});

// node_modules/picomatch/lib/scan.js
var require_scan = __commonJS({
  "node_modules/picomatch/lib/scan.js"(exports, module2) {
    "use strict";
    var utils = require_utils2();
    var {
      CHAR_ASTERISK,
      CHAR_AT,
      CHAR_BACKWARD_SLASH,
      CHAR_COMMA,
      CHAR_DOT,
      CHAR_EXCLAMATION_MARK,
      CHAR_FORWARD_SLASH,
      CHAR_LEFT_CURLY_BRACE,
      CHAR_LEFT_PARENTHESES,
      CHAR_LEFT_SQUARE_BRACKET,
      CHAR_PLUS,
      CHAR_QUESTION_MARK,
      CHAR_RIGHT_CURLY_BRACE,
      CHAR_RIGHT_PARENTHESES,
      CHAR_RIGHT_SQUARE_BRACKET
    } = require_constants2();
    var isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    var depth = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    var scan = (input, options) => {
      const opts = options || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str = input;
      let index = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob = false;
      let isExtglob = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces = 0;
      let prev;
      let code;
      let token = { value: "", depth: 0, isGlob: false };
      const eos = () => index >= length;
      const peek = () => str.charCodeAt(index + 1);
      const advance = () => {
        prev = code;
        return str.charCodeAt(++index);
      };
      while (index < length) {
        code = advance();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          code = advance();
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE) {
              braces--;
              if (braces === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index);
          tokens.push(token);
          token = { value: "", depth: 0, isGlob: false };
          if (finished === true)
            continue;
          if (prev === CHAR_DOT && index === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            isExtglob = token.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK && index === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob = token.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK)
            isGlobstar = token.isGlobstar = true;
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next = advance())) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token.isBracket = true;
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
          negated = token.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
      }
      let base = str;
      let prefix = "";
      let glob = "";
      if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
      }
      if (base && isGlob === true && lastIndex > 0) {
        base = str.slice(0, lastIndex);
        glob = str.slice(lastIndex);
      } else if (isGlob === true) {
        base = "";
        glob = str;
      } else {
        base = str;
      }
      if (base && base !== "" && base !== "/" && base !== str) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
          base = base.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob)
          glob = utils.removeBackslashes(glob);
        if (base && backslashes === true) {
          base = utils.removeBackslashes(base);
        }
      }
      const state = {
        prefix,
        input,
        start,
        base,
        glob,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n = prevIndex ? prevIndex + 1 : start;
          const i = slashes[idx];
          const value = input.slice(n, i);
          if (opts.tokens) {
            if (idx === 0 && start !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix;
            } else {
              tokens[idx].value = value;
            }
            depth(tokens[idx]);
            state.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value !== "") {
            parts.push(value);
          }
          prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value = input.slice(prevIndex + 1);
          parts.push(value);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value;
            depth(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    module2.exports = scan;
  }
});

// node_modules/picomatch/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/picomatch/lib/parse.js"(exports, module2) {
    "use strict";
    var constants = require_constants2();
    var utils = require_utils2();
    var {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants;
    var expandRange = (args, options) => {
      if (typeof options.expandRange === "function") {
        return options.expandRange(...args, options);
      }
      args.sort();
      const value = `[${args.join("-")}]`;
      try {
        new RegExp(value);
      } catch (ex) {
        return args.map((v) => utils.escapeRegex(v)).join("..");
      }
      return value;
    };
    var syntaxError = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    var parse = (input, options) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const win32 = utils.isWindows(options);
      const PLATFORM_CHARS = constants.globChars(win32);
      const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL,
        PLUS_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT;
      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
      let star = opts.bash === true ? globstar(opts) : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces = [];
      const stack = [];
      let prev = bos;
      let value;
      const eos = () => state.index === len - 1;
      const peek = state.peek = (n = 1) => input[state.index + n];
      const advance = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value2 = "", num = 0) => {
        state.consumed += value2;
        state.index += num;
      };
      const append = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate = () => {
        let count = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance();
          state.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output)
          append(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value;
          prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value2) => {
        const token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push({ type, value: value2, output: state.output ? "" : ONE_CHAR });
        push({ type: "paren", extglob: true, value: advance(), output });
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
          let extglobStar = star;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            output = token.close = `)${rest})${extglobStar})`;
          }
          if (token.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push({ type: "paren", extglob: true, value, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
          if (first === "\\") {
            backslashes = true;
            return m;
          }
          if (first === "?") {
            if (esc) {
              return esc + first + (rest ? QMARK.repeat(rest.length) : "");
            }
            if (index === 0) {
              return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
            }
            return QMARK.repeat(chars.length);
          }
          if (first === ".") {
            return DOT_LITERAL.repeat(chars.length);
          }
          if (first === "*") {
            if (esc) {
              return esc + first + (rest ? star : "");
            }
            return star;
          }
          return esc ? m : `\\${m}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m) => {
              return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils.wrapOutput(output, state, options);
        return state;
      }
      while (!eos()) {
        value = advance();
        if (value === "\0") {
          continue;
        }
        if (value === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value += "\\";
            push({ type: "text", value });
            continue;
          }
          const match = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match && match[0].length > 2) {
            slashes = match[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value += "\\";
            }
          }
          if (opts.unescape === true) {
            value = advance();
          } else {
            value += advance();
          }
          if (state.brackets === 0) {
            push({ type: "text", value });
            continue;
          }
        }
        if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix = POSIX_REGEX_SOURCE[rest2];
                if (posix) {
                  prev.value = pre + posix;
                  state.backtrack = true;
                  advance();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR;
                  }
                  continue;
                }
              }
            }
          }
          if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
            value = `\\${value}`;
          }
          if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
            value = `\\${value}`;
          }
          if (opts.posix === true && value === "!" && prev.value === "[") {
            value = "^";
          }
          prev.value += value;
          append({ value });
          continue;
        }
        if (state.quotes === 1 && value !== '"') {
          value = utils.escapeRegex(value);
          prev.value += value;
          append({ value });
          continue;
        }
        if (value === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push({ type: "text", value });
          }
          continue;
        }
        if (value === "(") {
          increment("parens");
          push({ type: "paren", value });
          continue;
        }
        if (value === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value = `\\${value}`;
          } else {
            increment("brackets");
          }
          push({ type: "bracket", value });
          continue;
        }
        if (value === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value = `/${value}`;
          }
          prev.value += value;
          append({ value });
          if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped = utils.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped;
            prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value === "{" && opts.nobrace !== true) {
          increment("braces");
          const open = {
            type: "brace",
            value,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces.push(open);
          push(open);
          continue;
        }
        if (value === "}") {
          const brace = braces[braces.length - 1];
          if (opts.nobrace === true || !brace) {
            push({ type: "text", value, output: value });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range = [];
            for (let i = arr.length - 1; i >= 0; i--) {
              tokens.pop();
              if (arr[i].type === "brace") {
                break;
              }
              if (arr[i].type !== "dots") {
                range.unshift(arr[i].value);
              }
            }
            output = expandRange(range, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value = output = "\\}";
            state.output = out;
            for (const t of toks) {
              state.output += t.output || t.value;
            }
          }
          push({ type: "brace", value, output });
          decrement("braces");
          braces.pop();
          continue;
        }
        if (value === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === ",") {
          let output = value;
          const brace = braces[braces.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push({ type: "comma", value, output });
          continue;
        }
        if (value === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push({ type: "slash", value, output: SLASH_LITERAL });
          continue;
        }
        if (value === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".")
              prev.output = DOT_LITERAL;
            const brace = braces[braces.length - 1];
            prev.type = "dots";
            prev.output += value;
            prev.value += value;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push({ type: "text", value, output: DOT_LITERAL });
            continue;
          }
          push({ type: "dot", value, output: DOT_LITERAL });
          continue;
        }
        if (value === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value;
            if (next === "<" && !utils.supportsLookbehinds()) {
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            }
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value}`;
            }
            push({ type: "text", value, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push({ type: "qmark", value, output: QMARK_NO_DOT });
            continue;
          }
          push({ type: "qmark", value, output: QMARK });
          continue;
        }
        if (value === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push({ type: "plus", value, output: PLUS_LITERAL });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push({ type: "plus", value });
            continue;
          }
          push({ type: "plus", value: PLUS_LITERAL });
          continue;
        }
        if (value === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push({ type: "at", extglob: true, value, output: "" });
            continue;
          }
          push({ type: "text", value });
          continue;
        }
        if (value !== "*") {
          if (value === "$" || value === "^") {
            value = `\\${value}`;
          }
          const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match) {
            value += match[0];
            state.index += match[0].length;
          }
          push({ type: "text", value });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value;
          prev.output = star;
          state.backtrack = true;
          state.globstar = true;
          consume(value);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push({ type: "star", value, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push({ type: "star", value, output: "" });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
            prev.value += value;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value;
            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value;
          state.output += prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        const token = { type: "star", value, output: star };
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value;
          push(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH;
            prev.output += NO_DOT_SLASH;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH;
            prev.output += NO_DOTS_SLASH;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR;
            prev.output += ONE_CHAR;
          }
        }
        push(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse.fastpaths = (input, options) => {
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      input = REPLACEMENTS[input] || input;
      const win32 = utils.isWindows(options);
      const {
        DOT_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOTS_SLASH,
        STAR,
        START_ANCHOR
      } = constants.globChars(win32);
      const nodot = opts.dot ? NO_DOTS : NO_DOT;
      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
      const capture = opts.capture ? "" : "?:";
      const state = { negated: false, prefix: "" };
      let star = opts.bash === true ? ".*?" : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true)
          return star;
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const create = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR}${star}`;
          case ".*":
            return `${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*.*":
            return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*/*":
            return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
          default: {
            const match = /^(.*?)\.(\w+)$/.exec(str);
            if (!match)
              return;
            const source2 = create(match[1]);
            if (!source2)
              return;
            return source2 + DOT_LITERAL + match[2];
          }
        }
      };
      const output = utils.removePrefix(input, state);
      let source = create(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL}?`;
      }
      return source;
    };
    module2.exports = parse;
  }
});

// node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS({
  "node_modules/picomatch/lib/picomatch.js"(exports, module2) {
    "use strict";
    var path = require("path");
    var scan = require_scan();
    var parse = require_parse2();
    var utils = require_utils2();
    var constants = require_constants2();
    var isObject = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch = (glob, options, returnState = false) => {
      if (Array.isArray(glob)) {
        const fns = glob.map((input) => picomatch(input, options, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch of fns) {
            const state2 = isMatch(str);
            if (state2)
              return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject(glob) && glob.tokens && glob.input;
      if (glob === "" || typeof glob !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options || {};
      const posix = utils.isWindows(options);
      const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored = () => false;
      if (opts.ignore) {
        const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
        isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input, returnObject = false) => {
        const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });
        const result = { glob, state, regex, posix, input, output, match, isMatch };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher.state = state;
      }
      return matcher;
    };
    picomatch.test = (input, regex, options, { glob, posix } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options || {};
      const format = opts.format || (posix ? utils.toPosixSlashes : null);
      let match = input === glob;
      let output = match && format ? format(input) : input;
      if (match === false) {
        output = format ? format(input) : input;
        match = output === glob;
      }
      if (match === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match = picomatch.matchBase(input, regex, options, posix);
        } else {
          match = regex.exec(output);
        }
      }
      return { isMatch: Boolean(match), match, output };
    };
    picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
      const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
      return regex.test(path.basename(input));
    };
    picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    picomatch.parse = (pattern, options) => {
      if (Array.isArray(pattern))
        return pattern.map((p) => picomatch.parse(p, options));
      return parse(pattern, { ...options, fastpaths: false });
    };
    picomatch.scan = (input, options) => scan(input, options);
    picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options || {};
      const prepend = opts.contains ? "" : "^";
      const append = opts.contains ? "" : "$";
      let source = `${prepend}(?:${state.output})${append}`;
      if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex = picomatch.toRegex(source, options);
      if (returnState === true) {
        regex.state = state;
      }
      return regex;
    };
    picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse.fastpaths(input, options);
      }
      if (!parsed.output) {
        parsed = parse(input, options);
      }
      return picomatch.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch.toRegex = (source, options) => {
      try {
        const opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options && options.debug === true)
          throw err;
        return /$^/;
      }
    };
    picomatch.constants = constants;
    module2.exports = picomatch;
  }
});

// node_modules/picomatch/index.js
var require_picomatch2 = __commonJS({
  "node_modules/picomatch/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_picomatch();
  }
});

// node_modules/micromatch/index.js
var require_micromatch = __commonJS({
  "node_modules/micromatch/index.js"(exports, module2) {
    "use strict";
    var util = require("util");
    var braces = require_braces();
    var picomatch = require_picomatch2();
    var utils = require_utils2();
    var isEmptyString = (val) => val === "" || val === "./";
    var micromatch2 = (list, patterns, options) => {
      patterns = [].concat(patterns);
      list = [].concat(list);
      let omit = new Set();
      let keep = new Set();
      let items = new Set();
      let negatives = 0;
      let onResult = (state) => {
        items.add(state.output);
        if (options && options.onResult) {
          options.onResult(state);
        }
      };
      for (let i = 0; i < patterns.length; i++) {
        let isMatch = picomatch(String(patterns[i]), { ...options, onResult }, true);
        let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
        if (negated)
          negatives++;
        for (let item of list) {
          let matched = isMatch(item, true);
          let match = negated ? !matched.isMatch : matched.isMatch;
          if (!match)
            continue;
          if (negated) {
            omit.add(matched.output);
          } else {
            omit.delete(matched.output);
            keep.add(matched.output);
          }
        }
      }
      let result = negatives === patterns.length ? [...items] : [...keep];
      let matches = result.filter((item) => !omit.has(item));
      if (options && matches.length === 0) {
        if (options.failglob === true) {
          throw new Error(`No matches found for "${patterns.join(", ")}"`);
        }
        if (options.nonull === true || options.nullglob === true) {
          return options.unescape ? patterns.map((p) => p.replace(/\\/g, "")) : patterns;
        }
      }
      return matches;
    };
    micromatch2.match = micromatch2;
    micromatch2.matcher = (pattern, options) => picomatch(pattern, options);
    micromatch2.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    micromatch2.any = micromatch2.isMatch;
    micromatch2.not = (list, patterns, options = {}) => {
      patterns = [].concat(patterns).map(String);
      let result = new Set();
      let items = [];
      let onResult = (state) => {
        if (options.onResult)
          options.onResult(state);
        items.push(state.output);
      };
      let matches = micromatch2(list, patterns, { ...options, onResult });
      for (let item of items) {
        if (!matches.includes(item)) {
          result.add(item);
        }
      }
      return [...result];
    };
    micromatch2.contains = (str, pattern, options) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      if (Array.isArray(pattern)) {
        return pattern.some((p) => micromatch2.contains(str, p, options));
      }
      if (typeof pattern === "string") {
        if (isEmptyString(str) || isEmptyString(pattern)) {
          return false;
        }
        if (str.includes(pattern) || str.startsWith("./") && str.slice(2).includes(pattern)) {
          return true;
        }
      }
      return micromatch2.isMatch(str, pattern, { ...options, contains: true });
    };
    micromatch2.matchKeys = (obj, patterns, options) => {
      if (!utils.isObject(obj)) {
        throw new TypeError("Expected the first argument to be an object");
      }
      let keys = micromatch2(Object.keys(obj), patterns, options);
      let res = {};
      for (let key of keys)
        res[key] = obj[key];
      return res;
    };
    micromatch2.some = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (items.some((item) => isMatch(item))) {
          return true;
        }
      }
      return false;
    };
    micromatch2.every = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (!items.every((item) => isMatch(item))) {
          return false;
        }
      }
      return true;
    };
    micromatch2.all = (str, patterns, options) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      return [].concat(patterns).every((p) => picomatch(p, options)(str));
    };
    micromatch2.capture = (glob, input, options) => {
      let posix = utils.isWindows(options);
      let regex = picomatch.makeRe(String(glob), { ...options, capture: true });
      let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);
      if (match) {
        return match.slice(1).map((v) => v === void 0 ? "" : v);
      }
    };
    micromatch2.makeRe = (...args) => picomatch.makeRe(...args);
    micromatch2.scan = (...args) => picomatch.scan(...args);
    micromatch2.parse = (patterns, options) => {
      let res = [];
      for (let pattern of [].concat(patterns || [])) {
        for (let str of braces(String(pattern), options)) {
          res.push(picomatch.parse(str, options));
        }
      }
      return res;
    };
    micromatch2.braces = (pattern, options) => {
      if (typeof pattern !== "string")
        throw new TypeError("Expected a string");
      if (options && options.nobrace === true || !/\{.*\}/.test(pattern)) {
        return [pattern];
      }
      return braces(pattern, options);
    };
    micromatch2.braceExpand = (pattern, options) => {
      if (typeof pattern !== "string")
        throw new TypeError("Expected a string");
      return micromatch2.braces(pattern, { ...options, expand: true });
    };
    module2.exports = micromatch2;
  }
});

// src/main.ts
__export(exports, {
  default: () => TopicLinkingPlugin
});
var import_obsidian5 = __toModule(require("obsidian"));

// src/settings.ts
var import_obsidian = __toModule(require("obsidian"));
var DEFAULT_SETTINGS = {
  generatedPath: "Generated/",
  pdfPath: "PDFs/",
  pdfOverwrite: false,
  pdfExtractFileNumberLimit: 0,
  pdfExtractFileSizeLimit: 5e3,
  pdfExtractChunkIfFileExceedsLimit: true,
  bookmarkPath: "Bookmarks/",
  bookmarkOverwrite: false,
  topicPathPattern: "Generated/",
  topicSearchPattern: "",
  topicTagPattern: "",
  numTopics: 5,
  numWords: 5,
  stemming: false,
  topicThreshold: 0.5,
  fixedWordLength: 1e3,
  percentageTextToScan: 5,
  wordSelectionRandom: true,
  topicIncludePattern: false,
  topicIncludeTimestamp: false,
  ldaIterations: 1e3,
  ldaBurnIn: 100,
  ldaThin: 10
};
var TopicLinkingSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Topic Link Plugin" });
    containerEl.createEl("h3", { text: "General" });
    new import_obsidian.Setting(containerEl).setName("Generated files").setDesc("Where to output generated files").addText((text) => {
      text.setPlaceholder("Generated/").setValue(this.plugin.settings.generatedPath.toString()).onChange(async (value) => {
        this.plugin.settings.generatedPath = value;
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h3", { text: "PDF Extraction Settings" });
    new import_obsidian.Setting(containerEl).setName("PDF files").setDesc("Where to find PDF files").addText((text) => {
      text.setPlaceholder("PDFs/").setValue(this.plugin.settings.pdfPath.toString()).onChange(async (value) => {
        this.plugin.settings.pdfPath = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Overwrite").setDesc("Overwrite Markdown file if it already exists").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.pdfOverwrite).onChange(async (value) => {
        this.plugin.settings.pdfOverwrite = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Limit file number").setDesc("Enter the number of files to limit PDF extraction (use when 'PDF Overwrite' is false). '0' means no limit.").addText((text) => {
      text.inputEl.setAttribute("type", "number");
      text.setPlaceholder("0-100").setValue(this.plugin.settings.pdfExtractFileNumberLimit.toString()).onChange(async (value) => {
        this.plugin.settings.pdfExtractFileNumberLimit = Math.min(Math.max(parseInt(value), 0), 1e3);
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Limit file size").setDesc("Enter the maximum file size (in KB) to process (0 means any size).").addText((text) => {
      text.inputEl.setAttribute("type", "number");
      text.setPlaceholder("0-100000").setValue(this.plugin.settings.pdfExtractFileSizeLimit.toString()).onChange(async (value) => {
        this.plugin.settings.pdfExtractFileSizeLimit = Math.min(Math.max(parseInt(value), 0), 1e5);
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Chunk file if size exceeds limit").setDesc("Chunks, or breaks down the resulting file if it exceeds *Limit file size*.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.pdfExtractChunkIfFileExceedsLimit).onChange(async (value) => {
        this.plugin.settings.pdfExtractChunkIfFileExceedsLimit = value;
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h3", { text: "Bookmark Extraction Settings" });
    new import_obsidian.Setting(containerEl).setName("Bookmark files").setDesc("Where to find Bookmark files").addText((text) => {
      text.setPlaceholder("Bookmarks/").setValue(this.plugin.settings.bookmarkPath.toString()).onChange(async (value) => {
        this.plugin.settings.bookmarkPath = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Overwrite").setDesc("Overwrite Markdown file if it already exists").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.bookmarkOverwrite).onChange(async (value) => {
        this.plugin.settings.bookmarkOverwrite = value;
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h3", { text: "Topic Linking Settings" });
    containerEl.createEl("h4", { text: "General Parameters" });
    new import_obsidian.Setting(containerEl).setName("Number of topics").setDesc("Enter the number of topics to generate.").addText((text) => {
      text.inputEl.setAttribute("type", "number");
      text.setPlaceholder("1-10").setValue(this.plugin.settings.numTopics.toString()).onChange(async (value) => {
        this.plugin.settings.numTopics = Math.min(Math.max(parseInt(value), 1), 10);
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Number of words").setDesc("Enter the number of words per topic to capture.").addText((text) => {
      text.inputEl.setAttribute("type", "number");
      text.setPlaceholder("1-20").setValue(this.plugin.settings.numWords.toString()).onChange(async (value) => {
        this.plugin.settings.numWords = Math.min(Math.max(parseInt(value), 1), 20);
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Stemming").setDesc("Select whether tokens should be stemmed before analysis.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.stemming).onChange(async (value) => {
        this.plugin.settings.stemming = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Topic threshold").setDesc("Enter the threshold (between 0 and 1) for a document to be relevant to a topic").addText((text) => {
      text.inputEl.setAttribute("type", "number");
      text.setPlaceholder("0.0-1.0").setValue(this.plugin.settings.topicThreshold.toString()).onChange(async (value) => {
        this.plugin.settings.topicThreshold = Math.min(Math.max(parseFloat(value), 0), 1);
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h4", { text: "Conditions" });
    new import_obsidian.Setting(containerEl).setName("Topc extraction file match").setDesc("Enter a pattern to match Markdown files for topic extraction.").addText((text) => {
      text.setPlaceholder("Generated/").setValue(this.plugin.settings.topicPathPattern.toString()).onChange(async (value) => {
        this.plugin.settings.topicPathPattern = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Topc extraction search match").setDesc("Enter a search expression that files must contain to be included in topic extraction.").addText((text) => {
      text.setPlaceholder("").setValue(this.plugin.settings.topicSearchPattern.toString()).onChange(async (value) => {
        this.plugin.settings.topicSearchPattern = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Topc extraction tag match").setDesc('Enter a series of tags (in the format "#fashion #photography") which must be included at least once in matching files.').addText((text) => {
      text.setPlaceholder("").setValue(this.plugin.settings.topicTagPattern.toString()).onChange(async (value) => {
        this.plugin.settings.topicTagPattern = value;
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h4", { text: "Source Text Filtering" });
    new import_obsidian.Setting(containerEl).setName("Fixed number of words").setDesc("Enter the number of words to extract from the text. Overrides 'Percentage of Total Text' below.").addText((text) => {
      text.inputEl.setAttribute("type", "number");
      text.setPlaceholder("0-5000").setValue(this.plugin.settings.fixedWordLength.toString()).onChange(async (value) => {
        this.plugin.settings.fixedWordLength = Math.min(Math.max(parseInt(value), 0), 5e3);
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Percentage of total text").setDesc("Enter the percentage of the total text to scan. ").addText((text) => {
      text.inputEl.setAttribute("type", "number");
      text.setPlaceholder("1-100").setValue(this.plugin.settings.percentageTextToScan.toString()).onChange(async (value) => {
        this.plugin.settings.percentageTextToScan = Math.min(Math.max(parseInt(value), 1), 100);
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Randomise text").setDesc('Select whether the text selection should be randomised ("false" means the text is scanned from the beginning).').addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.wordSelectionRandom).onChange(async (value) => {
        this.plugin.settings.wordSelectionRandom = value;
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h4", { text: "Topic Folder Naming" });
    new import_obsidian.Setting(containerEl).setName("Topic folder pattern").setDesc("Select whether the topic folder should include the Markdown search pattern.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.topicIncludePattern).onChange(async (value) => {
        this.plugin.settings.topicIncludePattern = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Topic folder timestamp").setDesc('Select whether the topic folder should have a timestamp included (note this can lead to a large number of "Topic-YYYYMMSShhmmss" folders).').addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.topicIncludeTimestamp).onChange(async (value) => {
        this.plugin.settings.topicIncludeTimestamp = value;
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h4", { text: "LDA (Latent Dirichet Allocation) Parameters" });
    new import_obsidian.Setting(containerEl).setName("LDA iterations").setDesc("Enter the number of iterations to fit the LDA model").addText((text) => {
      text.inputEl.setAttribute("type", "number");
      text.setPlaceholder("100-5000").setValue(this.plugin.settings.ldaIterations.toString()).onChange(async (value) => {
        this.plugin.settings.ldaIterations = Math.min(Math.max(parseInt(value), 100), 5e3);
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("LDA burn in").setDesc("Enter the number of estimates to discard at the first iteration").addText((text) => {
      text.inputEl.setAttribute("type", "number");
      text.setPlaceholder("10-500").setValue(this.plugin.settings.ldaBurnIn.toString()).onChange(async (value) => {
        this.plugin.settings.ldaBurnIn = Math.min(Math.max(parseInt(value), 10), 500);
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("LDA thin").setDesc("Enter the number of estimates to discard at every other iteration").addText((text) => {
      text.inputEl.setAttribute("type", "number");
      text.setPlaceholder("1-100").setValue(this.plugin.settings.ldaThin.toString()).onChange(async (value) => {
        this.plugin.settings.ldaThin = Math.min(Math.max(parseInt(value), 1), 100);
        await this.plugin.saveSettings();
      });
    });
  }
};

// src/pdf.ts
var import_obsidian2 = __toModule(require("obsidian"));
var PDFContentExtractor = class {
  constructor() {
    this.getContent = async (vault, file, counter) => {
      const pages = [];
      try {
        const buffer = await vault.readBinary(file);
        const pdf = await this.pdfjs.getDocument(buffer).promise;
        console.log(`Loading file num ${counter} at ${file.basename}, with: ${pdf.numPages} pages and size: ${file.stat.size / 1e3}KB.`);
        for (let i = 0; i < pdf.numPages; i++) {
          const page = await pdf.getPage(i + 1);
          const textContent = await page.getTextContent();
          const operators = await page.getOperatorList();
          const objs = page.commonObjs._objs;
          pages.push({ textContent, commonObjs: objs });
        }
      } catch (err) {
        console.log(`Error ${err} loading ${file.path}.`);
      }
      return pages;
    };
    this.subPathFactory = (file, offset) => {
      if (file.path.length > offset && file.path.lastIndexOf("/") > -1)
        return file.path.substring(0, file.path.lastIndexOf("/") + 1).substring(offset);
      else
        return "";
    };
    this.makeSubFolders = (vault, files) => {
      files.map(async (file) => {
        const subPath = this.subPathFactory(file, this.pdfPath.length);
        if (subPath.length > 0) {
          try {
            const folderLoc = (0, import_obsidian2.normalizePath)(`${this.generatedPath}${subPath}`);
            await vault.createFolder(folderLoc);
          } catch (err) {
          }
        }
      });
    };
    this.chunkSubstring = (str, num) => {
      const sizeChunks = Math.ceil(str.length / num);
      const chunks = new Array(num);
      for (let i = 0, o = 0; i < num; ++i, o += sizeChunks) {
        chunks[i] = str.substring(o, o + sizeChunks);
      }
      return chunks;
    };
    this.processPDF = async (vault, settings, file, fileCounter) => {
      const pages = await this.getContent(vault, file, fileCounter);
      const subPath = this.subPathFactory(file, this.pdfPath.length);
      let minH = -1, maxH = -1, totalH = 0, counterH = 0, meanH = 0;
      pages.forEach((page) => {
        const textContent = page.textContent;
        const commonObja = page.commonObjs;
        textContent.items.forEach((item) => {
          const { str, height } = item;
          if (str.trim().length > 0) {
            if (height > maxH)
              maxH = height;
            if (height < minH || minH == -1)
              minH = height;
            totalH += height;
            counterH++;
          }
        });
      });
      meanH = totalH / counterH;
      const markdownStrings = [];
      let counter = 0;
      let strL = "", widthL = 0, heightL = 0, transformL = [], fontNameL = "", hasEOLL = false;
      let leftMarginL = 0;
      let yCoordL = 0, yCoordLL = 0;
      let strLL = "", widthLL = 0, heightLL = 0, transformLL = [], fontNameLL = "", hasEOLLL = false;
      let pageCounter = 0;
      for (let j = 0; j < pages.length; j++) {
        const page = pages[j];
        const textContent = page.textContent;
        const commonObjs = page.commonObjs;
        let inCode = false;
        let newLine = true;
        let blockquote = false;
        const treatEOLasNewLine = false;
        for (let i = 0; i < textContent.items.length; i++) {
          const item = textContent.items[i];
          let markdownText = "";
          let { str } = item;
          const { dir, width, height, transform, fontName, hasEOL } = item;
          let leftMargin = parseFloat(transform[4]);
          let yCoord = parseFloat(transform[5]);
          let italicised = false, bolded = false;
          const font = commonObjs[fontName];
          if (font) {
            const fontDataName = font.data.name;
            italicised = fontDataName.indexOf("Italic") > -1;
            bolded = fontDataName.indexOf("Bold") > -1;
          }
          const leadingSpace = str.startsWith(" ") ? " " : "";
          const trailingSpace = str.endsWith(" ") ? " " : "";
          if (italicised && str.trim().length > 0)
            str = `*${str.trim()}*${trailingSpace}`;
          else if (bolded && str.trim().length > 0)
            str = `**${str.trim()}**${trailingSpace}`;
          let yDiff = 0;
          let yDiff2 = 0;
          if (transformL.length > 0)
            yDiff = yCoordL - yCoord;
          if (transformLL.length > 0)
            yDiff2 = yCoordLL - yCoord;
          if (height > 0 && height < meanH && i > 0 && leftMargin > leftMarginL) {
            const diffH = height / meanH - 1;
            if (hasEOLL) {
              if (diffH < -0.2 && !blockquote) {
                blockquote = true;
                markdownText += `

> `;
              }
            } else if (!blockquote) {
              str = `${leadingSpace}[${str.trim()}]${trailingSpace}`;
            }
          } else if (blockquote && str.trim().length > 0 && strL.trim().length === 0) {
            blockquote = false;
            markdownText += `

`;
          }
          if ((str.indexOf("//=>") == 0 || str.indexOf("=>") == 0 || str.indexOf(">>") == 0) && !inCode && newLine) {
            markdownText += "`" + str;
            inCode = true;
            newLine = false;
          } else if (strL.trim() != "" && hasEOLL && heightL == height) {
            if (strL.endsWith("-")) {
              newLine = false;
            } else if (!blockquote && Math.floor(widthL) != Math.floor(width) && (treatEOLasNewLine && hasEOL || strL.substring(strL.length - 1).match(/[\u{2019}?.:-]/u) != null)) {
              if (blockquote) {
                markdownStrings[counter - 1] = markdownStrings[counter - 1] + "\n";
              } else if (i > 0) {
                const lines = Math.floor(yDiff / height);
                let linePadding = "\n".repeat(lines);
                if (lines > 0 && leftMargin > leftMarginL)
                  linePadding += "\n";
                markdownStrings[counter - 1] = markdownStrings[counter - 1] + linePadding;
                newLine = true;
              }
              inCode = false;
            } else {
              markdownStrings[counter - 1] = strL + (strL.endsWith(" ") ? "" : " ");
              newLine = false;
            }
            markdownText += str;
          } else {
            if (hasEOLL && strL.trim() === "" && yDiff2 > height * 2) {
              const lines = Math.floor(yDiff2 / height);
              const linePadding = "\n".repeat(lines);
              markdownStrings[counter - 2] = markdownStrings[counter - 2] + (inCode ? "`" : "") + linePadding;
            } else if (hasEOLL && strL.trim() === "" && yDiff > height) {
              const lines = Math.floor(yDiff / height);
              const linePadding = "\n" + "\n".repeat(lines);
              markdownStrings[counter - 1] = markdownStrings[counter - 1] + (inCode ? "`" : "") + linePadding;
            } else if (i === 0) {
              markdownStrings[counter - 1] = strL + (strL.endsWith(" ") ? "" : " ");
            }
            inCode = false;
            newLine = true;
            let heading = "";
            let headingPadding = "";
            if (height > meanH) {
              const diffH = height / meanH - 1;
              const headingSize = Math.ceil(0.5 / diffH);
              if (headingSize <= 6) {
                heading = "#".repeat(headingSize) + " ";
                headingPadding = "\n".repeat(7 - headingSize);
              }
            }
            markdownText += headingPadding;
            markdownText += heading;
            markdownText += str;
          }
          markdownText = markdownText.replaceAll("[[", `\\[\\[`).replaceAll("  ", " ");
          counter++;
          markdownStrings.push(markdownText);
          strLL = strL;
          widthLL = widthL;
          heightLL = heightL;
          transformLL = transformL;
          fontNameLL = fontNameL;
          hasEOLLL = hasEOLL;
          yCoordLL = yCoordL;
          if (transform[5] !== transformL[5] && str !== "")
            leftMarginL = leftMargin;
          strL = markdownText;
          widthL = width;
          heightL = height;
          transformL = transform;
          fontNameL = fontName;
          hasEOLL = hasEOL;
          yCoordL = yCoord;
        }
        pageCounter++;
      }
      let markdownContents = markdownStrings.join("");
      markdownContents = `Source file: [[${file.path}]]

${markdownContents}`;
      const fileName = (0, import_obsidian2.normalizePath)(`${this.generatedPath}${subPath}${file.basename}.md`);
      const byteLength = Buffer.byteLength(markdownContents, "utf-8");
      const kb = Math.ceil(byteLength / 1024);
      if (kb > settings.pdfExtractFileSizeLimit && settings.pdfExtractFileSizeLimit > 0 && settings.pdfExtractChunkIfFileExceedsLimit === true) {
        const chunkNum = Math.ceil(byteLength / (settings.pdfExtractFileSizeLimit * 1024 * 0.5));
        const segments = this.chunkSubstring(markdownContents, chunkNum);
        for (let i = 0; i < segments.length; i++) {
          const segmentPath = (0, import_obsidian2.normalizePath)(`${this.generatedPath}${subPath}${file.basename}_${i + 1}.md`);
          const newSegmentFile = vault.getAbstractFileByPath(segmentPath);
          if (newSegmentFile !== null)
            await vault.modify(newSegmentFile, segments[i]);
          else
            await vault.create(segmentPath, segments[i]);
        }
      } else {
        const newFile = vault.getAbstractFileByPath(fileName);
        if (newFile !== null)
          await vault.modify(newFile, markdownContents);
        else
          await vault.create(fileName, markdownContents);
      }
    };
  }
  async extract(vault, settings, statusBarItemEl) {
    this.pdfjs = await (0, import_obsidian2.loadPdfJs)();
    statusBarItemEl.setText(`Extracting Markdown text from PDF files...`);
    this.generatedPath = settings.generatedPath;
    this.pdfPath = settings.pdfPath;
    const fileNumberLimit = settings.pdfExtractFileNumberLimit;
    const fileSizeLimit = settings.pdfExtractFileSizeLimit;
    const chunkIfFileExceedsLimit = settings.pdfExtractChunkIfFileExceedsLimit;
    const pdfOverwrite = settings.pdfOverwrite === true;
    console.log(`File number limit: ${fileNumberLimit}`);
    console.log(`File size limit: ${fileSizeLimit}`);
    console.log(`Chunk if file exceeds limit: ${chunkIfFileExceedsLimit}`);
    console.log(`Overwrite exising files: ${pdfOverwrite}`);
    let files = vault.getFiles().filter((file) => {
      let matches = false;
      if (file.extension === "pdf" && file.path.indexOf(this.pdfPath) > -1) {
        if (chunkIfFileExceedsLimit === false && fileSizeLimit > 0 && file.stat.size * 1024 > fileSizeLimit)
          matches = false;
        else if (!pdfOverwrite) {
          const subPath = this.subPathFactory(file, this.pdfPath.length);
          let mdFile = (0, import_obsidian2.normalizePath)(`${this.generatedPath}${subPath}${file.basename}.md`);
          let mdVersion = vault.getAbstractFileByPath(mdFile);
          if (mdVersion === null) {
            if (chunkIfFileExceedsLimit === true) {
              mdFile = (0, import_obsidian2.normalizePath)(`${this.generatedPath}${subPath}${file.basename}_1.md`);
              mdVersion = vault.getAbstractFileByPath(mdFile);
              if (mdVersion === null)
                matches = true;
            } else
              matches = true;
          }
        } else
          matches = true;
      }
      return matches;
    });
    if (fileNumberLimit > 0)
      files = files.slice(0, fileNumberLimit);
    this.makeSubFolders(vault, files);
    let index = 0;
    for (let file of files) {
      await this.processPDF(vault, settings, file, index++);
    }
    statusBarItemEl.setText("All done!");
  }
};

// src/bookmark.ts
var import_obsidian3 = __toModule(require("obsidian"));
var BookmarkContentExtractor = class {
  async deleteBookmarks(vault) {
    const filesToDelete = vault.getFiles().filter((file) => file.path.indexOf((0, import_obsidian3.normalizePath)(`${this.generatedPath}${this.bookmarkPath}`)) > -1 && file.extension === "md");
    for (let i = 0; i < filesToDelete.length; i++)
      await vault.delete(filesToDelete[i]);
  }
  async extract(vault, settings, statusBarItemEl) {
    this.generatedPath = settings.generatedPath;
    this.bookmarkPath = settings.bookmarkPath;
    statusBarItemEl.setText("Retrieving web content as markdown...");
    if (settings.bookmarkOverwrite)
      this.deleteBookmarks(vault);
    const files = vault.getMarkdownFiles().filter((file) => file.path.indexOf(this.bookmarkPath) === 0);
    const fileContents = [];
    for (let file of files) {
      fileContents.push(await vault.cachedRead(file));
    }
    for (let contents of fileContents) {
      let links = contents.match(/https*:\/\/[^ )]*/g);
      if (links != null) {
        links = links.filter((link) => !link.endsWith(".pdf") && !link.endsWith(".jpg"));
        for (let i = 0; i < links.length; i++) {
          const link = links[i];
          try {
            const htmlContents = await (0, import_obsidian3.request)({ url: link });
            let title = link;
            if (htmlContents != null) {
              const titleMatch = htmlContents.match(/<title>([^<]*)<\/title>/i);
              if (titleMatch !== null && titleMatch.length > 1 && titleMatch[1] !== "")
                title = titleMatch[1];
            }
            if (title.indexOf("40") === 0 || title.indexOf("50") === 0)
              return;
            title = title.trim().replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "-");
            if (title.indexOf("-") === 0)
              title = title.substring(1);
            title = title.substring(0, 50);
            let md = (0, import_obsidian3.htmlToMarkdown)(htmlContents);
            md = `${link}

${md}`;
            const fileName = (0, import_obsidian3.normalizePath)(`${this.generatedPath}${this.bookmarkPath}${title}.md`);
            const file = vault.getAbstractFileByPath(fileName);
            if (file !== null) {
              if (settings.bookmarkOverwrite)
                vault.modify(file, md);
            } else
              vault.create(fileName, md);
          } catch (err) {
            console.log(err);
          }
        }
      }
    }
    statusBarItemEl.setText("All done!");
  }
};

// src/topic.ts
var import_obsidian4 = __toModule(require("obsidian"));
var import_math_base_special_roundn = __toModule(require_lib55());
var import_datasets_stopwords_en = __toModule(require_browser());
var import_nlp_lda = __toModule(require_lib120());
var import_nlp_porter_stemmer = __toModule(require_lib126());
var import_micromatch = __toModule(require_micromatch());
var TopicLinker = class {
  async link(app, settings, statusBarItemEl) {
    const { vault } = app;
    const topicPathPattern = settings.topicPathPattern;
    const topicSearchPattern = settings.topicSearchPattern;
    const topicTagPattern = settings.topicTagPattern;
    console.log(`Number of topics: ${settings.numTopics}`);
    console.log(`Number of words: ${settings.numWords}`);
    console.log(`Topic threshold: ${settings.topicThreshold}`);
    console.log(`Percentage of text: ${settings.percentageTextToScan}`);
    console.log(`Topic file pattern: ${topicPathPattern}`);
    console.log(`Topic search pattern: ${topicSearchPattern}`);
    console.log(`Topic tag pattern: ${topicTagPattern}`);
    console.log(`Fixed word length: ${settings.fixedWordLength}`);
    console.log(`Text percentage: ${settings.percentageTextToScan}`);
    console.log(`Word selection: ${settings.wordSelectionRandom}`);
    statusBarItemEl.setText(`Extracting Markdown file contents at ${settings.percentageTextToScan}%...`);
    let files = vault.getMarkdownFiles().filter((file) => (0, import_micromatch.default)([file.path], ["*" + topicPathPattern + "*"]).length > 0);
    if (topicSearchPattern && topicSearchPattern.length > 0) {
      const topicSearchFunc = (0, import_obsidian4.prepareSimpleSearch)(topicSearchPattern);
      const resultingFiles = [];
      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        const fileContents2 = await vault.cachedRead(file);
        const result = topicSearchFunc(fileContents2);
        if (result) {
          resultingFiles.push(file);
        }
      }
      files = resultingFiles;
    }
    if (topicTagPattern && topicTagPattern.length > 0) {
      const topicTags = topicTagPattern.split(" ");
      const resultingFiles = [];
      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        const cm = app.metadataCache.getFileCache(file);
        const tags = (0, import_obsidian4.getAllTags)(cm);
        if (tags && tags.length > 0) {
          tags.forEach((tag) => {
            if (topicTags.indexOf(tag) >= 0)
              resultingFiles.push(file);
          });
        }
      }
      files = resultingFiles;
    }
    if (files.length === 0) {
      statusBarItemEl.setText("No Markdown files found!");
      return;
    }
    const pdfNames = vault.getFiles().filter((file) => {
      return file.extension === "pdf";
    }).map((file) => file.basename);
    const words = (0, import_datasets_stopwords_en.default)();
    const wordRegexes = words.map((word) => {
      return new RegExp("\\b" + word + "\\b", "gi");
    });
    const extendedStops = ["\xA9", "null", "obj", "pg", "de", "et", "la", "le", "el", "que", "dont", "flotr2", "mpg", "ibid", "pdses", "\xE0", "en", "les", "des", "qui", "du"];
    extendedStops.forEach((word) => {
      wordRegexes.push(new RegExp("\\b" + word + "\\b", "gi"));
    });
    const fileContents = [];
    for (let file of files) {
      fileContents.push(await vault.cachedRead(file));
    }
    const documents = fileContents.map((document) => {
      if (settings.fixedWordLength > 0) {
        const totalWords = document.split(" ");
        const wordLength = totalWords.length;
        const scanEnd = wordLength > settings.fixedWordLength ? settings.fixedWordLength : wordLength;
        let scanStart = 0;
        if (settings.wordSelectionRandom)
          scanStart = Math.floor(Math.random() * (wordLength - scanEnd));
        document = totalWords.slice(scanStart, scanStart + scanEnd).join(" ");
      } else if (settings.percentageTextToScan > 0 && settings.percentageTextToScan < 100) {
        const scanEnd = document.length * (settings.percentageTextToScan / 100);
        let scanStart = 0;
        if (settings.wordSelectionRandom)
          scanStart = Math.floor(Math.random() * (100 - scanEnd));
        document = document.substring(scanStart, scanEnd);
      }
      document = document.toLowerCase().replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,\-./:;<=>?@[\]^_`{|}~]/g, "").replace(/\b\d{1,}\b/g, "");
      wordRegexes.forEach((word) => {
        document = document.replace(word, "");
      });
      document = document.replace(/\s{2,}/g, " ");
      if (settings.stemming)
        document = document.split(" ").map((word) => (0, import_nlp_porter_stemmer.default)(word)).join(" ");
      return document.trim();
    });
    const numTopics = settings.numTopics;
    const numWords = settings.numWords;
    const threshold = settings.topicThreshold;
    const iterations = settings.ldaIterations;
    const burnin = settings.ldaBurnIn;
    const thin = settings.ldaThin;
    statusBarItemEl.setText("Finding " + numTopics + " topics to meet " + threshold + "...");
    const ldaModel = (0, import_nlp_lda.default)(documents, numTopics);
    ldaModel.fit(iterations, burnin, thin);
    const topicDocs = new Array(numTopics);
    for (let j = 0; j < numTopics; j++) {
      for (let i = 0; i < documents.length; i++) {
        const score = (0, import_math_base_special_roundn.default)(ldaModel.avgTheta.get(i, j), -3);
        if (score > threshold) {
          if (topicDocs[j] === void 0)
            topicDocs[j] = [];
          topicDocs[j].push({ doc: files[i].basename, score });
        }
      }
    }
    const topicStrings = [];
    for (let j = 0; j < numTopics; j++) {
      const terms = ldaModel.getTerms(j, numWords);
      const topicString = `Topic ${j + 1} - ${terms.map((t) => t.word).join("-")}`;
      topicStrings.push(topicString);
    }
    statusBarItemEl.setText(`Creating topic files with ${numWords} per topic...`);
    let topicDir = `Topics`;
    if (settings.topicIncludePattern)
      topicDir += `-${topicPathPattern.replace(/[*/. ]/g, "-")}-${topicSearchPattern.replace(/[*/. ]/g, "-")}`;
    if (settings.topicIncludeTimestamp)
      topicDir += `-${(0, import_obsidian4.moment)().format("YYYYMMDDhhmmss")}`;
    topicDir = topicDir.replace(/--/, "-");
    try {
      await vault.createFolder((0, import_obsidian4.normalizePath)(topicDir));
    } catch (err) {
    }
    for (let j = 0; j < numTopics; j++) {
      const terms = ldaModel.getTerms(j, numWords);
      if (terms[0].word === void 0)
        continue;
      const fileName = (0, import_obsidian4.normalizePath)(`${topicDir}/${topicStrings[j]}.md`);
      let fileText = `# Topic ${j + 1}

`;
      fileText += `Return to [[Topic Index]]

`;
      fileText += "## Keywords \n\n";
      fileText += "#### Tags \n\n";
      for (let k = 0; k < terms.length; k++) {
        const { word } = terms[k];
        fileText += `#${word} `;
      }
      fileText += "\n\n#### Topic-Word Relevance \n\n";
      fileText += `| ${"Word".padEnd(20)} | Probability  |
`;
      fileText += `| :${"-".repeat(19)} | ${"-".repeat(11)}: |
`;
      for (let k = 0; k < terms.length; k++) {
        const { word, prob } = terms[k];
        fileText += `| ${("**" + word + "**").padEnd(20)} | ${prob.toPrecision(2).padEnd(11)} |
`;
      }
      fileText += `

`;
      fileText += `## Links 

`;
      const thisTopicDocs = topicDocs[j];
      if (thisTopicDocs !== void 0) {
        thisTopicDocs.sort((td1, td2) => {
          return td1.score > td2.score ? -1 : td1.score < td2.score ? 1 : 0;
        });
        for (let k = 0; k < thisTopicDocs.length; k++) {
          const { doc, score } = thisTopicDocs[k];
          fileText += ` - [[${doc}]] [relevance: ${score.toPrecision(2)}]`;
          if (pdfNames.indexOf(doc) > -1)
            fileText += ` ([[${doc}.pdf|PDF]])`;
          fileText += `
`;
        }
      }
      try {
        const file = vault.getAbstractFileByPath(fileName);
        if (file !== void 0 && file !== null)
          vault.modify(file, fileText);
        else
          vault.create(fileName, fileText);
      } catch (err) {
        console.log(err);
      }
    }
    const topicFileName = (0, import_obsidian4.normalizePath)(`${topicDir}/Topic Index.md`);
    let topicFileText = `# Topic Index

`;
    topicFileText += `Results based on scanning files that match file path '*${topicPathPattern}*', search pattern '*${topicSearchPattern}* and tags '*${topicTagPattern}*'.

`;
    topicFileText += `## Topics 

`;
    for (let j = 0; j < numTopics; j++) {
      topicFileText += ` - [[${topicStrings[j]}]]
`;
    }
    topicFileText += `
## Reading List

`;
    topicFileText += `**Note:** to retain this list, copy to another location or check the 'Topic Folder Timestamp' option under 'Settings'.

`;
    const fileNames = files.map((file) => file.basename).sort();
    for (let j = 0; j < fileNames.length; j++) {
      topicFileText += `- [ ] [[${fileNames[j]}]]
`;
    }
    const topicFile = vault.getAbstractFileByPath(topicFileName);
    if (topicFile !== void 0 && topicFile !== null)
      vault.modify(topicFile, topicFileText);
    else
      vault.create(topicFileName, topicFileText);
    statusBarItemEl.setText(`All done!`);
  }
};

// src/main.ts
var TopicLinkingPlugin = class extends import_obsidian5.Plugin {
  async onload() {
    await this.loadSettings();
    const statusBarItemEl = this.addStatusBarItem();
    this.addCommand({
      id: "extract-md-from-pdfs-command",
      name: "Extract Markdown from PDFs",
      hotkeys: [{ modifiers: ["Mod", "Shift"], key: "a" }],
      callback: async () => {
        const { vault } = this.app;
        new PDFContentExtractor().extract(vault, this.settings, statusBarItemEl);
      }
    });
    this.addCommand({
      id: "extract-md-from-bookmarks-command",
      name: "Extract Markdown from Bookmarks",
      callback: async () => {
        const { vault } = this.app;
        new BookmarkContentExtractor().extract(vault, this.settings, statusBarItemEl);
      }
    });
    this.addCommand({
      id: "link-topics-command",
      name: "Link Topics",
      callback: async () => {
        new TopicLinker().link(this.app, this.settings, statusBarItemEl);
      }
    });
    this.addSettingTab(new TopicLinkingSettingTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * to-regex-range <https://github.com/micromatch/to-regex-range>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */
/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*
* ## Notice
*
* The following copyright and license were part of the original implementation available as part of [FreeBSD]{@link https://svnweb.freebsd.org/base/release/9.3.0/lib/msun/src/s_pow.c}. The implementation follows the original, but has been modified for JavaScript.
*
* ```text
* Copyright (C) 2004 by Sun Microsystems, Inc. All rights reserved.
*
* Developed at SunPro, a Sun Microsystems, Inc. business.
* Permission to use, copy, modify, and distribute this
* software is freely granted, provided that this notice
* is preserved.
* ```
*/
/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*
* ## Notice
*
* The original C code and copyright notice are from the [source implementation]{@link http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/CODES/mt19937ar.c}. The implementation has been modified for JavaScript.
*
* ```text
* Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
*
*   1. Redistributions of source code must retain the above copyright
*      notice, this list of conditions and the following disclaimer.
*
*   2. Redistributions in binary form must reproduce the above copyright
*      notice, this list of conditions and the following disclaimer in the
*      documentation and/or other materials provided with the distribution.
*
*   3. The names of its contributors may not be used to endorse or promote
*      products derived from this software without specific prior written
*      permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
* A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
* PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
* PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* ```
*/
/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/**
* @license Apache-2.0
*
* Copyright (c) 2019 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*
* ## Notice
*
* This code is a modification of an existing JavaScript implementation of ther [Porter stemming algorithm]{@link https://tartarus.org/martin/PorterStemmer/}.
*
* ```text
* Release 1 be 'andargor', Jul 2004
* Release 2 (substantially revised) by Christopher McKenzie, Aug 2009
* ```
*/
/**
* @license Apache-2.0
*
* Copyright (c) 2019 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/**
* @license Apache-2.0
*
* Copyright (c) 2021 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL0BzdGRsaWIvbWF0aC1iYXNlLWFzc2VydC1pcy1uYW4vbGliL21haW4uanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvbWF0aC1iYXNlLWFzc2VydC1pcy1uYW4vbGliL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2NvbnN0YW50cy1mbG9hdDY0LXBpbmYvbGliL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL251bWJlci1jdG9yL2xpYi9udW1iZXIuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvbnVtYmVyLWN0b3IvbGliL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2NvbnN0YW50cy1mbG9hdDY0LW5pbmYvbGliL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL21hdGgtYmFzZS1hc3NlcnQtaXMtaW5maW5pdGUvbGliL21haW4uanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvbWF0aC1iYXNlLWFzc2VydC1pcy1pbmZpbml0ZS9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvbWF0aC1iYXNlLXNwZWNpYWwtZmxvb3IvbGliL21haW4uanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvbWF0aC1iYXNlLXNwZWNpYWwtZmxvb3IvbGliL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL21hdGgtYmFzZS1hc3NlcnQtaXMtaW50ZWdlci9saWIvaXNfaW50ZWdlci5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9tYXRoLWJhc2UtYXNzZXJ0LWlzLWludGVnZXIvbGliL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL21hdGgtYmFzZS1hc3NlcnQtaXMtZXZlbi9saWIvaXNfZXZlbi5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9tYXRoLWJhc2UtYXNzZXJ0LWlzLWV2ZW4vbGliL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL21hdGgtYmFzZS1hc3NlcnQtaXMtb2RkL2xpYi9pc19vZGQuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvbWF0aC1iYXNlLWFzc2VydC1pcy1vZGQvbGliL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL21hdGgtYmFzZS1zcGVjaWFsLXNxcnQvbGliL21haW4uanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvbWF0aC1iYXNlLXNwZWNpYWwtc3FydC9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvbWF0aC1iYXNlLXNwZWNpYWwtYWJzL2xpYi9tYWluLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL21hdGgtYmFzZS1zcGVjaWFsLWFicy9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWhhcy1zeW1ib2wtc3VwcG9ydC9saWIvbWFpbi5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9hc3NlcnQtaGFzLXN5bWJvbC1zdXBwb3J0L2xpYi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9hc3NlcnQtaGFzLXRvc3RyaW5ndGFnLXN1cHBvcnQvbGliL21haW4uanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWhhcy10b3N0cmluZ3RhZy1zdXBwb3J0L2xpYi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi91dGlscy1uYXRpdmUtY2xhc3MvbGliL3Rvc3RyaW5nLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL3V0aWxzLW5hdGl2ZS1jbGFzcy9saWIvbmF0aXZlX2NsYXNzLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2Fzc2VydC1oYXMtb3duLXByb3BlcnR5L2xpYi9tYWluLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2Fzc2VydC1oYXMtb3duLXByb3BlcnR5L2xpYi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi91dGlscy1uYXRpdmUtY2xhc3MvbGliL3Rvc3RyaW5ndGFnLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL3V0aWxzLW5hdGl2ZS1jbGFzcy9saWIvcG9seWZpbGwuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvdXRpbHMtbmF0aXZlLWNsYXNzL2xpYi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9hc3NlcnQtaXMtdWludDMyYXJyYXkvbGliL21haW4uanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWlzLXVpbnQzMmFycmF5L2xpYi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9jb25zdGFudHMtdWludDMyLW1heC9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWhhcy11aW50MzJhcnJheS1zdXBwb3J0L2xpYi91aW50MzJhcnJheS5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9hc3NlcnQtaGFzLXVpbnQzMmFycmF5LXN1cHBvcnQvbGliL21haW4uanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWhhcy11aW50MzJhcnJheS1zdXBwb3J0L2xpYi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9hcnJheS11aW50MzIvbGliL3VpbnQzMmFycmF5LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2FycmF5LXVpbnQzMi9saWIvcG9seWZpbGwuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXJyYXktdWludDMyL2xpYi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9hc3NlcnQtaXMtZmxvYXQ2NGFycmF5L2xpYi9tYWluLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2Fzc2VydC1pcy1mbG9hdDY0YXJyYXkvbGliL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2Fzc2VydC1oYXMtZmxvYXQ2NGFycmF5LXN1cHBvcnQvbGliL2Zsb2F0NjRhcnJheS5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9hc3NlcnQtaGFzLWZsb2F0NjRhcnJheS1zdXBwb3J0L2xpYi9tYWluLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2Fzc2VydC1oYXMtZmxvYXQ2NGFycmF5LXN1cHBvcnQvbGliL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2FycmF5LWZsb2F0NjQvbGliL2Zsb2F0NjRhcnJheS5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9hcnJheS1mbG9hdDY0L2xpYi9wb2x5ZmlsbC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9hcnJheS1mbG9hdDY0L2xpYi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9hc3NlcnQtaXMtdWludDhhcnJheS9saWIvbWFpbi5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9hc3NlcnQtaXMtdWludDhhcnJheS9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvY29uc3RhbnRzLXVpbnQ4LW1heC9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWhhcy11aW50OGFycmF5LXN1cHBvcnQvbGliL3VpbnQ4YXJyYXkuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWhhcy11aW50OGFycmF5LXN1cHBvcnQvbGliL21haW4uanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWhhcy11aW50OGFycmF5LXN1cHBvcnQvbGliL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2FycmF5LXVpbnQ4L2xpYi91aW50OGFycmF5LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2FycmF5LXVpbnQ4L2xpYi9wb2x5ZmlsbC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9hcnJheS11aW50OC9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWlzLXVpbnQxNmFycmF5L2xpYi9tYWluLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2Fzc2VydC1pcy11aW50MTZhcnJheS9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvY29uc3RhbnRzLXVpbnQxNi1tYXgvbGliL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2Fzc2VydC1oYXMtdWludDE2YXJyYXktc3VwcG9ydC9saWIvdWludDE2YXJyYXkuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWhhcy11aW50MTZhcnJheS1zdXBwb3J0L2xpYi9tYWluLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2Fzc2VydC1oYXMtdWludDE2YXJyYXktc3VwcG9ydC9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXJyYXktdWludDE2L2xpYi91aW50MTZhcnJheS5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9hcnJheS11aW50MTYvbGliL3BvbHlmaWxsLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2FycmF5LXVpbnQxNi9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWlzLWxpdHRsZS1lbmRpYW4vbGliL2N0b3JzLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2Fzc2VydC1pcy1saXR0bGUtZW5kaWFuL2xpYi9tYWluLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2Fzc2VydC1pcy1saXR0bGUtZW5kaWFuL2xpYi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9udW1iZXItZmxvYXQ2NC1iYXNlLXRvLXdvcmRzL2xpYi9pbmRpY2VzLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL251bWJlci1mbG9hdDY0LWJhc2UtdG8td29yZHMvbGliL3RvX3dvcmRzLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL251bWJlci1mbG9hdDY0LWJhc2UtdG8td29yZHMvbGliL21haW4uanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvbnVtYmVyLWZsb2F0NjQtYmFzZS10by13b3Jkcy9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvbnVtYmVyLWZsb2F0NjQtYmFzZS1zZXQtbG93LXdvcmQvbGliL2xvdy5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9udW1iZXItZmxvYXQ2NC1iYXNlLXNldC1sb3ctd29yZC9saWIvbWFpbi5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9udW1iZXItZmxvYXQ2NC1iYXNlLXNldC1sb3ctd29yZC9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvbnVtYmVyLXVpbnQzMi1iYXNlLXRvLWludDMyL2xpYi9tYWluLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL251bWJlci11aW50MzItYmFzZS10by1pbnQzMi9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvbnVtYmVyLWZsb2F0NjQtYmFzZS1nZXQtaGlnaC13b3JkL2xpYi9oaWdoLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL251bWJlci1mbG9hdDY0LWJhc2UtZ2V0LWhpZ2gtd29yZC9saWIvbWFpbi5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9udW1iZXItZmxvYXQ2NC1iYXNlLWdldC1oaWdoLXdvcmQvbGliL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL251bWJlci1mbG9hdDY0LWJhc2UtZnJvbS13b3Jkcy9saWIvaW5kaWNlcy5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9udW1iZXItZmxvYXQ2NC1iYXNlLWZyb20td29yZHMvbGliL21haW4uanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvbnVtYmVyLWZsb2F0NjQtYmFzZS1mcm9tLXdvcmRzL2xpYi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9tYXRoLWJhc2Utc3BlY2lhbC1jb3B5c2lnbi9saWIvY29weXNpZ24uanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvbWF0aC1iYXNlLXNwZWNpYWwtY29weXNpZ24vbGliL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL21hdGgtYmFzZS1zcGVjaWFsLXBvdy9saWIveF9pc196ZXJvLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL21hdGgtYmFzZS1zcGVjaWFsLXBvdy9saWIveV9pc19odWdlLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL21hdGgtYmFzZS1zcGVjaWFsLXBvdy9saWIveV9pc19pbmZpbml0ZS5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9udW1iZXItZmxvYXQ2NC1iYXNlLXNldC1oaWdoLXdvcmQvbGliL2hpZ2guanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvbnVtYmVyLWZsb2F0NjQtYmFzZS1zZXQtaGlnaC13b3JkL2xpYi9tYWluLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL251bWJlci1mbG9hdDY0LWJhc2Utc2V0LWhpZ2gtd29yZC9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvY29uc3RhbnRzLWZsb2F0NjQtZXhwb25lbnQtYmlhcy9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvbWF0aC1iYXNlLXNwZWNpYWwtcG93L2xpYi9wb2x5dmFsX2wuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvbWF0aC1iYXNlLXNwZWNpYWwtcG93L2xpYi9sb2cyYXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvbWF0aC1iYXNlLXNwZWNpYWwtcG93L2xpYi9wb2x5dmFsX3cuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvbWF0aC1iYXNlLXNwZWNpYWwtcG93L2xpYi9sb2d4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2NvbnN0YW50cy1mbG9hdDY0LW1heC1iYXNlMi1leHBvbmVudC9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvY29uc3RhbnRzLWZsb2F0NjQtbWF4LWJhc2UyLWV4cG9uZW50LXN1Ym5vcm1hbC9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvY29uc3RhbnRzLWZsb2F0NjQtbWluLWJhc2UyLWV4cG9uZW50LXN1Ym5vcm1hbC9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvY29uc3RhbnRzLWZsb2F0NjQtc21hbGxlc3Qtbm9ybWFsL2xpYi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9udW1iZXItZmxvYXQ2NC1iYXNlLW5vcm1hbGl6ZS9saWIvbm9ybWFsaXplLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL251bWJlci1mbG9hdDY0LWJhc2Utbm9ybWFsaXplL2xpYi9tYWluLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL251bWJlci1mbG9hdDY0LWJhc2Utbm9ybWFsaXplL2xpYi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9jb25zdGFudHMtZmxvYXQ2NC1oaWdoLXdvcmQtZXhwb25lbnQtbWFzay9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvbnVtYmVyLWZsb2F0NjQtYmFzZS1leHBvbmVudC9saWIvbWFpbi5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9udW1iZXItZmxvYXQ2NC1iYXNlLWV4cG9uZW50L2xpYi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9tYXRoLWJhc2Utc3BlY2lhbC1sZGV4cC9saWIvbGRleHAuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvbWF0aC1iYXNlLXNwZWNpYWwtbGRleHAvbGliL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2NvbnN0YW50cy1mbG9hdDY0LWxuLXR3by9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvbWF0aC1iYXNlLXNwZWNpYWwtcG93L2xpYi9wb2x5dmFsX3AuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvbWF0aC1iYXNlLXNwZWNpYWwtcG93L2xpYi9wb3cyLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL21hdGgtYmFzZS1zcGVjaWFsLXBvdy9saWIvcG93LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL21hdGgtYmFzZS1zcGVjaWFsLXBvdy9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvbWF0aC1iYXNlLXNwZWNpYWwtcm91bmQvbGliL3JvdW5kLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL21hdGgtYmFzZS1zcGVjaWFsLXJvdW5kL2xpYi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9jb25zdGFudHMtZmxvYXQ2NC1tYXgtc2FmZS1pbnRlZ2VyL2xpYi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9jb25zdGFudHMtZmxvYXQ2NC1tYXgtYmFzZTEwLWV4cG9uZW50L2xpYi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9jb25zdGFudHMtZmxvYXQ2NC1taW4tYmFzZTEwLWV4cG9uZW50L2xpYi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9jb25zdGFudHMtZmxvYXQ2NC1taW4tYmFzZTEwLWV4cG9uZW50LXN1Ym5vcm1hbC9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvbWF0aC1iYXNlLXNwZWNpYWwtcm91bmRuL2xpYi9yb3VuZG4uanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvbWF0aC1iYXNlLXNwZWNpYWwtcm91bmRuL2xpYi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9kYXRhc2V0cy1zdG9wd29yZHMtZW4vbGliL2Jyb3dzZXIuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvdXRpbHMtZGVmaW5lLXByb3BlcnR5L2xpYi9kZWZpbmVfcHJvcGVydHkuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvdXRpbHMtZGVmaW5lLXByb3BlcnR5L2xpYi9oYXNfZGVmaW5lX3Byb3BlcnR5X3N1cHBvcnQuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvdXRpbHMtZGVmaW5lLXByb3BlcnR5L2xpYi9idWlsdGluLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL3V0aWxzLWRlZmluZS1wcm9wZXJ0eS9saWIvcG9seWZpbGwuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvdXRpbHMtZGVmaW5lLXByb3BlcnR5L2xpYi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi91dGlscy1kZWZpbmUtbm9uZW51bWVyYWJsZS1yZWFkLW9ubHktcHJvcGVydHkvbGliL21haW4uanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvdXRpbHMtZGVmaW5lLW5vbmVudW1lcmFibGUtcmVhZC1vbmx5LXByb3BlcnR5L2xpYi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9hc3NlcnQtaXMtbnVtYmVyL2xpYi9wcmltaXRpdmUuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWlzLW51bWJlci9saWIvdG9zdHJpbmcuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWlzLW51bWJlci9saWIvdHJ5MnNlcmlhbGl6ZS5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9hc3NlcnQtaXMtbnVtYmVyL2xpYi9vYmplY3QuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWlzLW51bWJlci9saWIvbWFpbi5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9hc3NlcnQtaXMtbnVtYmVyL2xpYi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9hc3NlcnQtaXMtaW50ZWdlci9saWIvaW50ZWdlci5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9hc3NlcnQtaXMtaW50ZWdlci9saWIvcHJpbWl0aXZlLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2Fzc2VydC1pcy1pbnRlZ2VyL2xpYi9vYmplY3QuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWlzLWludGVnZXIvbGliL21haW4uanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWlzLWludGVnZXIvbGliL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2Fzc2VydC1pcy1ub25uZWdhdGl2ZS1pbnRlZ2VyL2xpYi9wcmltaXRpdmUuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWlzLW5vbm5lZ2F0aXZlLWludGVnZXIvbGliL29iamVjdC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9hc3NlcnQtaXMtbm9ubmVnYXRpdmUtaW50ZWdlci9saWIvbWFpbi5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9hc3NlcnQtaXMtbm9ubmVnYXRpdmUtaW50ZWdlci9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWlzLXBvc2l0aXZlLWludGVnZXIvbGliL3ByaW1pdGl2ZS5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9hc3NlcnQtaXMtcG9zaXRpdmUtaW50ZWdlci9saWIvb2JqZWN0LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2Fzc2VydC1pcy1wb3NpdGl2ZS1pbnRlZ2VyL2xpYi9tYWluLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2Fzc2VydC1pcy1wb3NpdGl2ZS1pbnRlZ2VyL2xpYi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9hc3NlcnQtaXMtYXJyYXkvbGliL21haW4uanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWlzLWFycmF5L2xpYi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9hc3NlcnQtdG9vbHMtYXJyYXktZnVuY3Rpb24vbGliL2FycmF5ZmNuLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2Fzc2VydC10b29scy1hcnJheS1mdW5jdGlvbi9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWlzLXN0cmluZy9saWIvcHJpbWl0aXZlLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2Fzc2VydC1pcy1zdHJpbmcvbGliL3ZhbHVlb2YuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWlzLXN0cmluZy9saWIvdHJ5MnZhbHVlb2YuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWlzLXN0cmluZy9saWIvb2JqZWN0LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2Fzc2VydC1pcy1zdHJpbmcvbGliL21haW4uanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWlzLXN0cmluZy9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWlzLXN0cmluZy1hcnJheS9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvdXRpbHMtZGVmaW5lLXJlYWQtb25seS1wcm9wZXJ0eS9saWIvbWFpbi5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi91dGlscy1kZWZpbmUtcmVhZC1vbmx5LXByb3BlcnR5L2xpYi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9jb25zdGFudHMtYXJyYXktbWF4LXR5cGVkLWFycmF5LWxlbmd0aC9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWlzLWNvbGxlY3Rpb24vbGliL21haW4uanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWlzLWNvbGxlY3Rpb24vbGliL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2Fzc2VydC1pcy1uYW4vbGliL3ByaW1pdGl2ZS5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9hc3NlcnQtaXMtbmFuL2xpYi9vYmplY3QuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWlzLW5hbi9saWIvbWFpbi5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9hc3NlcnQtaXMtbmFuL2xpYi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9hc3NlcnQtY29udGFpbnMvbGliL2NvbnRhaW5zLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2Fzc2VydC1jb250YWlucy9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWlzLWJvb2xlYW4vbGliL3ByaW1pdGl2ZS5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9hc3NlcnQtaXMtYm9vbGVhbi9saWIvdG9zdHJpbmcuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWlzLWJvb2xlYW4vbGliL3RyeTJzZXJpYWxpemUuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWlzLWJvb2xlYW4vbGliL29iamVjdC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9hc3NlcnQtaXMtYm9vbGVhbi9saWIvbWFpbi5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9hc3NlcnQtaXMtYm9vbGVhbi9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvbmxwLXRva2VuaXplL2xpYi90b2tlbml6ZS5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9ubHAtdG9rZW5pemUvbGliL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2Fzc2VydC1pcy1pbnQzMmFycmF5L2xpYi9tYWluLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2Fzc2VydC1pcy1pbnQzMmFycmF5L2xpYi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9jb25zdGFudHMtaW50MzItbWF4L2xpYi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9jb25zdGFudHMtaW50MzItbWluL2xpYi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9hc3NlcnQtaGFzLWludDMyYXJyYXktc3VwcG9ydC9saWIvaW50MzJhcnJheS5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9hc3NlcnQtaGFzLWludDMyYXJyYXktc3VwcG9ydC9saWIvbWFpbi5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9hc3NlcnQtaGFzLWludDMyYXJyYXktc3VwcG9ydC9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXJyYXktaW50MzIvbGliL2ludDMyYXJyYXkuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXJyYXktaW50MzIvbGliL3BvbHlmaWxsLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2FycmF5LWludDMyL2xpYi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9ubHAtbGRhL2xpYi9tYXRyaXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvbmxwLWxkYS9saWIvZ2V0X3RoZXRhcy5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9hc3NlcnQtaXMtcG9zaXRpdmUtbnVtYmVyL2xpYi9wcmltaXRpdmUuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWlzLXBvc2l0aXZlLW51bWJlci9saWIvb2JqZWN0LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2Fzc2VydC1pcy1wb3NpdGl2ZS1udW1iZXIvbGliL21haW4uanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWlzLXBvc2l0aXZlLW51bWJlci9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWlzLW9iamVjdC9saWIvbWFpbi5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9hc3NlcnQtaXMtb2JqZWN0L2xpYi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi91dGlscy10eXBlLW9mL2xpYi9maXh0dXJlcy9yZS5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi91dGlscy1nbG9iYWwvbGliL2NvZGVnZW4uanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvdXRpbHMtZ2xvYmFsL2xpYi9zZWxmLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL3V0aWxzLWdsb2JhbC9saWIvd2luZG93LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL3V0aWxzLWdsb2JhbC9saWIvZ2xvYmFsLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL3V0aWxzLWdsb2JhbC9saWIvbWFpbi5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi91dGlscy1nbG9iYWwvbGliL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL3V0aWxzLXR5cGUtb2YvbGliL2ZpeHR1cmVzL25vZGVsaXN0LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL3V0aWxzLXR5cGUtb2YvbGliL2ZpeHR1cmVzL3R5cGVkYXJyYXkuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvdXRpbHMtdHlwZS1vZi9saWIvY2hlY2suanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvcmVnZXhwLWZ1bmN0aW9uLW5hbWUvbGliL21haW4uanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvcmVnZXhwLWZ1bmN0aW9uLW5hbWUvbGliL3JlZ2V4cC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9yZWdleHAtZnVuY3Rpb24tbmFtZS9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWlzLW9iamVjdC1saWtlL2xpYi9tYWluLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2Fzc2VydC1pcy1vYmplY3QtbGlrZS9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWlzLWJ1ZmZlci9saWIvbWFpbi5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9hc3NlcnQtaXMtYnVmZmVyL2xpYi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi91dGlscy1jb25zdHJ1Y3Rvci1uYW1lL2xpYi9tYWluLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL3V0aWxzLWNvbnN0cnVjdG9yLW5hbWUvbGliL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL3V0aWxzLXR5cGUtb2YvbGliL3R5cGVvZi5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi91dGlscy10eXBlLW9mL2xpYi9wb2x5ZmlsbC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi91dGlscy10eXBlLW9mL2xpYi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9hc3NlcnQtaXMtZnVuY3Rpb24vbGliL21haW4uanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWlzLWZ1bmN0aW9uL2xpYi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi91dGlscy1nZXQtcHJvdG90eXBlLW9mL2xpYi9uYXRpdmUuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvdXRpbHMtZ2V0LXByb3RvdHlwZS1vZi9saWIvcHJvdG8uanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvdXRpbHMtZ2V0LXByb3RvdHlwZS1vZi9saWIvcG9seWZpbGwuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvdXRpbHMtZ2V0LXByb3RvdHlwZS1vZi9saWIvZGV0ZWN0LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL3V0aWxzLWdldC1wcm90b3R5cGUtb2YvbGliL2dldF9wcm90b3R5cGVfb2YuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvdXRpbHMtZ2V0LXByb3RvdHlwZS1vZi9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWlzLXBsYWluLW9iamVjdC9saWIvbWFpbi5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9hc3NlcnQtaXMtcGxhaW4tb2JqZWN0L2xpYi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9ubHAtbGRhL2xpYi92YWxpZGF0ZS5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9ubHAtbGRhL2xpYi9nZXRfcGhpcy5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi91dGlscy1kZWZpbmUtbm9uZW51bWVyYWJsZS1yZWFkLW9ubHktYWNjZXNzb3IvbGliL21haW4uanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvdXRpbHMtZGVmaW5lLW5vbmVudW1lcmFibGUtcmVhZC1vbmx5LWFjY2Vzc29yL2xpYi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi91dGlscy1kZWZpbmUtbm9uZW51bWVyYWJsZS1yZWFkLXdyaXRlLWFjY2Vzc29yL2xpYi9tYWluLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL3V0aWxzLWRlZmluZS1ub25lbnVtZXJhYmxlLXJlYWQtd3JpdGUtYWNjZXNzb3IvbGliL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2Fzc2VydC1oYXMtZnVuY3Rpb24tbmFtZS1zdXBwb3J0L2xpYi9mb28uanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWhhcy1mdW5jdGlvbi1uYW1lLXN1cHBvcnQvbGliL21haW4uanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWhhcy1mdW5jdGlvbi1uYW1lLXN1cHBvcnQvbGliL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL3V0aWxzLWZ1bmN0aW9uLW5hbWUvbGliL2Z1bmN0aW9uX25hbWUuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvdXRpbHMtZnVuY3Rpb24tbmFtZS9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWlzLWludDhhcnJheS9saWIvbWFpbi5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9hc3NlcnQtaXMtaW50OGFycmF5L2xpYi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9jb25zdGFudHMtaW50OC1tYXgvbGliL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2NvbnN0YW50cy1pbnQ4LW1pbi9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWhhcy1pbnQ4YXJyYXktc3VwcG9ydC9saWIvaW50OGFycmF5LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2Fzc2VydC1oYXMtaW50OGFycmF5LXN1cHBvcnQvbGliL21haW4uanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWhhcy1pbnQ4YXJyYXktc3VwcG9ydC9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXJyYXktaW50OC9saWIvaW50OGFycmF5LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2FycmF5LWludDgvbGliL3BvbHlmaWxsLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2FycmF5LWludDgvbGliL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2Fzc2VydC1pcy11aW50OGNsYW1wZWRhcnJheS9saWIvbWFpbi5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9hc3NlcnQtaXMtdWludDhjbGFtcGVkYXJyYXkvbGliL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2Fzc2VydC1oYXMtdWludDhjbGFtcGVkYXJyYXktc3VwcG9ydC9saWIvdWludDhjbGFtcGVkYXJyYXkuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWhhcy11aW50OGNsYW1wZWRhcnJheS1zdXBwb3J0L2xpYi9tYWluLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2Fzc2VydC1oYXMtdWludDhjbGFtcGVkYXJyYXktc3VwcG9ydC9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXJyYXktdWludDhjL2xpYi91aW50OGNsYW1wZWRhcnJheS5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9hcnJheS11aW50OGMvbGliL3BvbHlmaWxsLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2FycmF5LXVpbnQ4Yy9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWlzLWludDE2YXJyYXkvbGliL21haW4uanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWlzLWludDE2YXJyYXkvbGliL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2NvbnN0YW50cy1pbnQxNi1tYXgvbGliL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2NvbnN0YW50cy1pbnQxNi1taW4vbGliL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2Fzc2VydC1oYXMtaW50MTZhcnJheS1zdXBwb3J0L2xpYi9pbnQxNmFycmF5LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2Fzc2VydC1oYXMtaW50MTZhcnJheS1zdXBwb3J0L2xpYi9tYWluLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2Fzc2VydC1oYXMtaW50MTZhcnJheS1zdXBwb3J0L2xpYi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9hcnJheS1pbnQxNi9saWIvaW50MTZhcnJheS5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9hcnJheS1pbnQxNi9saWIvcG9seWZpbGwuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXJyYXktaW50MTYvbGliL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2Fzc2VydC1pcy1mbG9hdDMyYXJyYXkvbGliL21haW4uanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWlzLWZsb2F0MzJhcnJheS9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWhhcy1mbG9hdDMyYXJyYXktc3VwcG9ydC9saWIvZmxvYXQzMmFycmF5LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2Fzc2VydC1oYXMtZmxvYXQzMmFycmF5LXN1cHBvcnQvbGliL21haW4uanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWhhcy1mbG9hdDMyYXJyYXktc3VwcG9ydC9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXJyYXktZmxvYXQzMi9saWIvZmxvYXQzMmFycmF5LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2FycmF5LWZsb2F0MzIvbGliL3BvbHlmaWxsLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2FycmF5LWZsb2F0MzIvbGliL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2Fzc2VydC1pcy10eXBlZC1hcnJheS9saWIvY3RvcnMuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWlzLXR5cGVkLWFycmF5L2xpYi9tYWluLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2Fzc2VydC1pcy10eXBlZC1hcnJheS9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWluc3RhbmNlLW9mL2xpYi9tYWluLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2Fzc2VydC1pbnN0YW5jZS1vZi9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXJyYXktdG8tanNvbi9saWIvY3RvcnMuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXJyYXktdG8tanNvbi9saWIvdHlwZS5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9hcnJheS10by1qc29uL2xpYi90b19qc29uLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2FycmF5LXRvLWpzb24vbGliL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2JsYXMtYmFzZS1nY29weS9saWIvbWFpbi5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9ibGFzLWJhc2UtZ2NvcHkvbGliL25kYXJyYXkuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYmxhcy1iYXNlLWdjb3B5L2xpYi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9yYW5kb20tYmFzZS1taW5zdGQvbGliL3JhbmRfaW50MzIuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvcmFuZG9tLWJhc2UtbWluc3RkL2xpYi9mYWN0b3J5LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL3JhbmRvbS1iYXNlLW1pbnN0ZC9saWIvbWFpbi5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9yYW5kb20tYmFzZS1taW5zdGQvbGliL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL3JhbmRvbS1iYXNlLW1pbnN0ZC1zaHVmZmxlL2xpYi9jcmVhdGVfdGFibGUuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvcmFuZG9tLWJhc2UtbWluc3RkLXNodWZmbGUvbGliL3JhbmRfaW50MzIuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvcmFuZG9tLWJhc2UtbWluc3RkLXNodWZmbGUvbGliL2ZhY3RvcnkuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvcmFuZG9tLWJhc2UtbWluc3RkLXNodWZmbGUvbGliL21haW4uanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvcmFuZG9tLWJhc2UtbWluc3RkLXNodWZmbGUvbGliL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL21hdGgtYmFzZS1hc3NlcnQtaXMtcG9zaXRpdmUtemVyby9saWIvbWFpbi5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9tYXRoLWJhc2UtYXNzZXJ0LWlzLXBvc2l0aXZlLXplcm8vbGliL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL21hdGgtYmFzZS1zcGVjaWFsLW1heC9saWIvbWF4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL21hdGgtYmFzZS1zcGVjaWFsLW1heC9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvbWF0aC1iYXNlLXNwZWNpYWwtdWltdWwvbGliL21haW4uanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvbWF0aC1iYXNlLXNwZWNpYWwtdWltdWwvbGliL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL3JhbmRvbS1iYXNlLW10MTk5MzcvbGliL3JhbmRfdWludDMyLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL3JhbmRvbS1iYXNlLW10MTk5MzcvbGliL2ZhY3RvcnkuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvcmFuZG9tLWJhc2UtbXQxOTkzNy9saWIvbWFpbi5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9yYW5kb20tYmFzZS1tdDE5OTM3L2xpYi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9yYW5kb20tYmFzZS1yYW5kdS9saWIvcHJuZ3MuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvcmFuZG9tLWJhc2UtcmFuZHUvbGliL2ZhY3RvcnkuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvcmFuZG9tLWJhc2UtcmFuZHUvbGliL21haW4uanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvcmFuZG9tLWJhc2UtcmFuZHUvbGliL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL25scC1sZGEvbGliL2luaXQuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvbmxwLWxkYS9saWIvYXZnX21hdHJpeC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9ubHAtbGRhL2xpYi9maXQuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvbmxwLWxkYS9saWIvbGRhLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL25scC1sZGEvbGliL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL3N0cmluZy1lbmRzLXdpdGgvbGliL2VuZHNfd2l0aC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9zdHJpbmctZW5kcy13aXRoL2xpYi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9zdHJpbmctbG93ZXJjYXNlL2xpYi9sb3dlcmNhc2UuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvc3RyaW5nLWxvd2VyY2FzZS9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvdXRpbHMtZXNjYXBlLXJlZ2V4cC1zdHJpbmcvbGliL21haW4uanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvdXRpbHMtZXNjYXBlLXJlZ2V4cC1zdHJpbmcvbGliL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL2Fzc2VydC1pcy1yZWdleHAvbGliL2V4ZWMuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWlzLXJlZ2V4cC9saWIvdHJ5MmV4ZWMuanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvYXNzZXJ0LWlzLXJlZ2V4cC9saWIvbWFpbi5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9hc3NlcnQtaXMtcmVnZXhwL2xpYi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9zdHJpbmctcmVwbGFjZS9saWIvcmVwbGFjZS5qcyIsICJub2RlX21vZHVsZXMvQHN0ZGxpYi9zdHJpbmctcmVwbGFjZS9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BzdGRsaWIvbmxwLXBvcnRlci1zdGVtbWVyL2xpYi9tYWluLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac3RkbGliL25scC1wb3J0ZXItc3RlbW1lci9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL2JyYWNlcy9saWIvdXRpbHMuanMiLCAibm9kZV9tb2R1bGVzL2JyYWNlcy9saWIvc3RyaW5naWZ5LmpzIiwgIm5vZGVfbW9kdWxlcy9pcy1udW1iZXIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL3RvLXJlZ2V4LXJhbmdlL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9maWxsLXJhbmdlL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9icmFjZXMvbGliL2NvbXBpbGUuanMiLCAibm9kZV9tb2R1bGVzL2JyYWNlcy9saWIvZXhwYW5kLmpzIiwgIm5vZGVfbW9kdWxlcy9icmFjZXMvbGliL2NvbnN0YW50cy5qcyIsICJub2RlX21vZHVsZXMvYnJhY2VzL2xpYi9wYXJzZS5qcyIsICJub2RlX21vZHVsZXMvYnJhY2VzL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9waWNvbWF0Y2gvbGliL2NvbnN0YW50cy5qcyIsICJub2RlX21vZHVsZXMvcGljb21hdGNoL2xpYi91dGlscy5qcyIsICJub2RlX21vZHVsZXMvcGljb21hdGNoL2xpYi9zY2FuLmpzIiwgIm5vZGVfbW9kdWxlcy9waWNvbWF0Y2gvbGliL3BhcnNlLmpzIiwgIm5vZGVfbW9kdWxlcy9waWNvbWF0Y2gvbGliL3BpY29tYXRjaC5qcyIsICJub2RlX21vZHVsZXMvcGljb21hdGNoL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9taWNyb21hdGNoL2luZGV4LmpzIiwgInNyYy9tYWluLnRzIiwgInNyYy9zZXR0aW5ncy50cyIsICJzcmMvcGRmLnRzIiwgInNyYy9ib29rbWFyay50cyIsICJzcmMvdG9waWMudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIFRlc3RzIGlmIGEgZG91YmxlLXByZWNpc2lvbiBmbG9hdGluZy1wb2ludCBudW1lcmljIHZhbHVlIGlzIGBOYU5gLlxuKlxuKiBAcGFyYW0ge251bWJlcn0geCAtIHZhbHVlIHRvIHRlc3RcbiogQHJldHVybnMge2Jvb2xlYW59IGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSB2YWx1ZSBpcyBgTmFOYFxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgYm9vbCA9IGlzbmFuKCBOYU4gKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaXNuYW4oIDcuMCApO1xuKiAvLyByZXR1cm5zIGZhbHNlXG4qL1xuZnVuY3Rpb24gaXNuYW4oIHggKSB7XG5cdHJldHVybiAoIHggIT09IHggKTtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNuYW47XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIFRlc3QgaWYgYSBkb3VibGUtcHJlY2lzaW9uIGZsb2F0aW5nLXBvaW50IG51bWVyaWMgdmFsdWUgaXMgYE5hTmAuXG4qXG4qIEBtb2R1bGUgQHN0ZGxpYi9tYXRoLWJhc2UtYXNzZXJ0LWlzLW5hblxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgaXNuYW4gPSByZXF1aXJlKCAnQHN0ZGxpYi9tYXRoLWJhc2UtYXNzZXJ0LWlzLW5hbicgKTtcbipcbiogdmFyIGJvb2wgPSBpc25hbiggTmFOICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKlxuKiBib29sID0gaXNuYW4oIDcuMCApO1xuKiAvLyByZXR1cm5zIGZhbHNlXG4qL1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBpc25hbiA9IHJlcXVpcmUoICcuL21haW4uanMnICk7XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzbmFuO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBEb3VibGUtcHJlY2lzaW9uIGZsb2F0aW5nLXBvaW50IHBvc2l0aXZlIGluZmluaXR5LlxuKlxuKiBAbW9kdWxlIEBzdGRsaWIvY29uc3RhbnRzLWZsb2F0NjQtcGluZlxuKiBAdHlwZSB7bnVtYmVyfVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgRkxPQVQ2NF9QSU5GID0gcmVxdWlyZSggJ0BzdGRsaWIvY29uc3RhbnRzLWZsb2F0NjQtcGluZicgKTtcbiogLy8gcmV0dXJucyBJbmZpbml0eVxuKi9cblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBEb3VibGUtcHJlY2lzaW9uIGZsb2F0aW5nLXBvaW50IHBvc2l0aXZlIGluZmluaXR5LlxuKlxuKiAjIyBOb3Rlc1xuKlxuKiBEb3VibGUtcHJlY2lzaW9uIGZsb2F0aW5nLXBvaW50IHBvc2l0aXZlIGluZmluaXR5IGhhcyB0aGUgYml0IHNlcXVlbmNlXG4qXG4qIGBgYGJpbmFyeXN0cmluZ1xuKiAwIDExMTExMTExMTExIDAwMDAwMDAwMDAwMDAwMDAwMDAwIDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXG4qIGBgYFxuKlxuKiBAY29uc3RhbnRcbiogQHR5cGUge251bWJlcn1cbiogQGRlZmF1bHQgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXG4qIEBzZWUgW0lFRUUgNzU0XXtAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JRUVFXzc1NC0xOTg1fVxuKi9cbnZhciBGTE9BVDY0X1BJTkYgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgc3RkbGliL3JlcXVpcmUtZ2xvYmFsc1xuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBGTE9BVDY0X1BJTkY7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE51bWJlcjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBzdGRsaWIvcmVxdWlyZS1nbG9iYWxzXG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIENvbnN0cnVjdG9yIHdoaWNoIHJldHVybnMgYSBgTnVtYmVyYCBvYmplY3QuXG4qXG4qIEBtb2R1bGUgQHN0ZGxpYi9udW1iZXItY3RvclxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgTnVtYmVyID0gcmVxdWlyZSggJ0BzdGRsaWIvbnVtYmVyLWN0b3InICk7XG4qXG4qIHZhciB2ID0gbmV3IE51bWJlciggMTAuMCApO1xuKiAvLyByZXR1cm5zIDxOdW1iZXI+XG4qL1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBOdW1iZXIgPSByZXF1aXJlKCAnLi9udW1iZXIuanMnICk7XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE51bWJlcjtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogRG91YmxlLXByZWNpc2lvbiBmbG9hdGluZy1wb2ludCBuZWdhdGl2ZSBpbmZpbml0eS5cbipcbiogQG1vZHVsZSBAc3RkbGliL2NvbnN0YW50cy1mbG9hdDY0LW5pbmZcbiogQHR5cGUge251bWJlcn1cbipcbiogQGV4YW1wbGVcbiogdmFyIEZMT0FUNjRfTklORiA9IHJlcXVpcmUoICdAc3RkbGliL2NvbnN0YW50cy1mbG9hdDY0LW5pbmYnICk7XG4qIC8vIHJldHVybnMgLUluZmluaXR5XG4qL1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBOdW1iZXIgPSByZXF1aXJlKCAnQHN0ZGxpYi9udW1iZXItY3RvcicgKTtcblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBEb3VibGUtcHJlY2lzaW9uIGZsb2F0aW5nLXBvaW50IG5lZ2F0aXZlIGluZmluaXR5LlxuKlxuKiAjIyBOb3Rlc1xuKlxuKiBEb3VibGUtcHJlY2lzaW9uIGZsb2F0aW5nLXBvaW50IG5lZ2F0aXZlIGluZmluaXR5IGhhcyB0aGUgYml0IHNlcXVlbmNlXG4qXG4qIGBgYGJpbmFyeXN0cmluZ1xuKiAxIDExMTExMTExMTExIDAwMDAwMDAwMDAwMDAwMDAwMDAwIDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXG4qIGBgYFxuKlxuKiBAY29uc3RhbnRcbiogQHR5cGUge251bWJlcn1cbiogQGRlZmF1bHQgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZXG4qIEBzZWUgW0lFRUUgNzU0XXtAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JRUVFXzc1NC0xOTg1fVxuKi9cbnZhciBGTE9BVDY0X05JTkYgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZMT0FUNjRfTklORjtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBQSU5GID0gcmVxdWlyZSggJ0BzdGRsaWIvY29uc3RhbnRzLWZsb2F0NjQtcGluZicgKTtcbnZhciBOSU5GID0gcmVxdWlyZSggJ0BzdGRsaWIvY29uc3RhbnRzLWZsb2F0NjQtbmluZicgKTtcblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBUZXN0cyBpZiBhIGRvdWJsZS1wcmVjaXNpb24gZmxvYXRpbmctcG9pbnQgbnVtZXJpYyB2YWx1ZSBpcyBpbmZpbml0ZS5cbipcbiogQHBhcmFtIHtudW1iZXJ9IHggLSB2YWx1ZSB0byB0ZXN0XG4qIEByZXR1cm5zIHtib29sZWFufSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgdmFsdWUgaXMgaW5maW5pdGVcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBpc0luZmluaXRlKCBJbmZpbml0eSApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBpc0luZmluaXRlKCAtSW5maW5pdHkgKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaXNJbmZpbml0ZSggNS4wICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBpc0luZmluaXRlKCBOYU4gKTtcbiogLy8gcmV0dXJucyBmYWxzZVxuKi9cbmZ1bmN0aW9uIGlzSW5maW5pdGUoIHggKSB7XG5cdHJldHVybiAoeCA9PT0gUElORiB8fCB4ID09PSBOSU5GKTtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNJbmZpbml0ZTtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogVGVzdCBpZiBhIGRvdWJsZS1wcmVjaXNpb24gZmxvYXRpbmctcG9pbnQgbnVtZXJpYyB2YWx1ZSBpcyBpbmZpbml0ZS5cbipcbiogQG1vZHVsZSBAc3RkbGliL21hdGgtYmFzZS1hc3NlcnQtaXMtaW5maW5pdGVcbipcbiogQGV4YW1wbGVcbiogdmFyIGlzSW5maW5pdGUgPSByZXF1aXJlKCAnQHN0ZGxpYi9tYXRoLWJhc2UtYXNzZXJ0LWlzLWluZmluaXRlJyApO1xuKlxuKiB2YXIgYm9vbCA9IGlzSW5maW5pdGUoIEluZmluaXR5ICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKlxuKiBib29sID0gaXNJbmZpbml0ZSggLUluZmluaXR5ICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKlxuKiBib29sID0gaXNJbmZpbml0ZSggNS4wICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbipcbiogYm9vbCA9IGlzSW5maW5pdGUoIE5hTiApO1xuKiAvLyByZXR1cm5zIGZhbHNlXG4qL1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBpc0luZmluaXRlID0gcmVxdWlyZSggJy4vbWFpbi5qcycgKTtcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNJbmZpbml0ZTtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUT0RPOiBpbXBsZW1lbnRhdGlvbiAoPylcblxuLyoqXG4qIFJvdW5kcyBhIGRvdWJsZS1wcmVjaXNpb24gZmxvYXRpbmctcG9pbnQgbnVtYmVyIHRvd2FyZCBuZWdhdGl2ZSBpbmZpbml0eS5cbipcbiogQHBhcmFtIHtudW1iZXJ9IHggLSBpbnB1dCB2YWx1ZVxuKiBAcmV0dXJucyB7bnVtYmVyfSByb3VuZGVkIHZhbHVlXG4qXG4qIEBleGFtcGxlXG4qIHZhciB2ID0gZmxvb3IoIC00LjIgKTtcbiogLy8gcmV0dXJucyAtNS4wXG4qXG4qIEBleGFtcGxlXG4qIHZhciB2ID0gZmxvb3IoIDkuOTk5OTkgKTtcbiogLy8gcmV0dXJucyA5LjBcbipcbiogQGV4YW1wbGVcbiogdmFyIHYgPSBmbG9vciggMC4wICk7XG4qIC8vIHJldHVybnMgMC4wXG4qXG4qIEBleGFtcGxlXG4qIHZhciB2ID0gZmxvb3IoIE5hTiApO1xuKiAvLyByZXR1cm5zIE5hTlxuKi9cbnZhciBmbG9vciA9IE1hdGguZmxvb3I7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgc3RkbGliL25vLWJ1aWx0aW4tbWF0aFxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBmbG9vcjtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogUm91bmQgYSBkb3VibGUtcHJlY2lzaW9uIGZsb2F0aW5nLXBvaW50IG51bWJlciB0b3dhcmQgbmVnYXRpdmUgaW5maW5pdHkuXG4qXG4qIEBtb2R1bGUgQHN0ZGxpYi9tYXRoLWJhc2Utc3BlY2lhbC1mbG9vclxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgZmxvb3IgPSByZXF1aXJlKCAnQHN0ZGxpYi9tYXRoLWJhc2Utc3BlY2lhbC1mbG9vcicgKTtcbipcbiogdmFyIHYgPSBmbG9vciggLTQuMiApO1xuKiAvLyByZXR1cm5zIC01LjBcbipcbiogdiA9IGZsb29yKCA5Ljk5OTk5ICk7XG4qIC8vIHJldHVybnMgOS4wXG4qXG4qIHYgPSBmbG9vciggMC4wICk7XG4qIC8vIHJldHVybnMgMC4wXG4qXG4qIHYgPSBmbG9vciggTmFOICk7XG4qIC8vIHJldHVybnMgTmFOXG4qL1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBmbG9vciA9IHJlcXVpcmUoICcuL21haW4uanMnICk7XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZsb29yO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGZsb29yID0gcmVxdWlyZSggJ0BzdGRsaWIvbWF0aC1iYXNlLXNwZWNpYWwtZmxvb3InICk7XG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogVGVzdHMgaWYgYSBmaW5pdGUgZG91YmxlLXByZWNpc2lvbiBmbG9hdGluZy1wb2ludCBudW1iZXIgaXMgYW4gaW50ZWdlci5cbipcbiogQHBhcmFtIHtudW1iZXJ9IHggLSB2YWx1ZSB0byB0ZXN0XG4qIEByZXR1cm5zIHtib29sZWFufSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgdmFsdWUgaXMgYW4gaW50ZWdlclxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgYm9vbCA9IGlzSW50ZWdlciggMS4wICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgYm9vbCA9IGlzSW50ZWdlciggMy4xNCApO1xuKiAvLyByZXR1cm5zIGZhbHNlXG4qL1xuZnVuY3Rpb24gaXNJbnRlZ2VyKCB4ICkge1xuXHRyZXR1cm4gKGZsb29yKHgpID09PSB4KTtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNJbnRlZ2VyO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBUZXN0IGlmIGEgZmluaXRlIGRvdWJsZS1wcmVjaXNpb24gZmxvYXRpbmctcG9pbnQgbnVtYmVyIGlzIGFuIGludGVnZXIuXG4qXG4qIEBtb2R1bGUgQHN0ZGxpYi9tYXRoLWJhc2UtYXNzZXJ0LWlzLWludGVnZXJcbipcbiogQGV4YW1wbGVcbiogdmFyIGlzSW50ZWdlciA9IHJlcXVpcmUoICdAc3RkbGliL21hdGgtYmFzZS1hc3NlcnQtaXMtaW50ZWdlcicgKTtcbipcbiogdmFyIGJvb2wgPSBpc0ludGVnZXIoIDEuMCApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogYm9vbCA9IGlzSW50ZWdlciggMy4xNCApO1xuKiAvLyByZXR1cm5zIGZhbHNlXG4qL1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBpc0ludGVnZXIgPSByZXF1aXJlKCAnLi9pc19pbnRlZ2VyLmpzJyApO1xuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBpc0ludGVnZXI7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgaXNJbnRlZ2VyID0gcmVxdWlyZSggJ0BzdGRsaWIvbWF0aC1iYXNlLWFzc2VydC1pcy1pbnRlZ2VyJyApO1xuXG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIFRlc3RzIGlmIGEgZmluaXRlIG51bWVyaWMgdmFsdWUgaXMgYW4gZXZlbiBudW1iZXIuXG4qXG4qIEBwYXJhbSB7bnVtYmVyfSB4IC0gdmFsdWUgdG8gdGVzdFxuKiBAcmV0dXJucyB7Ym9vbGVhbn0gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHZhbHVlIGlzIGFuIGV2ZW4gbnVtYmVyXG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaXNFdmVuKCA1LjAgKTtcbiogLy8gcmV0dXJucyBmYWxzZVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgYm9vbCA9IGlzRXZlbiggLTIuMCApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBpc0V2ZW4oIDAuMCApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBpc0V2ZW4oIE5hTiApO1xuKiAvLyByZXR1cm5zIGZhbHNlXG4qL1xuZnVuY3Rpb24gaXNFdmVuKCB4ICkge1xuXHRyZXR1cm4gaXNJbnRlZ2VyKCB4LzIuMCApO1xufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBpc0V2ZW47XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIFRlc3QgaWYgYSBmaW5pdGUgbnVtZXJpYyB2YWx1ZSBpcyBhbiBldmVuIG51bWJlci5cbipcbiogQG1vZHVsZSBAc3RkbGliL21hdGgtYmFzZS1hc3NlcnQtaXMtZXZlblxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgaXNFdmVuID0gcmVxdWlyZSggJ0BzdGRsaWIvbWF0aC1iYXNlLWFzc2VydC1pcy1ldmVuJyApO1xuKlxuKiB2YXIgYm9vbCA9IGlzRXZlbiggNS4wICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbipcbiogYm9vbCA9IGlzRXZlbiggLTIuMCApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogYm9vbCA9IGlzRXZlbiggMC4wICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKlxuKiBib29sID0gaXNFdmVuKCBOYU4gKTtcbiogLy8gcmV0dXJucyBmYWxzZVxuKi9cblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgaXNFdmVuID0gcmVxdWlyZSggJy4vaXNfZXZlbi5qcycgKTtcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNFdmVuO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGlzRXZlbiA9IHJlcXVpcmUoICdAc3RkbGliL21hdGgtYmFzZS1hc3NlcnQtaXMtZXZlbicgKTtcblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBUZXN0cyBpZiBhIGZpbml0ZSBudW1lcmljIHZhbHVlIGlzIGFuIG9kZCBudW1iZXIuXG4qXG4qIEBwYXJhbSB7bnVtYmVyfSB4IC0gdmFsdWUgdG8gdGVzdFxuKiBAcmV0dXJucyB7Ym9vbGVhbn0gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHZhbHVlIGlzIGFuIG9kZCBudW1iZXJcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBpc09kZCggNS4wICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgYm9vbCA9IGlzT2RkKCAtMi4wICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBpc09kZCggMC4wICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBpc09kZCggTmFOICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbiovXG5mdW5jdGlvbiBpc09kZCggeCApIHtcblx0Ly8gQ2hlY2sgc2lnbiB0byBwcmV2ZW50IG92ZXJmbG93Li4uXG5cdGlmICggeCA+IDAuMCApIHtcblx0XHRyZXR1cm4gaXNFdmVuKCB4LTEuMCApO1xuXHR9XG5cdHJldHVybiBpc0V2ZW4oIHgrMS4wICk7XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2RkO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBUZXN0IGlmIGEgZmluaXRlIG51bWVyaWMgdmFsdWUgaXMgYW4gb2RkIG51bWJlci5cbipcbiogQG1vZHVsZSBAc3RkbGliL21hdGgtYmFzZS1hc3NlcnQtaXMtb2RkXG4qXG4qIEBleGFtcGxlXG4qIHZhciBpc09kZCA9IHJlcXVpcmUoICdAc3RkbGliL21hdGgtYmFzZS1hc3NlcnQtaXMtb2RkJyApO1xuKlxuKiB2YXIgYm9vbCA9IGlzT2RkKCA1LjAgKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qXG4qIGJvb2wgPSBpc09kZCggLTIuMCApO1xuKiAvLyByZXR1cm5zIGZhbHNlXG4qXG4qIGJvb2wgPSBpc09kZCggMC4wICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbipcbiogYm9vbCA9IGlzT2RkKCBOYU4gKTtcbiogLy8gcmV0dXJucyBmYWxzZVxuKi9cblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgaXNPZGQgPSByZXF1aXJlKCAnLi9pc19vZGQuanMnICk7XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2RkO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIENvbXB1dGUgdGhlIHByaW5jaXBhbCBzcXVhcmUgcm9vdCBvZiBhIGRvdWJsZS1wcmVjaXNpb24gZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxuKlxuKiBAdHlwZSB7RnVuY3Rpb259XG4qIEBwYXJhbSB7bnVtYmVyfSB4IC0gaW5wdXQgdmFsdWVcbiogQHJldHVybnMge251bWJlcn0gcHJpbmNpcGFsIHNxdWFyZSByb290XG4qXG4qIEBleGFtcGxlXG4qIHZhciB2ID0gc3FydCggNC4wICk7XG4qIC8vIHJldHVybnMgMi4wXG4qXG4qIHYgPSBzcXJ0KCA5LjAgKTtcbiogLy8gcmV0dXJucyAzLjBcbipcbiogdiA9IHNxcnQoIDAuMCApO1xuKiAvLyByZXR1cm5zIDAuMFxuKlxuKiB2ID0gc3FydCggLTQuMCApO1xuKiAvLyByZXR1cm5zIE5hTlxuKlxuKiB2ID0gc3FydCggTmFOICk7XG4qIC8vIHJldHVybnMgTmFOXG4qL1xudmFyIHNxcnQgPSBNYXRoLnNxcnQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgc3RkbGliL25vLWJ1aWx0aW4tbWF0aFxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBzcXJ0O1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBDb21wdXRlIHRoZSBwcmluY2lwYWwgc3F1YXJlIHJvb3Qgb2YgYSBkb3VibGUtcHJlY2lzaW9uIGZsb2F0aW5nLXBvaW50IG51bWJlci5cbipcbiogQG1vZHVsZSBAc3RkbGliL21hdGgtYmFzZS1zcGVjaWFsLXNxcnRcbipcbiogQGV4YW1wbGVcbiogdmFyIHNxcnQgPSByZXF1aXJlKCAnQHN0ZGxpYi9tYXRoLWJhc2Utc3BlY2lhbC1zcXJ0JyApO1xuKlxuKiB2YXIgdiA9IHNxcnQoIDQuMCApO1xuKiAvLyByZXR1cm5zIDIuMFxuKlxuKiB2ID0gc3FydCggOS4wICk7XG4qIC8vIHJldHVybnMgMy4wXG4qXG4qIHYgPSBzcXJ0KCAwLjAgKTtcbiogLy8gcmV0dXJucyAwLjBcbipcbiogdiA9IHNxcnQoIC00LjAgKTtcbiogLy8gcmV0dXJucyBOYU5cbipcbiogdiA9IHNxcnQoIE5hTiApO1xuKiAvLyByZXR1cm5zIE5hTlxuKi9cblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgc3FydCA9IHJlcXVpcmUoICcuL21haW4uanMnICk7XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNxcnQ7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDIxIFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTUFJTiAvL1xuXG4vKipcbiogQ29tcHV0ZXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIGEgZG91YmxlLXByZWNpc2lvbiBmbG9hdGluZy1wb2ludCBudW1iZXIgYHhgLlxuKlxuKiBAcGFyYW0ge251bWJlcn0geCAtIGlucHV0IHZhbHVlXG4qIEByZXR1cm5zIHtudW1iZXJ9IGFic29sdXRlIHZhbHVlXG4qXG4qIEBleGFtcGxlXG4qIHZhciB2ID0gYWJzKCAtMS4wICk7XG4qIC8vIHJldHVybnMgMS4wXG4qXG4qIEBleGFtcGxlXG4qIHZhciB2ID0gYWJzKCAyLjAgKTtcbiogLy8gcmV0dXJucyAyLjBcbipcbiogQGV4YW1wbGVcbiogdmFyIHYgPSBhYnMoIDAuMCApO1xuKiAvLyByZXR1cm5zIDAuMFxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgdiA9IGFicyggLTAuMCApO1xuKiAvLyByZXR1cm5zIDAuMFxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgdiA9IGFicyggTmFOICk7XG4qIC8vIHJldHVybnMgTmFOXG4qL1xuZnVuY3Rpb24gYWJzKCB4ICkge1xuXHRyZXR1cm4gTWF0aC5hYnMoIHggKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBzdGRsaWIvbm8tYnVpbHRpbi1tYXRoXG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFicztcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogQ29tcHV0ZSBhbiBhYnNvbHV0ZSB2YWx1ZSBvZiBhIGRvdWJsZS1wcmVjaXNpb24gZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxuKlxuKiBAbW9kdWxlIEBzdGRsaWIvbWF0aC1iYXNlLXNwZWNpYWwtYWJzXG4qXG4qIEBleGFtcGxlXG4qIHZhciBhYnMgPSByZXF1aXJlKCAnQHN0ZGxpYi9tYXRoLWJhc2Utc3BlY2lhbC1hYnMnICk7XG4qXG4qIHZhciB2ID0gYWJzKCAtMS4wICk7XG4qIC8vIHJldHVybnMgMS4wXG4qXG4qIHYgPSBhYnMoIDIuMCApO1xuKiAvLyByZXR1cm5zIDIuMFxuKlxuKiB2ID0gYWJzKCAwLjAgKTtcbiogLy8gcmV0dXJucyAwLjBcbipcbiogdiA9IGFicyggLTAuMCApO1xuKiAvLyByZXR1cm5zIDAuMFxuKlxuKiB2ID0gYWJzKCBOYU4gKTtcbiogLy8gcmV0dXJucyBOYU5cbiovXG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGFicyA9IHJlcXVpcmUoICcuL21haW4uanMnICk7XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFicztcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBUZXN0cyBmb3IgbmF0aXZlIGBTeW1ib2xgIHN1cHBvcnQuXG4qXG4qIEByZXR1cm5zIHtib29sZWFufSBib29sZWFuIGluZGljYXRpbmcgaWYgYW4gZW52aXJvbm1lbnQgaGFzIGBTeW1ib2xgIHN1cHBvcnRcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBoYXNTeW1ib2xTdXBwb3J0KCk7XG4qIC8vIHJldHVybnMgPGJvb2xlYW4+XG4qL1xuZnVuY3Rpb24gaGFzU3ltYm9sU3VwcG9ydCgpIHtcblx0cmV0dXJuIChcblx0XHR0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIFN5bWJvbCggJ2ZvbycgKSA9PT0gJ3N5bWJvbCdcblx0KTtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaGFzU3ltYm9sU3VwcG9ydDtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogVGVzdCBmb3IgbmF0aXZlIGBTeW1ib2xgIHN1cHBvcnQuXG4qXG4qIEBtb2R1bGUgQHN0ZGxpYi9hc3NlcnQtaGFzLXN5bWJvbC1zdXBwb3J0XG4qXG4qIEBleGFtcGxlXG4qIHZhciBoYXNTeW1ib2xTdXBwb3J0ID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWhhcy1zeW1ib2wtc3VwcG9ydCcgKTtcbipcbiogdmFyIGJvb2wgPSBoYXNTeW1ib2xTdXBwb3J0KCk7XG4qIC8vIHJldHVybnMgPGJvb2xlYW4+XG4qL1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBoYXNTeW1ib2xTdXBwb3J0ID0gcmVxdWlyZSggJy4vbWFpbi5qcycgKTtcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaGFzU3ltYm9sU3VwcG9ydDtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBoYXNTeW1ib2xzID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWhhcy1zeW1ib2wtc3VwcG9ydCcgKTtcblxuXG4vLyBWQVJJQUJMRVMgLy9cblxudmFyIEZMRyA9IGhhc1N5bWJvbHMoKTtcblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBUZXN0cyBmb3IgbmF0aXZlIGB0b1N0cmluZ1RhZ2Agc3VwcG9ydC5cbipcbiogQHJldHVybnMge2Jvb2xlYW59IGJvb2xlYW4gaW5kaWNhdGluZyBpZiBhbiBlbnZpcm9ubWVudCBoYXMgYHRvU3RyaW5nVGFnYCBzdXBwb3J0XG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaGFzVG9TdHJpbmdUYWdTdXBwb3J0KCk7XG4qIC8vIHJldHVybnMgPGJvb2xlYW4+XG4qL1xuZnVuY3Rpb24gaGFzVG9TdHJpbmdUYWdTdXBwb3J0KCkge1xuXHRyZXR1cm4gKCBGTEcgJiYgdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcgKTtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaGFzVG9TdHJpbmdUYWdTdXBwb3J0O1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBUZXN0IGZvciBuYXRpdmUgYHRvU3RyaW5nVGFnYCBzdXBwb3J0LlxuKlxuKiBAbW9kdWxlIEBzdGRsaWIvYXNzZXJ0LWhhcy10b3N0cmluZ3RhZy1zdXBwb3J0XG4qXG4qIEBleGFtcGxlXG4qIHZhciBoYXNUb1N0cmluZ1RhZ1N1cHBvcnQgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaGFzLXRvc3RyaW5ndGFnLXN1cHBvcnQnICk7XG4qXG4qIHZhciBib29sID0gaGFzVG9TdHJpbmdUYWdTdXBwb3J0KCk7XG4qIC8vIHJldHVybnMgPGJvb2xlYW4+XG4qL1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBoYXNUb1N0cmluZ1RhZ1N1cHBvcnQgPSByZXF1aXJlKCAnLi9tYWluLmpzJyApO1xuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNUb1N0cmluZ1RhZ1N1cHBvcnQ7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTUFJTiAvL1xuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSB0b1N0cjtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciB0b1N0ciA9IHJlcXVpcmUoICcuL3Rvc3RyaW5nLmpzJyApO1xuXG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIFJldHVybnMgYSBzdHJpbmcgdmFsdWUgaW5kaWNhdGluZyBhIHNwZWNpZmljYXRpb24gZGVmaW5lZCBjbGFzc2lmaWNhdGlvbiAodmlhIHRoZSBpbnRlcm5hbCBwcm9wZXJ0eSBgW1tDbGFzc11dYCkgb2YgYW4gb2JqZWN0LlxuKlxuKiBAcGFyYW0geyp9IHYgLSBpbnB1dCB2YWx1ZVxuKiBAcmV0dXJucyB7c3RyaW5nfSBzdHJpbmcgdmFsdWUgaW5kaWNhdGluZyBhIHNwZWNpZmljYXRpb24gZGVmaW5lZCBjbGFzc2lmaWNhdGlvbiBvZiB0aGUgaW5wdXQgdmFsdWVcbipcbiogQGV4YW1wbGVcbiogdmFyIHN0ciA9IG5hdGl2ZUNsYXNzKCAnYScgKTtcbiogLy8gcmV0dXJucyAnW29iamVjdCBTdHJpbmddJ1xuKlxuKiBAZXhhbXBsZVxuKiB2YXIgc3RyID0gbmF0aXZlQ2xhc3MoIDUgKTtcbiogLy8gcmV0dXJucyAnW29iamVjdCBOdW1iZXJdJ1xuKlxuKiBAZXhhbXBsZVxuKiBmdW5jdGlvbiBCZWVwKCkge1xuKiAgICAgcmV0dXJuIHRoaXM7XG4qIH1cbiogdmFyIHN0ciA9IG5hdGl2ZUNsYXNzKCBuZXcgQmVlcCgpICk7XG4qIC8vIHJldHVybnMgJ1tvYmplY3QgT2JqZWN0XSdcbiovXG5mdW5jdGlvbiBuYXRpdmVDbGFzcyggdiApIHtcblx0cmV0dXJuIHRvU3RyLmNhbGwoIHYgKTtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlQ2xhc3M7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gRlVOQ1RJT05TIC8vXG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIFRlc3RzIGlmIGFuIG9iamVjdCBoYXMgYSBzcGVjaWZpZWQgcHJvcGVydHkuXG4qXG4qIEBwYXJhbSB7Kn0gdmFsdWUgLSB2YWx1ZSB0byB0ZXN0XG4qIEBwYXJhbSB7Kn0gcHJvcGVydHkgLSBwcm9wZXJ0eSB0byB0ZXN0XG4qIEByZXR1cm5zIHtib29sZWFufSBib29sZWFuIGluZGljYXRpbmcgaWYgYW4gb2JqZWN0IGhhcyBhIHNwZWNpZmllZCBwcm9wZXJ0eVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgYmVlcCA9IHtcbiogICAgICdib29wJzogdHJ1ZVxuKiB9O1xuKlxuKiB2YXIgYm9vbCA9IGhhc093blByb3AoIGJlZXAsICdib29wJyApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogQGV4YW1wbGVcbiogdmFyIGJlZXAgPSB7XG4qICAgICAnYm9vcCc6IHRydWVcbiogfTtcbipcbiogdmFyIGJvb2wgPSBoYXNPd25Qcm9wKCBiZWVwLCAnYmFwJyApO1xuKiAvLyByZXR1cm5zIGZhbHNlXG4qL1xuZnVuY3Rpb24gaGFzT3duUHJvcCggdmFsdWUsIHByb3BlcnR5ICkge1xuXHRpZiAoXG5cdFx0dmFsdWUgPT09IHZvaWQgMCB8fFxuXHRcdHZhbHVlID09PSBudWxsXG5cdCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRyZXR1cm4gaGFzLmNhbGwoIHZhbHVlLCBwcm9wZXJ0eSApO1xufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNPd25Qcm9wO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBUZXN0IHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIHNwZWNpZmllZCBwcm9wZXJ0eS5cbipcbiogQG1vZHVsZSBAc3RkbGliL2Fzc2VydC1oYXMtb3duLXByb3BlcnR5XG4qXG4qIEBleGFtcGxlXG4qIHZhciBoYXNPd25Qcm9wID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWhhcy1vd24tcHJvcGVydHknICk7XG4qXG4qIHZhciBiZWVwID0ge1xuKiAgICAgJ2Jvb3AnOiB0cnVlXG4qIH07XG4qXG4qIHZhciBib29sID0gaGFzT3duUHJvcCggYmVlcCwgJ2Jvb3AnICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKlxuKiBib29sID0gaGFzT3duUHJvcCggYmVlcCwgJ2JvcCcgKTtcbiogLy8gcmV0dXJucyBmYWxzZVxuKi9cblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgaGFzT3duUHJvcCA9IHJlcXVpcmUoICcuL21haW4uanMnICk7XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc093blByb3A7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTUFJTiAvL1xuXG52YXIgdG9TdHJUYWcgPSAoIHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgKSA/IFN5bWJvbC50b1N0cmluZ1RhZyA6ICcnO1xuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSB0b1N0clRhZztcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBoYXNPd25Qcm9wID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWhhcy1vd24tcHJvcGVydHknICk7XG52YXIgdG9TdHJpbmdUYWcgPSByZXF1aXJlKCAnLi90b3N0cmluZ3RhZy5qcycgKTtcbnZhciB0b1N0ciA9IHJlcXVpcmUoICcuL3Rvc3RyaW5nLmpzJyApO1xuXG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIFJldHVybnMgYSBzdHJpbmcgdmFsdWUgaW5kaWNhdGluZyBhIHNwZWNpZmljYXRpb24gZGVmaW5lZCBjbGFzc2lmaWNhdGlvbiBvZiBhbiBvYmplY3QgaW4gZW52aXJvbm1lbnRzIHN1cHBvcnRpbmcgYFN5bWJvbC50b1N0cmluZ1RhZ2AuXG4qXG4qIEBwYXJhbSB7Kn0gdiAtIGlucHV0IHZhbHVlXG4qIEByZXR1cm5zIHtzdHJpbmd9IHN0cmluZyB2YWx1ZSBpbmRpY2F0aW5nIGEgc3BlY2lmaWNhdGlvbiBkZWZpbmVkIGNsYXNzaWZpY2F0aW9uIG9mIHRoZSBpbnB1dCB2YWx1ZVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgc3RyID0gbmF0aXZlQ2xhc3MoICdhJyApO1xuKiAvLyByZXR1cm5zICdbb2JqZWN0IFN0cmluZ10nXG4qXG4qIEBleGFtcGxlXG4qIHZhciBzdHIgPSBuYXRpdmVDbGFzcyggNSApO1xuKiAvLyByZXR1cm5zICdbb2JqZWN0IE51bWJlcl0nXG4qXG4qIEBleGFtcGxlXG4qIGZ1bmN0aW9uIEJlZXAoKSB7XG4qICAgICByZXR1cm4gdGhpcztcbiogfVxuKiB2YXIgc3RyID0gbmF0aXZlQ2xhc3MoIG5ldyBCZWVwKCkgKTtcbiogLy8gcmV0dXJucyAnW29iamVjdCBPYmplY3RdJ1xuKi9cbmZ1bmN0aW9uIG5hdGl2ZUNsYXNzKCB2ICkge1xuXHR2YXIgaXNPd247XG5cdHZhciB0YWc7XG5cdHZhciBvdXQ7XG5cblx0aWYgKCB2ID09PSBudWxsIHx8IHYgPT09IHZvaWQgMCApIHtcblx0XHRyZXR1cm4gdG9TdHIuY2FsbCggdiApO1xuXHR9XG5cdHRhZyA9IHZbIHRvU3RyaW5nVGFnIF07XG5cdGlzT3duID0gaGFzT3duUHJvcCggdiwgdG9TdHJpbmdUYWcgKTtcblxuXHQvLyBBdHRlbXB0IHRvIG92ZXJyaWRlIHRoZSBgdG9TdHJpbmdUYWdgIHByb3BlcnR5LiBGb3IgYnVpbHQtaW5zIGhhdmluZyBhIGBTeW1ib2wudG9TdHJpbmdUYWdgIHByb3BlcnR5IChlLmcuLCBgSlNPTmAsIGBNYXRoYCwgZXRjKSwgdGhlIGBTeW1ib2wudG9TdHJpbmdUYWdgIHByb3BlcnR5IGlzIHJlYWQtb25seSAoZS5nLiwgLCBzbyB3ZSBuZWVkIHRvIHdyYXAgaW4gYSBgdHJ5L2NhdGNoYC5cblx0dHJ5IHtcblx0XHR2WyB0b1N0cmluZ1RhZyBdID0gdm9pZCAwO1xuXHR9IGNhdGNoICggZXJyICkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cdFx0cmV0dXJuIHRvU3RyLmNhbGwoIHYgKTtcblx0fVxuXHRvdXQgPSB0b1N0ci5jYWxsKCB2ICk7XG5cblx0aWYgKCBpc093biApIHtcblx0XHR2WyB0b1N0cmluZ1RhZyBdID0gdGFnO1xuXHR9IGVsc2Uge1xuXHRcdGRlbGV0ZSB2WyB0b1N0cmluZ1RhZyBdO1xuXHR9XG5cdHJldHVybiBvdXQ7XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUNsYXNzO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBSZXR1cm4gYSBzdHJpbmcgdmFsdWUgaW5kaWNhdGluZyBhIHNwZWNpZmljYXRpb24gZGVmaW5lZCBjbGFzc2lmaWNhdGlvbiBvZiBhbiBvYmplY3QuXG4qXG4qIEBtb2R1bGUgQHN0ZGxpYi91dGlscy1uYXRpdmUtY2xhc3NcbipcbiogQGV4YW1wbGVcbiogdmFyIG5hdGl2ZUNsYXNzID0gcmVxdWlyZSggJ0BzdGRsaWIvdXRpbHMtbmF0aXZlLWNsYXNzJyApO1xuKlxuKiB2YXIgc3RyID0gbmF0aXZlQ2xhc3MoICdhJyApO1xuKiAvLyByZXR1cm5zICdbb2JqZWN0IFN0cmluZ10nXG4qXG4qIHN0ciA9IG5hdGl2ZUNsYXNzKCA1ICk7XG4qIC8vIHJldHVybnMgJ1tvYmplY3QgTnVtYmVyXSdcbipcbiogZnVuY3Rpb24gQmVlcCgpIHtcbiogICAgIHJldHVybiB0aGlzO1xuKiB9XG4qIHN0ciA9IG5hdGl2ZUNsYXNzKCBuZXcgQmVlcCgpICk7XG4qIC8vIHJldHVybnMgJ1tvYmplY3QgT2JqZWN0XSdcbiovXG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGhhc1RvU3RyaW5nVGFnID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWhhcy10b3N0cmluZ3RhZy1zdXBwb3J0JyApO1xudmFyIGJ1aWx0aW4gPSByZXF1aXJlKCAnLi9uYXRpdmVfY2xhc3MuanMnICk7XG52YXIgcG9seWZpbGwgPSByZXF1aXJlKCAnLi9wb2x5ZmlsbC5qcycgKTtcblxuXG4vLyBNQUlOIC8vXG5cbnZhciBuYXRpdmVDbGFzcztcbmlmICggaGFzVG9TdHJpbmdUYWcoKSApIHtcblx0bmF0aXZlQ2xhc3MgPSBwb2x5ZmlsbDtcbn0gZWxzZSB7XG5cdG5hdGl2ZUNsYXNzID0gYnVpbHRpbjtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlQ2xhc3M7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgbmF0aXZlQ2xhc3MgPSByZXF1aXJlKCAnQHN0ZGxpYi91dGlscy1uYXRpdmUtY2xhc3MnICk7XG5cblxuLy8gVkFSSUFCTEVTIC8vXG5cbnZhciBoYXNVaW50MzJBcnJheSA9ICggdHlwZW9mIFVpbnQzMkFycmF5ID09PSAnZnVuY3Rpb24nICk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgc3RkbGliL3JlcXVpcmUtZ2xvYmFsc1xuXG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIFRlc3RzIGlmIGEgdmFsdWUgaXMgYSBVaW50MzJBcnJheS5cbipcbiogQHBhcmFtIHsqfSB2YWx1ZSAtIHZhbHVlIHRvIHRlc3RcbiogQHJldHVybnMge2Jvb2xlYW59IGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHZhbHVlIGlzIGEgVWludDMyQXJyYXlcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBpc1VpbnQzMkFycmF5KCBuZXcgVWludDMyQXJyYXkoIDEwICkgKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaXNVaW50MzJBcnJheSggW10gKTtcbiogLy8gcmV0dXJucyBmYWxzZVxuKi9cbmZ1bmN0aW9uIGlzVWludDMyQXJyYXkoIHZhbHVlICkge1xuXHRyZXR1cm4gKFxuXHRcdCggaGFzVWludDMyQXJyYXkgJiYgdmFsdWUgaW5zdGFuY2VvZiBVaW50MzJBcnJheSApIHx8IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgc3RkbGliL3JlcXVpcmUtZ2xvYmFsc1xuXHRcdG5hdGl2ZUNsYXNzKCB2YWx1ZSApID09PSAnW29iamVjdCBVaW50MzJBcnJheV0nXG5cdCk7XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVWludDMyQXJyYXk7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIFRlc3QgaWYgYSB2YWx1ZSBpcyBhIFVpbnQzMkFycmF5LlxuKlxuKiBAbW9kdWxlIEBzdGRsaWIvYXNzZXJ0LWlzLXVpbnQzMmFycmF5XG4qXG4qIEBleGFtcGxlXG4qIHZhciBpc1VpbnQzMkFycmF5ID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLXVpbnQzMmFycmF5JyApO1xuKlxuKiB2YXIgYm9vbCA9IGlzVWludDMyQXJyYXkoIG5ldyBVaW50MzJBcnJheSggMTAgKSApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogYm9vbCA9IGlzVWludDMyQXJyYXkoIFtdICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbiovXG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGlzVWludDMyQXJyYXkgPSByZXF1aXJlKCAnLi9tYWluLmpzJyApO1xuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBpc1VpbnQzMkFycmF5O1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBNYXhpbXVtIHVuc2lnbmVkIDMyLWJpdCBpbnRlZ2VyLlxuKlxuKiBAbW9kdWxlIEBzdGRsaWIvY29uc3RhbnRzLXVpbnQzMi1tYXhcbiogQHR5cGUge3VpbnRlZ2VyMzJ9XG4qXG4qIEBleGFtcGxlXG4qIHZhciBVSU5UMzJfTUFYID0gcmVxdWlyZSggJ0BzdGRsaWIvY29uc3RhbnRzLXVpbnQzMi1tYXgnICk7XG4qIC8vIHJldHVybnMgNDI5NDk2NzI5NVxuKi9cblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBNYXhpbXVtIHVuc2lnbmVkIDMyLWJpdCBpbnRlZ2VyLlxuKlxuKiAjIyBOb3Rlc1xuKlxuKiBUaGUgbnVtYmVyIGhhcyB0aGUgdmFsdWVcbipcbiogYGBgdGV4XG4qIDJeezMyfSAtIDFcbiogYGBgXG4qXG4qIHdoaWNoIGNvcnJlc3BvbmRzIHRvIHRoZSBiaXQgc2VxdWVuY2VcbipcbiogYGBgYmluYXJ5c3RyaW5nXG4qIDExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExXG4qIGBgYFxuKlxuKiBAY29uc3RhbnRcbiogQHR5cGUge3VpbnRlZ2VyMzJ9XG4qIEBkZWZhdWx0IDQyOTQ5NjcyOTVcbiovXG52YXIgVUlOVDMyX01BWCA9IDQyOTQ5NjcyOTU7XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVJTlQzMl9NQVg7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTUFJTiAvL1xuXG52YXIgbWFpbiA9ICggdHlwZW9mIFVpbnQzMkFycmF5ID09PSAnZnVuY3Rpb24nICkgPyBVaW50MzJBcnJheSA6IG51bGw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgc3RkbGliL3JlcXVpcmUtZ2xvYmFsc1xuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBtYWluO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGlzVWludDMyQXJyYXkgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaXMtdWludDMyYXJyYXknICk7XG52YXIgVUlOVDMyX01BWCA9IHJlcXVpcmUoICdAc3RkbGliL2NvbnN0YW50cy11aW50MzItbWF4JyApO1xudmFyIEdsb2JhbFVpbnQzMkFycmF5ID0gcmVxdWlyZSggJy4vdWludDMyYXJyYXkuanMnICk7XG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogVGVzdHMgZm9yIG5hdGl2ZSBgVWludDMyQXJyYXlgIHN1cHBvcnQuXG4qXG4qIEByZXR1cm5zIHtib29sZWFufSBib29sZWFuIGluZGljYXRpbmcgaWYgYW4gZW52aXJvbm1lbnQgaGFzIGBVaW50MzJBcnJheWAgc3VwcG9ydFxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgYm9vbCA9IGhhc1VpbnQzMkFycmF5U3VwcG9ydCgpO1xuKiAvLyByZXR1cm5zIDxib29sZWFuPlxuKi9cbmZ1bmN0aW9uIGhhc1VpbnQzMkFycmF5U3VwcG9ydCgpIHtcblx0dmFyIGJvb2w7XG5cdHZhciBhcnI7XG5cblx0aWYgKCB0eXBlb2YgR2xvYmFsVWludDMyQXJyYXkgIT09ICdmdW5jdGlvbicgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdC8vIFRlc3QgYmFzaWMgc3VwcG9ydC4uLlxuXHR0cnkge1xuXHRcdGFyciA9IFsgMSwgMy4xNCwgLTMuMTQsIFVJTlQzMl9NQVgrMSwgVUlOVDMyX01BWCsyIF07XG5cdFx0YXJyID0gbmV3IEdsb2JhbFVpbnQzMkFycmF5KCBhcnIgKTtcblx0XHRib29sID0gKFxuXHRcdFx0aXNVaW50MzJBcnJheSggYXJyICkgJiZcblx0XHRcdGFyclsgMCBdID09PSAxICYmXG5cdFx0XHRhcnJbIDEgXSA9PT0gMyAmJiAgICAgICAgICAgIC8vIHRydW5jYXRpb25cblx0XHRcdGFyclsgMiBdID09PSBVSU5UMzJfTUFYLTIgJiYgLy8gdHJ1bmNhdGlvbiBhbmQgd3JhcCBhcm91bmRcblx0XHRcdGFyclsgMyBdID09PSAwICYmICAgICAgICAgICAgLy8gd3JhcCBhcm91bmRcblx0XHRcdGFyclsgNCBdID09PSAxICAgICAgICAgICAgICAgLy8gd3JhcCBhcm91bmRcblx0XHQpO1xuXHR9IGNhdGNoICggZXJyICkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cdFx0Ym9vbCA9IGZhbHNlO1xuXHR9XG5cdHJldHVybiBib29sO1xufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNVaW50MzJBcnJheVN1cHBvcnQ7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIFRlc3QgZm9yIG5hdGl2ZSBgVWludDMyQXJyYXlgIHN1cHBvcnQuXG4qXG4qIEBtb2R1bGUgQHN0ZGxpYi9hc3NlcnQtaGFzLXVpbnQzMmFycmF5LXN1cHBvcnRcbipcbiogQGV4YW1wbGVcbiogdmFyIGhhc1VpbnQzMkFycmF5U3VwcG9ydCA9IHJlcXVpcmUoICdAc3RkbGliL2Fzc2VydC1oYXMtdWludDMyYXJyYXktc3VwcG9ydCcgKTtcbipcbiogdmFyIGJvb2wgPSBoYXNVaW50MzJBcnJheVN1cHBvcnQoKTtcbiogLy8gcmV0dXJucyA8Ym9vbGVhbj5cbiovXG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGhhc1VpbnQzMkFycmF5U3VwcG9ydCA9IHJlcXVpcmUoICcuL21haW4uanMnICk7XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc1VpbnQzMkFycmF5U3VwcG9ydDtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNQUlOIC8vXG5cbnZhciBjdG9yID0gKCB0eXBlb2YgVWludDMyQXJyYXkgPT09ICdmdW5jdGlvbicgKSA/IFVpbnQzMkFycmF5IDogdm9pZCAwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHN0ZGxpYi9yZXF1aXJlLWdsb2JhbHNcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gY3RvcjtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUT0RPOiB3cml0ZSBwb2x5ZmlsbFxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBUeXBlZCBhcnJheSB3aGljaCByZXByZXNlbnRzIGFuIGFycmF5IG9mIDMyLWJpdCB1bnNpZ25lZCBpbnRlZ2VycyBpbiB0aGUgcGxhdGZvcm0gYnl0ZSBvcmRlci5cbipcbiogQHRocm93cyB7RXJyb3J9IG5vdCBpbXBsZW1lbnRlZFxuKi9cbmZ1bmN0aW9uIHBvbHlmaWxsKCkge1xuXHR0aHJvdyBuZXcgRXJyb3IoICdub3QgaW1wbGVtZW50ZWQnICk7XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBvbHlmaWxsO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBUeXBlZCBhcnJheSBjb25zdHJ1Y3RvciB3aGljaCByZXR1cm5zIGEgdHlwZWQgYXJyYXkgcmVwcmVzZW50aW5nIGFuIGFycmF5IG9mIDMyLWJpdCB1bnNpZ25lZCBpbnRlZ2VycyBpbiB0aGUgcGxhdGZvcm0gYnl0ZSBvcmRlci5cbipcbiogQG1vZHVsZSBAc3RkbGliL2FycmF5LXVpbnQzMlxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgY3RvciA9IHJlcXVpcmUoICdAc3RkbGliL2FycmF5LXVpbnQzMicgKTtcbipcbiogdmFyIGFyciA9IG5ldyBjdG9yKCAxMCApO1xuKiAvLyByZXR1cm5zIDxVaW50MzJBcnJheT5cbiovXG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGhhc1VpbnQzMkFycmF5U3VwcG9ydCA9IHJlcXVpcmUoICdAc3RkbGliL2Fzc2VydC1oYXMtdWludDMyYXJyYXktc3VwcG9ydCcgKTtcbnZhciBidWlsdGluID0gcmVxdWlyZSggJy4vdWludDMyYXJyYXkuanMnICk7XG52YXIgcG9seWZpbGwgPSByZXF1aXJlKCAnLi9wb2x5ZmlsbC5qcycgKTtcblxuXG4vLyBNQUlOIC8vXG5cbnZhciBjdG9yO1xuaWYgKCBoYXNVaW50MzJBcnJheVN1cHBvcnQoKSApIHtcblx0Y3RvciA9IGJ1aWx0aW47XG59IGVsc2Uge1xuXHRjdG9yID0gcG9seWZpbGw7XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGN0b3I7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgbmF0aXZlQ2xhc3MgPSByZXF1aXJlKCAnQHN0ZGxpYi91dGlscy1uYXRpdmUtY2xhc3MnICk7XG5cblxuLy8gVkFSSUFCTEVTIC8vXG5cbnZhciBoYXNGbG9hdDY0QXJyYXkgPSAoIHR5cGVvZiBGbG9hdDY0QXJyYXkgPT09ICdmdW5jdGlvbicgKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBzdGRsaWIvcmVxdWlyZS1nbG9iYWxzXG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogVGVzdHMgaWYgYSB2YWx1ZSBpcyBhIEZsb2F0NjRBcnJheS5cbipcbiogQHBhcmFtIHsqfSB2YWx1ZSAtIHZhbHVlIHRvIHRlc3RcbiogQHJldHVybnMge2Jvb2xlYW59IGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHZhbHVlIGlzIGEgRmxvYXQ2NEFycmF5XG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaXNGbG9hdDY0QXJyYXkoIG5ldyBGbG9hdDY0QXJyYXkoIDEwICkgKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaXNGbG9hdDY0QXJyYXkoIFtdICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbiovXG5mdW5jdGlvbiBpc0Zsb2F0NjRBcnJheSggdmFsdWUgKSB7XG5cdHJldHVybiAoXG5cdFx0KCBoYXNGbG9hdDY0QXJyYXkgJiYgdmFsdWUgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkgKSB8fCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHN0ZGxpYi9yZXF1aXJlLWdsb2JhbHNcblx0XHRuYXRpdmVDbGFzcyggdmFsdWUgKSA9PT0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XSdcblx0KTtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNGbG9hdDY0QXJyYXk7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIFRlc3QgaWYgYSB2YWx1ZSBpcyBhIEZsb2F0NjRBcnJheS5cbipcbiogQG1vZHVsZSBAc3RkbGliL2Fzc2VydC1pcy1mbG9hdDY0YXJyYXlcbipcbiogQGV4YW1wbGVcbiogdmFyIGlzRmxvYXQ2NEFycmF5ID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLWZsb2F0NjRhcnJheScgKTtcbipcbiogdmFyIGJvb2wgPSBpc0Zsb2F0NjRBcnJheSggbmV3IEZsb2F0NjRBcnJheSggMTAgKSApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogYm9vbCA9IGlzRmxvYXQ2NEFycmF5KCBbXSApO1xuKiAvLyByZXR1cm5zIGZhbHNlXG4qL1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBpc0Zsb2F0NjRBcnJheSA9IHJlcXVpcmUoICcuL21haW4uanMnICk7XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRmxvYXQ2NEFycmF5O1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1BSU4gLy9cblxudmFyIG1haW4gPSAoIHR5cGVvZiBGbG9hdDY0QXJyYXkgPT09ICdmdW5jdGlvbicgKSA/IEZsb2F0NjRBcnJheSA6IG51bGw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgc3RkbGliL3JlcXVpcmUtZ2xvYmFsc1xuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBtYWluO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGlzRmxvYXQ2NEFycmF5ID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLWZsb2F0NjRhcnJheScgKTtcbnZhciBHbG9iYWxGbG9hdDY0QXJyYXkgPSByZXF1aXJlKCAnLi9mbG9hdDY0YXJyYXkuanMnICk7XG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogVGVzdHMgZm9yIG5hdGl2ZSBgRmxvYXQ2NEFycmF5YCBzdXBwb3J0LlxuKlxuKiBAcmV0dXJucyB7Ym9vbGVhbn0gYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGFuIGVudmlyb25tZW50IGhhcyBgRmxvYXQ2NEFycmF5YCBzdXBwb3J0XG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaGFzRmxvYXQ2NEFycmF5U3VwcG9ydCgpO1xuKiAvLyByZXR1cm5zIDxib29sZWFuPlxuKi9cbmZ1bmN0aW9uIGhhc0Zsb2F0NjRBcnJheVN1cHBvcnQoKSB7XG5cdHZhciBib29sO1xuXHR2YXIgYXJyO1xuXG5cdGlmICggdHlwZW9mIEdsb2JhbEZsb2F0NjRBcnJheSAhPT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0Ly8gVGVzdCBiYXNpYyBzdXBwb3J0Li4uXG5cdHRyeSB7XG5cdFx0YXJyID0gbmV3IEdsb2JhbEZsb2F0NjRBcnJheSggWyAxLjAsIDMuMTQsIC0zLjE0LCBOYU4gXSApO1xuXHRcdGJvb2wgPSAoXG5cdFx0XHRpc0Zsb2F0NjRBcnJheSggYXJyICkgJiZcblx0XHRcdGFyclsgMCBdID09PSAxLjAgJiZcblx0XHRcdGFyclsgMSBdID09PSAzLjE0ICYmXG5cdFx0XHRhcnJbIDIgXSA9PT0gLTMuMTQgJiZcblx0XHRcdGFyclsgMyBdICE9PSBhcnJbIDMgXVxuXHRcdCk7XG5cdH0gY2F0Y2ggKCBlcnIgKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblx0XHRib29sID0gZmFsc2U7XG5cdH1cblx0cmV0dXJuIGJvb2w7XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc0Zsb2F0NjRBcnJheVN1cHBvcnQ7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIFRlc3QgZm9yIG5hdGl2ZSBgRmxvYXQ2NEFycmF5YCBzdXBwb3J0LlxuKlxuKiBAbW9kdWxlIEBzdGRsaWIvYXNzZXJ0LWhhcy1mbG9hdDY0YXJyYXktc3VwcG9ydFxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgaGFzRmxvYXQ2NEFycmF5U3VwcG9ydCA9IHJlcXVpcmUoICdAc3RkbGliL2Fzc2VydC1oYXMtZmxvYXQ2NGFycmF5LXN1cHBvcnQnICk7XG4qXG4qIHZhciBib29sID0gaGFzRmxvYXQ2NEFycmF5U3VwcG9ydCgpO1xuKiAvLyByZXR1cm5zIDxib29sZWFuPlxuKi9cblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgaGFzRmxvYXQ2NEFycmF5U3VwcG9ydCA9IHJlcXVpcmUoICcuL21haW4uanMnICk7XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc0Zsb2F0NjRBcnJheVN1cHBvcnQ7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTUFJTiAvL1xuXG52YXIgY3RvciA9ICggdHlwZW9mIEZsb2F0NjRBcnJheSA9PT0gJ2Z1bmN0aW9uJyApID8gRmxvYXQ2NEFycmF5IDogdm9pZCAwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHN0ZGxpYi9yZXF1aXJlLWdsb2JhbHNcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gY3RvcjtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUT0RPOiB3cml0ZSBwb2x5ZmlsbFxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBUeXBlZCBhcnJheSB3aGljaCByZXByZXNlbnRzIGFuIGFycmF5IG9mIGRvdWJsZS1wcmVjaXNpb24gZmxvYXRpbmctcG9pbnQgbnVtYmVycyBpbiB0aGUgcGxhdGZvcm0gYnl0ZSBvcmRlci5cbipcbiogQHRocm93cyB7RXJyb3J9IG5vdCBpbXBsZW1lbnRlZFxuKi9cbmZ1bmN0aW9uIHBvbHlmaWxsKCkge1xuXHR0aHJvdyBuZXcgRXJyb3IoICdub3QgaW1wbGVtZW50ZWQnICk7XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBvbHlmaWxsO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBUeXBlZCBhcnJheSBjb25zdHJ1Y3RvciB3aGljaCByZXR1cm5zIGEgdHlwZWQgYXJyYXkgcmVwcmVzZW50aW5nIGFuIGFycmF5IG9mIGRvdWJsZS1wcmVjaXNpb24gZmxvYXRpbmctcG9pbnQgbnVtYmVycyBpbiB0aGUgcGxhdGZvcm0gYnl0ZSBvcmRlci5cbipcbiogQG1vZHVsZSBAc3RkbGliL2FycmF5LWZsb2F0NjRcbipcbiogQGV4YW1wbGVcbiogdmFyIGN0b3IgPSByZXF1aXJlKCAnQHN0ZGxpYi9hcnJheS1mbG9hdDY0JyApO1xuKlxuKiB2YXIgYXJyID0gbmV3IGN0b3IoIDEwICk7XG4qIC8vIHJldHVybnMgPEZsb2F0NjRBcnJheT5cbiovXG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGhhc0Zsb2F0NjRBcnJheVN1cHBvcnQgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaGFzLWZsb2F0NjRhcnJheS1zdXBwb3J0JyApO1xudmFyIGJ1aWx0aW4gPSByZXF1aXJlKCAnLi9mbG9hdDY0YXJyYXkuanMnICk7XG52YXIgcG9seWZpbGwgPSByZXF1aXJlKCAnLi9wb2x5ZmlsbC5qcycgKTtcblxuXG4vLyBNQUlOIC8vXG5cbnZhciBjdG9yO1xuaWYgKCBoYXNGbG9hdDY0QXJyYXlTdXBwb3J0KCkgKSB7XG5cdGN0b3IgPSBidWlsdGluO1xufSBlbHNlIHtcblx0Y3RvciA9IHBvbHlmaWxsO1xufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBjdG9yO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIG5hdGl2ZUNsYXNzID0gcmVxdWlyZSggJ0BzdGRsaWIvdXRpbHMtbmF0aXZlLWNsYXNzJyApO1xuXG5cbi8vIFZBUklBQkxFUyAvL1xuXG52YXIgaGFzVWludDhBcnJheSA9ICggdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICdmdW5jdGlvbicgKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBzdGRsaWIvcmVxdWlyZS1nbG9iYWxzXG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogVGVzdHMgaWYgYSB2YWx1ZSBpcyBhIFVpbnQ4QXJyYXkuXG4qXG4qIEBwYXJhbSB7Kn0gdmFsdWUgLSB2YWx1ZSB0byB0ZXN0XG4qIEByZXR1cm5zIHtib29sZWFufSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB2YWx1ZSBpcyBhIFVpbnQ4QXJyYXlcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBpc1VpbnQ4QXJyYXkoIG5ldyBVaW50OEFycmF5KCAxMCApICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgYm9vbCA9IGlzVWludDhBcnJheSggW10gKTtcbiogLy8gcmV0dXJucyBmYWxzZVxuKi9cbmZ1bmN0aW9uIGlzVWludDhBcnJheSggdmFsdWUgKSB7XG5cdHJldHVybiAoXG5cdFx0KCBoYXNVaW50OEFycmF5ICYmIHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSApIHx8IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgc3RkbGliL3JlcXVpcmUtZ2xvYmFsc1xuXHRcdG5hdGl2ZUNsYXNzKCB2YWx1ZSApID09PSAnW29iamVjdCBVaW50OEFycmF5XSdcblx0KTtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNVaW50OEFycmF5O1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBUZXN0IGlmIGEgdmFsdWUgaXMgYSBVaW50OEFycmF5LlxuKlxuKiBAbW9kdWxlIEBzdGRsaWIvYXNzZXJ0LWlzLXVpbnQ4YXJyYXlcbipcbiogQGV4YW1wbGVcbiogdmFyIGlzVWludDhBcnJheSA9IHJlcXVpcmUoICdAc3RkbGliL2Fzc2VydC1pcy11aW50OGFycmF5JyApO1xuKlxuKiB2YXIgYm9vbCA9IGlzVWludDhBcnJheSggbmV3IFVpbnQ4QXJyYXkoIDEwICkgKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qXG4qIGJvb2wgPSBpc1VpbnQ4QXJyYXkoIFtdICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbiovXG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGlzVWludDhBcnJheSA9IHJlcXVpcmUoICcuL21haW4uanMnICk7XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVWludDhBcnJheTtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogTWF4aW11bSB1bnNpZ25lZCA4LWJpdCBpbnRlZ2VyLlxuKlxuKiBAbW9kdWxlIEBzdGRsaWIvY29uc3RhbnRzLXVpbnQ4LW1heFxuKiBAdHlwZSB7aW50ZWdlcjMyfVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgVUlOVDhfTUFYID0gcmVxdWlyZSggJ0BzdGRsaWIvY29uc3RhbnRzLXVpbnQ4LW1heCcgKTtcbiogLy8gcmV0dXJucyAyNTVcbiovXG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogTWF4aW11bSB1bnNpZ25lZCA4LWJpdCBpbnRlZ2VyLlxuKlxuKiAjIyBOb3Rlc1xuKlxuKiBUaGUgbnVtYmVyIGhhcyB0aGUgdmFsdWVcbipcbiogYGBgdGV4XG4qIDJeezh9IC0gMVxuKiBgYGBcbipcbiogd2hpY2ggY29ycmVzcG9uZHMgdG8gdGhlIGJpdCBzZXF1ZW5jZVxuKlxuKiBgYGBiaW5hcnlzdHJpbmdcbiogMTExMTExMTFcbiogYGBgXG4qXG4qIEBjb25zdGFudFxuKiBAdHlwZSB7aW50ZWdlcjMyfVxuKiBAZGVmYXVsdCAyNTVcbiovXG52YXIgVUlOVDhfTUFYID0gMjU1fDA7IC8vIGFzbSB0eXBlIGFubm90YXRpb25cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gVUlOVDhfTUFYO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1BSU4gLy9cblxudmFyIG1haW4gPSAoIHR5cGVvZiBVaW50OEFycmF5ID09PSAnZnVuY3Rpb24nICkgPyBVaW50OEFycmF5IDogbnVsbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBzdGRsaWIvcmVxdWlyZS1nbG9iYWxzXG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1haW47XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgaXNVaW50OEFycmF5ID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLXVpbnQ4YXJyYXknICk7XG52YXIgVUlOVDhfTUFYID0gcmVxdWlyZSggJ0BzdGRsaWIvY29uc3RhbnRzLXVpbnQ4LW1heCcgKTtcbnZhciBHbG9iYWxVaW50OEFycmF5ID0gcmVxdWlyZSggJy4vdWludDhhcnJheS5qcycgKTtcblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBUZXN0cyBmb3IgbmF0aXZlIGBVaW50OEFycmF5YCBzdXBwb3J0LlxuKlxuKiBAcmV0dXJucyB7Ym9vbGVhbn0gYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGFuIGVudmlyb25tZW50IGhhcyBgVWludDhBcnJheWAgc3VwcG9ydFxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgYm9vbCA9IGhhc1VpbnQ4QXJyYXlTdXBwb3J0KCk7XG4qIC8vIHJldHVybnMgPGJvb2xlYW4+XG4qL1xuZnVuY3Rpb24gaGFzVWludDhBcnJheVN1cHBvcnQoKSB7XG5cdHZhciBib29sO1xuXHR2YXIgYXJyO1xuXG5cdGlmICggdHlwZW9mIEdsb2JhbFVpbnQ4QXJyYXkgIT09ICdmdW5jdGlvbicgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdC8vIFRlc3QgYmFzaWMgc3VwcG9ydC4uLlxuXHR0cnkge1xuXHRcdGFyciA9IFsgMSwgMy4xNCwgLTMuMTQsIFVJTlQ4X01BWCsxLCBVSU5UOF9NQVgrMiBdO1xuXHRcdGFyciA9IG5ldyBHbG9iYWxVaW50OEFycmF5KCBhcnIgKTtcblx0XHRib29sID0gKFxuXHRcdFx0aXNVaW50OEFycmF5KCBhcnIgKSAmJlxuXHRcdFx0YXJyWyAwIF0gPT09IDEgJiZcblx0XHRcdGFyclsgMSBdID09PSAzICYmICAgICAgICAgICAvLyB0cnVuY2F0aW9uXG5cdFx0XHRhcnJbIDIgXSA9PT0gVUlOVDhfTUFYLTIgJiYgLy8gdHJ1bmNhdGlvbiBhbmQgd3JhcCBhcm91bmRcblx0XHRcdGFyclsgMyBdID09PSAwICYmICAgICAgICAgICAvLyB3cmFwIGFyb3VuZFxuXHRcdFx0YXJyWyA0IF0gPT09IDEgICAgICAgICAgICAgIC8vIHdyYXAgYXJvdW5kXG5cdFx0KTtcblx0fSBjYXRjaCAoIGVyciApIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXHRcdGJvb2wgPSBmYWxzZTtcblx0fVxuXHRyZXR1cm4gYm9vbDtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaGFzVWludDhBcnJheVN1cHBvcnQ7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIFRlc3QgZm9yIG5hdGl2ZSBgVWludDhBcnJheWAgc3VwcG9ydC5cbipcbiogQG1vZHVsZSBAc3RkbGliL2Fzc2VydC1oYXMtdWludDhhcnJheS1zdXBwb3J0XG4qXG4qIEBleGFtcGxlXG4qIHZhciBoYXNVaW50OEFycmF5U3VwcG9ydCA9IHJlcXVpcmUoICdAc3RkbGliL2Fzc2VydC1oYXMtdWludDhhcnJheS1zdXBwb3J0JyApO1xuKlxuKiB2YXIgYm9vbCA9IGhhc1VpbnQ4QXJyYXlTdXBwb3J0KCk7XG4qIC8vIHJldHVybnMgPGJvb2xlYW4+XG4qL1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBoYXNVaW50OEFycmF5U3VwcG9ydCA9IHJlcXVpcmUoICcuL21haW4uanMnICk7XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc1VpbnQ4QXJyYXlTdXBwb3J0O1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1BSU4gLy9cblxudmFyIGN0b3IgPSAoIHR5cGVvZiBVaW50OEFycmF5ID09PSAnZnVuY3Rpb24nICkgPyBVaW50OEFycmF5IDogdm9pZCAwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHN0ZGxpYi9yZXF1aXJlLWdsb2JhbHNcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gY3RvcjtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUT0RPOiB3cml0ZSBwb2x5ZmlsbFxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBUeXBlZCBhcnJheSB3aGljaCByZXByZXNlbnRzIGFuIGFycmF5IG9mIDgtYml0IHVuc2lnbmVkIGludGVnZXJzIGluIHRoZSBwbGF0Zm9ybSBieXRlIG9yZGVyLlxuKlxuKiBAdGhyb3dzIHtFcnJvcn0gbm90IGltcGxlbWVudGVkXG4qL1xuZnVuY3Rpb24gcG9seWZpbGwoKSB7XG5cdHRocm93IG5ldyBFcnJvciggJ25vdCBpbXBsZW1lbnRlZCcgKTtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gcG9seWZpbGw7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIFR5cGVkIGFycmF5IGNvbnN0cnVjdG9yIHdoaWNoIHJldHVybnMgYSB0eXBlZCBhcnJheSByZXByZXNlbnRpbmcgYW4gYXJyYXkgb2YgOC1iaXQgdW5zaWduZWQgaW50ZWdlcnMgaW4gdGhlIHBsYXRmb3JtIGJ5dGUgb3JkZXIuXG4qXG4qIEBtb2R1bGUgQHN0ZGxpYi9hcnJheS11aW50OFxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgY3RvciA9IHJlcXVpcmUoICdAc3RkbGliL2FycmF5LXVpbnQ4JyApO1xuKlxuKiB2YXIgYXJyID0gbmV3IGN0b3IoIDEwICk7XG4qIC8vIHJldHVybnMgPFVpbnQ4QXJyYXk+XG4qL1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBoYXNVaW50OEFycmF5U3VwcG9ydCA9IHJlcXVpcmUoICdAc3RkbGliL2Fzc2VydC1oYXMtdWludDhhcnJheS1zdXBwb3J0JyApO1xudmFyIGJ1aWx0aW4gPSByZXF1aXJlKCAnLi91aW50OGFycmF5LmpzJyApO1xudmFyIHBvbHlmaWxsID0gcmVxdWlyZSggJy4vcG9seWZpbGwuanMnICk7XG5cblxuLy8gTUFJTiAvL1xuXG52YXIgY3RvcjtcbmlmICggaGFzVWludDhBcnJheVN1cHBvcnQoKSApIHtcblx0Y3RvciA9IGJ1aWx0aW47XG59IGVsc2Uge1xuXHRjdG9yID0gcG9seWZpbGw7XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGN0b3I7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgbmF0aXZlQ2xhc3MgPSByZXF1aXJlKCAnQHN0ZGxpYi91dGlscy1uYXRpdmUtY2xhc3MnICk7XG5cblxuLy8gVkFSSUFCTEVTIC8vXG5cbnZhciBoYXNVaW50MTZBcnJheSA9ICggdHlwZW9mIFVpbnQxNkFycmF5ID09PSAnZnVuY3Rpb24nICk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgc3RkbGliL3JlcXVpcmUtZ2xvYmFsc1xuXG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIFRlc3RzIGlmIGEgdmFsdWUgaXMgYSBVaW50MTZBcnJheS5cbipcbiogQHBhcmFtIHsqfSB2YWx1ZSAtIHZhbHVlIHRvIHRlc3RcbiogQHJldHVybnMge2Jvb2xlYW59IGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHZhbHVlIGlzIGEgVWludDE2QXJyYXlcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBpc1VpbnQxNkFycmF5KCBuZXcgVWludDE2QXJyYXkoIDEwICkgKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaXNVaW50MTZBcnJheSggW10gKTtcbiogLy8gcmV0dXJucyBmYWxzZVxuKi9cbmZ1bmN0aW9uIGlzVWludDE2QXJyYXkoIHZhbHVlICkge1xuXHRyZXR1cm4gKFxuXHRcdCggaGFzVWludDE2QXJyYXkgJiYgdmFsdWUgaW5zdGFuY2VvZiBVaW50MTZBcnJheSApIHx8IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgc3RkbGliL3JlcXVpcmUtZ2xvYmFsc1xuXHRcdG5hdGl2ZUNsYXNzKCB2YWx1ZSApID09PSAnW29iamVjdCBVaW50MTZBcnJheV0nXG5cdCk7XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVWludDE2QXJyYXk7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIFRlc3QgaWYgYSB2YWx1ZSBpcyBhIFVpbnQxNkFycmF5LlxuKlxuKiBAbW9kdWxlIEBzdGRsaWIvYXNzZXJ0LWlzLXVpbnQxNmFycmF5XG4qXG4qIEBleGFtcGxlXG4qIHZhciBpc1VpbnQxNkFycmF5ID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLXVpbnQxNmFycmF5JyApO1xuKlxuKiB2YXIgYm9vbCA9IGlzVWludDE2QXJyYXkoIG5ldyBVaW50MTZBcnJheSggMTAgKSApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogYm9vbCA9IGlzVWludDE2QXJyYXkoIFtdICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbiovXG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGlzVWludDE2QXJyYXkgPSByZXF1aXJlKCAnLi9tYWluLmpzJyApO1xuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBpc1VpbnQxNkFycmF5O1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBNYXhpbXVtIHVuc2lnbmVkIDE2LWJpdCBpbnRlZ2VyLlxuKlxuKiBAbW9kdWxlIEBzdGRsaWIvY29uc3RhbnRzLXVpbnQxNi1tYXhcbiogQHR5cGUge2ludGVnZXIzMn1cbipcbiogQGV4YW1wbGVcbiogdmFyIFVJTlQxNl9NQVggPSByZXF1aXJlKCAnQHN0ZGxpYi9jb25zdGFudHMtdWludDE2LW1heCcgKTtcbiogLy8gcmV0dXJucyA2NTUzNVxuKi9cblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBNYXhpbXVtIHVuc2lnbmVkIDE2LWJpdCBpbnRlZ2VyLlxuKlxuKiAjIyBOb3Rlc1xuKlxuKiBUaGUgbnVtYmVyIGhhcyB0aGUgdmFsdWVcbipcbiogYGBgdGV4XG4qIDJeezE2fSAtIDFcbiogYGBgXG4qXG4qIHdoaWNoIGNvcnJlc3BvbmRzIHRvIHRoZSBiaXQgc2VxdWVuY2VcbipcbiogYGBgYmluYXJ5c3RyaW5nXG4qIDExMTExMTExMTExMTExMTFcbiogYGBgXG4qXG4qIEBjb25zdGFudFxuKiBAdHlwZSB7aW50ZWdlcjMyfVxuKiBAZGVmYXVsdCA2NTUzNVxuKi9cbnZhciBVSU5UMTZfTUFYID0gNjU1MzV8MDsgLy8gYXNtIHR5cGUgYW5ub3RhdGlvblxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBVSU5UMTZfTUFYO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1BSU4gLy9cblxudmFyIG1haW4gPSAoIHR5cGVvZiBVaW50MTZBcnJheSA9PT0gJ2Z1bmN0aW9uJyApID8gVWludDE2QXJyYXkgOiBudWxsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHN0ZGxpYi9yZXF1aXJlLWdsb2JhbHNcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gbWFpbjtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBpc1VpbnQxNkFycmF5ID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLXVpbnQxNmFycmF5JyApO1xudmFyIFVJTlQxNl9NQVggPSByZXF1aXJlKCAnQHN0ZGxpYi9jb25zdGFudHMtdWludDE2LW1heCcgKTtcbnZhciBHbG9iYWxVaW50MTZBcnJheSA9IHJlcXVpcmUoICcuL3VpbnQxNmFycmF5LmpzJyApO1xuXG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIFRlc3RzIGZvciBuYXRpdmUgYFVpbnQxNkFycmF5YCBzdXBwb3J0LlxuKlxuKiBAcmV0dXJucyB7Ym9vbGVhbn0gYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGFuIGVudmlyb25tZW50IGhhcyBgVWludDE2QXJyYXlgIHN1cHBvcnRcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBoYXNVaW50MTZBcnJheVN1cHBvcnQoKTtcbiogLy8gcmV0dXJucyA8Ym9vbGVhbj5cbiovXG5mdW5jdGlvbiBoYXNVaW50MTZBcnJheVN1cHBvcnQoKSB7XG5cdHZhciBib29sO1xuXHR2YXIgYXJyO1xuXG5cdGlmICggdHlwZW9mIEdsb2JhbFVpbnQxNkFycmF5ICE9PSAnZnVuY3Rpb24nICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHQvLyBUZXN0IGJhc2ljIHN1cHBvcnQuLi5cblx0dHJ5IHtcblx0XHRhcnIgPSBbIDEsIDMuMTQsIC0zLjE0LCBVSU5UMTZfTUFYKzEsIFVJTlQxNl9NQVgrMiBdO1xuXHRcdGFyciA9IG5ldyBHbG9iYWxVaW50MTZBcnJheSggYXJyICk7XG5cdFx0Ym9vbCA9IChcblx0XHRcdGlzVWludDE2QXJyYXkoIGFyciApICYmXG5cdFx0XHRhcnJbIDAgXSA9PT0gMSAmJlxuXHRcdFx0YXJyWyAxIF0gPT09IDMgJiYgICAgICAgICAgICAvLyB0cnVuY2F0aW9uXG5cdFx0XHRhcnJbIDIgXSA9PT0gVUlOVDE2X01BWC0yICYmIC8vIHRydW5jYXRpb24gYW5kIHdyYXAgYXJvdW5kXG5cdFx0XHRhcnJbIDMgXSA9PT0gMCAmJiAgICAgICAgICAgIC8vIHdyYXAgYXJvdW5kXG5cdFx0XHRhcnJbIDQgXSA9PT0gMSAgICAgICAgICAgICAgIC8vIHdyYXAgYXJvdW5kXG5cdFx0KTtcblx0fSBjYXRjaCAoIGVyciApIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXHRcdGJvb2wgPSBmYWxzZTtcblx0fVxuXHRyZXR1cm4gYm9vbDtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaGFzVWludDE2QXJyYXlTdXBwb3J0O1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBUZXN0IGZvciBuYXRpdmUgYFVpbnQxNkFycmF5YCBzdXBwb3J0LlxuKlxuKiBAbW9kdWxlIEBzdGRsaWIvYXNzZXJ0LWhhcy11aW50MTZhcnJheS1zdXBwb3J0XG4qXG4qIEBleGFtcGxlXG4qIHZhciBoYXNVaW50MTZBcnJheVN1cHBvcnQgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaGFzLXVpbnQxNmFycmF5LXN1cHBvcnQnICk7XG4qXG4qIHZhciBib29sID0gaGFzVWludDE2QXJyYXlTdXBwb3J0KCk7XG4qIC8vIHJldHVybnMgPGJvb2xlYW4+XG4qL1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBoYXNVaW50MTZBcnJheVN1cHBvcnQgPSByZXF1aXJlKCAnLi9tYWluLmpzJyApO1xuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNVaW50MTZBcnJheVN1cHBvcnQ7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTUFJTiAvL1xuXG52YXIgY3RvciA9ICggdHlwZW9mIFVpbnQxNkFycmF5ID09PSAnZnVuY3Rpb24nICkgPyBVaW50MTZBcnJheSA6IHZvaWQgMDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBzdGRsaWIvcmVxdWlyZS1nbG9iYWxzXG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGN0b3I7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gVE9ETzogd3JpdGUgcG9seWZpbGxcblxuLy8gTUFJTiAvL1xuXG4vKipcbiogVHlwZWQgYXJyYXkgd2hpY2ggcmVwcmVzZW50cyBhbiBhcnJheSBvZiAxNi1iaXQgdW5zaWduZWQgaW50ZWdlcnMgaW4gdGhlIHBsYXRmb3JtIGJ5dGUgb3JkZXIuXG4qXG4qIEB0aHJvd3Mge0Vycm9yfSBub3QgaW1wbGVtZW50ZWRcbiovXG5mdW5jdGlvbiBwb2x5ZmlsbCgpIHtcblx0dGhyb3cgbmV3IEVycm9yKCAnbm90IGltcGxlbWVudGVkJyApO1xufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBwb2x5ZmlsbDtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogVHlwZWQgYXJyYXkgY29uc3RydWN0b3Igd2hpY2ggcmV0dXJucyBhIHR5cGVkIGFycmF5IHJlcHJlc2VudGluZyBhbiBhcnJheSBvZiAxNi1iaXQgdW5zaWduZWQgaW50ZWdlcnMgaW4gdGhlIHBsYXRmb3JtIGJ5dGUgb3JkZXIuXG4qXG4qIEBtb2R1bGUgQHN0ZGxpYi9hcnJheS11aW50MTZcbipcbiogQGV4YW1wbGVcbiogdmFyIGN0b3IgPSByZXF1aXJlKCAnQHN0ZGxpYi9hcnJheS11aW50MTYnICk7XG4qXG4qIHZhciBhcnIgPSBuZXcgY3RvciggMTAgKTtcbiogLy8gcmV0dXJucyA8VWludDE2QXJyYXk+XG4qL1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBoYXNVaW50MTZBcnJheVN1cHBvcnQgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaGFzLXVpbnQxNmFycmF5LXN1cHBvcnQnICk7XG52YXIgYnVpbHRpbiA9IHJlcXVpcmUoICcuL3VpbnQxNmFycmF5LmpzJyApO1xudmFyIHBvbHlmaWxsID0gcmVxdWlyZSggJy4vcG9seWZpbGwuanMnICk7XG5cblxuLy8gTUFJTiAvL1xuXG52YXIgY3RvcjtcbmlmICggaGFzVWludDE2QXJyYXlTdXBwb3J0KCkgKSB7XG5cdGN0b3IgPSBidWlsdGluO1xufSBlbHNlIHtcblx0Y3RvciA9IHBvbHlmaWxsO1xufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBjdG9yO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIFVpbnQ4QXJyYXkgPSByZXF1aXJlKCAnQHN0ZGxpYi9hcnJheS11aW50OCcgKTtcbnZhciBVaW50MTZBcnJheSA9IHJlcXVpcmUoICdAc3RkbGliL2FycmF5LXVpbnQxNicgKTtcblxuXG4vLyBNQUlOIC8vXG5cbnZhciBjdG9ycyA9IHtcblx0J3VpbnQxNic6IFVpbnQxNkFycmF5LFxuXHQndWludDgnOiBVaW50OEFycmF5XG59O1xuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBjdG9ycztcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBjdG9ycyA9IHJlcXVpcmUoICcuL2N0b3JzLmpzJyApO1xuXG5cbi8vIFZBUklBQkxFUyAvL1xuXG52YXIgYm9vbDtcblxuXG4vLyBGVU5DVElPTlMgLy9cblxuLyoqXG4qIFJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgaWYgYW4gZW52aXJvbm1lbnQgaXMgbGl0dGxlIGVuZGlhbi5cbipcbiogQHByaXZhdGVcbiogQHJldHVybnMge2Jvb2xlYW59IGJvb2xlYW4gaW5kaWNhdGluZyBpZiBhbiBlbnZpcm9ubWVudCBpcyBsaXR0bGUgZW5kaWFuXG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaXNMaXR0bGVFbmRpYW4oKTtcbiogLy8gcmV0dXJucyA8Ym9vbGVhbj5cbiovXG5mdW5jdGlvbiBpc0xpdHRsZUVuZGlhbigpIHtcblx0dmFyIHVpbnQxNnZpZXc7XG5cdHZhciB1aW50OHZpZXc7XG5cblx0dWludDE2dmlldyA9IG5ldyBjdG9yc1sgJ3VpbnQxNicgXSggMSApO1xuXG5cdC8qXG5cdCogU2V0IHRoZSB1aW50MTYgdmlldyB0byBhIHZhbHVlIGhhdmluZyBkaXN0aW5ndWlzaGFibGUgbG93ZXIgYW5kIGhpZ2hlciBvcmRlciB3b3Jkcy5cblx0KlxuXHQqIDQ2NjAgPT4gMHgxMjM0ID0+IDB4MTIgMHgzNCA9PiAnMDAwMTAwMTAgMDAxMTAxMDAnID0+ICgweDEyLDB4MzQpID09ICgxOCw1Milcblx0Ki9cblx0dWludDE2dmlld1sgMCBdID0gMHgxMjM0O1xuXG5cdC8vIENyZWF0ZSBhIHVpbnQ4IHZpZXcgb24gdG9wIG9mIHRoZSB1aW50MTYgYnVmZmVyOlxuXHR1aW50OHZpZXcgPSBuZXcgY3RvcnNbICd1aW50OCcgXSggdWludDE2dmlldy5idWZmZXIgKTtcblxuXHQvLyBJZiBsaXR0bGUgZW5kaWFuLCB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYnl0ZSB3aWxsIGJlIGZpcnN0Li4uXG5cdHJldHVybiAoIHVpbnQ4dmlld1sgMCBdID09PSAweDM0ICk7XG59XG5cblxuLy8gTUFJTiAvL1xuXG5ib29sID0gaXNMaXR0bGVFbmRpYW4oKTtcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gYm9vbDtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogUmV0dXJuIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGFuIGVudmlyb25tZW50IGlzIGxpdHRsZSBlbmRpYW4uXG4qXG4qIEBtb2R1bGUgQHN0ZGxpYi9hc3NlcnQtaXMtbGl0dGxlLWVuZGlhblxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgSVNfTElUVExFX0VORElBTiA9IHJlcXVpcmUoICdAc3RkbGliL2Fzc2VydC1pcy1saXR0bGUtZW5kaWFuJyApO1xuKlxuKiB2YXIgYm9vbCA9IElTX0xJVFRMRV9FTkRJQU47XG4qIC8vIHJldHVybnMgPGJvb2xlYW4+XG4qL1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBJU19MSVRUTEVfRU5ESUFOID0gcmVxdWlyZSggJy4vbWFpbi5qcycgKTtcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gSVNfTElUVExFX0VORElBTjtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBpc0xpdHRsZUVuZGlhbiA9IHJlcXVpcmUoICdAc3RkbGliL2Fzc2VydC1pcy1saXR0bGUtZW5kaWFuJyApO1xuXG5cbi8vIE1BSU4gLy9cblxudmFyIGluZGljZXM7XG52YXIgSElHSDtcbnZhciBMT1c7XG5cbmlmICggaXNMaXR0bGVFbmRpYW4gPT09IHRydWUgKSB7XG5cdEhJR0ggPSAxOyAvLyBzZWNvbmQgaW5kZXhcblx0TE9XID0gMDsgLy8gZmlyc3QgaW5kZXhcbn0gZWxzZSB7XG5cdEhJR0ggPSAwOyAvLyBmaXJzdCBpbmRleFxuXHRMT1cgPSAxOyAvLyBzZWNvbmQgaW5kZXhcbn1cbmluZGljZXMgPSB7XG5cdCdISUdIJzogSElHSCxcblx0J0xPVyc6IExPV1xufTtcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaW5kaWNlcztcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBVaW50MzJBcnJheSA9IHJlcXVpcmUoICdAc3RkbGliL2FycmF5LXVpbnQzMicgKTtcbnZhciBGbG9hdDY0QXJyYXkgPSByZXF1aXJlKCAnQHN0ZGxpYi9hcnJheS1mbG9hdDY0JyApO1xudmFyIGluZGljZXMgPSByZXF1aXJlKCAnLi9pbmRpY2VzLmpzJyApO1xuXG5cbi8vIFZBUklBQkxFUyAvL1xuXG52YXIgRkxPQVQ2NF9WSUVXID0gbmV3IEZsb2F0NjRBcnJheSggMSApO1xudmFyIFVJTlQzMl9WSUVXID0gbmV3IFVpbnQzMkFycmF5KCBGTE9BVDY0X1ZJRVcuYnVmZmVyICk7XG5cbnZhciBISUdIID0gaW5kaWNlcy5ISUdIO1xudmFyIExPVyA9IGluZGljZXMuTE9XO1xuXG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIFNwbGl0cyBhIGRvdWJsZS1wcmVjaXNpb24gZmxvYXRpbmctcG9pbnQgbnVtYmVyIGludG8gYSBoaWdoZXIgb3JkZXIgd29yZCAodW5zaWduZWQgMzItYml0IGludGVnZXIpIGFuZCBhIGxvd2VyIG9yZGVyIHdvcmQgKHVuc2lnbmVkIDMyLWJpdCBpbnRlZ2VyKS5cbipcbiogIyMgTm90ZXNcbipcbiogYGBgdGV4dFxuKiBmbG9hdDY0ICg2NCBiaXRzKVxuKiBmIDo9IGZyYWN0aW9uIChzaWduaWZpY2FuZC9tYW50aXNzYSkgKDUyIGJpdHMpXG4qIGUgOj0gZXhwb25lbnQgKDExIGJpdHMpXG4qIHMgOj0gc2lnbiBiaXQgKDEgYml0KVxuKlxuKiB8LS0tLS0tLS0gLS0tLS0tLS0gLS0tLS0tLS0gLS0tLS0tLS0gLS0tLS0tLS0gLS0tLS0tLS0gLS0tLS0tLS0gLS0tLS0tLS18XG4qIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZsb2F0NjQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiogfC0tLS0tLS0tIC0tLS0tLS0tIC0tLS0tLS0tIC0tLS0tLS0tIC0tLS0tLS0tIC0tLS0tLS0tIC0tLS0tLS0tIC0tLS0tLS0tfFxuKiB8ICAgICAgICAgICAgICBVaW50MzIgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgVWludDMyICAgICAgICAgICAgICB8XG4qIHwtLS0tLS0tLSAtLS0tLS0tLSAtLS0tLS0tLSAtLS0tLS0tLSAtLS0tLS0tLSAtLS0tLS0tLSAtLS0tLS0tLSAtLS0tLS0tLXxcbiogYGBgXG4qXG4qIElmIGxpdHRsZSBlbmRpYW4gKG1vcmUgc2lnbmlmaWNhbnQgYml0cyBsYXN0KTpcbipcbiogYGBgdGV4dFxuKiAgICAgICAgICAgICAgICAgICAgICAgICA8LS0gbG93ZXIgICAgICBoaWdoZXIgLS0+XG4qIHwgICBmNyAgICAgICBmNiAgICAgICBmNSAgICAgICBmNCAgICAgICBmMyAgICAgICBmMiAgICBlMiB8IGYxIHxzfCAgZTEgIHxcbiogYGBgXG4qXG4qIElmIGJpZyBlbmRpYW4gKG1vcmUgc2lnbmlmaWNhbnQgYml0cyBmaXJzdCk6XG4qXG4qIGBgYHRleHRcbiogICAgICAgICAgICAgICAgICAgICAgICAgPC0tIGhpZ2hlciAgICAgIGxvd2VyIC0tPlxuKiB8c3wgZTEgICAgZTIgfCBmMSAgICAgZjIgICAgICAgZjMgICAgICAgZjQgICAgICAgZjUgICAgICAgIGY2ICAgICAgZjcgICB8XG4qIGBgYFxuKlxuKiBJbiB3aGljaCBVaW50MzIgY2FuIHdlIGZpbmQgdGhlIGhpZ2hlciBvcmRlciBiaXRzPyBJZiBsaXR0bGUgZW5kaWFuLCB0aGUgc2Vjb25kOyBpZiBiaWcgZW5kaWFuLCB0aGUgZmlyc3QuXG4qXG4qXG4qICMjIFJlZmVyZW5jZXNcbipcbiogLSAgIFtPcGVuIEdyb3VwXVsxXVxuKlxuKiBbMV06IGh0dHA6Ly9wdWJzLm9wZW5ncm91cC5vcmcvb25saW5lcHVicy85NjI5Mzk5L2NoYXAxNC5odG1cbipcbipcbiogQHByaXZhdGVcbiogQHBhcmFtIHsoQXJyYXl8VHlwZWRBcnJheXxPYmplY3QpfSBvdXQgLSBvdXRwdXQgYXJyYXlcbiogQHBhcmFtIHtudW1iZXJ9IHggLSBpbnB1dCB2YWx1ZVxuKiBAcmV0dXJucyB7KEFycmF5fFR5cGVkQXJyYXl8T2JqZWN0KX0gb3V0cHV0IGFycmF5XG4qXG4qIEBleGFtcGxlXG4qIHZhciBVaW50MzJBcnJheSA9IHJlcXVpcmUoICdAc3RkbGliL2FycmF5LXVpbnQzMicgKTtcbipcbiogdmFyIG91dCA9IG5ldyBVaW50MzJBcnJheSggMiApO1xuKlxuKiB2YXIgdyA9IHRvV29yZHMoIG91dCwgMy4xNGUyMDEgKTtcbiogLy8gcmV0dXJucyA8VWludDMyQXJyYXk+WyAxNzc0NDg2MjExLCAyNDc5NTc3MjE4IF1cbipcbiogdmFyIGJvb2wgPSAoIHcgPT09IG91dCApO1xuKiAvLyByZXR1cm5zIHRydWVcbiovXG5mdW5jdGlvbiB0b1dvcmRzKCBvdXQsIHggKSB7XG5cdEZMT0FUNjRfVklFV1sgMCBdID0geDtcblx0b3V0WyAwIF0gPSBVSU5UMzJfVklFV1sgSElHSCBdO1xuXHRvdXRbIDEgXSA9IFVJTlQzMl9WSUVXWyBMT1cgXTtcblx0cmV0dXJuIG91dDtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gdG9Xb3JkcztcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBmY24gPSByZXF1aXJlKCAnLi90b193b3Jkcy5qcycgKTtcblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBTcGxpdHMgYSBkb3VibGUtcHJlY2lzaW9uIGZsb2F0aW5nLXBvaW50IG51bWJlciBpbnRvIGEgaGlnaGVyIG9yZGVyIHdvcmQgKHVuc2lnbmVkIDMyLWJpdCBpbnRlZ2VyKSBhbmQgYSBsb3dlciBvcmRlciB3b3JkICh1bnNpZ25lZCAzMi1iaXQgaW50ZWdlcikuXG4qXG4qIEBwYXJhbSB7KEFycmF5fFR5cGVkQXJyYXl8T2JqZWN0KX0gW291dF0gLSBvdXRwdXQgYXJyYXlcbiogQHBhcmFtIHtudW1iZXJ9IHggLSBpbnB1dCB2YWx1ZVxuKiBAcmV0dXJucyB7KEFycmF5fFR5cGVkQXJyYXl8T2JqZWN0KX0gb3V0cHV0IGFycmF5XG4qXG4qIEBleGFtcGxlXG4qIHZhciB3ID0gdG9Xb3JkcyggMy4xNGUyMDEgKTtcbiogLy8gcmV0dXJucyBbIDE3NzQ0ODYyMTEsIDI0Nzk1NzcyMTggXVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgVWludDMyQXJyYXkgPSByZXF1aXJlKCAnQHN0ZGxpYi9hcnJheS11aW50MzInICk7XG4qXG4qIHZhciBvdXQgPSBuZXcgVWludDMyQXJyYXkoIDIgKTtcbipcbiogdmFyIHcgPSB0b1dvcmRzKCBvdXQsIDMuMTRlMjAxICk7XG4qIC8vIHJldHVybnMgPFVpbnQzMkFycmF5PlsgMTc3NDQ4NjIxMSwgMjQ3OTU3NzIxOCBdXG4qXG4qIHZhciBib29sID0gKCB3ID09PSBvdXQgKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qL1xuZnVuY3Rpb24gdG9Xb3Jkcyggb3V0LCB4ICkge1xuXHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgKSB7XG5cdFx0cmV0dXJuIGZjbiggWyAwLCAwIF0sIG91dCApO1xuXHR9XG5cdHJldHVybiBmY24oIG91dCwgeCApO1xufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSB0b1dvcmRzO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBTcGxpdCBhIGRvdWJsZS1wcmVjaXNpb24gZmxvYXRpbmctcG9pbnQgbnVtYmVyIGludG8gYSBoaWdoZXIgb3JkZXIgd29yZCAodW5zaWduZWQgMzItYml0IGludGVnZXIpIGFuZCBhIGxvd2VyIG9yZGVyIHdvcmQgKHVuc2lnbmVkIDMyLWJpdCBpbnRlZ2VyKS5cbipcbiogQG1vZHVsZSBAc3RkbGliL251bWJlci1mbG9hdDY0LWJhc2UtdG8td29yZHNcbipcbiogQGV4YW1wbGVcbiogdmFyIHRvV29yZHMgPSByZXF1aXJlKCAnQHN0ZGxpYi9udW1iZXItZmxvYXQ2NC1iYXNlLXRvLXdvcmRzJyApO1xuKlxuKiB2YXIgdyA9IHRvV29yZHMoIDMuMTRlMjAxICk7XG4qIC8vIHJldHVybnMgWyAxNzc0NDg2MjExLCAyNDc5NTc3MjE4IF1cbipcbiogQGV4YW1wbGVcbiogdmFyIFVpbnQzMkFycmF5ID0gcmVxdWlyZSggJ0BzdGRsaWIvYXJyYXktdWludDMyJyApO1xuKiB2YXIgdG9Xb3JkcyA9IHJlcXVpcmUoICdAc3RkbGliL251bWJlci1mbG9hdDY0LWJhc2UtdG8td29yZHMnICk7XG4qXG4qIHZhciBvdXQgPSBuZXcgVWludDMyQXJyYXkoIDIgKTtcbipcbiogdmFyIHcgPSB0b1dvcmRzKCBvdXQsIDMuMTRlMjAxICk7XG4qIC8vIHJldHVybnMgPFVpbnQzMkFycmF5PlsgMTc3NDQ4NjIxMSwgMjQ3OTU3NzIxOCBdXG4qXG4qIHZhciBib29sID0gKCB3ID09PSBvdXQgKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qL1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciB0b1dvcmRzID0gcmVxdWlyZSggJy4vbWFpbi5qcycgKTtcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gdG9Xb3JkcztcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBpc0xpdHRsZUVuZGlhbiA9IHJlcXVpcmUoICdAc3RkbGliL2Fzc2VydC1pcy1saXR0bGUtZW5kaWFuJyApO1xuXG5cbi8vIE1BSU4gLy9cblxudmFyIExPVztcbmlmICggaXNMaXR0bGVFbmRpYW4gPT09IHRydWUgKSB7XG5cdExPVyA9IDA7IC8vIGZpcnN0IGluZGV4XG59IGVsc2Uge1xuXHRMT1cgPSAxOyAvLyBzZWNvbmQgaW5kZXhcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gTE9XO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIFVpbnQzMkFycmF5ID0gcmVxdWlyZSggJ0BzdGRsaWIvYXJyYXktdWludDMyJyApO1xudmFyIEZsb2F0NjRBcnJheSA9IHJlcXVpcmUoICdAc3RkbGliL2FycmF5LWZsb2F0NjQnICk7XG52YXIgTE9XID0gcmVxdWlyZSggJy4vbG93LmpzJyApO1xuXG5cbi8vIFZBUklBQkxFUyAvL1xuXG52YXIgRkxPQVQ2NF9WSUVXID0gbmV3IEZsb2F0NjRBcnJheSggMSApO1xudmFyIFVJTlQzMl9WSUVXID0gbmV3IFVpbnQzMkFycmF5KCBGTE9BVDY0X1ZJRVcuYnVmZmVyICk7XG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogU2V0cyB0aGUgbGVzcyBzaWduaWZpY2FudCAzMiBiaXRzIG9mIGEgZG91YmxlLXByZWNpc2lvbiBmbG9hdGluZy1wb2ludCBudW1iZXIuXG4qXG4qICMjIE5vdGVzXG4qXG4qIGBgYHRleHRcbiogZmxvYXQ2NCAoNjQgYml0cylcbiogZiA6PSBmcmFjdGlvbiAoc2lnbmlmaWNhbmQvbWFudGlzc2EpICg1MiBiaXRzKVxuKiBlIDo9IGV4cG9uZW50ICgxMSBiaXRzKVxuKiBzIDo9IHNpZ24gYml0ICgxIGJpdClcbipcbiogfC0tLS0tLS0tIC0tLS0tLS0tIC0tLS0tLS0tIC0tLS0tLS0tIC0tLS0tLS0tIC0tLS0tLS0tIC0tLS0tLS0tIC0tLS0tLS0tfFxuKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGbG9hdDY0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4qIHwtLS0tLS0tLSAtLS0tLS0tLSAtLS0tLS0tLSAtLS0tLS0tLSAtLS0tLS0tLSAtLS0tLS0tLSAtLS0tLS0tLSAtLS0tLS0tLXxcbiogfCAgICAgICAgICAgICAgVWludDMyICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgIFVpbnQzMiAgICAgICAgICAgICAgfFxuKiB8LS0tLS0tLS0gLS0tLS0tLS0gLS0tLS0tLS0gLS0tLS0tLS0gLS0tLS0tLS0gLS0tLS0tLS0gLS0tLS0tLS0gLS0tLS0tLS18XG4qIGBgYFxuKlxuKiBJZiBsaXR0bGUgZW5kaWFuIChtb3JlIHNpZ25pZmljYW50IGJpdHMgbGFzdCk6XG4qXG4qIGBgYHRleHRcbiogICAgICAgICAgICAgICAgICAgICAgICAgPC0tIGxvd2VyICAgICAgaGlnaGVyIC0tPlxuKiB8ICAgZjcgICAgICAgZjYgICAgICAgZjUgICAgICAgZjQgICAgICAgZjMgICAgICAgZjIgICAgZTIgfCBmMSB8c3wgIGUxICB8XG4qIGBgYFxuKlxuKiBJZiBiaWcgZW5kaWFuIChtb3JlIHNpZ25pZmljYW50IGJpdHMgZmlyc3QpOlxuKlxuKiBgYGB0ZXh0XG4qICAgICAgICAgICAgICAgICAgICAgICAgIDwtLSBoaWdoZXIgICAgICBsb3dlciAtLT5cbiogfHN8IGUxICAgIGUyIHwgZjEgICAgIGYyICAgICAgIGYzICAgICAgIGY0ICAgICAgIGY1ICAgICAgICBmNiAgICAgIGY3ICAgfFxuKiBgYGBcbipcbiogSW4gd2hpY2ggVWludDMyIGNhbiB3ZSBmaW5kIHRoZSBsb3dlciBvcmRlciBiaXRzPyBJZiBsaXR0bGUgZW5kaWFuLCB0aGUgZmlyc3Q7IGlmIGJpZyBlbmRpYW4sIHRoZSBzZWNvbmQuXG4qXG4qXG4qICMjIFJlZmVyZW5jZXNcbipcbiogLSAgIFtPcGVuIEdyb3VwXVsxXVxuKlxuKiBbMV06IGh0dHA6Ly9wdWJzLm9wZW5ncm91cC5vcmcvb25saW5lcHVicy85NjI5Mzk5L2NoYXAxNC5odG1cbipcbiogQHBhcmFtIHtudW1iZXJ9IHggLSBkb3VibGVcbiogQHBhcmFtIHt1aW50ZWdlcjMyfSBsb3cgLSB1bnNpZ25lZCAzMi1iaXQgaW50ZWdlciB0byByZXBsYWNlIHRoZSBsb3dlciBvcmRlciB3b3JkIG9mIGB4YFxuKiBAcmV0dXJucyB7bnVtYmVyfSBkb3VibGUgaGF2aW5nIHRoZSBzYW1lIGhpZ2hlciBvcmRlciB3b3JkIGFzIGB4YFxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgbG93ID0gNSA+Pj4gMDsgLy8gPT4gMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDFcbipcbiogdmFyIHggPSAzLjE0ZTIwMTsgLy8gPT4gMCAxMTAxMDAxMTEwMCAwMTAwMTAwMDAwMTAxMTAwMDAxMSAxMDAxMDAxMTExMDAxMDExMDEwMTEwMDAxMDAwMDAxMFxuKlxuKiB2YXIgeSA9IHNldExvd1dvcmQoIHgsIGxvdyApOyAvLyA9PiAwIDExMDEwMDExMTAwIDAxMDAxMDAwMDAxMDExMDAwMDExIDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxXG4qIC8vIHJldHVybnMgMy4xMzk5OTg2NTEzOTQzOTJlKzIwMVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgUElORiA9IHJlcXVpcmUoICdAc3RkbGliL2NvbnN0YW50cy1mbG9hdDY0LXBpbmYnICk7XG4qIHZhciBOSU5GID0gcmVxdWlyZSggJ0BzdGRsaWIvY29uc3RhbnRzLWZsb2F0NjQtbmluZicgKTtcbipcbiogdmFyIGxvdyA9IDEyMzQ1Njc4O1xuKlxuKiB2YXIgeSA9IHNldExvd1dvcmQoIFBJTkYsIGxvdyApO1xuKiAvLyByZXR1cm5zIE5hTlxuKlxuKiB5ID0gc2V0TG93V29yZCggTklORiwgbG93ICk7XG4qIC8vIHJldHVybnMgTmFOXG4qXG4qIHkgPSBzZXRMb3dXb3JkKCBOYU4sIGxvdyApO1xuKiAvLyByZXR1cm5zIE5hTlxuKi9cbmZ1bmN0aW9uIHNldExvd1dvcmQoIHgsIGxvdyApIHtcblx0RkxPQVQ2NF9WSUVXWyAwIF0gPSB4O1xuXHRVSU5UMzJfVklFV1sgTE9XIF0gPSAoIGxvdyA+Pj4gMCApOyAvLyBpZGVudGl0eSBiaXQgc2hpZnQgdG8gZW5zdXJlIGludGVnZXJcblx0cmV0dXJuIEZMT0FUNjRfVklFV1sgMCBdO1xufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRMb3dXb3JkO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBTZXQgdGhlIGxlc3Mgc2lnbmlmaWNhbnQgMzIgYml0cyBvZiBhIGRvdWJsZS1wcmVjaXNpb24gZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxuKlxuKiBAbW9kdWxlIEBzdGRsaWIvbnVtYmVyLWZsb2F0NjQtYmFzZS1zZXQtbG93LXdvcmRcbipcbiogQGV4YW1wbGVcbiogdmFyIHNldExvd1dvcmQgPSByZXF1aXJlKCAnQHN0ZGxpYi9udW1iZXItZmxvYXQ2NC1iYXNlLXNldC1sb3ctd29yZCcgKTtcbipcbiogdmFyIGxvdyA9IDUgPj4+IDA7IC8vID0+IDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxXG4qXG4qIHZhciB4ID0gMy4xNGUyMDE7IC8vID0+IDAgMTEwMTAwMTExMDAgMDEwMDEwMDAwMDEwMTEwMDAwMTEgMTAwMTAwMTExMTAwMTAxMTAxMDExMDAwMTAwMDAwMTBcbipcbiogdmFyIHkgPSBzZXRMb3dXb3JkKCB4LCBsb3cgKTsgLy8gPT4gMCAxMTAxMDAxMTEwMCAwMTAwMTAwMDAwMTAxMTAwMDAxMSAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMVxuKiAvLyByZXR1cm5zIDMuMTM5OTk4NjUxMzk0MzkyZSsyMDFcbipcbiogQGV4YW1wbGVcbiogdmFyIHNldExvd1dvcmQgPSByZXF1aXJlKCAnQHN0ZGxpYi9udW1iZXItZmxvYXQ2NC1iYXNlLXNldC1sb3ctd29yZCcgKTtcbiogdmFyIFBJTkYgPSByZXF1aXJlKCAnQHN0ZGxpYi9jb25zdGFudHMtZmxvYXQ2NC1waW5mJyApO1xuKiB2YXIgTklORiA9IHJlcXVpcmUoICdAc3RkbGliL2NvbnN0YW50cy1mbG9hdDY0LW5pbmYnICk7XG4qXG4qIHZhciBsb3cgPSAxMjM0NTY3ODtcbipcbiogdmFyIHkgPSBzZXRMb3dXb3JkKCBQSU5GLCBsb3cgKTtcbiogLy8gcmV0dXJucyBOYU5cbipcbiogeSA9IHNldExvd1dvcmQoIE5JTkYsIGxvdyApO1xuKiAvLyByZXR1cm5zIE5hTlxuKlxuKiB5ID0gc2V0TG93V29yZCggTmFOLCBsb3cgKTtcbiogLy8gcmV0dXJucyBOYU5cbiovXG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIHNldExvd1dvcmQgPSByZXF1aXJlKCAnLi9tYWluLmpzJyApO1xuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRMb3dXb3JkO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIENvbnZlcnRzIGFuIHVuc2lnbmVkIDMyLWJpdCBpbnRlZ2VyIHRvIGEgc2lnbmVkIDMyLWJpdCBpbnRlZ2VyLlxuKlxuKiBAcGFyYW0ge3VpbnRlZ2VyMzJ9IHggLSB1bnNpZ25lZCAzMi1iaXQgaW50ZWdlclxuKiBAcmV0dXJucyB7aW50ZWdlcjMyfSBzaWduZWQgMzItYml0IGludGVnZXJcbipcbiogQGV4YW1wbGVcbiogdmFyIGZsb2F0NjRUb1VpbnQzMiA9IHJlcXVpcmUoICdAc3RkbGliL251bWJlci1mbG9hdDY0LWJhc2UtdG8tdWludDMyJyApO1xuKiB2YXIgeSA9IHVpbnQzMlRvSW50MzIoIGZsb2F0NjRUb1VpbnQzMiggNDI5NDk2NzI5NSApICk7XG4qIC8vIHJldHVybnMgLTFcbipcbiogQGV4YW1wbGVcbiogdmFyIGZsb2F0NjRUb1VpbnQzMiA9IHJlcXVpcmUoICdAc3RkbGliL251bWJlci1mbG9hdDY0LWJhc2UtdG8tdWludDMyJyApO1xuKiB2YXIgeSA9IHVpbnQzMlRvSW50MzIoIGZsb2F0NjRUb1VpbnQzMiggMyApICk7XG4qIC8vIHJldHVybnMgM1xuKi9cbmZ1bmN0aW9uIHVpbnQzMlRvSW50MzIoIHggKSB7XG5cdC8vIE5PVEU6IHdlIGNvdWxkIGFsc28gdXNlIHR5cGVkLWFycmF5cyB0byBhY2hpZXZlIHRoZSBzYW1lIGVuZC5cblx0cmV0dXJuIHh8MDsgLy8gYXNtIHR5cGUgYW5ub3RhdGlvblxufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSB1aW50MzJUb0ludDMyO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBDb252ZXJ0IGFuIHVuc2lnbmVkIDMyLWJpdCBpbnRlZ2VyIHRvIGEgc2lnbmVkIDMyLWJpdCBpbnRlZ2VyLlxuKlxuKiBAbW9kdWxlIEBzdGRsaWIvbnVtYmVyLXVpbnQzMi1iYXNlLXRvLWludDMyXG4qXG4qIEBleGFtcGxlXG4qIHZhciBmbG9hdDY0VG9VaW50MzIgPSByZXF1aXJlKCAnQHN0ZGxpYi9udW1iZXItZmxvYXQ2NC1iYXNlLXRvLXVpbnQzMicgKTtcbiogdmFyIHVpbnQzMlRvSW50MzIgPSByZXF1aXJlKCAnQHN0ZGxpYi9udW1iZXItdWludDMyLWJhc2UtdG8taW50MzInICk7XG4qXG4qIHZhciB5ID0gdWludDMyVG9JbnQzMiggZmxvYXQ2NFRvVWludDMyKCA0Mjk0OTY3Mjk1ICkgKTtcbiogLy8gcmV0dXJucyAtMVxuKlxuKiB5ID0gdWludDMyVG9JbnQzMiggZmxvYXQ2NFRvVWludDMyKCAzICkgKTtcbiogLy8gcmV0dXJucyAzXG4qL1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciB1aW50MzJUb0ludDMyID0gcmVxdWlyZSggJy4vbWFpbi5qcycgKTtcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gdWludDMyVG9JbnQzMjtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBpc0xpdHRsZUVuZGlhbiA9IHJlcXVpcmUoICdAc3RkbGliL2Fzc2VydC1pcy1saXR0bGUtZW5kaWFuJyApO1xuXG5cbi8vIE1BSU4gLy9cblxudmFyIEhJR0g7XG5pZiAoIGlzTGl0dGxlRW5kaWFuID09PSB0cnVlICkge1xuXHRISUdIID0gMTsgLy8gc2Vjb25kIGluZGV4XG59IGVsc2Uge1xuXHRISUdIID0gMDsgLy8gZmlyc3QgaW5kZXhcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gSElHSDtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBVaW50MzJBcnJheSA9IHJlcXVpcmUoICdAc3RkbGliL2FycmF5LXVpbnQzMicgKTtcbnZhciBGbG9hdDY0QXJyYXkgPSByZXF1aXJlKCAnQHN0ZGxpYi9hcnJheS1mbG9hdDY0JyApO1xudmFyIEhJR0ggPSByZXF1aXJlKCAnLi9oaWdoLmpzJyApO1xuXG5cbi8vIFZBUklBQkxFUyAvL1xuXG52YXIgRkxPQVQ2NF9WSUVXID0gbmV3IEZsb2F0NjRBcnJheSggMSApO1xudmFyIFVJTlQzMl9WSUVXID0gbmV3IFVpbnQzMkFycmF5KCBGTE9BVDY0X1ZJRVcuYnVmZmVyICk7XG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogUmV0dXJucyBhbiB1bnNpZ25lZCAzMi1iaXQgaW50ZWdlciBjb3JyZXNwb25kaW5nIHRvIHRoZSBtb3JlIHNpZ25pZmljYW50IDMyIGJpdHMgb2YgYSBkb3VibGUtcHJlY2lzaW9uIGZsb2F0aW5nLXBvaW50IG51bWJlci5cbipcbiogIyMgTm90ZXNcbipcbiogYGBgdGV4dFxuKiBmbG9hdDY0ICg2NCBiaXRzKVxuKiBmIDo9IGZyYWN0aW9uIChzaWduaWZpY2FuZC9tYW50aXNzYSkgKDUyIGJpdHMpXG4qIGUgOj0gZXhwb25lbnQgKDExIGJpdHMpXG4qIHMgOj0gc2lnbiBiaXQgKDEgYml0KVxuKlxuKiB8LS0tLS0tLS0gLS0tLS0tLS0gLS0tLS0tLS0gLS0tLS0tLS0gLS0tLS0tLS0gLS0tLS0tLS0gLS0tLS0tLS0gLS0tLS0tLS18XG4qIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZsb2F0NjQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiogfC0tLS0tLS0tIC0tLS0tLS0tIC0tLS0tLS0tIC0tLS0tLS0tIC0tLS0tLS0tIC0tLS0tLS0tIC0tLS0tLS0tIC0tLS0tLS0tfFxuKiB8ICAgICAgICAgICAgICBVaW50MzIgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgVWludDMyICAgICAgICAgICAgICB8XG4qIHwtLS0tLS0tLSAtLS0tLS0tLSAtLS0tLS0tLSAtLS0tLS0tLSAtLS0tLS0tLSAtLS0tLS0tLSAtLS0tLS0tLSAtLS0tLS0tLXxcbiogYGBgXG4qXG4qIElmIGxpdHRsZSBlbmRpYW4gKG1vcmUgc2lnbmlmaWNhbnQgYml0cyBsYXN0KTpcbipcbiogYGBgdGV4dFxuKiAgICAgICAgICAgICAgICAgICAgICAgICA8LS0gbG93ZXIgICAgICBoaWdoZXIgLS0+XG4qIHwgICBmNyAgICAgICBmNiAgICAgICBmNSAgICAgICBmNCAgICAgICBmMyAgICAgICBmMiAgICBlMiB8IGYxIHxzfCAgZTEgIHxcbiogYGBgXG4qXG4qIElmIGJpZyBlbmRpYW4gKG1vcmUgc2lnbmlmaWNhbnQgYml0cyBmaXJzdCk6XG4qXG4qIGBgYHRleHRcbiogICAgICAgICAgICAgICAgICAgICAgICAgPC0tIGhpZ2hlciAgICAgIGxvd2VyIC0tPlxuKiB8c3wgZTEgICAgZTIgfCBmMSAgICAgZjIgICAgICAgZjMgICAgICAgZjQgICAgICAgZjUgICAgICAgIGY2ICAgICAgZjcgICB8XG4qIGBgYFxuKlxuKiBJbiB3aGljaCBVaW50MzIgY2FuIHdlIGZpbmQgdGhlIGhpZ2hlciBvcmRlciBiaXRzPyBJZiBsaXR0bGUgZW5kaWFuLCB0aGUgc2Vjb25kOyBpZiBiaWcgZW5kaWFuLCB0aGUgZmlyc3QuXG4qXG4qXG4qICMjIFJlZmVyZW5jZXNcbipcbiogLSAgIFtPcGVuIEdyb3VwXVsxXVxuKlxuKiBbMV06IGh0dHA6Ly9wdWJzLm9wZW5ncm91cC5vcmcvb25saW5lcHVicy85NjI5Mzk5L2NoYXAxNC5odG1cbipcbiogQHBhcmFtIHtudW1iZXJ9IHggLSBpbnB1dCB2YWx1ZVxuKiBAcmV0dXJucyB7dWludGVnZXIzMn0gaGlnaGVyIG9yZGVyIHdvcmRcbipcbiogQGV4YW1wbGVcbiogdmFyIHcgPSBnZXRIaWdoV29yZCggMy4xNGUyMDEgKTsgLy8gPT4gMDExMDEwMDExMTAwMDEwMDEwMDAwMDEwMTEwMDAwMTFcbiogLy8gcmV0dXJucyAxNzc0NDg2MjExXG4qL1xuZnVuY3Rpb24gZ2V0SGlnaFdvcmQoIHggKSB7XG5cdEZMT0FUNjRfVklFV1sgMCBdID0geDtcblx0cmV0dXJuIFVJTlQzMl9WSUVXWyBISUdIIF07XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEhpZ2hXb3JkO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBSZXR1cm4gYW4gdW5zaWduZWQgMzItYml0IGludGVnZXIgY29ycmVzcG9uZGluZyB0byB0aGUgbW9yZSBzaWduaWZpY2FudCAzMiBiaXRzIG9mIGEgZG91YmxlLXByZWNpc2lvbiBmbG9hdGluZy1wb2ludCBudW1iZXIuXG4qXG4qIEBtb2R1bGUgQHN0ZGxpYi9udW1iZXItZmxvYXQ2NC1iYXNlLWdldC1oaWdoLXdvcmRcbipcbiogQGV4YW1wbGVcbiogdmFyIGdldEhpZ2hXb3JkID0gcmVxdWlyZSggJ0BzdGRsaWIvbnVtYmVyLWZsb2F0NjQtYmFzZS1nZXQtaGlnaC13b3JkJyApO1xuKlxuKiB2YXIgdyA9IGdldEhpZ2hXb3JkKCAzLjE0ZTIwMSApOyAvLyA9PiAwMTEwMTAwMTExMDAwMTAwMTAwMDAwMTAxMTAwMDAxMVxuKiAvLyByZXR1cm5zIDE3NzQ0ODYyMTFcbiovXG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGdldEhpZ2hXb3JkID0gcmVxdWlyZSggJy4vbWFpbi5qcycgKTtcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0SGlnaFdvcmQ7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgaXNMaXR0bGVFbmRpYW4gPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaXMtbGl0dGxlLWVuZGlhbicgKTtcblxuXG4vLyBNQUlOIC8vXG5cbnZhciBpbmRpY2VzO1xudmFyIEhJR0g7XG52YXIgTE9XO1xuXG5pZiAoIGlzTGl0dGxlRW5kaWFuID09PSB0cnVlICkge1xuXHRISUdIID0gMTsgLy8gc2Vjb25kIGluZGV4XG5cdExPVyA9IDA7IC8vIGZpcnN0IGluZGV4XG59IGVsc2Uge1xuXHRISUdIID0gMDsgLy8gZmlyc3QgaW5kZXhcblx0TE9XID0gMTsgLy8gc2Vjb25kIGluZGV4XG59XG5pbmRpY2VzID0ge1xuXHQnSElHSCc6IEhJR0gsXG5cdCdMT1cnOiBMT1dcbn07XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGluZGljZXM7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgVWludDMyQXJyYXkgPSByZXF1aXJlKCAnQHN0ZGxpYi9hcnJheS11aW50MzInICk7XG52YXIgRmxvYXQ2NEFycmF5ID0gcmVxdWlyZSggJ0BzdGRsaWIvYXJyYXktZmxvYXQ2NCcgKTtcbnZhciBpbmRpY2VzID0gcmVxdWlyZSggJy4vaW5kaWNlcy5qcycgKTtcblxuXG4vLyBWQVJJQUJMRVMgLy9cblxudmFyIEZMT0FUNjRfVklFVyA9IG5ldyBGbG9hdDY0QXJyYXkoIDEgKTtcbnZhciBVSU5UMzJfVklFVyA9IG5ldyBVaW50MzJBcnJheSggRkxPQVQ2NF9WSUVXLmJ1ZmZlciApO1xuXG52YXIgSElHSCA9IGluZGljZXMuSElHSDtcbnZhciBMT1cgPSBpbmRpY2VzLkxPVztcblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBDcmVhdGVzIGEgZG91YmxlLXByZWNpc2lvbiBmbG9hdGluZy1wb2ludCBudW1iZXIgZnJvbSBhIGhpZ2hlciBvcmRlciB3b3JkICh1bnNpZ25lZCAzMi1iaXQgaW50ZWdlcikgYW5kIGEgbG93ZXIgb3JkZXIgd29yZCAodW5zaWduZWQgMzItYml0IGludGVnZXIpLlxuKlxuKiAjIyBOb3Rlc1xuKlxuKiBgYGB0ZXh0XG4qIGZsb2F0NjQgKDY0IGJpdHMpXG4qIGYgOj0gZnJhY3Rpb24gKHNpZ25pZmljYW5kL21hbnRpc3NhKSAoNTIgYml0cylcbiogZSA6PSBleHBvbmVudCAoMTEgYml0cylcbiogcyA6PSBzaWduIGJpdCAoMSBiaXQpXG4qXG4qIHwtLS0tLS0tLSAtLS0tLS0tLSAtLS0tLS0tLSAtLS0tLS0tLSAtLS0tLS0tLSAtLS0tLS0tLSAtLS0tLS0tLSAtLS0tLS0tLXxcbiogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRmxvYXQ2NCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuKiB8LS0tLS0tLS0gLS0tLS0tLS0gLS0tLS0tLS0gLS0tLS0tLS0gLS0tLS0tLS0gLS0tLS0tLS0gLS0tLS0tLS0gLS0tLS0tLS18XG4qIHwgICAgICAgICAgICAgIFVpbnQzMiAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICBVaW50MzIgICAgICAgICAgICAgIHxcbiogfC0tLS0tLS0tIC0tLS0tLS0tIC0tLS0tLS0tIC0tLS0tLS0tIC0tLS0tLS0tIC0tLS0tLS0tIC0tLS0tLS0tIC0tLS0tLS0tfFxuKiBgYGBcbipcbiogSWYgbGl0dGxlIGVuZGlhbiAobW9yZSBzaWduaWZpY2FudCBiaXRzIGxhc3QpOlxuKlxuKiBgYGB0ZXh0XG4qICAgICAgICAgICAgICAgICAgICAgICAgIDwtLSBsb3dlciAgICAgIGhpZ2hlciAtLT5cbiogfCAgIGY3ICAgICAgIGY2ICAgICAgIGY1ICAgICAgIGY0ICAgICAgIGYzICAgICAgIGYyICAgIGUyIHwgZjEgfHN8ICBlMSAgfFxuKiBgYGBcbipcbiogSWYgYmlnIGVuZGlhbiAobW9yZSBzaWduaWZpY2FudCBiaXRzIGZpcnN0KTpcbipcbiogYGBgdGV4dFxuKiAgICAgICAgICAgICAgICAgICAgICAgICA8LS0gaGlnaGVyICAgICAgbG93ZXIgLS0+XG4qIHxzfCBlMSAgICBlMiB8IGYxICAgICBmMiAgICAgICBmMyAgICAgICBmNCAgICAgICBmNSAgICAgICAgZjYgICAgICBmNyAgIHxcbiogYGBgXG4qXG4qXG4qIEluIHdoaWNoIFVpbnQzMiBzaG91bGQgd2UgcGxhY2UgdGhlIGhpZ2hlciBvcmRlciBiaXRzPyBJZiBsaXR0bGUgZW5kaWFuLCB0aGUgc2Vjb25kOyBpZiBiaWcgZW5kaWFuLCB0aGUgZmlyc3QuXG4qXG4qXG4qICMjIFJlZmVyZW5jZXNcbipcbiogLSAgIFtPcGVuIEdyb3VwXVsxXVxuKlxuKiBbMV06IGh0dHA6Ly9wdWJzLm9wZW5ncm91cC5vcmcvb25saW5lcHVicy85NjI5Mzk5L2NoYXAxNC5odG1cbipcbiogQHBhcmFtIHt1aW50ZWdlcjMyfSBoaWdoIC0gaGlnaGVyIG9yZGVyIHdvcmQgKHVuc2lnbmVkIDMyLWJpdCBpbnRlZ2VyKVxuKiBAcGFyYW0ge3VpbnRlZ2VyMzJ9IGxvdyAtIGxvd2VyIG9yZGVyIHdvcmQgKHVuc2lnbmVkIDMyLWJpdCBpbnRlZ2VyKVxuKiBAcmV0dXJucyB7bnVtYmVyfSBmbG9hdGluZy1wb2ludCBudW1iZXJcbipcbiogQGV4YW1wbGVcbiogdmFyIHYgPSBmcm9tV29yZHMoIDE3NzQ0ODYyMTEsIDI0Nzk1NzcyMTggKTtcbiogLy8gcmV0dXJucyAzLjE0ZTIwMVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgdiA9IGZyb21Xb3JkcyggMzIyMTgyMzk5NSwgMTQxMzc1NDEzNiApO1xuKiAvLyByZXR1cm5zIC0zLjE0MTU5MjY1MzU4OTc5M1xuKlxuKiBAZXhhbXBsZVxuKiB2YXIgdiA9IGZyb21Xb3JkcyggMCwgMCApO1xuKiAvLyByZXR1cm5zIDAuMFxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgdiA9IGZyb21Xb3JkcyggMjE0NzQ4MzY0OCwgMCApO1xuKiAvLyByZXR1cm5zIC0wLjBcbipcbiogQGV4YW1wbGVcbiogdmFyIHYgPSBmcm9tV29yZHMoIDIxNDY5NTkzNjAsIDAgKTtcbiogLy8gcmV0dXJucyBOYU5cbipcbiogQGV4YW1wbGVcbiogdmFyIHYgPSBmcm9tV29yZHMoIDIxNDY0MzUwNzIsIDAgKTtcbiogLy8gcmV0dXJucyBJbmZpbml0eVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgdiA9IGZyb21Xb3JkcyggNDI5MzkxODcyMCwgMCApO1xuKiAvLyByZXR1cm5zIC1JbmZpbml0eVxuKi9cbmZ1bmN0aW9uIGZyb21Xb3JkcyggaGlnaCwgbG93ICkge1xuXHRVSU5UMzJfVklFV1sgSElHSCBdID0gaGlnaDtcblx0VUlOVDMyX1ZJRVdbIExPVyBdID0gbG93O1xuXHRyZXR1cm4gRkxPQVQ2NF9WSUVXWyAwIF07XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZyb21Xb3JkcztcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogQ3JlYXRlIGEgZG91YmxlLXByZWNpc2lvbiBmbG9hdGluZy1wb2ludCBudW1iZXIgZnJvbSBhIGhpZ2hlciBvcmRlciB3b3JkICh1bnNpZ25lZCAzMi1iaXQgaW50ZWdlcikgYW5kIGEgbG93ZXIgb3JkZXIgd29yZCAodW5zaWduZWQgMzItYml0IGludGVnZXIpLlxuKlxuKiBAbW9kdWxlIEBzdGRsaWIvbnVtYmVyLWZsb2F0NjQtYmFzZS1mcm9tLXdvcmRzXG4qXG4qIEBleGFtcGxlXG4qIHZhciBmcm9tV29yZHMgPSByZXF1aXJlKCAnQHN0ZGxpYi9udW1iZXItZmxvYXQ2NC1iYXNlLWZyb20td29yZHMnICk7XG4qXG4qIHZhciB2ID0gZnJvbVdvcmRzKCAxNzc0NDg2MjExLCAyNDc5NTc3MjE4ICk7XG4qIC8vIHJldHVybnMgMy4xNGUyMDFcbipcbiogdiA9IGZyb21Xb3JkcyggMzIyMTgyMzk5NSwgMTQxMzc1NDEzNiApO1xuKiAvLyByZXR1cm5zIC0zLjE0MTU5MjY1MzU4OTc5M1xuKlxuKiB2ID0gZnJvbVdvcmRzKCAwLCAwICk7XG4qIC8vIHJldHVybnMgMC4wXG4qXG4qIHYgPSBmcm9tV29yZHMoIDIxNDc0ODM2NDgsIDAgKTtcbiogLy8gcmV0dXJucyAtMC4wXG4qXG4qIHYgPSBmcm9tV29yZHMoIDIxNDY5NTkzNjAsIDAgKTtcbiogLy8gcmV0dXJucyBOYU5cbipcbiogdiA9IGZyb21Xb3JkcyggMjE0NjQzNTA3MiwgMCApO1xuKiAvLyByZXR1cm5zIEluZmluaXR5XG4qXG4qIHYgPSBmcm9tV29yZHMoIDQyOTM5MTg3MjAsIDAgKTtcbiogLy8gcmV0dXJucyAtSW5maW5pdHlcbiovXG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGZyb21Xb3JkcyA9IHJlcXVpcmUoICcuL21haW4uanMnICk7XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZyb21Xb3JkcztcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciB0b1dvcmRzID0gcmVxdWlyZSggJ0BzdGRsaWIvbnVtYmVyLWZsb2F0NjQtYmFzZS10by13b3JkcycgKTtcbnZhciBnZXRIaWdoV29yZCA9IHJlcXVpcmUoICdAc3RkbGliL251bWJlci1mbG9hdDY0LWJhc2UtZ2V0LWhpZ2gtd29yZCcgKTtcbnZhciBmcm9tV29yZHMgPSByZXF1aXJlKCAnQHN0ZGxpYi9udW1iZXItZmxvYXQ2NC1iYXNlLWZyb20td29yZHMnICk7XG5cblxuLy8gVkFSSUFCTEVTIC8vXG5cbi8vIDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwID0+IDIxNDc0ODM2NDggPT4gMHg4MDAwMDAwMFxudmFyIFNJR05fTUFTSyA9IDB4ODAwMDAwMDA+Pj4wOyAvLyBhc20gdHlwZSBhbm5vdGF0aW9uXG5cbi8vIDAxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExID0+IDIxNDc0ODM2NDcgPT4gMHg3ZmZmZmZmZlxudmFyIE1BR05JVFVERV9NQVNLID0gMHg3ZmZmZmZmZnwwOyAvLyBhc20gdHlwZSBhbm5vdGF0aW9uXG5cbi8vIEhpZ2gvbG93IHdvcmRzIHdvcmtzcGFjZTpcbnZhciBXT1JEUyA9IFsgMCwgMCBdOyAvLyBXQVJOSU5HOiBub3QgdGhyZWFkIHNhZmVcblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBSZXR1cm5zIGEgZG91YmxlLXByZWNpc2lvbiBmbG9hdGluZy1wb2ludCBudW1iZXIgd2l0aCB0aGUgbWFnbml0dWRlIG9mIGB4YCBhbmQgdGhlIHNpZ24gb2YgYHlgLlxuKlxuKiBAcGFyYW0ge251bWJlcn0geCAtIG51bWJlciBmcm9tIHdoaWNoIHRvIGRlcml2ZSBhIG1hZ25pdHVkZVxuKiBAcGFyYW0ge251bWJlcn0geSAtIG51bWJlciBmcm9tIHdoaWNoIHRvIGRlcml2ZSBhIHNpZ25cbiogQHJldHVybnMge251bWJlcn0gYSBkb3VibGUtcHJlY2lzaW9uIGZsb2F0aW5nLXBvaW50IG51bWJlclxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgeiA9IGNvcHlzaWduKCAtMy4xNCwgMTAuMCApO1xuKiAvLyByZXR1cm5zIDMuMTRcbipcbiogQGV4YW1wbGVcbiogdmFyIHogPSBjb3B5c2lnbiggMy4xNCwgLTEuMCApO1xuKiAvLyByZXR1cm5zIC0zLjE0XG4qXG4qIEBleGFtcGxlXG4qIHZhciB6ID0gY29weXNpZ24oIDEuMCwgLTAuMCApO1xuKiAvLyByZXR1cm5zIC0xLjBcbipcbiogQGV4YW1wbGVcbiogdmFyIHogPSBjb3B5c2lnbiggLTMuMTQsIC0wLjAgKTtcbiogLy8gcmV0dXJucyAtMy4xNFxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgeiA9IGNvcHlzaWduKCAtMC4wLCAxLjAgKTtcbiogLy8gcmV0dXJucyAwLjBcbiovXG5mdW5jdGlvbiBjb3B5c2lnbiggeCwgeSApIHtcblx0dmFyIGh4O1xuXHR2YXIgaHk7XG5cblx0Ly8gU3BsaXQgYHhgIGludG8gaGlnaGVyIGFuZCBsb3dlciBvcmRlciB3b3Jkczpcblx0dG9Xb3JkcyggV09SRFMsIHggKTtcblx0aHggPSBXT1JEU1sgMCBdO1xuXG5cdC8vIFR1cm4gb2ZmIHRoZSBzaWduIGJpdCBvZiBgeGA6XG5cdGh4ICY9IE1BR05JVFVERV9NQVNLO1xuXG5cdC8vIEV4dHJhY3QgdGhlIGhpZ2hlciBvcmRlciB3b3JkIGZyb20gYHlgOlxuXHRoeSA9IGdldEhpZ2hXb3JkKCB5ICk7XG5cblx0Ly8gTGVhdmUgb25seSB0aGUgc2lnbiBiaXQgb2YgYHlgIHR1cm5lZCBvbjpcblx0aHkgJj0gU0lHTl9NQVNLO1xuXG5cdC8vIENvcHkgdGhlIHNpZ24gYml0IG9mIGB5YCB0byBgeGA6XG5cdGh4IHw9IGh5O1xuXG5cdC8vIFJldHVybiBhIG5ldyB2YWx1ZSBoYXZpbmcgdGhlIHNhbWUgbWFnbml0dWRlIGFzIGB4YCwgYnV0IHdpdGggdGhlIHNpZ24gb2YgYHlgOlxuXHRyZXR1cm4gZnJvbVdvcmRzKCBoeCwgV09SRFNbIDEgXSApO1xufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5c2lnbjtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogUmV0dXJuIGEgZG91YmxlLXByZWNpc2lvbiBmbG9hdGluZy1wb2ludCBudW1iZXIgd2l0aCB0aGUgbWFnbml0dWRlIG9mIGB4YCBhbmQgdGhlIHNpZ24gb2YgYHlgLlxuKlxuKiBAbW9kdWxlIEBzdGRsaWIvbWF0aC1iYXNlLXNwZWNpYWwtY29weXNpZ25cbipcbiogQGV4YW1wbGVcbiogdmFyIGNvcHlzaWduID0gcmVxdWlyZSggJ0BzdGRsaWIvbWF0aC1iYXNlLXNwZWNpYWwtY29weXNpZ24nICk7XG4qXG4qIHZhciB6ID0gY29weXNpZ24oIC0zLjE0LCAxMC4wICk7XG4qIC8vIHJldHVybnMgMy4xNFxuKlxuKiB6ID0gY29weXNpZ24oIDMuMTQsIC0xLjAgKTtcbiogLy8gcmV0dXJucyAtMy4xNFxuKlxuKiB6ID0gY29weXNpZ24oIDEuMCwgLTAuMCApO1xuKiAvLyByZXR1cm5zIC0xLjBcbipcbiogeiA9IGNvcHlzaWduKCAtMy4xNCwgLTAuMCApO1xuKiAvLyByZXR1cm5zIC0zLjE0XG4qXG4qIHogPSBjb3B5c2lnbiggLTAuMCwgMS4wICk7XG4qIC8vIHJldHVybnMgMC4wXG4qL1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBjb3B5c2lnbiA9IHJlcXVpcmUoICcuL2NvcHlzaWduLmpzJyApO1xuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5c2lnbjtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKlxuKlxuKiAjIyBOb3RpY2VcbipcbiogVGhlIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2Ugd2VyZSBwYXJ0IG9mIHRoZSBvcmlnaW5hbCBpbXBsZW1lbnRhdGlvbiBhdmFpbGFibGUgYXMgcGFydCBvZiBbRnJlZUJTRF17QGxpbmsgaHR0cHM6Ly9zdm53ZWIuZnJlZWJzZC5vcmcvYmFzZS9yZWxlYXNlLzkuMy4wL2xpYi9tc3VuL3NyYy9zX3Bvdy5jfS4gVGhlIGltcGxlbWVudGF0aW9uIGZvbGxvd3MgdGhlIG9yaWdpbmFsLCBidXQgaGFzIGJlZW4gbW9kaWZpZWQgZm9yIEphdmFTY3JpcHQuXG4qXG4qIGBgYHRleHRcbiogQ29weXJpZ2h0IChDKSAyMDA0IGJ5IFN1biBNaWNyb3N5c3RlbXMsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogRGV2ZWxvcGVkIGF0IFN1blBybywgYSBTdW4gTWljcm9zeXN0ZW1zLCBJbmMuIGJ1c2luZXNzLlxuKiBQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQgZGlzdHJpYnV0ZSB0aGlzXG4qIHNvZnR3YXJlIGlzIGZyZWVseSBncmFudGVkLCBwcm92aWRlZCB0aGF0IHRoaXMgbm90aWNlXG4qIGlzIHByZXNlcnZlZC5cbiogYGBgXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGlzT2RkID0gcmVxdWlyZSggJ0BzdGRsaWIvbWF0aC1iYXNlLWFzc2VydC1pcy1vZGQnICk7XG52YXIgY29weXNpZ24gPSByZXF1aXJlKCAnQHN0ZGxpYi9tYXRoLWJhc2Utc3BlY2lhbC1jb3B5c2lnbicgKTtcbnZhciBOSU5GID0gcmVxdWlyZSggJ0BzdGRsaWIvY29uc3RhbnRzLWZsb2F0NjQtbmluZicgKTtcbnZhciBQSU5GID0gcmVxdWlyZSggJ0BzdGRsaWIvY29uc3RhbnRzLWZsb2F0NjQtcGluZicgKTtcblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBFdmFsdWF0ZXMgdGhlIGV4cG9uZW50aWFsIGZ1bmN0aW9uIHdoZW4gXFxcXCh8eHwgPSAwXFxcXCkuXG4qXG4qIEBwcml2YXRlXG4qIEBwYXJhbSB7bnVtYmVyfSB4IC0gYmFzZVxuKiBAcGFyYW0ge251bWJlcn0geSAtIGV4cG9uZW50XG4qIEByZXR1cm5zIHtudW1iZXJ9IGZ1bmN0aW9uIHZhbHVlXG4qXG4qIEBleGFtcGxlXG4qIHZhciB2ID0gcG93KCAwLjAsIDIgKTtcbiogLy8gcmV0dXJucyAwLjBcbipcbiogQGV4YW1wbGVcbiogdmFyIHYgPSBwb3coIC0wLjAsIC05ICk7XG4qIC8vIHJldHVybnMgLUluZmluaXR5XG4qXG4qIEBleGFtcGxlXG4qIHZhciB2ID0gcG93KCAwLjAsIC05ICk7XG4qIC8vIHJldHVybnMgSW5maW5pdHlcbipcbiogQGV4YW1wbGVcbiogdmFyIHYgPSBwb3coIC0wLjAsIDkgKTtcbiogLy8gcmV0dXJucyAwLjBcbipcbiogQGV4YW1wbGVcbiogdmFyIHYgPSBwb3coIDAuMCwgLUluZmluaXR5ICApO1xuKiAvLyByZXR1cm5zIEluZmluaXR5XG4qXG4qIEBleGFtcGxlXG4qIHZhciB2ID0gcG93KCAwLjAsIEluZmluaXR5ICk7XG4qIC8vIHJldHVybnMgMC4wXG4qL1xuZnVuY3Rpb24gcG93KCB4LCB5ICkge1xuXHRpZiAoIHkgPT09IE5JTkYgKSB7XG5cdFx0cmV0dXJuIFBJTkY7XG5cdH1cblx0aWYgKCB5ID09PSBQSU5GICkge1xuXHRcdHJldHVybiAwLjA7XG5cdH1cblx0aWYgKCB5ID4gMC4wICkge1xuXHRcdGlmICggaXNPZGQoIHkgKSApIHtcblx0XHRcdHJldHVybiB4OyAvLyBoYW5kbGVzICstMFxuXHRcdH1cblx0XHRyZXR1cm4gMC4wO1xuXHR9XG5cdC8vIHkgPCAwLjBcblx0aWYgKCBpc09kZCggeSApICkge1xuXHRcdHJldHVybiBjb3B5c2lnbiggUElORiwgeCApOyAvLyBoYW5kbGVzICstMFxuXHR9XG5cdHJldHVybiBQSU5GO1xufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBwb3c7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbipcbipcbiogIyMgTm90aWNlXG4qXG4qIFRoZSBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlIHdlcmUgcGFydCBvZiB0aGUgb3JpZ2luYWwgaW1wbGVtZW50YXRpb24gYXZhaWxhYmxlIGFzIHBhcnQgb2YgW0ZyZWVCU0Rde0BsaW5rIGh0dHBzOi8vc3Zud2ViLmZyZWVic2Qub3JnL2Jhc2UvcmVsZWFzZS85LjMuMC9saWIvbXN1bi9zcmMvc19wb3cuY30uIFRoZSBpbXBsZW1lbnRhdGlvbiBmb2xsb3dzIHRoZSBvcmlnaW5hbCwgYnV0IGhhcyBiZWVuIG1vZGlmaWVkIGZvciBKYXZhU2NyaXB0LlxuKlxuKiBgYGB0ZXh0XG4qIENvcHlyaWdodCAoQykgMjAwNCBieSBTdW4gTWljcm9zeXN0ZW1zLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIERldmVsb3BlZCBhdCBTdW5Qcm8sIGEgU3VuIE1pY3Jvc3lzdGVtcywgSW5jLiBidXNpbmVzcy5cbiogUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kIGRpc3RyaWJ1dGUgdGhpc1xuKiBzb2Z0d2FyZSBpcyBmcmVlbHkgZ3JhbnRlZCwgcHJvdmlkZWQgdGhhdCB0aGlzIG5vdGljZVxuKiBpcyBwcmVzZXJ2ZWQuXG4qIGBgYFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBnZXRIaWdoV29yZCA9IHJlcXVpcmUoICdAc3RkbGliL251bWJlci1mbG9hdDY0LWJhc2UtZ2V0LWhpZ2gtd29yZCcgKTtcblxuXG4vLyBWQVJJQUJMRVMgLy9cblxuLy8gMHg3ZmZmZmZmZiA9IDIxNDc0ODM2NDcgPT4gMCAxMTExMTExMTExMSAxMTExMTExMTExMTExMTExMTExMVxudmFyIEFCU19NQVNLID0gMHg3ZmZmZmZmZnwwOyAvLyBhc20gdHlwZSBhbm5vdGF0aW9uXG5cbi8vIDB4M2ZlZmZmZmYgPSAxMDcyNjkzMjQ3ID0+IDAgMDExMTExMTExMTAgMTExMTExMTExMTExMTExMTExMTEgPT4gYmlhc2VkIGV4cG9uZW50OiAxMDIyID0gLTErMTAyMyA9PiAyXi0xXG52YXIgSElHSF9NQVhfTkVBUl9VTklUWSA9IDB4M2ZlZmZmZmZ8MDsgLy8gYXNtIHR5cGUgYW5ub3RhdGlvblxuXG52YXIgSFVHRSA9IDEuMGUzMDA7XG52YXIgVElOWSA9IDEuMGUtMzAwO1xuXG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIEV2YWx1YXRlcyB0aGUgZXhwb25lbnRpYWwgZnVuY3Rpb24gd2hlbiBcXFxcKHx5fCA+IDJeNjRcXFxcKS5cbipcbiogQHByaXZhdGVcbiogQHBhcmFtIHtudW1iZXJ9IHggLSBiYXNlXG4qIEBwYXJhbSB7bnVtYmVyfSB5IC0gZXhwb25lbnRcbiogQHJldHVybnMge251bWJlcn0gb3ZlcmZsb3cgb3IgdW5kZXJmbG93IHJlc3VsdFxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgdiA9IHBvdyggOS4wLCAzLjY4OTM0ODgxNDc0MTkxMDNlMTkgKTtcbiogLy8gcmV0dXJucyBJbmZpbml0eVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgdiA9IHBvdyggLTMuMTQsIC0zLjY4OTM0ODgxNDc0MTkxMDNlMTkgKTtcbiogLy8gcmV0dXJucyAwLjBcbiovXG5mdW5jdGlvbiBwb3coIHgsIHkgKSB7XG5cdHZhciBhaHg7XG5cdHZhciBoeDtcblxuXHRoeCA9IGdldEhpZ2hXb3JkKCB4ICk7XG5cdGFoeCA9IChoeCAmIEFCU19NQVNLKTtcblxuXHRpZiAoIGFoeCA8PSBISUdIX01BWF9ORUFSX1VOSVRZICkge1xuXHRcdGlmICggeSA8IDAgKSB7XG5cdFx0XHQvLyBzaWduYWwgb3ZlcmZsb3cuLi5cblx0XHRcdHJldHVybiBIVUdFICogSFVHRTtcblx0XHR9XG5cdFx0Ly8gc2lnbmFsIHVuZGVyZmxvdy4uLlxuXHRcdHJldHVybiBUSU5ZICogVElOWTtcblx0fVxuXHQvLyBgeGAgaGFzIGEgYmlhc2VkIGV4cG9uZW50IGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgMGAuLi5cblxuXHRpZiAoIHkgPiAwICkge1xuXHRcdC8vIHNpZ25hbCBvdmVyZmxvdy4uLlxuXHRcdHJldHVybiBIVUdFICogSFVHRTtcblx0fVxuXHQvLyBzaWduYWwgdW5kZXJmbG93Li4uXG5cdHJldHVybiBUSU5ZICogVElOWTtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gcG93O1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGFicyA9IHJlcXVpcmUoICdAc3RkbGliL21hdGgtYmFzZS1zcGVjaWFsLWFicycgKTtcbnZhciBQSU5GID0gcmVxdWlyZSggJ0BzdGRsaWIvY29uc3RhbnRzLWZsb2F0NjQtcGluZicgKTtcblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBFdmFsdWF0ZXMgdGhlIGV4cG9uZW50aWFsIGZ1bmN0aW9uIHdoZW4gXFxcXCggeSA9IFxccG0gXFxpbmZ0eVxcXFwpLlxuKlxuKiBAcHJpdmF0ZVxuKiBAcGFyYW0ge251bWJlcn0geCAtIGJhc2VcbiogQHBhcmFtIHtudW1iZXJ9IHkgLSBleHBvbmVudFxuKiBAcmV0dXJucyB7bnVtYmVyfSBmdW5jdGlvbiB2YWx1ZVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgdiA9IHBvdyggLTEuMCwgSW5maW5pdHkgKTtcbiogLy8gcmV0dXJucyBOYU5cbipcbiogQGV4YW1wbGVcbiogdmFyIHYgPSBwb3coIC0xLjAsIC1JbmZpbml0eSAgKTtcbiogLy8gcmV0dXJucyBOYU5cbipcbiogQGV4YW1wbGVcbiogdmFyIHYgPSBwb3coIDEuMCwgSW5maW5pdHkgKTtcbiogLy8gcmV0dXJucyAxLjBcbipcbiogQGV4YW1wbGVcbiogdmFyIHYgPSBwb3coIDEuMCwgLUluZmluaXR5ICApO1xuKiAvLyByZXR1cm5zIDEuMFxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgdiA9IHBvdyggMC41LCBJbmZpbml0eSApO1xuKiAvLyByZXR1cm5zIDAuMFxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgdiA9IHBvdyggMC41LCAtSW5maW5pdHkgICk7XG4qIC8vIHJldHVybnMgSW5maW5pdHlcbipcbiogQGV4YW1wbGVcbiogdmFyIHYgPSBwb3coIDEuNSwgLUluZmluaXR5ICApO1xuKiAvLyByZXR1cm5zIDAuMFxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgdiA9IHBvdyggMS41LCBJbmZpbml0eSApO1xuKiAvLyByZXR1cm5zIEluZmluaXR5XG4qL1xuZnVuY3Rpb24gcG93KCB4LCB5ICkge1xuXHRpZiAoIHggPT09IC0xLjAgKSB7XG5cdFx0Ly8gSnVsaWEgKDAuNC4yKSBhbmQgUHl0aG9uICgyLjcuOSkgcmV0dXJuIGAxLjBgIChXVEY/Pz8pLiBKYXZhU2NyaXB0IChgTWF0aC5wb3dgKSwgUiwgYW5kIGxpYm0gcmV0dXJuIGBOYU5gLiBXZSBjaG9vc2UgYE5hTmAsIGFzIHRoZSB2YWx1ZSBpcyBpbmRldGVybWluYXRlOyBpLmUuLCB3ZSBjYW5ub3QgZGV0ZXJtaW5lIHdoZXRoZXIgYHlgIGlzIG9kZCwgZXZlbiwgb3Igc29tZXdoZXJlIGluIGJldHdlZW4uXG5cdFx0cmV0dXJuICh4LXgpLyh4LXgpOyAvLyBzaWduYWwgTmFOXG5cdH1cblx0aWYgKCB4ID09PSAxLjAgKSB7XG5cdFx0cmV0dXJuIDEuMDtcblx0fVxuXHQvLyAofHh8ID4gMSAmJiB5ID09PSBOSU5GKSB8fCAofHh8IDwgMSAmJiB5ID09PSBQSU5GKVxuXHRpZiAoIChhYnMoeCkgPCAxLjApID09PSAoeSA9PT0gUElORikgKSB7XG5cdFx0cmV0dXJuIDAuMDtcblx0fVxuXHQvLyAofHh8ID4gMSAmJiB5ID09PSBQSU5GKSB8fCAofHh8IDwgMSAmJiB5ID09PSBOSU5GKVxuXHRyZXR1cm4gUElORjtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gcG93O1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGlzTGl0dGxlRW5kaWFuID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLWxpdHRsZS1lbmRpYW4nICk7XG5cblxuLy8gTUFJTiAvL1xuXG52YXIgSElHSDtcbmlmICggaXNMaXR0bGVFbmRpYW4gPT09IHRydWUgKSB7XG5cdEhJR0ggPSAxOyAvLyBzZWNvbmQgaW5kZXhcbn0gZWxzZSB7XG5cdEhJR0ggPSAwOyAvLyBmaXJzdCBpbmRleFxufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBISUdIO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIFVpbnQzMkFycmF5ID0gcmVxdWlyZSggJ0BzdGRsaWIvYXJyYXktdWludDMyJyApO1xudmFyIEZsb2F0NjRBcnJheSA9IHJlcXVpcmUoICdAc3RkbGliL2FycmF5LWZsb2F0NjQnICk7XG52YXIgSElHSCA9IHJlcXVpcmUoICcuL2hpZ2guanMnICk7XG5cblxuLy8gVkFSSUFCTEVTIC8vXG5cbnZhciBGTE9BVDY0X1ZJRVcgPSBuZXcgRmxvYXQ2NEFycmF5KCAxICk7XG52YXIgVUlOVDMyX1ZJRVcgPSBuZXcgVWludDMyQXJyYXkoIEZMT0FUNjRfVklFVy5idWZmZXIgKTtcblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBTZXRzIHRoZSBtb3JlIHNpZ25pZmljYW50IDMyIGJpdHMgb2YgYSBkb3VibGUtcHJlY2lzaW9uIGZsb2F0aW5nLXBvaW50IG51bWJlci5cbipcbiogIyMgTm90ZXNcbipcbiogYGBgdGV4dFxuKiBmbG9hdDY0ICg2NCBiaXRzKVxuKiBmIDo9IGZyYWN0aW9uIChzaWduaWZpY2FuZC9tYW50aXNzYSkgKDUyIGJpdHMpXG4qIGUgOj0gZXhwb25lbnQgKDExIGJpdHMpXG4qIHMgOj0gc2lnbiBiaXQgKDEgYml0KVxuKlxuKiB8LS0tLS0tLS0gLS0tLS0tLS0gLS0tLS0tLS0gLS0tLS0tLS0gLS0tLS0tLS0gLS0tLS0tLS0gLS0tLS0tLS0gLS0tLS0tLS18XG4qIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZsb2F0NjQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiogfC0tLS0tLS0tIC0tLS0tLS0tIC0tLS0tLS0tIC0tLS0tLS0tIC0tLS0tLS0tIC0tLS0tLS0tIC0tLS0tLS0tIC0tLS0tLS0tfFxuKiB8ICAgICAgICAgICAgICBVaW50MzIgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgVWludDMyICAgICAgICAgICAgICB8XG4qIHwtLS0tLS0tLSAtLS0tLS0tLSAtLS0tLS0tLSAtLS0tLS0tLSAtLS0tLS0tLSAtLS0tLS0tLSAtLS0tLS0tLSAtLS0tLS0tLXxcbiogYGBgXG4qXG4qIElmIGxpdHRsZSBlbmRpYW4gKG1vcmUgc2lnbmlmaWNhbnQgYml0cyBsYXN0KTpcbipcbiogYGBgdGV4dFxuKiAgICAgICAgICAgICAgICAgICAgICAgICA8LS0gbG93ZXIgICAgICBoaWdoZXIgLS0+XG4qIHwgICBmNyAgICAgICBmNiAgICAgICBmNSAgICAgICBmNCAgICAgICBmMyAgICAgICBmMiAgICBlMiB8IGYxIHxzfCAgZTEgIHxcbiogYGBgXG4qXG4qIElmIGJpZyBlbmRpYW4gKG1vcmUgc2lnbmlmaWNhbnQgYml0cyBmaXJzdCk6XG4qXG4qIGBgYHRleHRcbiogICAgICAgICAgICAgICAgICAgICAgICAgPC0tIGhpZ2hlciAgICAgIGxvd2VyIC0tPlxuKiB8c3wgZTEgICAgZTIgfCBmMSAgICAgZjIgICAgICAgZjMgICAgICAgZjQgICAgICAgZjUgICAgICAgIGY2ICAgICAgZjcgICB8XG4qIGBgYFxuKlxuKiBJbiB3aGljaCBVaW50MzIgY2FuIHdlIGZpbmQgdGhlIGhpZ2hlciBvcmRlciBiaXRzPyBJZiBsaXR0bGUgZW5kaWFuLCB0aGUgc2Vjb25kOyBpZiBiaWcgZW5kaWFuLCB0aGUgZmlyc3QuXG4qXG4qXG4qICMjIFJlZmVyZW5jZXNcbipcbiogLSAgIFtPcGVuIEdyb3VwXVsxXVxuKlxuKiBbMV06IGh0dHA6Ly9wdWJzLm9wZW5ncm91cC5vcmcvb25saW5lcHVicy85NjI5Mzk5L2NoYXAxNC5odG1cbipcbiogQHBhcmFtIHtudW1iZXJ9IHggLSBkb3VibGVcbiogQHBhcmFtIHt1aW50ZWdlcjMyfSBoaWdoIC0gdW5zaWduZWQgMzItYml0IGludGVnZXIgdG8gcmVwbGFjZSB0aGUgaGlnaGVyIG9yZGVyIHdvcmQgb2YgYHhgXG4qIEByZXR1cm5zIHtudW1iZXJ9IGRvdWJsZSBoYXZpbmcgdGhlIHNhbWUgbG93ZXIgb3JkZXIgd29yZCBhcyBgeGBcbipcbiogQGV4YW1wbGVcbiogdmFyIGhpZ2ggPSA1ID4+PiAwOyAvLyA9PiAwIDAwMDAwMDAwMDAwIDAwMDAwMDAwMDAwMDAwMDAwMTAxXG4qXG4qIHZhciB5ID0gc2V0SGlnaFdvcmQoIDMuMTRlMjAxLCBoaWdoICk7IC8vICA9PiAwIDAwMDAwMDAwMDAwIDAwMDAwMDAwMDAwMDAwMDAwMTAxMTAwMTAwMTExMTAwMTAxMTAxMDExMDAwMTAwMDAwMTBcbiogLy8gcmV0dXJucyAxLjE4MzUwNTI4NzQ1ZS0zMTNcbipcbiogQGV4YW1wbGVcbiogdmFyIFBJTkYgPSByZXF1aXJlKCAnQHN0ZGxpYi9jb25zdGFudHMtZmxvYXQ2NC1waW5mJyApOyAvLyA9PiAwIDExMTExMTExMTExIDAwMDAwMDAwMDAwMDAwMDAwMDAwIDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXG4qXG4qIHZhciBoaWdoID0gMTA3MjY5MzI0OCA+Pj4gMDsgLy8gPT4gMCAwMTExMTExMTExMSAwMDAwMDAwMDAwMDAwMDAwMDAwMFxuKlxuKiAvLyBTZXQgdGhlIGhpZ2hlciBvcmRlciBiaXRzIG9mIGAraW5maW5pdHlgIHRvIHJldHVybiBgMWA6XG4qIHZhciB5ID0gc2V0SGlnaFdvcmQoIFBJTkYsIGhpZ2ggKTsgLy8gPT4gMCAwMTExMTExMTExMSAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXG4qIC8vIHJldHVybnMgMS4wXG4qL1xuZnVuY3Rpb24gc2V0SGlnaFdvcmQoIHgsIGhpZ2ggKSB7XG5cdEZMT0FUNjRfVklFV1sgMCBdID0geDtcblx0VUlOVDMyX1ZJRVdbIEhJR0ggXSA9ICggaGlnaCA+Pj4gMCApOyAvLyBpZGVudGl0eSBiaXQgc2hpZnQgdG8gZW5zdXJlIGludGVnZXJcblx0cmV0dXJuIEZMT0FUNjRfVklFV1sgMCBdO1xufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRIaWdoV29yZDtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogU2V0IHRoZSBtb3JlIHNpZ25pZmljYW50IDMyIGJpdHMgb2YgYSBkb3VibGUtcHJlY2lzaW9uIGZsb2F0aW5nLXBvaW50IG51bWJlci5cbipcbiogQG1vZHVsZSBAc3RkbGliL251bWJlci1mbG9hdDY0LWJhc2Utc2V0LWhpZ2gtd29yZFxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgc2V0SGlnaFdvcmQgPSByZXF1aXJlKCAnQHN0ZGxpYi9udW1iZXItZmxvYXQ2NC1iYXNlLXNldC1oaWdoLXdvcmQnICk7XG4qXG4qIHZhciBoaWdoID0gNSA+Pj4gMDsgLy8gPT4gMCAwMDAwMDAwMDAwMCAwMDAwMDAwMDAwMDAwMDAwMDEwMVxuKlxuKiB2YXIgeSA9IHNldEhpZ2hXb3JkKCAzLjE0ZTIwMSwgaGlnaCApOyAvLyA9PiAwIDAwMDAwMDAwMDAwIDAwMDAwMDAwMDAwMDAwMDAwMTAxMTAwMTAwMTExMTAwMTAxMTAxMDExMDAwMTAwMDAwMTBcbiogLy8gcmV0dXJucyAxLjE4MzUwNTI4NzQ1ZS0zMTNcbipcbiogQGV4YW1wbGVcbiogdmFyIHNldEhpZ2hXb3JkID0gcmVxdWlyZSggJ0BzdGRsaWIvbnVtYmVyLWZsb2F0NjQtYmFzZS1zZXQtaGlnaC13b3JkJyApO1xuKiB2YXIgUElORiA9IHJlcXVpcmUoICdAc3RkbGliL2NvbnN0YW50cy1mbG9hdDY0LXBpbmYnICk7IC8vICA9PiAwIDExMTExMTExMTExIDAwMDAwMDAwMDAwMDAwMDAwMDAwIDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXG4qXG4qIHZhciBoaWdoID0gMTA3MjY5MzI0OCA+Pj4gMDsgLy8gPT4gMCAwMTExMTExMTExMSAwMDAwMDAwMDAwMDAwMDAwMDAwMFxuKlxuKiAvLyBTZXQgdGhlIGhpZ2hlciBvcmRlciBiaXRzIG9mIGAraW5maW5pdHlgIHRvIHJldHVybiBgMWA6XG4qIHZhciB5ID0gc2V0SGlnaFdvcmQoIFBJTkYsIGhpZ2ggKTsgPT4gMCAwMTExMTExMTExMSAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXG4qIC8vIHJldHVybnMgMS4wXG4qL1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBzZXRIaWdoV29yZCA9IHJlcXVpcmUoICcuL21haW4uanMnICk7XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNldEhpZ2hXb3JkO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBUaGUgYmlhcyBvZiBhIGRvdWJsZS1wcmVjaXNpb24gZmxvYXRpbmctcG9pbnQgbnVtYmVyJ3MgZXhwb25lbnQuXG4qXG4qIEBtb2R1bGUgQHN0ZGxpYi9jb25zdGFudHMtZmxvYXQ2NC1leHBvbmVudC1iaWFzXG4qIEB0eXBlIHtpbnRlZ2VyMzJ9XG4qXG4qIEBleGFtcGxlXG4qIHZhciBGTE9BVDY0X0VYUE9ORU5UX0JJQVMgPSByZXF1aXJlKCAnQHN0ZGxpYi9jb25zdGFudHMtZmxvYXQ2NC1leHBvbmVudC1iaWFzJyApO1xuKiAvLyByZXR1cm5zIDEwMjNcbiovXG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogQmlhcyBvZiBhIGRvdWJsZS1wcmVjaXNpb24gZmxvYXRpbmctcG9pbnQgbnVtYmVyJ3MgZXhwb25lbnQuXG4qXG4qICMjIE5vdGVzXG4qXG4qIFRoZSBiaWFzIGNhbiBiZSBjb21wdXRlZCB2aWFcbipcbiogYGBgdGV4XG4qIFxcbWF0aHJte2JpYXN9ID0gMl57ay0xfSAtIDFcbiogYGBgXG4qXG4qIHdoZXJlIFxcXFwoa1xcXFwpIGlzIHRoZSBudW1iZXIgb2YgYml0cyBpbiB0aGUgZXhwb25lbnQ7IGhlcmUsIFxcXFwoayA9IDExXFxcXCkuXG4qXG4qIEBjb25zdGFudFxuKiBAdHlwZSB7aW50ZWdlcjMyfVxuKiBAZGVmYXVsdCAxMDIzXG4qIEBzZWUgW0lFRUUgNzU0XXtAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JRUVFXzc1NC0xOTg1fVxuKi9cbnZhciBGTE9BVDY0X0VYUE9ORU5UX0JJQVMgPSAxMDIzfDA7IC8vIGFzbSB0eXBlIGFubm90YXRpb25cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gRkxPQVQ2NF9FWFBPTkVOVF9CSUFTO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4vKiBUaGlzIGlzIGEgZ2VuZXJhdGVkIGZpbGUuIERvIG5vdCBlZGl0IGRpcmVjdGx5LiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBFdmFsdWF0ZXMgYSBwb2x5bm9taWFsLlxuKlxuKiAjIyBOb3Rlc1xuKlxuKiAtICAgVGhlIGltcGxlbWVudGF0aW9uIHVzZXMgW0hvcm5lcidzIHJ1bGVdW2hvcm5lcnMtbWV0aG9kXSBmb3IgZWZmaWNpZW50IGNvbXB1dGF0aW9uLlxuKlxuKiBbaG9ybmVycy1tZXRob2RdOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ib3JuZXIlMjdzX21ldGhvZFxuKlxuKlxuKiBAcHJpdmF0ZVxuKiBAcGFyYW0ge251bWJlcn0geCAtIHZhbHVlIGF0IHdoaWNoIHRvIGV2YWx1YXRlIHRoZSBwb2x5bm9taWFsXG4qIEByZXR1cm5zIHtudW1iZXJ9IGV2YWx1YXRlZCBwb2x5bm9taWFsXG4qL1xuZnVuY3Rpb24gZXZhbHBvbHkoIHggKSB7XG5cdGlmICggeCA9PT0gMC4wICkge1xuXHRcdHJldHVybiAwLjU5OTk5OTk5OTk5OTk5NDY7XG5cdH1cblx0cmV0dXJuIDAuNTk5OTk5OTk5OTk5OTk0NiArICh4ICogKDAuNDI4NTcxNDI4NTc4NTUwMiArICh4ICogKDAuMzMzMzMzMzI5ODE4Mzc3NDMgKyAoeCAqICgwLjI3MjcyODEyMzgwODUzNCArICh4ICogKDAuMjMwNjYwNzQ1Nzc1NTYxNzUgKyAoeCAqIDAuMjA2OTc1MDE3ODAwMzM4NDIpKSkpKSkpKSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbWF4LWxlblxufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBldmFscG9seTtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKlxuKlxuKiAjIyBOb3RpY2VcbipcbiogVGhlIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2Ugd2VyZSBwYXJ0IG9mIHRoZSBvcmlnaW5hbCBpbXBsZW1lbnRhdGlvbiBhdmFpbGFibGUgYXMgcGFydCBvZiBbRnJlZUJTRF17QGxpbmsgaHR0cHM6Ly9zdm53ZWIuZnJlZWJzZC5vcmcvYmFzZS9yZWxlYXNlLzkuMy4wL2xpYi9tc3VuL3NyYy9zX3Bvdy5jfS4gVGhlIGltcGxlbWVudGF0aW9uIGZvbGxvd3MgdGhlIG9yaWdpbmFsLCBidXQgaGFzIGJlZW4gbW9kaWZpZWQgZm9yIEphdmFTY3JpcHQuXG4qXG4qIGBgYHRleHRcbiogQ29weXJpZ2h0IChDKSAyMDA0IGJ5IFN1biBNaWNyb3N5c3RlbXMsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogRGV2ZWxvcGVkIGF0IFN1blBybywgYSBTdW4gTWljcm9zeXN0ZW1zLCBJbmMuIGJ1c2luZXNzLlxuKiBQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQgZGlzdHJpYnV0ZSB0aGlzXG4qIHNvZnR3YXJlIGlzIGZyZWVseSBncmFudGVkLCBwcm92aWRlZCB0aGF0IHRoaXMgbm90aWNlXG4qIGlzIHByZXNlcnZlZC5cbiogYGBgXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGdldEhpZ2hXb3JkID0gcmVxdWlyZSggJ0BzdGRsaWIvbnVtYmVyLWZsb2F0NjQtYmFzZS1nZXQtaGlnaC13b3JkJyApO1xudmFyIHNldExvd1dvcmQgPSByZXF1aXJlKCAnQHN0ZGxpYi9udW1iZXItZmxvYXQ2NC1iYXNlLXNldC1sb3ctd29yZCcgKTtcbnZhciBzZXRIaWdoV29yZCA9IHJlcXVpcmUoICdAc3RkbGliL251bWJlci1mbG9hdDY0LWJhc2Utc2V0LWhpZ2gtd29yZCcgKTtcbnZhciBCSUFTID0gcmVxdWlyZSggJ0BzdGRsaWIvY29uc3RhbnRzLWZsb2F0NjQtZXhwb25lbnQtYmlhcycgKTtcbnZhciBwb2x5dmFsTCA9IHJlcXVpcmUoICcuL3BvbHl2YWxfbC5qcycgKTtcblxuXG4vLyBWQVJJQUJMRVMgLy9cblxuLy8gMHgwMDBmZmZmZiA9IDEwNDg1NzUgPT4gMCAwMDAwMDAwMDAwMCAxMTExMTExMTExMTExMTExMTExMVxudmFyIEhJR0hfU0lHTklGSUNBTkRfTUFTSyA9IDB4MDAwZmZmZmZ8MDsgLy8gYXNtIHR5cGUgYW5ub3RhdGlvblxuXG4vLyAweDAwMTAwMDAwID0gMTA0ODU3NiA9PiAwIDAwMDAwMDAwMDAxIDAwMDAwMDAwMDAwMDAwMDAwMDAwID0+IGJpYXNlZCBleHBvbmVudDogMSA9IC0xMDIyKzEwMjMgPT4gMl4tMTAyMlxudmFyIEhJR0hfTUlOX05PUk1BTF9FWFAgPSAweDAwMTAwMDAwfDA7IC8vIGFzbSB0eXBlIGFubm90YXRpb25cblxuLy8gMHgzZmYwMDAwMCA9IDEwNzI2OTMyNDggPT4gMCAwMTExMTExMTExMSAwMDAwMDAwMDAwMDAwMDAwMDAwMCA9PiBiaWFzZWQgZXhwb25lbnQ6IDEwMjMgPSAwKzEwMjMgPT4gMl4wID0gMVxudmFyIEhJR0hfQklBU0VEX0VYUF8wID0gMHgzZmYwMDAwMHwwOyAvLyBhc20gdHlwZSBhbm5vdGF0aW9uXG5cbi8vIDB4MjAwMDAwMDAgPSA1MzY4NzA5MTIgPT4gMCAwMTAwMDAwMDAwMCAwMDAwMDAwMDAwMDAwMDAwMDAwMCA9PiBiaWFzZWQgZXhwb25lbnQ6IDUxMiA9IC01MTErMTAyM1xudmFyIEhJR0hfQklBU0VEX0VYUF9ORUdfNTEyID0gMHgyMDAwMDAwMHwwOyAvLyBhc20gdHlwZSBhbm5vdGF0aW9uXG5cbi8vIDB4MDAwODAwMDAgPSA1MjQyODggPT4gMCAwMDAwMDAwMDAwMCAxMDAwMDAwMDAwMDAwMDAwMDAwMFxudmFyIEhJR0hfU0lHTklGSUNBTkRfSEFMRiA9IDB4MDAwODAwMDB8MDsgLy8gYXNtIHR5cGUgYW5ub3RhdGlvblxuXG4vLyBUT0RPOiBjb25zaWRlciBtYWtpbmcgYW4gZXh0ZXJuYWwgY29uc3RhbnRcbnZhciBISUdIX05VTV9TSUdOSUZJQ0FORF9CSVRTID0gMjB8MDsgLy8gYXNtIHR5cGUgYW5ub3RhdGlvblxuXG52YXIgVFdPNTMgPSA5MDA3MTk5MjU0NzQwOTkyLjA7XHQvLyAweDQzNDAwMDAwLCAweDAwMDAwMDAwXG5cbi8vIDIvKDMqTE4yKVxudmFyIENQID0gOS42MTc5NjY5MzkyNTk3NTU1NDMyOWUtMDE7IC8vIDB4M0ZFRUM3MDksIDB4REMzQTAzRkRcblxuLy8gKGZsb2F0KUNQXG52YXIgQ1BfSEkgPSA5LjYxNzk2NzAwOTU0NDM3MjU1ODU5ZS0wMTsgLy8gMHgzRkVFQzcwOSwgMHhFMDAwMDAwMFxuXG4vLyBMb3c6IENQX0hJXG52YXIgQ1BfTE8gPSAtNy4wMjg0NjE2NTA5NTI3NTgyNjUxNmUtMDk7IC8vIDB4QkUzRTJGRTAsIDB4MTQ1QjAxRjVcblxudmFyIEJQID0gW1xuXHQxLjAsXG5cdDEuNVxuXTtcbnZhciBEUF9ISSA9IFtcblx0MC4wLFxuXHQ1Ljg0OTYyNDg3MjIwNzY0MTYwMTU2ZS0wMSAvLyAweDNGRTJCODAzLCAweDQwMDAwMDAwXG5dO1xudmFyIERQX0xPID0gW1xuXHQwLjAsXG5cdDEuMzUwMDM5MjAyMTI5NzQ4OTcxMjhlLTA4IC8vIDB4M0U0Q0ZERUIsIDB4NDNDRkQwMDZcbl07XG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogQ29tcHV0ZXMgXFxcXChcXG9wZXJhdG9ybmFtZXtsb2cyfShheClcXFxcKS5cbipcbiogQHByaXZhdGVcbiogQHBhcmFtIHtBcnJheX0gb3V0IC0gb3V0cHV0IGFycmF5XG4qIEBwYXJhbSB7bnVtYmVyfSBheCAtIGFic29sdXRlIHZhbHVlIG9mIGB4YFxuKiBAcGFyYW0ge251bWJlcn0gYWh4IC0gaGlnaCB3b3JkIG9mIGBheGBcbiogQHJldHVybnMge0FycmF5fSBvdXRwdXQgYXJyYXkgY29udGFpbmluZyBhIHR1cGxlIGNvbXByaXNlZCBvZiBoaWdoIGFuZCBsb3cgcGFydHNcbipcbiogQGV4YW1wbGVcbiogdmFyIHQgPSBsb2cyYXgoIFsgMC4wLCAwLjAgXSwgOS4wLCAxMDc1OTcwMDQ4ICk7IC8vID0+IFsgdDEsIHQyIF1cbiogLy8gcmV0dXJucyBbIDMuMTY5OTIzNzgyMzQ4NjMzLCAwLjAwMDAwMTIxOTA5MzY3OTU1MDQwNzUgXVxuKi9cbmZ1bmN0aW9uIGxvZzJheCggb3V0LCBheCwgYWh4ICkge1xuXHR2YXIgdG1wO1xuXHR2YXIgc3M7IC8vIGBocyArIGxzYFxuXHR2YXIgczI7IC8vIGBzc2Agc3F1YXJlZFxuXHR2YXIgaHM7XG5cdHZhciBscztcblx0dmFyIGh0O1xuXHR2YXIgbHQ7XG5cdHZhciBicDsgLy8gYEJQYCBjb25zdGFudFxuXHR2YXIgZHA7IC8vIGBEUGAgY29uc3RhbnRcblx0dmFyIGhwO1xuXHR2YXIgbHA7XG5cdHZhciBoejtcblx0dmFyIGx6O1xuXHR2YXIgdDE7XG5cdHZhciB0Mjtcblx0dmFyIHQ7XG5cdHZhciByO1xuXHR2YXIgdTtcblx0dmFyIHY7XG5cdHZhciBuO1xuXHR2YXIgajtcblx0dmFyIGs7XG5cblx0biA9IDB8MDsgLy8gYXNtIHR5cGUgYW5ub3RhdGlvblxuXG5cdC8vIENoZWNrIGlmIGB4YCBpcyBzdWJub3JtYWwuLi5cblx0aWYgKCBhaHggPCBISUdIX01JTl9OT1JNQUxfRVhQICkge1xuXHRcdGF4ICo9IFRXTzUzO1xuXHRcdG4gLT0gNTN8MDsgLy8gYXNtIHR5cGUgYW5ub3RhdGlvblxuXHRcdGFoeCA9IGdldEhpZ2hXb3JkKCBheCApO1xuXHR9XG5cdC8vIEV4dHJhY3QgdGhlIHVuYmlhc2VkIGV4cG9uZW50IG9mIGB4YDpcblx0biArPSAoKGFoeCA+PiBISUdIX05VTV9TSUdOSUZJQ0FORF9CSVRTKSAtIEJJQVMpfDA7IC8vIGFzbSB0eXBlIGFubm90YXRpb25cblxuXHQvLyBJc29sYXRlIHRoZSBzaWduaWZpY2FuZCBiaXRzIG9mIGB4YDpcblx0aiA9IChhaHggJiBISUdIX1NJR05JRklDQU5EX01BU0spfDA7IC8vIGFzbSB0eXBlIGFubm90YXRpb25cblxuXHQvLyBOb3JtYWxpemUgYGFoeGAgYnkgc2V0dGluZyB0aGUgKGJpYXNlZCkgZXhwb25lbnQgdG8gYDEwMjNgOlxuXHRhaHggPSAoaiB8IEhJR0hfQklBU0VEX0VYUF8wKXwwOyAvLyBhc20gdHlwZSBhbm5vdGF0aW9uXG5cblx0Ly8gRGV0ZXJtaW5lIHRoZSBpbnRlcnZhbCBvZiBgfHh8YCBieSBjb21wYXJpbmcgc2lnbmlmaWNhbmQgYml0cy4uLlxuXG5cdC8vIHx4fCA8IHNxcnQoMy8yKVxuXHRpZiAoIGogPD0gMHgzOTg4RSApIHsgLy8gMCAwMDAwMDAwMDAwMCAwMDExMTAwMTEwMDAxMDAwMTExMFxuXHRcdGsgPSAwO1xuXHR9XG5cdC8vIHx4fCA8IHNxcnQoMylcblx0ZWxzZSBpZiAoIGogPCAweEJCNjdBICkgeyAvLyAwIDAwMDAwMDAwMDAwIDEwMTExMDExMDExMDAxMTExMDEwXG5cdFx0ayA9IDE7XG5cdH1cblx0Ly8gfHh8ID49IHNxcnQoMylcblx0ZWxzZSB7XG5cdFx0ayA9IDA7XG5cdFx0biArPSAxfDA7IC8vIGFzbSB0eXBlIGFubm90YXRpb25cblx0XHRhaHggLT0gSElHSF9NSU5fTk9STUFMX0VYUDtcblx0fVxuXHQvLyBMb2FkIHRoZSBub3JtYWxpemVkIGhpZ2ggd29yZCBpbnRvIGB8eHxgOlxuXHRheCA9IHNldEhpZ2hXb3JkKCBheCwgYWh4ICk7XG5cblx0Ly8gQ29tcHV0ZSBgc3MgPSBocyArIGxzID0gKHgtMSkvKHgrMSlgIG9yIGAoeC0xLjUpLyh4KzEuNSlgOlxuXHRicCA9IEJQWyBrIF07IC8vIEJQWzBdID0gMS4wLCBCUFsxXSA9IDEuNVxuXHR1ID0gYXggLSBicDsgLy8gKHgtMSkgfHwgKHgtMS41KVxuXHR2ID0gMS4wIC8gKGF4ICsgYnApOyAvLyAxLyh4KzEpIHx8IDEvKHgrMS41KVxuXHRzcyA9IHUgKiB2O1xuXHRocyA9IHNldExvd1dvcmQoIHNzLCAwICk7IC8vIHNldCBhbGwgbG93IHdvcmQgKGxlc3Mgc2lnbmlmaWNhbnQgc2lnbmlmaWNhbmQpIGJpdHMgdG8gMHNcblxuXHQvLyBDb21wdXRlIGBodCA9IGF4ICsgYnBgICh2aWEgbWFuaXB1bGF0aW9uLCBpLmUuLCBiaXQgZmxpcHBpbmcsIG9mIHRoZSBoaWdoIHdvcmQpOlxuXHR0bXAgPSAoKGFoeD4+MSkgfCBISUdIX0JJQVNFRF9FWFBfTkVHXzUxMikgKyBISUdIX1NJR05JRklDQU5EX0hBTEY7XG5cdHRtcCArPSAoayA8PCAxOCk7IC8vIGAoazw8MTgpYCBjYW4gYmUgY29uc2lkZXJlZCB0aGUgd29yZCBlcXVpdmFsZW50IG9mIGAxLjBgIG9yIGAxLjVgXG5cdGh0ID0gc2V0SGlnaFdvcmQoIDAuMCwgdG1wICk7XG5cdGx0ID0gYXggLSAoaHQgLSBicCk7XG5cdGxzID0gdiAqICggKCB1IC0gKGhzKmh0KSApIC0gKCBocypsdCApICk7XG5cblx0Ly8gQ29tcHV0ZSBgbG9nKGF4KWAuLi5cblxuXHRzMiA9IHNzICogc3M7XG5cdHIgPSBzMiAqIHMyICogcG9seXZhbEwoIHMyICk7XG5cdHIgKz0gbHMgKiAoaHMgKyBzcyk7XG5cdHMyID0gaHMgKiBocztcblx0aHQgPSAzLjAgKyBzMiArIHI7XG5cdGh0ID0gc2V0TG93V29yZCggaHQsIDAgKTtcblx0bHQgPSByIC0gKChodC0zLjApIC0gczIpO1xuXG5cdC8vIHUrdiA9IHNzKigxKy4uLik6XG5cdHUgPSBocyAqIGh0O1xuXHR2ID0gKCBscypodCApICsgKCBsdCpzcyApO1xuXG5cdC8vIDIvKDNMTjIpICogKHNzKy4uLik6XG5cdGhwID0gdSArIHY7XG5cdGhwID0gc2V0TG93V29yZCggaHAsIDAgKTtcblx0bHAgPSB2IC0gKGhwIC0gdSk7XG5cdGh6ID0gQ1BfSEkgKiBocDsgLy8gQ1BfSEkrQ1BfTE8gPSAyLygzKkxOMilcblx0bHogPSAoIENQX0xPKmhwICkgKyAoIGxwKkNQICkgKyBEUF9MT1sgayBdO1xuXG5cdC8vIGxvZzIoYXgpID0gKHNzKy4uLikqMi8oMypMTjIpID0gbiArIGRwICsgaHogKyBselxuXHRkcCA9IERQX0hJWyBrIF07XG5cdHQgPSBuO1xuXHR0MSA9ICgoaHorbHopICsgZHApICsgdDsgLy8gbG9nMihheClcblx0dDEgPSBzZXRMb3dXb3JkKCB0MSwgMCApO1xuXHR0MiA9IGx6IC0gKCgodDEtdCkgLSBkcCkgLSBoeik7XG5cblx0b3V0WyAwIF0gPSB0MTtcblx0b3V0WyAxIF0gPSB0Mjtcblx0cmV0dXJuIG91dDtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gbG9nMmF4O1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4vKiBUaGlzIGlzIGEgZ2VuZXJhdGVkIGZpbGUuIERvIG5vdCBlZGl0IGRpcmVjdGx5LiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBFdmFsdWF0ZXMgYSBwb2x5bm9taWFsLlxuKlxuKiAjIyBOb3Rlc1xuKlxuKiAtICAgVGhlIGltcGxlbWVudGF0aW9uIHVzZXMgW0hvcm5lcidzIHJ1bGVdW2hvcm5lcnMtbWV0aG9kXSBmb3IgZWZmaWNpZW50IGNvbXB1dGF0aW9uLlxuKlxuKiBbaG9ybmVycy1tZXRob2RdOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ib3JuZXIlMjdzX21ldGhvZFxuKlxuKlxuKiBAcHJpdmF0ZVxuKiBAcGFyYW0ge251bWJlcn0geCAtIHZhbHVlIGF0IHdoaWNoIHRvIGV2YWx1YXRlIHRoZSBwb2x5bm9taWFsXG4qIEByZXR1cm5zIHtudW1iZXJ9IGV2YWx1YXRlZCBwb2x5bm9taWFsXG4qL1xuZnVuY3Rpb24gZXZhbHBvbHkoIHggKSB7XG5cdGlmICggeCA9PT0gMC4wICkge1xuXHRcdHJldHVybiAwLjU7XG5cdH1cblx0cmV0dXJuIDAuNSArICh4ICogKC0wLjMzMzMzMzMzMzMzMzMzMzMgKyAoeCAqIDAuMjUpKSk7XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV2YWxwb2x5O1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qXG4qXG4qICMjIE5vdGljZVxuKlxuKiBUaGUgZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZSB3ZXJlIHBhcnQgb2YgdGhlIG9yaWdpbmFsIGltcGxlbWVudGF0aW9uIGF2YWlsYWJsZSBhcyBwYXJ0IG9mIFtGcmVlQlNEXXtAbGluayBodHRwczovL3N2bndlYi5mcmVlYnNkLm9yZy9iYXNlL3JlbGVhc2UvOS4zLjAvbGliL21zdW4vc3JjL3NfcG93LmN9LiBUaGUgaW1wbGVtZW50YXRpb24gZm9sbG93cyB0aGUgb3JpZ2luYWwsIGJ1dCBoYXMgYmVlbiBtb2RpZmllZCBmb3IgSmF2YVNjcmlwdC5cbipcbiogYGBgdGV4dFxuKiBDb3B5cmlnaHQgKEMpIDIwMDQgYnkgU3VuIE1pY3Jvc3lzdGVtcywgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBEZXZlbG9wZWQgYXQgU3VuUHJvLCBhIFN1biBNaWNyb3N5c3RlbXMsIEluYy4gYnVzaW5lc3MuXG4qIFBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZCBkaXN0cmlidXRlIHRoaXNcbiogc29mdHdhcmUgaXMgZnJlZWx5IGdyYW50ZWQsIHByb3ZpZGVkIHRoYXQgdGhpcyBub3RpY2VcbiogaXMgcHJlc2VydmVkLlxuKiBgYGBcbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgc2V0TG93V29yZCA9IHJlcXVpcmUoICdAc3RkbGliL251bWJlci1mbG9hdDY0LWJhc2Utc2V0LWxvdy13b3JkJyApO1xudmFyIHBvbHl2YWxXID0gcmVxdWlyZSggJy4vcG9seXZhbF93LmpzJyApO1xuXG5cbi8vIFZBUklBQkxFUyAvL1xuXG4vLyAxL0xOMlxudmFyIElOVl9MTjIgPSAxLjQ0MjY5NTA0MDg4ODk2MzM4NzAwZSswMDsgLy8gMHgzRkY3MTU0NywgMHg2NTJCODJGRVxuXG4vLyBIaWdoICgyNCBiaXRzKTogMS9MTjJcbnZhciBJTlZfTE4yX0hJID0gMS40NDI2OTUwMjE2MjkzMzM0OTYwOWUrMDA7IC8vIDB4M0ZGNzE1NDcsIDB4NjAwMDAwMDBcblxuLy8gTG93OiAxL0xOMlxudmFyIElOVl9MTjJfTE8gPSAxLjkyNTk2Mjk5MTEyNjYxNzQ2ODg3ZS0wODsgLy8gMHgzRTU0QUUwQiwgMHhGODVEREY0NFxuXG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIENvbXB1dGVzIFxcXFwoXFxvcGVyYXRvcm5hbWV7bG9nfSh4KVxcXFwpIGFzc3VtaW5nIFxcXFwofDEteHxcXFxcKSBpcyBzbWFsbCBhbmQgdXNpbmcgdGhlIGFwcHJveGltYXRpb24gXFxcXCh4IC0geF4yLzIgKyB4XjMvMyAtIHheNC80XFxcXCkuXG4qXG4qIEBwcml2YXRlXG4qIEBwYXJhbSB7QXJyYXl9IG91dCAtIG91dHB1dCBhcnJheVxuKiBAcGFyYW0ge251bWJlcn0gYXggLSBhYnNvbHV0ZSB2YWx1ZSBvZiBgeGBcbiogQHJldHVybnMge0FycmF5fSBvdXRwdXQgYXJyYXkgY29udGFpbmluZyBhIHR1cGxlIGNvbXByaXNlZCBvZiBoaWdoIGFuZCBsb3cgcGFydHNcbipcbiogQGV4YW1wbGVcbiogdmFyIHQgPSBsb2d4KCBbIDAuMCwgMC4wIF0sIDkuMCApOyAvLyA9PiBbIHQxLCB0MiBdXG4qIC8vIHJldHVybnMgWyAtMTI2NS43MjM2MzI4MTI1LCAtMC4wMDA4MTYzOTQwODQwNDA0MzkzIF1cbiovXG5mdW5jdGlvbiBsb2d4KCBvdXQsIGF4ICkge1xuXHR2YXIgdDI7XG5cdHZhciB0MTtcblx0dmFyIHQ7XG5cdHZhciB3O1xuXHR2YXIgdTtcblx0dmFyIHY7XG5cblx0dCA9IGF4IC0gMS4wOyAvLyBgdGAgaGFzIGAyMGAgdHJhaWxpbmcgemVyb3Ncblx0dyA9IHQgKiB0ICogcG9seXZhbFcoIHQgKTtcblx0dSA9IElOVl9MTjJfSEkgKiB0OyAvLyBgSU5WX0xOMl9ISWAgaGFzIGAyMWAgc2lnbmlmaWNhbnQgYml0c1xuXHR2ID0gKCB0KklOVl9MTjJfTE8gKSAtICggdypJTlZfTE4yICk7XG5cdHQxID0gdSArIHY7XG5cdHQxID0gc2V0TG93V29yZCggdDEsIDAgKTtcblx0dDIgPSB2IC0gKHQxIC0gdSk7XG5cblx0b3V0WyAwIF0gPSB0MTtcblx0b3V0WyAxIF0gPSB0Mjtcblx0cmV0dXJuIG91dDtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gbG9neDtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogVGhlIG1heGltdW0gYmlhc2VkIGJhc2UgMiBleHBvbmVudCBmb3IgYSBkb3VibGUtcHJlY2lzaW9uIGZsb2F0aW5nLXBvaW50IG51bWJlci5cbipcbiogQG1vZHVsZSBAc3RkbGliL2NvbnN0YW50cy1mbG9hdDY0LW1heC1iYXNlMi1leHBvbmVudFxuKiBAdHlwZSB7aW50ZWdlcjMyfVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgRkxPQVQ2NF9NQVhfQkFTRTJfRVhQT05FTlQgPSByZXF1aXJlKCAnQHN0ZGxpYi9jb25zdGFudHMtZmxvYXQ2NC1tYXgtYmFzZTItZXhwb25lbnQnICk7XG4qIC8vIHJldHVybnMgMTAyM1xuKi9cblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBUaGUgbWF4aW11bSBiaWFzZWQgYmFzZSAyIGV4cG9uZW50IGZvciBhIGRvdWJsZS1wcmVjaXNpb24gZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxuKlxuKiBgYGB0ZXh0XG4qIDExMTExMTExMTEwID0+IDIwNDYgLSBCSUFTID0gMTAyM1xuKiBgYGBcbipcbiogd2hlcmUgYEJJQVMgPSAxMDIzYC5cbipcbiogQGNvbnN0YW50XG4qIEB0eXBlIHtpbnRlZ2VyMzJ9XG4qIEBkZWZhdWx0IDEwMjNcbiogQHNlZSBbSUVFRSA3NTRde0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lFRUVfNzU0LTE5ODV9XG4qL1xudmFyIEZMT0FUNjRfTUFYX0JBU0UyX0VYUE9ORU5UID0gMTAyM3wwOyAvLyBhc20gdHlwZSBhbm5vdGF0aW9uXG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZMT0FUNjRfTUFYX0JBU0UyX0VYUE9ORU5UO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBUaGUgbWF4aW11bSBiaWFzZWQgYmFzZSAyIGV4cG9uZW50IGZvciBhIHN1Ym5vcm1hbCBkb3VibGUtcHJlY2lzaW9uIGZsb2F0aW5nLXBvaW50IG51bWJlci5cbipcbiogQG1vZHVsZSBAc3RkbGliL2NvbnN0YW50cy1mbG9hdDY0LW1heC1iYXNlMi1leHBvbmVudC1zdWJub3JtYWxcbiogQHR5cGUge2ludGVnZXIzMn1cbipcbiogQGV4YW1wbGVcbiogdmFyIEZMT0FUNjRfTUFYX0JBU0UyX0VYUE9ORU5UX1NVQk5PUk1BTCA9IHJlcXVpcmUoICdAc3RkbGliL2NvbnN0YW50cy1mbG9hdDY0LW1heC1iYXNlMi1leHBvbmVudC1zdWJub3JtYWwnICk7XG4qIC8vIHJldHVybnMgLTEwMjNcbiovXG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogVGhlIG1heGltdW0gYmlhc2VkIGJhc2UgMiBleHBvbmVudCBmb3IgYSBzdWJub3JtYWwgZG91YmxlLXByZWNpc2lvbiBmbG9hdGluZy1wb2ludCBudW1iZXIuXG4qXG4qIGBgYHRleHRcbiogMDAwMDAwMDAwMDAgPT4gMCAtIEJJQVMgPSAtMTAyM1xuKiBgYGBcbipcbiogd2hlcmUgYEJJQVMgPSAxMDIzYC5cbipcbiogQGNvbnN0YW50XG4qIEB0eXBlIHtpbnRlZ2VyMzJ9XG4qIEBkZWZhdWx0IC0xMDIzXG4qIEBzZWUgW0lFRUUgNzU0XXtAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JRUVFXzc1NC0xOTg1fVxuKi9cbnZhciBGTE9BVDY0X01BWF9CQVNFMl9FWFBPTkVOVF9TVUJOT1JNQUwgPSAtMTAyM3wwOyAvLyBhc20gdHlwZSBhbm5vdGF0aW9uXG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZMT0FUNjRfTUFYX0JBU0UyX0VYUE9ORU5UX1NVQk5PUk1BTDtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogVGhlIG1pbmltdW0gYmlhc2VkIGJhc2UgMiBleHBvbmVudCBmb3IgYSBzdWJub3JtYWwgZG91YmxlLXByZWNpc2lvbiBmbG9hdGluZy1wb2ludCBudW1iZXIuXG4qXG4qIEBtb2R1bGUgQHN0ZGxpYi9jb25zdGFudHMtZmxvYXQ2NC1taW4tYmFzZTItZXhwb25lbnQtc3Vibm9ybWFsXG4qIEB0eXBlIHtpbnRlZ2VyMzJ9XG4qXG4qIEBleGFtcGxlXG4qIHZhciBGTE9BVDY0X01JTl9CQVNFMl9FWFBPTkVOVF9TVUJOT1JNQUwgPSByZXF1aXJlKCAnQHN0ZGxpYi9jb25zdGFudHMtZmxvYXQ2NC1taW4tYmFzZTItZXhwb25lbnQtc3Vibm9ybWFsJyApO1xuKiAvLyByZXR1cm5zIC0xMDc0XG4qL1xuXG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIFRoZSBtaW5pbXVtIGJpYXNlZCBiYXNlIDIgZXhwb25lbnQgZm9yIGEgc3Vibm9ybWFsIGRvdWJsZS1wcmVjaXNpb24gZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxuKlxuKiBgYGB0ZXh0XG4qIC0oQklBUysoNTItMSkpID0gLSgxMDIzKzUxKSA9IC0xMDc0XG4qIGBgYFxuKlxuKiB3aGVyZSBgQklBUyA9IDEwMjNgIGFuZCBgNTJgIGlzIHRoZSBudW1iZXIgb2YgZGlnaXRzIGluIHRoZSBzaWduaWZpY2FuZC5cbipcbiogQGNvbnN0YW50XG4qIEB0eXBlIHtpbnRlZ2VyMzJ9XG4qIEBkZWZhdWx0IC0xMDc0XG4qIEBzZWUgW0lFRUUgNzU0XXtAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JRUVFXzc1NC0xOTg1fVxuKi9cbnZhciBGTE9BVDY0X01JTl9CQVNFMl9FWFBPTkVOVF9TVUJOT1JNQUwgPSAtMTA3NHwwOyAvLyBhc20gdHlwZSBhbm5vdGF0aW9uXG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZMT0FUNjRfTUlOX0JBU0UyX0VYUE9ORU5UX1NVQk5PUk1BTDtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogU21hbGxlc3QgcG9zaXRpdmUgZG91YmxlLXByZWNpc2lvbiBmbG9hdGluZy1wb2ludCBub3JtYWwgbnVtYmVyLlxuKlxuKiBAbW9kdWxlIEBzdGRsaWIvY29uc3RhbnRzLWZsb2F0NjQtc21hbGxlc3Qtbm9ybWFsXG4qIEB0eXBlIHtudW1iZXJ9XG4qXG4qIEBleGFtcGxlXG4qIHZhciBGTE9BVDY0X1NNQUxMRVNUX05PUk1BTCA9IHJlcXVpcmUoICdAc3RkbGliL2NvbnN0YW50cy1mbG9hdDY0LXNtYWxsZXN0LW5vcm1hbCcgKTtcbiogLy8gcmV0dXJucyAyLjIyNTA3Mzg1ODUwNzIwMTRlLTMwOFxuKi9cblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBUaGUgc21hbGxlc3QgcG9zaXRpdmUgZG91YmxlLXByZWNpc2lvbiBmbG9hdGluZy1wb2ludCBub3JtYWwgbnVtYmVyLlxuKlxuKiAjIyBOb3Rlc1xuKlxuKiBUaGUgbnVtYmVyIGhhcyB0aGUgdmFsdWVcbipcbiogYGBgdGV4XG4qIFxcZnJhY3sxfXsyXnsxMDIzLTF9fVxuKiBgYGBcbipcbiogd2hpY2ggY29ycmVzcG9uZHMgdG8gdGhlIGJpdCBzZXF1ZW5jZVxuKlxuKiBgYGBiaW5hcnlzdHJpbmdcbiogMCAwMDAwMDAwMDAwMSAwMDAwMDAwMDAwMDAwMDAwMDAwMCAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFxuKiBgYGBcbipcbiogQGNvbnN0YW50XG4qIEB0eXBlIHtudW1iZXJ9XG4qIEBkZWZhdWx0IDIuMjI1MDczODU4NTA3MjAxNGUtMzA4XG4qIEBzZWUgW0lFRUUgNzU0XXtAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JRUVFXzc1NC0xOTg1fVxuKi9cbnZhciBGTE9BVDY0X1NNQUxMRVNUX05PUk1BTCA9IDIuMjI1MDczODU4NTA3MjAxNGUtMzA4O1xuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBGTE9BVDY0X1NNQUxMRVNUX05PUk1BTDtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBGTE9BVDY0X1NNQUxMRVNUX05PUk1BTCA9IHJlcXVpcmUoICdAc3RkbGliL2NvbnN0YW50cy1mbG9hdDY0LXNtYWxsZXN0LW5vcm1hbCcgKTtcbnZhciBpc0luZmluaXRlID0gcmVxdWlyZSggJ0BzdGRsaWIvbWF0aC1iYXNlLWFzc2VydC1pcy1pbmZpbml0ZScgKTtcbnZhciBpc25hbiA9IHJlcXVpcmUoICdAc3RkbGliL21hdGgtYmFzZS1hc3NlcnQtaXMtbmFuJyApO1xudmFyIGFicyA9IHJlcXVpcmUoICdAc3RkbGliL21hdGgtYmFzZS1zcGVjaWFsLWFicycgKTtcblxuXG4vLyBWQVJJQUJMRVMgLy9cblxuLy8gKDE8PDUyKVxudmFyIFNDQUxBUiA9IDQ1MDM1OTk2MjczNzA0OTY7XG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogUmV0dXJucyBhIG5vcm1hbCBudW1iZXIgYHlgIGFuZCBleHBvbmVudCBgZXhwYCBzYXRpc2Z5aW5nIFxcXFwoeCA9IHkgXFxjZG90IDJeXFxtYXRocm17ZXhwfVxcXFwpLlxuKlxuKiBAcHJpdmF0ZVxuKiBAcGFyYW0geyhBcnJheXxUeXBlZEFycmF5fE9iamVjdCl9IG91dCAtIG91dHB1dCBhcnJheVxuKiBAcGFyYW0ge251bWJlcn0geCAtIGlucHV0IHZhbHVlXG4qIEByZXR1cm5zIHsoQXJyYXl8VHlwZWRBcnJheXxPYmplY3QpfSBvdXRwdXQgYXJyYXlcbipcbiogQGV4YW1wbGVcbiogdmFyIHBvdyA9IHJlcXVpcmUoICdAc3RkbGliL21hdGgtYmFzZS1zcGVjaWFsLXBvdycgKTtcbipcbiogdmFyIG91dCA9IG5vcm1hbGl6ZSggWyAwLjAsIDAgXSwgMy4xNGUtMzE5ICk7XG4qIC8vIHJldHVybnMgWyAxLjQxNDEyMzQ0MDAzNTY2NjhlLTMwMywgLTUyIF1cbipcbiogdmFyIHkgPSBvdXRbIDAgXTtcbiogdmFyIGV4cCA9IG91dFsgMSBdO1xuKlxuKiB2YXIgYm9vbCA9ICggeSpwb3coMi4wLGV4cCkgPT09IDMuMTRlLTMxOSApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogQGV4YW1wbGVcbiogdmFyIG91dCA9IG5vcm1hbGl6ZSggWyAwLjAsIDAgXSwgMC4wICk7XG4qIC8vIHJldHVybnMgWyAwLjAsIDAgXTtcbipcbiogQGV4YW1wbGVcbiogdmFyIG91dCA9IG5vcm1hbGl6ZSggWyAwLjAsIDAgXSwgSW5maW5pdHkgKTtcbiogLy8gcmV0dXJucyBbIEluZmluaXR5LCAwIF1cbipcbiogQGV4YW1wbGVcbiogdmFyIG91dCA9IG5vcm1hbGl6ZSggWyAwLjAsIDAgXSwgLUluZmluaXR5ICk7XG4qIC8vIHJldHVybnMgWyAtSW5maW5pdHksIDAgXVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgb3V0ID0gbm9ybWFsaXplKCBbIDAuMCwgMCBdLCBOYU4gKTtcbiogLy8gcmV0dXJucyBbIE5hTiwgMCBdXG4qL1xuZnVuY3Rpb24gbm9ybWFsaXplKCBvdXQsIHggKSB7XG5cdGlmICggaXNuYW4oIHggKSB8fCBpc0luZmluaXRlKCB4ICkgKSB7XG5cdFx0b3V0WyAwIF0gPSB4O1xuXHRcdG91dFsgMSBdID0gMDtcblx0XHRyZXR1cm4gb3V0O1xuXHR9XG5cdGlmICggeCAhPT0gMC4wICYmIGFicyggeCApIDwgRkxPQVQ2NF9TTUFMTEVTVF9OT1JNQUwgKSB7XG5cdFx0b3V0WyAwIF0gPSB4ICogU0NBTEFSO1xuXHRcdG91dFsgMSBdID0gLTUyO1xuXHRcdHJldHVybiBvdXQ7XG5cdH1cblx0b3V0WyAwIF0gPSB4O1xuXHRvdXRbIDEgXSA9IDA7XG5cdHJldHVybiBvdXQ7XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5vcm1hbGl6ZTtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBmY24gPSByZXF1aXJlKCAnLi9ub3JtYWxpemUuanMnICk7XG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogUmV0dXJucyBhIG5vcm1hbCBudW1iZXIgYHlgIGFuZCBleHBvbmVudCBgZXhwYCBzYXRpc2Z5aW5nIFxcXFwoeCA9IHkgXFxjZG90IDJeXFxtYXRocm17ZXhwfVxcXFwpLlxuKlxuKiBAcGFyYW0geyhBcnJheXxUeXBlZEFycmF5fE9iamVjdCl9IFtvdXRdIC0gb3V0cHV0IGFycmF5XG4qIEBwYXJhbSB7bnVtYmVyfSB4IC0gaW5wdXQgdmFsdWVcbiogQHJldHVybnMgeyhBcnJheXxUeXBlZEFycmF5fE9iamVjdCl9IG91dHB1dCBhcnJheVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgcG93ID0gcmVxdWlyZSggJ0BzdGRsaWIvbWF0aC1iYXNlLXNwZWNpYWwtcG93JyApO1xuKlxuKiB2YXIgb3V0ID0gbm9ybWFsaXplKCBbIDAuMCwgMCBdLCAzLjE0ZS0zMTkgKTtcbiogLy8gcmV0dXJucyBbIDEuNDE0MTIzNDQwMDM1NjY2OGUtMzAzLCAtNTIgXVxuKlxuKiB2YXIgeSA9IG91dFsgMCBdO1xuKiB2YXIgZXhwID0gb3V0WyAxIF07XG4qXG4qIHZhciBib29sID0gKCB5KnBvdygyLjAsZXhwKSA9PT0gMy4xNGUtMzE5ICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgRmxvYXQ2NEFycmF5ID0gcmVxdWlyZSggJ0BzdGRsaWIvYXJyYXktZmxvYXQ2NCcgKTtcbiogdmFyIHBvdyA9IHJlcXVpcmUoICdAc3RkbGliL21hdGgtYmFzZS1zcGVjaWFsLXBvdycgKTtcbipcbiogdmFyIG91dCA9IG5ldyBGbG9hdDY0QXJyYXkoIDIgKTtcbipcbiogdmFyIHYgPSBub3JtYWxpemUoIG91dCwgMy4xNGUtMzE5ICk7XG4qIC8vIHJldHVybnMgPEZsb2F0NjRBcnJheT5bIDEuNDE0MTIzNDQwMDM1NjY2OGUtMzAzLCAtNTIgXVxuKlxuKiB2YXIgYm9vbCA9ICggdiA9PT0gb3V0ICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgb3V0ID0gbm9ybWFsaXplKCBbIDAuMCwgMCBdLCAwLjAgKTtcbiogLy8gcmV0dXJucyBbIDAuMCwgMCBdXG4qXG4qIEBleGFtcGxlXG4qIHZhciBvdXQgPSBub3JtYWxpemUoIFsgMC4wLCAwIF0sIEluZmluaXR5ICk7XG4qIC8vIHJldHVybnMgWyBJbmZpbml0eSwgMCBdXG4qXG4qIEBleGFtcGxlXG4qIHZhciBvdXQgPSBub3JtYWxpemUoIFsgMC4wLCAwIF0sIC1JbmZpbml0eSApO1xuKiAvLyByZXR1cm5zIFsgLUluZmluaXR5LCAwIF1cbipcbiogQGV4YW1wbGVcbiogdmFyIG91dCA9IG5vcm1hbGl6ZSggWyAwLjAsIDAgXSwgTmFOICk7XG4qIC8vIHJldHVybnMgWyBOYU4sIDAgXVxuKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZSggb3V0LCB4ICkge1xuXHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgKSB7XG5cdFx0cmV0dXJuIGZjbiggWyAwLjAsIDAgXSwgb3V0ICk7XG5cdH1cblx0cmV0dXJuIGZjbiggb3V0LCB4ICk7XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5vcm1hbGl6ZTtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogUmV0dXJuIGEgbm9ybWFsIG51bWJlciBgeWAgYW5kIGV4cG9uZW50IGBleHBgIHNhdGlzZnlpbmcgXFxcXCh4ID0geSBcXGNkb3QgMl5cXG1hdGhybXtleHB9XFxcXCkuXG4qXG4qIEBtb2R1bGUgQHN0ZGxpYi9udW1iZXItZmxvYXQ2NC1iYXNlLW5vcm1hbGl6ZVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgbm9ybWFsaXplID0gcmVxdWlyZSggJ0BzdGRsaWIvbnVtYmVyLWZsb2F0NjQtYmFzZS1ub3JtYWxpemUnICk7XG4qIHZhciBwb3cgPSByZXF1aXJlKCAnQHN0ZGxpYi9tYXRoLWJhc2Utc3BlY2lhbC1wb3cnICk7XG4qXG4qIHZhciBvdXQgPSBub3JtYWxpemUoIDMuMTRlLTMxOSApO1xuKiAvLyByZXR1cm5zIFsgMS40MTQxMjM0NDAwMzU2NjY4ZS0zMDMsIC01MiBdXG4qXG4qIHZhciB5ID0gb3V0WyAwIF07XG4qIHZhciBleHAgPSBvdXRbIDEgXTtcbipcbiogdmFyIGJvb2wgPSAoIHkqcG93KDIuMCxleHApID09PSAzLjE0ZS0zMTkgKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBGbG9hdDY0QXJyYXkgPSByZXF1aXJlKCAnQHN0ZGxpYi9hcnJheS1mbG9hdDY0JyApO1xuKiB2YXIgbm9ybWFsaXplID0gcmVxdWlyZSggJ0BzdGRsaWIvbnVtYmVyLWZsb2F0NjQtYmFzZS1ub3JtYWxpemUnICk7XG4qXG4qIHZhciBvdXQgPSBuZXcgRmxvYXQ2NEFycmF5KCAyICk7XG4qXG4qIHZhciB2ID0gbm9ybWFsaXplKCBvdXQsIDMuMTRlLTMxOSApO1xuKiAvLyByZXR1cm5zIDxGbG9hdDY0QXJyYXk+WyAxLjQxNDEyMzQ0MDAzNTY2NjhlLTMwMywgLTUyIF1cbipcbiogdmFyIGJvb2wgPSAoIHYgPT09IG91dCApO1xuKiAvLyByZXR1cm5zIHRydWVcbiovXG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIG5vcm1hbGl6ZSA9IHJlcXVpcmUoICcuL21haW4uanMnICk7XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5vcm1hbGl6ZTtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogSGlnaCB3b3JkIG1hc2sgZm9yIHRoZSBleHBvbmVudCBvZiBhIGRvdWJsZS1wcmVjaXNpb24gZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxuKlxuKiBAbW9kdWxlIEBzdGRsaWIvY29uc3RhbnRzLWZsb2F0NjQtaGlnaC13b3JkLWV4cG9uZW50LW1hc2tcbiogQHR5cGUge3VpbnRlZ2VyMzJ9XG4qXG4qIEBleGFtcGxlXG4qIHZhciBGTE9BVDY0X0hJR0hfV09SRF9FWFBPTkVOVF9NQVNLID0gcmVxdWlyZSggJ0BzdGRsaWIvY29uc3RhbnRzLWZsb2F0NjQtaGlnaC13b3JkLWV4cG9uZW50LW1hc2snICk7XG4qIC8vIHJldHVybnMgMjE0NjQzNTA3MlxuKi9cblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBIaWdoIHdvcmQgbWFzayBmb3IgdGhlIGV4cG9uZW50IG9mIGEgZG91YmxlLXByZWNpc2lvbiBmbG9hdGluZy1wb2ludCBudW1iZXIuXG4qXG4qICMjIE5vdGVzXG4qXG4qIFRoZSBoaWdoIHdvcmQgbWFzayBmb3IgdGhlIGV4cG9uZW50IG9mIGEgZG91YmxlLXByZWNpc2lvbiBmbG9hdGluZy1wb2ludCBudW1iZXIgaXMgYW4gdW5zaWduZWQgMzItYml0IGludGVnZXIgd2l0aCB0aGUgdmFsdWUgXFxcXCggMjE0NjQzNTA3MiBcXFxcKSwgd2hpY2ggY29ycmVzcG9uZHMgdG8gdGhlIGJpdCBzZXF1ZW5jZVxuKlxuKiBgYGBiaW5hcnlzdHJpbmdcbiogMCAxMTExMTExMTExMSAwMDAwMDAwMDAwMDAwMDAwMDAwMFxuKiBgYGBcbipcbiogQGNvbnN0YW50XG4qIEB0eXBlIHt1aW50ZWdlcjMyfVxuKiBAZGVmYXVsdCAweDdmZjAwMDAwXG4qIEBzZWUgW0lFRUUgNzU0XXtAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JRUVFXzc1NC0xOTg1fVxuKi9cbnZhciBGTE9BVDY0X0hJR0hfV09SRF9FWFBPTkVOVF9NQVNLID0gMHg3ZmYwMDAwMDtcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gRkxPQVQ2NF9ISUdIX1dPUkRfRVhQT05FTlRfTUFTSztcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBnZXRIaWdoV29yZCA9IHJlcXVpcmUoICdAc3RkbGliL251bWJlci1mbG9hdDY0LWJhc2UtZ2V0LWhpZ2gtd29yZCcgKTtcbnZhciBFWFBfTUFTSyA9IHJlcXVpcmUoICdAc3RkbGliL2NvbnN0YW50cy1mbG9hdDY0LWhpZ2gtd29yZC1leHBvbmVudC1tYXNrJyApO1xudmFyIEJJQVMgPSByZXF1aXJlKCAnQHN0ZGxpYi9jb25zdGFudHMtZmxvYXQ2NC1leHBvbmVudC1iaWFzJyApO1xuXG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIFJldHVybnMgYW4gaW50ZWdlciBjb3JyZXNwb25kaW5nIHRvIHRoZSB1bmJpYXNlZCBleHBvbmVudCBvZiBhIGRvdWJsZS1wcmVjaXNpb24gZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxuKlxuKiBAcGFyYW0ge251bWJlcn0geCAtIGlucHV0IHZhbHVlXG4qIEByZXR1cm5zIHtpbnRlZ2VyMzJ9IHVuYmlhc2VkIGV4cG9uZW50XG4qXG4qIEBleGFtcGxlXG4qIHZhciBleHAgPSBleHBvbmVudCggMy4xNGUtMzA3ICk7IC8vID0+IDIqKi0xMDE5IH4gMWUtMzA3XG4qIC8vIHJldHVybnMgLTEwMTlcbipcbiogQGV4YW1wbGVcbiogdmFyIGV4cCA9IGV4cG9uZW50KCAtMy4xNCApO1xuKiAvLyByZXR1cm5zIDFcbipcbiogQGV4YW1wbGVcbiogdmFyIGV4cCA9IGV4cG9uZW50KCAwLjAgKTtcbiogLy8gcmV0dXJucyAtMTAyM1xuKlxuKiBAZXhhbXBsZVxuKiB2YXIgZXhwID0gZXhwb25lbnQoIE5hTiApO1xuKiAvLyByZXR1cm5zIDEwMjRcbiovXG5mdW5jdGlvbiBleHBvbmVudCggeCApIHtcblx0Ly8gRXh0cmFjdCBmcm9tIHRoZSBpbnB1dCB2YWx1ZSBhIGhpZ2hlciBvcmRlciB3b3JkICh1bnNpZ25lZCAzMi1iaXQgaW50ZWdlcikgd2hpY2ggY29udGFpbnMgdGhlIGV4cG9uZW50OlxuXHR2YXIgaGlnaCA9IGdldEhpZ2hXb3JkKCB4ICk7XG5cblx0Ly8gQXBwbHkgYSBtYXNrIHRvIGlzb2xhdGUgb25seSB0aGUgZXhwb25lbnQgYml0cyBhbmQgdGhlbiBzaGlmdCBvZmYgYWxsIGJpdHMgd2hpY2ggYXJlIHBhcnQgb2YgdGhlIGZyYWN0aW9uOlxuXHRoaWdoID0gKCBoaWdoICYgRVhQX01BU0sgKSA+Pj4gMjA7XG5cblx0Ly8gUmVtb3ZlIHRoZSBiaWFzIGFuZCByZXR1cm46XG5cdHJldHVybiAoaGlnaCAtIEJJQVMpfDA7IC8vIGFzbSB0eXBlIGFubm90YXRpb25cbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb25lbnQ7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIFJldHVybiBhbiBpbnRlZ2VyIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHVuYmlhc2VkIGV4cG9uZW50IG9mIGEgZG91YmxlLXByZWNpc2lvbiBmbG9hdGluZy1wb2ludCBudW1iZXIuXG4qXG4qIEBtb2R1bGUgQHN0ZGxpYi9udW1iZXItZmxvYXQ2NC1iYXNlLWV4cG9uZW50XG4qXG4qIEBleGFtcGxlXG4qIHZhciBleHBvbmVudCA9IHJlcXVpcmUoICdAc3RkbGliL251bWJlci1mbG9hdDY0LWJhc2UtZXhwb25lbnQnICk7XG4qXG4qIHZhciBleHAgPSBleHBvbmVudCggMy4xNGUtMzA3ICk7IC8vID0+IDIqKi0xMDE5IH4gMWUtMzA3XG4qIC8vIHJldHVybnMgLTEwMTlcbipcbiogZXhwID0gZXhwb25lbnQoIC0zLjE0ICk7XG4qIC8vIHJldHVybnMgMVxuKlxuKiBleHAgPSBleHBvbmVudCggMC4wICk7XG4qIC8vIHJldHVybnMgLTEwMjNcbipcbiogZXhwID0gZXhwb25lbnQoIE5hTiApO1xuKiAvLyByZXR1cm5zIDEwMjRcbiovXG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGV4cG9uZW50ID0gcmVxdWlyZSggJy4vbWFpbi5qcycgKTtcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb25lbnQ7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTk9URVMgLy9cblxuLypcbiogPT4gbGRleHA6IGxvYWQgZXhwb25lbnQgKHNlZSBbVGhlIE9wZW4gR3JvdXBde0BsaW5rIGh0dHA6Ly9wdWJzLm9wZW5ncm91cC5vcmcvb25saW5lcHVicy85Njk5OTE5Nzk5L2Z1bmN0aW9ucy9sZGV4cC5odG1sfSBhbmQgW2NwcHJlZmVyZW5jZV17QGxpbmsgaHR0cDovL2VuLmNwcHJlZmVyZW5jZS5jb20vdy9jL251bWVyaWMvbWF0aC9sZGV4cH0pLlxuKi9cblxuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBQSU5GID0gcmVxdWlyZSggJ0BzdGRsaWIvY29uc3RhbnRzLWZsb2F0NjQtcGluZicgKTtcbnZhciBOSU5GID0gcmVxdWlyZSggJ0BzdGRsaWIvY29uc3RhbnRzLWZsb2F0NjQtbmluZicgKTtcbnZhciBCSUFTID0gcmVxdWlyZSggJ0BzdGRsaWIvY29uc3RhbnRzLWZsb2F0NjQtZXhwb25lbnQtYmlhcycgKTtcbnZhciBNQVhfRVhQT05FTlQgPSByZXF1aXJlKCAnQHN0ZGxpYi9jb25zdGFudHMtZmxvYXQ2NC1tYXgtYmFzZTItZXhwb25lbnQnICk7XG52YXIgTUFYX1NVQk5PUk1BTF9FWFBPTkVOVCA9IHJlcXVpcmUoICdAc3RkbGliL2NvbnN0YW50cy1mbG9hdDY0LW1heC1iYXNlMi1leHBvbmVudC1zdWJub3JtYWwnICk7XG52YXIgTUlOX1NVQk5PUk1BTF9FWFBPTkVOVCA9IHJlcXVpcmUoICdAc3RkbGliL2NvbnN0YW50cy1mbG9hdDY0LW1pbi1iYXNlMi1leHBvbmVudC1zdWJub3JtYWwnICk7XG52YXIgaXNuYW4gPSByZXF1aXJlKCAnQHN0ZGxpYi9tYXRoLWJhc2UtYXNzZXJ0LWlzLW5hbicgKTtcbnZhciBpc0luZmluaXRlID0gcmVxdWlyZSggJ0BzdGRsaWIvbWF0aC1iYXNlLWFzc2VydC1pcy1pbmZpbml0ZScgKTtcbnZhciBjb3B5c2lnbiA9IHJlcXVpcmUoICdAc3RkbGliL21hdGgtYmFzZS1zcGVjaWFsLWNvcHlzaWduJyApO1xudmFyIG5vcm1hbGl6ZSA9IHJlcXVpcmUoICdAc3RkbGliL251bWJlci1mbG9hdDY0LWJhc2Utbm9ybWFsaXplJyApO1xudmFyIGZsb2F0RXhwID0gcmVxdWlyZSggJ0BzdGRsaWIvbnVtYmVyLWZsb2F0NjQtYmFzZS1leHBvbmVudCcgKTtcbnZhciB0b1dvcmRzID0gcmVxdWlyZSggJ0BzdGRsaWIvbnVtYmVyLWZsb2F0NjQtYmFzZS10by13b3JkcycgKTtcbnZhciBmcm9tV29yZHMgPSByZXF1aXJlKCAnQHN0ZGxpYi9udW1iZXItZmxvYXQ2NC1iYXNlLWZyb20td29yZHMnICk7XG5cblxuLy8gVkFSSUFCTEVTIC8vXG5cbi8vIDEvKDE8PDUyKSA9IDEvKDIqKjUyKSA9IDEvNDUwMzU5OTYyNzM3MDQ5NlxudmFyIFRXTzUyX0lOViA9IDIuMjIwNDQ2MDQ5MjUwMzEzZS0xNjtcblxuLy8gRXhwb25lbnQgYWxsIDBzOiAxIDAwMDAwMDAwMDAwIDExMTExMTExMTExMTExMTExMTExID0+IDIxNDg1MzIyMjNcbnZhciBDTEVBUl9FWFBfTUFTSyA9IDB4ODAwZmZmZmY+Pj4wOyAvLyBhc20gdHlwZSBhbm5vdGF0aW9uXG5cbi8vIE5vcm1hbGl6YXRpb24gd29ya3NwYWNlOlxudmFyIEZSQUMgPSBbIDAuMCwgMC4wIF07IC8vIFdBUk5JTkc6IG5vdCB0aHJlYWQgc2FmZVxuXG4vLyBIaWdoL2xvdyB3b3JkcyB3b3Jrc3BhY2U6XG52YXIgV09SRFMgPSBbIDAsIDAgXTsgLy8gV0FSTklORzogbm90IHRocmVhZCBzYWZlXG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogTXVsdGlwbGllcyBhIGRvdWJsZS1wcmVjaXNpb24gZmxvYXRpbmctcG9pbnQgbnVtYmVyIGJ5IGFuIGludGVnZXIgcG93ZXIgb2YgdHdvLlxuKlxuKiBAcGFyYW0ge251bWJlcn0gZnJhYyAtIGZyYWN0aW9uXG4qIEBwYXJhbSB7aW50ZWdlcn0gZXhwIC0gZXhwb25lbnRcbiogQHJldHVybnMge251bWJlcn0gZG91YmxlLXByZWNpc2lvbiBmbG9hdGluZy1wb2ludCBudW1iZXJcbipcbiogQGV4YW1wbGVcbiogdmFyIHggPSBsZGV4cCggMC41LCAzICk7IC8vID0+IDAuNSAqIDJeMyA9IDAuNSAqIDhcbiogLy8gcmV0dXJucyA0LjBcbipcbiogQGV4YW1wbGVcbiogdmFyIHggPSBsZGV4cCggNC4wLCAtMiApOyAvLyA9PiA0ICogMl4oLTIpID0gNCAqICgxLzQpXG4qIC8vIHJldHVybnMgMS4wXG4qXG4qIEBleGFtcGxlXG4qIHZhciB4ID0gbGRleHAoIDAuMCwgMjAgKTtcbiogLy8gcmV0dXJucyAwLjBcbipcbiogQGV4YW1wbGVcbiogdmFyIHggPSBsZGV4cCggLTAuMCwgMzkgKTtcbiogLy8gcmV0dXJucyAtMC4wXG4qXG4qIEBleGFtcGxlXG4qIHZhciB4ID0gbGRleHAoIE5hTiwgLTEwMSApO1xuKiAvLyByZXR1cm5zIE5hTlxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgeCA9IGxkZXhwKCBJbmZpbml0eSwgMTEgKTtcbiogLy8gcmV0dXJucyBJbmZpbml0eVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgeCA9IGxkZXhwKCAtSW5maW5pdHksIC0xMTggKTtcbiogLy8gcmV0dXJucyAtSW5maW5pdHlcbiovXG5mdW5jdGlvbiBsZGV4cCggZnJhYywgZXhwICkge1xuXHR2YXIgaGlnaDtcblx0dmFyIG07XG5cdGlmIChcblx0XHRmcmFjID09PSAwLjAgfHwgLy8gaGFuZGxlcyArLTBcblx0XHRpc25hbiggZnJhYyApIHx8XG5cdFx0aXNJbmZpbml0ZSggZnJhYyApXG5cdCkge1xuXHRcdHJldHVybiBmcmFjO1xuXHR9XG5cdC8vIE5vcm1hbGl6ZSB0aGUgaW5wdXQgZnJhY3Rpb246XG5cdG5vcm1hbGl6ZSggRlJBQywgZnJhYyApO1xuXHRmcmFjID0gRlJBQ1sgMCBdO1xuXHRleHAgKz0gRlJBQ1sgMSBdO1xuXG5cdC8vIEV4dHJhY3QgdGhlIGV4cG9uZW50IGZyb20gYGZyYWNgIGFuZCBhZGQgaXQgdG8gYGV4cGA6XG5cdGV4cCArPSBmbG9hdEV4cCggZnJhYyApO1xuXG5cdC8vIENoZWNrIGZvciB1bmRlcmZsb3cvb3ZlcmZsb3cuLi5cblx0aWYgKCBleHAgPCBNSU5fU1VCTk9STUFMX0VYUE9ORU5UICkge1xuXHRcdHJldHVybiBjb3B5c2lnbiggMC4wLCBmcmFjICk7XG5cdH1cblx0aWYgKCBleHAgPiBNQVhfRVhQT05FTlQgKSB7XG5cdFx0aWYgKCBmcmFjIDwgMC4wICkge1xuXHRcdFx0cmV0dXJuIE5JTkY7XG5cdFx0fVxuXHRcdHJldHVybiBQSU5GO1xuXHR9XG5cdC8vIENoZWNrIGZvciBhIHN1Ym5vcm1hbCBhbmQgc2NhbGUgYWNjb3JkaW5nbHkgdG8gcmV0YWluIHByZWNpc2lvbi4uLlxuXHRpZiAoIGV4cCA8PSBNQVhfU1VCTk9STUFMX0VYUE9ORU5UICkge1xuXHRcdGV4cCArPSA1Mjtcblx0XHRtID0gVFdPNTJfSU5WO1xuXHR9IGVsc2Uge1xuXHRcdG0gPSAxLjA7XG5cdH1cblx0Ly8gU3BsaXQgdGhlIGZyYWN0aW9uIGludG8gaGlnaGVyIGFuZCBsb3dlciBvcmRlciB3b3Jkczpcblx0dG9Xb3JkcyggV09SRFMsIGZyYWMgKTtcblx0aGlnaCA9IFdPUkRTWyAwIF07XG5cblx0Ly8gQ2xlYXIgdGhlIGV4cG9uZW50IGJpdHMgd2l0aGluIHRoZSBoaWdoZXIgb3JkZXIgd29yZDpcblx0aGlnaCAmPSBDTEVBUl9FWFBfTUFTSztcblxuXHQvLyBTZXQgdGhlIGV4cG9uZW50IGJpdHMgdG8gdGhlIG5ldyBleHBvbmVudDpcblx0aGlnaCB8PSAoKGV4cCtCSUFTKSA8PCAyMCk7XG5cblx0Ly8gQ3JlYXRlIGEgbmV3IGZsb2F0aW5nLXBvaW50IG51bWJlcjpcblx0cmV0dXJuIG0gKiBmcm9tV29yZHMoIGhpZ2gsIFdPUkRTWyAxIF0gKTtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gbGRleHA7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIE11bHRpcGx5IGEgZG91YmxlLXByZWNpc2lvbiBmbG9hdGluZy1wb2ludCBudW1iZXIgYnkgYW4gaW50ZWdlciBwb3dlciBvZiB0d28uXG4qXG4qIEBtb2R1bGUgQHN0ZGxpYi9tYXRoLWJhc2Utc3BlY2lhbC1sZGV4cFxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgbGRleHAgPSByZXF1aXJlKCAnQHN0ZGxpYi9tYXRoLWJhc2Utc3BlY2lhbC1sZGV4cCcgKTtcbipcbiogdmFyIHggPSBsZGV4cCggMC41LCAzICk7IC8vID0+IDAuNSAqIDJeMyA9IDAuNSAqIDhcbiogLy8gcmV0dXJucyA0LjBcbipcbiogeCA9IGxkZXhwKCA0LjAsIC0yICk7IC8vID0+IDQgKiAyXigtMikgPSA0ICogKDEvNClcbiogLy8gcmV0dXJucyAxLjBcbipcbiogeCA9IGxkZXhwKCAwLjAsIDIwICk7XG4qIC8vIHJldHVybnMgMC4wXG4qXG4qIHggPSBsZGV4cCggLTAuMCwgMzkgKTtcbiogLy8gcmV0dXJucyAtMC4wXG4qXG4qIHggPSBsZGV4cCggTmFOLCAtMTAxICk7XG4qIC8vIHJldHVybnMgTmFOXG4qXG4qIHggPSBsZGV4cCggSW5maW5pdHksIDExICk7XG4qIC8vIHJldHVybnMgSW5maW5pdHlcbipcbiogeCA9IGxkZXhwKCAtSW5maW5pdHksIC0xMTggKTtcbiogLy8gcmV0dXJucyAtSW5maW5pdHlcbiovXG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGxkZXhwID0gcmVxdWlyZSggJy4vbGRleHAuanMnICk7XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGxkZXhwO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBOYXR1cmFsIGxvZ2FyaXRobSBvZiBgMmAuXG4qXG4qIEBtb2R1bGUgQHN0ZGxpYi9jb25zdGFudHMtZmxvYXQ2NC1sbi10d29cbiogQHR5cGUge251bWJlcn1cbipcbiogQGV4YW1wbGVcbiogdmFyIExOMiA9IHJlcXVpcmUoICdAc3RkbGliL2NvbnN0YW50cy1mbG9hdDY0LWxuLXR3bycgKTtcbiogLy8gcmV0dXJucyAwLjY5MzE0NzE4MDU1OTk0NTNcbiovXG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogTmF0dXJhbCBsb2dhcml0aG0gb2YgYDJgLlxuKlxuKiBgYGB0ZXhcbiogXFxsbiAyXG4qIGBgYFxuKlxuKiBAY29uc3RhbnRcbiogQHR5cGUge251bWJlcn1cbiogQGRlZmF1bHQgMC42OTMxNDcxODA1NTk5NDUzXG4qL1xudmFyIExOMiA9IDYuOTMxNDcxODA1NTk5NDUzMDk0MTcyMzIxMjE0NTgxNzY1NjgwNzU1MDAxMzQzNjAyNTUyNTQxMjA2ODAwMDk0OTMzOTM2MjE5Njk2OTQ3MTU2MDU4NjMzMjY5OTY0MTg2ODc1NDIwMDE0ODEwMjFlLTAxOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG1heC1sZW5cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gTE4yO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4vKiBUaGlzIGlzIGEgZ2VuZXJhdGVkIGZpbGUuIERvIG5vdCBlZGl0IGRpcmVjdGx5LiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBFdmFsdWF0ZXMgYSBwb2x5bm9taWFsLlxuKlxuKiAjIyBOb3Rlc1xuKlxuKiAtICAgVGhlIGltcGxlbWVudGF0aW9uIHVzZXMgW0hvcm5lcidzIHJ1bGVdW2hvcm5lcnMtbWV0aG9kXSBmb3IgZWZmaWNpZW50IGNvbXB1dGF0aW9uLlxuKlxuKiBbaG9ybmVycy1tZXRob2RdOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ib3JuZXIlMjdzX21ldGhvZFxuKlxuKlxuKiBAcHJpdmF0ZVxuKiBAcGFyYW0ge251bWJlcn0geCAtIHZhbHVlIGF0IHdoaWNoIHRvIGV2YWx1YXRlIHRoZSBwb2x5bm9taWFsXG4qIEByZXR1cm5zIHtudW1iZXJ9IGV2YWx1YXRlZCBwb2x5bm9taWFsXG4qL1xuZnVuY3Rpb24gZXZhbHBvbHkoIHggKSB7XG5cdGlmICggeCA9PT0gMC4wICkge1xuXHRcdHJldHVybiAwLjE2NjY2NjY2NjY2NjY2NjAyO1xuXHR9XG5cdHJldHVybiAwLjE2NjY2NjY2NjY2NjY2NjAyICsgKHggKiAoLTAuMDAyNzc3Nzc3Nzc3NzAxNTU5MyArICh4ICogKDAuMDAwMDY2MTM3NTYzMjE0Mzc5MzQgKyAoeCAqICgtMC4wMDAwMDE2NTMzOTAyMjA1NDY1MjUyICsgKHggKiA0LjEzODEzNjc5NzA1NzIzODVlLTgpKSkpKSkpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG1heC1sZW5cbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gZXZhbHBvbHk7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbipcbipcbiogIyMgTm90aWNlXG4qXG4qIFRoZSBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlIHdlcmUgcGFydCBvZiB0aGUgb3JpZ2luYWwgaW1wbGVtZW50YXRpb24gYXZhaWxhYmxlIGFzIHBhcnQgb2YgW0ZyZWVCU0Rde0BsaW5rIGh0dHBzOi8vc3Zud2ViLmZyZWVic2Qub3JnL2Jhc2UvcmVsZWFzZS85LjMuMC9saWIvbXN1bi9zcmMvc19wb3cuY30uIFRoZSBpbXBsZW1lbnRhdGlvbiBmb2xsb3dzIHRoZSBvcmlnaW5hbCwgYnV0IGhhcyBiZWVuIG1vZGlmaWVkIGZvciBKYXZhU2NyaXB0LlxuKlxuKiBgYGB0ZXh0XG4qIENvcHlyaWdodCAoQykgMjAwNCBieSBTdW4gTWljcm9zeXN0ZW1zLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIERldmVsb3BlZCBhdCBTdW5Qcm8sIGEgU3VuIE1pY3Jvc3lzdGVtcywgSW5jLiBidXNpbmVzcy5cbiogUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kIGRpc3RyaWJ1dGUgdGhpc1xuKiBzb2Z0d2FyZSBpcyBmcmVlbHkgZ3JhbnRlZCwgcHJvdmlkZWQgdGhhdCB0aGlzIG5vdGljZVxuKiBpcyBwcmVzZXJ2ZWQuXG4qIGBgYFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBnZXRIaWdoV29yZCA9IHJlcXVpcmUoICdAc3RkbGliL251bWJlci1mbG9hdDY0LWJhc2UtZ2V0LWhpZ2gtd29yZCcgKTtcbnZhciBzZXRIaWdoV29yZCA9IHJlcXVpcmUoICdAc3RkbGliL251bWJlci1mbG9hdDY0LWJhc2Utc2V0LWhpZ2gtd29yZCcgKTtcbnZhciBzZXRMb3dXb3JkID0gcmVxdWlyZSggJ0BzdGRsaWIvbnVtYmVyLWZsb2F0NjQtYmFzZS1zZXQtbG93LXdvcmQnICk7XG52YXIgdWludDMyVG9JbnQzMiA9IHJlcXVpcmUoICdAc3RkbGliL251bWJlci11aW50MzItYmFzZS10by1pbnQzMicgKTtcbnZhciBsZGV4cCA9IHJlcXVpcmUoICdAc3RkbGliL21hdGgtYmFzZS1zcGVjaWFsLWxkZXhwJyApO1xudmFyIExOMiA9IHJlcXVpcmUoICdAc3RkbGliL2NvbnN0YW50cy1mbG9hdDY0LWxuLXR3bycgKTtcbnZhciBCSUFTID0gcmVxdWlyZSggJ0BzdGRsaWIvY29uc3RhbnRzLWZsb2F0NjQtZXhwb25lbnQtYmlhcycgKTtcbnZhciBwb2x5dmFsUCA9IHJlcXVpcmUoICcuL3BvbHl2YWxfcC5qcycgKTtcblxuXG4vLyBWQVJJQUJMRVMgLy9cblxuLy8gMHg3ZmZmZmZmZiA9IDIxNDc0ODM2NDcgPT4gMCAxMTExMTExMTExMSAxMTExMTExMTExMTExMTExMTExMVxudmFyIEFCU19NQVNLID0gMHg3ZmZmZmZmZnwwOyAvLyBhc20gdHlwZSBhbm5vdGF0aW9uXG5cbi8vIDB4MDAwZmZmZmYgPSAxMDQ4NTc1ID0+IDAgMDAwMDAwMDAwMDAgMTExMTExMTExMTExMTExMTExMTFcbnZhciBISUdIX1NJR05JRklDQU5EX01BU0sgPSAweDAwMGZmZmZmfDA7IC8vIGFzbSB0eXBlIGFubm90YXRpb25cblxuLy8gMHgwMDEwMDAwMCA9IDEwNDg1NzYgPT4gMCAwMDAwMDAwMDAwMSAwMDAwMDAwMDAwMDAwMDAwMDAwMCA9PiBiaWFzZWQgZXhwb25lbnQ6IDEgPSAtMTAyMisxMDIzID0+IDJeLTEwMjJcbnZhciBISUdIX01JTl9OT1JNQUxfRVhQID0gMHgwMDEwMDAwMHwwOyAvLyBhc20gdHlwZSBhbm5vdGF0aW9uXG5cbi8vIDB4M2ZlMDAwMDAgPSAxMDcxNjQ0NjcyID0+IDAgMDExMTExMTExMTAgMDAwMDAwMDAwMDAwMDAwMDAwMDAgPT4gYmlhc2VkIGV4cG9uZW50OiAxMDIyID0gLTErMTAyMyA9PiAyXi0xXG52YXIgSElHSF9CSUFTRURfRVhQX05FR18xID0gMHgzZmUwMDAwMHwwOyAvLyBhc20gdHlwZSBhbm5vdGF0aW9uXG5cbi8vIFRPRE86IGNvbnNpZGVyIG1ha2luZyBpbnRvIGFuIGV4dGVybmFsIGNvbnN0YW50XG52YXIgSElHSF9OVU1fU0lHTklGSUNBTkRfQklUUyA9IDIwfDA7IC8vIGFzbSB0eXBlIGFubm90YXRpb25cblxuLy8gSGlnaDogTE4yXG52YXIgTE4yX0hJID0gNi45MzE0NzE4MjQ2NDU5OTYwOTM3NWUtMDE7IC8vIDB4M0ZFNjJFNDMsIDB4MDAwMDAwMDBcblxuLy8gTG93OiBMTjJcbnZhciBMTjJfTE8gPSAtMS45MDQ2NTQyOTk5NTc3NjgwNDUyNWUtMDk7IC8vIDB4QkUyMDVDNjEsIDB4MENBODZDMzlcblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBDb21wdXRlcyBcXFxcKDJee1xcbWF0aHJte2hwfSArIFxcbWF0aHJte2xwfVxcXFwpLlxuKlxuKiBAcHJpdmF0ZVxuKiBAcGFyYW0ge251bWJlcn0gaiAtIGhpZ2ggd29yZCBvZiBgaHAgKyBscGBcbiogQHBhcmFtIHtudW1iZXJ9IGhwIC0gZmlyc3QgcG93ZXIgc3VtbWFuZFxuKiBAcGFyYW0ge251bWJlcn0gbHAgLSBzZWNvbmQgcG93ZXIgc3VtbWFuZFxuKiBAcmV0dXJucyB7bnVtYmVyfSBmdW5jdGlvbiB2YWx1ZVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgeiA9IHBvdzIoIDEwNjU5NjE2NDgsIC0wLjMzOTg0NzU2NDY5NzI2NTYsIC0wLjAwMDAwMjQzODE4NzM1OTEwMDgxNSApO1xuKiAvLyByZXR1cm5zIH4wLjc5XG4qL1xuZnVuY3Rpb24gcG93MiggaiwgaHAsIGxwICkge1xuXHR2YXIgdG1wO1xuXHR2YXIgdDE7XG5cdHZhciB0O1xuXHR2YXIgcjtcblx0dmFyIHU7XG5cdHZhciB2O1xuXHR2YXIgdztcblx0dmFyIHo7XG5cdHZhciBuO1xuXHR2YXIgaTtcblx0dmFyIGs7XG5cblx0aSA9IChqICYgQUJTX01BU0spfDA7IC8vIGFzbSB0eXBlIGFubm90YXRpb25cblx0ayA9ICgoaT4+SElHSF9OVU1fU0lHTklGSUNBTkRfQklUUykgLSBCSUFTKXwwOyAvLyBhc20gdHlwZSBhbm5vdGF0aW9uXG5cdG4gPSAwO1xuXG5cdC8vIGB8enwgPiAwLjVgLCBzZXQgYG4gPSB6KzAuNWBcblx0aWYgKCBpID4gSElHSF9CSUFTRURfRVhQX05FR18xICkge1xuXHRcdG4gPSAoaiArIChISUdIX01JTl9OT1JNQUxfRVhQPj4oaysxKSkpPj4+MDsgLy8gYXNtIHR5cGUgYW5ub3RhdGlvblxuXHRcdGsgPSAoKChuICYgQUJTX01BU0spPj5ISUdIX05VTV9TSUdOSUZJQ0FORF9CSVRTKSAtIEJJQVMpfDA7IC8vIG5ldyBrIGZvciBuXG5cdFx0dG1wID0gKChuICYgfihISUdIX1NJR05JRklDQU5EX01BU0sgPj4gaykpKT4+PjA7IC8vIGFzbSB0eXBlIGFubm90YXRpb25cblx0XHR0ID0gc2V0SGlnaFdvcmQoIDAuMCwgdG1wICk7XG5cdFx0biA9ICgoKG4gJiBISUdIX1NJR05JRklDQU5EX01BU0spfEhJR0hfTUlOX05PUk1BTF9FWFApID4+IChISUdIX05VTV9TSUdOSUZJQ0FORF9CSVRTLWspKT4+PjA7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbWF4LWxlblxuXHRcdGlmICggaiA8IDAgKSB7XG5cdFx0XHRuID0gLW47XG5cdFx0fVxuXHRcdGhwIC09IHQ7XG5cdH1cblx0dCA9IGxwICsgaHA7XG5cdHQgPSBzZXRMb3dXb3JkKCB0LCAwICk7XG5cdHUgPSB0ICogTE4yX0hJO1xuXHR2ID0gKCAobHAgLSAodC1ocCkpKkxOMiApICsgKCB0KkxOMl9MTyApO1xuXHR6ID0gdSArIHY7XG5cdHcgPSB2IC0gKHogLSB1KTtcblx0dCA9IHogKiB6O1xuXHR0MSA9IHogLSAoIHQqcG9seXZhbFAoIHQgKSApO1xuXHRyID0gKCAoeip0MSkgLyAodDEtMi4wKSApIC0gKCB3ICsgKHoqdykgKTtcblx0eiA9IDEuMCAtIChyIC0geik7XG5cdGogPSBnZXRIaWdoV29yZCggeiApO1xuXHRqID0gdWludDMyVG9JbnQzMiggaiApO1xuXHRqICs9IChuIDw8IEhJR0hfTlVNX1NJR05JRklDQU5EX0JJVFMpPj4+MDsgLy8gYXNtIHR5cGUgYW5ub3RhdGlvblxuXG5cdC8vIENoZWNrIGZvciBzdWJub3JtYWwgb3V0cHV0Li4uXG5cdGlmICggKGo+PkhJR0hfTlVNX1NJR05JRklDQU5EX0JJVFMpIDw9IDAgKSB7XG5cdFx0eiA9IGxkZXhwKCB6LCBuICk7XG5cdH0gZWxzZSB7XG5cdFx0eiA9IHNldEhpZ2hXb3JkKCB6LCBqICk7XG5cdH1cblx0cmV0dXJuIHo7XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBvdzI7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbipcbipcbiogIyMgTm90aWNlXG4qXG4qIFRoZSBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlIHdlcmUgcGFydCBvZiB0aGUgb3JpZ2luYWwgaW1wbGVtZW50YXRpb24gYXZhaWxhYmxlIGFzIHBhcnQgb2YgW0ZyZWVCU0Rde0BsaW5rIGh0dHBzOi8vc3Zud2ViLmZyZWVic2Qub3JnL2Jhc2UvcmVsZWFzZS85LjMuMC9saWIvbXN1bi9zcmMvc19wb3cuY30uIFRoZSBpbXBsZW1lbnRhdGlvbiBmb2xsb3dzIHRoZSBvcmlnaW5hbCwgYnV0IGhhcyBiZWVuIG1vZGlmaWVkIGZvciBKYXZhU2NyaXB0LlxuKlxuKiBgYGB0ZXh0XG4qIENvcHlyaWdodCAoQykgMjAwNCBieSBTdW4gTWljcm9zeXN0ZW1zLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIERldmVsb3BlZCBhdCBTdW5Qcm8sIGEgU3VuIE1pY3Jvc3lzdGVtcywgSW5jLiBidXNpbmVzcy5cbiogUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kIGRpc3RyaWJ1dGUgdGhpc1xuKiBzb2Z0d2FyZSBpcyBmcmVlbHkgZ3JhbnRlZCwgcHJvdmlkZWQgdGhhdCB0aGlzIG5vdGljZVxuKiBpcyBwcmVzZXJ2ZWQuXG4qIGBgYFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBpc25hbiA9IHJlcXVpcmUoICdAc3RkbGliL21hdGgtYmFzZS1hc3NlcnQtaXMtbmFuJyApO1xudmFyIGlzT2RkID0gcmVxdWlyZSggJ0BzdGRsaWIvbWF0aC1iYXNlLWFzc2VydC1pcy1vZGQnICk7XG52YXIgaXNJbmZpbml0ZSA9IHJlcXVpcmUoICdAc3RkbGliL21hdGgtYmFzZS1hc3NlcnQtaXMtaW5maW5pdGUnICk7XG52YXIgaXNJbnRlZ2VyID0gcmVxdWlyZSggJ0BzdGRsaWIvbWF0aC1iYXNlLWFzc2VydC1pcy1pbnRlZ2VyJyApO1xudmFyIHNxcnQgPSByZXF1aXJlKCAnQHN0ZGxpYi9tYXRoLWJhc2Utc3BlY2lhbC1zcXJ0JyApO1xudmFyIGFicyA9IHJlcXVpcmUoICdAc3RkbGliL21hdGgtYmFzZS1zcGVjaWFsLWFicycgKTtcbnZhciB0b1dvcmRzID0gcmVxdWlyZSggJ0BzdGRsaWIvbnVtYmVyLWZsb2F0NjQtYmFzZS10by13b3JkcycgKTtcbnZhciBzZXRMb3dXb3JkID0gcmVxdWlyZSggJ0BzdGRsaWIvbnVtYmVyLWZsb2F0NjQtYmFzZS1zZXQtbG93LXdvcmQnICk7XG52YXIgdWludDMyVG9JbnQzMiA9IHJlcXVpcmUoICdAc3RkbGliL251bWJlci11aW50MzItYmFzZS10by1pbnQzMicgKTtcbnZhciBOSU5GID0gcmVxdWlyZSggJ0BzdGRsaWIvY29uc3RhbnRzLWZsb2F0NjQtbmluZicgKTtcbnZhciBQSU5GID0gcmVxdWlyZSggJ0BzdGRsaWIvY29uc3RhbnRzLWZsb2F0NjQtcGluZicgKTtcbnZhciB4SXNaZXJvID0gcmVxdWlyZSggJy4veF9pc196ZXJvLmpzJyApO1xudmFyIHlJc0h1Z2UgPSByZXF1aXJlKCAnLi95X2lzX2h1Z2UuanMnICk7XG52YXIgeUlzSW5maW5pdGUgPSByZXF1aXJlKCAnLi95X2lzX2luZmluaXRlLmpzJyApO1xudmFyIGxvZzJheCA9IHJlcXVpcmUoICcuL2xvZzJheC5qcycgKTtcbnZhciBsb2d4ID0gcmVxdWlyZSggJy4vbG9neC5qcycgKTtcbnZhciBwb3cyID0gcmVxdWlyZSggJy4vcG93Mi5qcycgKTtcblxuXG4vLyBWQVJJQUJMRVMgLy9cblxuLy8gMHg3ZmZmZmZmZiA9IDIxNDc0ODM2NDcgPT4gMCAxMTExMTExMTExMSAxMTExMTExMTExMTExMTExMTExMVxudmFyIEFCU19NQVNLID0gMHg3ZmZmZmZmZnwwOyAvLyBhc20gdHlwZSBhbm5vdGF0aW9uXG5cbi8vIDB4M2ZlZmZmZmYgPSAxMDcyNjkzMjQ3ID0+IDAgMDExMTExMTExMTAgMTExMTExMTExMTExMTExMTExMTEgPT4gYmlhc2VkIGV4cG9uZW50OiAxMDIyID0gLTErMTAyMyA9PiAyXi0xXG52YXIgSElHSF9NQVhfTkVBUl9VTklUWSA9IDB4M2ZlZmZmZmZ8MDsgLy8gYXNtIHR5cGUgYW5ub3RhdGlvblxuXG4vLyAweDQxZTAwMDAwID0gMTEwNTE5OTEwNCA9PiAwIDEwMDAwMDExMTEwIDAwMDAwMDAwMDAwMDAwMDAwMDAwID0+IGJpYXNlZCBleHBvbmVudDogMTA1NCA9IDMxKzEwMjMgPT4gMl4zMVxudmFyIEhJR0hfQklBU0VEX0VYUF8zMSA9IDB4NDFlMDAwMDB8MDsgLy8gYXNtIHR5cGUgYW5ub3RhdGlvblxuXG4vLyAweDQzZjAwMDAwID0gMTEzOTgwMjExMiA9PiAwIDEwMDAwMTExMTExIDAwMDAwMDAwMDAwMDAwMDAwMDAwID0+IGJpYXNlZCBleHBvbmVudDogMTA4NyA9IDY0KzEwMjMgPT4gMl42NFxudmFyIEhJR0hfQklBU0VEX0VYUF82NCA9IDB4NDNmMDAwMDB8MDsgLy8gYXNtIHR5cGUgYW5ub3RhdGlvblxuXG4vLyAweDQwOTAwMDAwID0gMTA4MzE3OTAwOCA9PiAwIDEwMDAwMDAxMDAxIDAwMDAwMDAwMDAwMDAwMDAwMDAwID0+IGJpYXNlZCBleHBvbmVudDogMTAzMyA9IDEwKzEwMjMgPT4gMl4xMCA9IDEwMjRcbnZhciBISUdIX0JJQVNFRF9FWFBfMTAgPSAweDQwOTAwMDAwfDA7IC8vIGFzbSB0eXBlIGFubm90YXRpb25cblxuLy8gMHgzZmYwMDAwMCA9IDEwNzI2OTMyNDggPT4gMCAwMTExMTExMTExMSAwMDAwMDAwMDAwMDAwMDAwMDAwMCA9PiBiaWFzZWQgZXhwb25lbnQ6IDEwMjMgPSAwKzEwMjMgPT4gMl4wID0gMVxudmFyIEhJR0hfQklBU0VEX0VYUF8wID0gMHgzZmYwMDAwMHwwOyAvLyBhc20gdHlwZSBhbm5vdGF0aW9uXG5cbi8vIDB4NDA5MGNjMDAgPSAxMDgzMjMxMjMyID0+IDAgMTAwMDAwMDEwMDEgMDAwMDExMDAxMTAwMDAwMDAwMDBcbnZhciBISUdIXzEwNzUgPSAweDQwOTBjYzAwfDA7IC8vIGFzbSB0eXBlIGFubm90YXRpb25cblxuLy8gMHhjMDkwY2MwMCA9IDMyMzA3MTQ4ODAgPT4gMSAxMDAwMDAwMTAwMSAwMDAwMTEwMDExMDAwMDAwMDAwMFxudmFyIEhJR0hfTkVHXzEwNzUgPSAweGMwOTBjYzAwPj4+MDsgLy8gYXNtIHR5cGUgYW5ub3RhdGlvblxuXG52YXIgSElHSF9OVU1fTk9OU0lHTl9CSVRTID0gMzF8MDsgLy8gYXNtIHR5cGUgYW5ub3RhdGlvblxuXG52YXIgSFVHRSA9IDEuMGUzMDA7XG52YXIgVElOWSA9IDEuMGUtMzAwO1xuXG4vLyAtKDEwMjQtbG9nMihvdmZsKy41dWxwKSlcbnZhciBPVlQgPSA4LjAwODU2NjI1OTUzNzI5NDQzNzJlLTE3O1xuXG4vLyBIaWdoL2xvdyB3b3JkcyB3b3Jrc3BhY2U6XG52YXIgV09SRFMgPSBbIDB8MCwgMHwwIF07IC8vIFdBUk5JTkc6IG5vdCB0aHJlYWQgc2FmZVxuXG4vLyBMb2cgd29ya3NwYWNlOlxudmFyIExPR19XT1JLU1BBQ0UgPSBbIDAuMCwgMC4wIF07IC8vIFdBUk5JTkc6IG5vdCB0aHJlYWQgc2FmZVxuXG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIEV2YWx1YXRlcyB0aGUgZXhwb25lbnRpYWwgZnVuY3Rpb24uXG4qXG4qICMjIE1ldGhvZFxuKlxuKiAxLiAgTGV0IFxcXFwoeCA9IDJebiAoMStmKVxcXFwpLlxuKlxuKiAyLiAgQ29tcHV0ZSBcXFxcKFxcb3BlcmF0b3JuYW1le2xvZzJ9KHgpXFxcXCkgYXNcbipcbiogICAgIGBgYHRleFxuKiAgICAgXFxvcGVyYXRvcm5hbWV7bG9nMn0oeCkgPSB3XzEgKyB3XzJcbiogICAgIGBgYFxuKlxuKiAgICAgd2hlcmUgXFxcXCh3XzFcXFxcKSBoYXMgXFxcXCg1MyAtIDI0ID0gMjlcXFxcKSBiaXQgdHJhaWxpbmcgemVyb3MuXG4qXG4qIDMuICBDb21wdXRlXG4qXG4qICAgICBgYGB0ZXhcbiogICAgIHkgXFxjZG90IFxcb3BlcmF0b3JuYW1le2xvZzJ9KHgpID0gbiArIHleXFxwcmltZVxuKiAgICAgYGBgXG4qXG4qICAgICBieSBzaW11bGF0aW5nIG11bHRpLXByZWNpc2lvbiBhcml0aG1ldGljLCB3aGVyZSBcXFxcKHx5XlxccHJpbWV8IFxcbGVxIDAuNVxcXFwpLlxuKlxuKiA0LiAgUmV0dXJuXG4qXG4qICAgICBgYGB0ZXhcbiogICAgIHheeSA9IDJebiBlXnt5XlxccHJpbWUgXFxjZG90IFxcbWF0aHJte2xvZzJ9fVxuKiAgICAgYGBgXG4qXG4qICMjIFNwZWNpYWwgQ2FzZXNcbipcbiogYGBgdGV4XG4qIFxcYmVnaW57YWxpZ24qfVxuKiB4XntcXG1hdGhybXtOYU59fSAmPSBcXG1hdGhybXtOYU59ICYgXFxcXFxuKiAoXFxtYXRocm17TmFOfSleeSAmPSBcXG1hdGhybXtOYU59ICYgXFxcXFxuKiAxXnkgJj0gMSAmIFxcXFxcbiogeF4wICY9IDEgJiBcXFxcXG4qIHheMSAmPSB4ICYgXFxcXFxuKiAoXFxwbSAwKV5cXGluZnR5ICY9ICswICYgXFxcXFxuKiAoXFxwbSAwKV57LVxcaW5mdHl9ICY9ICtcXGluZnR5ICYgXFxcXFxuKiAoKzApXnkgJj0gKzAgJiBcXG1hdGhybXtpZn1cXCB5ID4gMCBcXFxcXG4qICgrMCleeSAmPSArXFxpbmZ0eSAmIFxcbWF0aHJte2lmfVxcIHkgPCAwIFxcXFxcbiogKC0wKV55ICY9IC1cXGluZnR5ICYgXFxtYXRocm17aWZ9XFwgeVxcIFxcbWF0aHJte2lzXFwgYW5cXCBvZGRcXCBpbnRlZ2VyXFwgYW5kfVxcIHkgPCAwIFxcXFxcbiogKC0wKV55ICY9ICtcXGluZnR5ICYgXFxtYXRocm17aWZ9XFwgeVxcIFxcbWF0aHJte2lzXFwgbm90XFwgYW5cXCBvZGRcXCBpbnRlZ2VyXFwgYW5kfVxcIHkgPCAwIFxcXFxcbiogKC0wKV55ICY9IC0wICYgXFxtYXRocm17aWZ9XFwgeVxcIFxcbWF0aHJte2lzXFwgYW5cXCBvZGRcXCBpbnRlZ2VyXFwgYW5kfVxcIHkgPiAwIFxcXFxcbiogKC0wKV55ICY9ICswICYgXFxtYXRocm17aWZ9XFwgeVxcIFxcbWF0aHJte2lzXFwgbm90XFwgYW5cXCBvZGRcXCBpbnRlZ2VyXFwgYW5kfVxcIHkgPiAwIFxcXFxcbiogKC0xKV57XFxwbVxcaW5mdHl9ICY9IFxcbWF0aHJte05hTn0gJiBcXFxcXG4qIHhee1xcaW5mdHl9ICY9ICtcXGluZnR5ICYgfHh8ID4gMSBcXFxcXG4qIHhee1xcaW5mdHl9ICY9ICswICYgfHh8IDwgMSBcXFxcXG4qIHheey1cXGluZnR5fSAmPSArMCAmIHx4fCA+IDEgXFxcXFxuKiB4XnstXFxpbmZ0eX0gJj0gK1xcaW5mdHkgJiB8eHwgPCAxIFxcXFxcbiogKC1cXGluZnR5KV55ICY9ICgtMCleeSAmIFxcXFxcbiogXFxpbmZ0eV55ICY9ICswICYgeSA8IDAgXFxcXFxuKiBcXGluZnR5XnkgJj0gK1xcaW5mdHkgJiB5ID4gMCBcXFxcXG4qIHheeSAmPSBcXG1hdGhybXtOYU59ICYgXFxtYXRocm17aWZ9XFwgeVxcIFxcbWF0aHJte2lzXFwgbm90XFwgYVxcIGZpbml0ZVxcIGludGVnZXJcXCBhbmR9XFwgeCA8IDBcbiogXFxlbmR7YWxpZ24qfVxuKiBgYGBcbipcbiogIyMgTm90ZXNcbipcbiogLSAgIFxcXFwoXFxvcGVyYXRvcm5hbWV7cG93fSh4LHkpXFxcXCkgcmV0dXJucyBcXFxcKHheeVxcXFwpIG5lYXJseSByb3VuZGVkLiBJbiBwYXJ0aWN1bGFyLCBcXFxcKFxcb3BlcmF0b3JuYW1le3Bvd30oPFxcbWF0aHJte2ludGVnZXJ9Piw8XFxtYXRocm17aW50ZWdlcn0+KVxcXFwpICoqYWx3YXlzKiogcmV0dXJucyB0aGUgY29ycmVjdCBpbnRlZ2VyLCBwcm92aWRlZCB0aGUgdmFsdWUgaXMgcmVwcmVzZW50YWJsZS5cbiogLSAgIFRoZSBoZXhhZGVjaW1hbCB2YWx1ZXMgc2hvd24gaW4gdGhlIHNvdXJjZSBjb2RlIGFyZSB0aGUgaW50ZW5kZWQgdmFsdWVzIGZvciB1c2VkIGNvbnN0YW50cy4gRGVjaW1hbCB2YWx1ZXMgbWF5IGJlIHVzZWQsIHByb3ZpZGVkIHRoZSBjb21waWxlciB3aWxsIGFjY3VyYXRlbHkgY29udmVydCBkZWNpbWFsIHRvIGJpbmFyeSBpbiBvcmRlciB0byBwcm9kdWNlIHRoZSBoZXhhZGVjaW1hbCB2YWx1ZXMuXG4qXG4qXG4qIEBwYXJhbSB7bnVtYmVyfSB4IC0gYmFzZVxuKiBAcGFyYW0ge251bWJlcn0geSAtIGV4cG9uZW50XG4qIEByZXR1cm5zIHtudW1iZXJ9IGZ1bmN0aW9uIHZhbHVlXG4qXG4qIEBleGFtcGxlXG4qIHZhciB2ID0gcG93KCAyLjAsIDMuMCApO1xuKiAvLyByZXR1cm5zIDguMFxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgdiA9IHBvdyggNC4wLCAwLjUgKTtcbiogLy8gcmV0dXJucyAyLjBcbipcbiogQGV4YW1wbGVcbiogdmFyIHYgPSBwb3coIDEwMC4wLCAwLjAgKTtcbiogLy8gcmV0dXJucyAxLjBcbipcbiogQGV4YW1wbGVcbiogdmFyIHYgPSBwb3coIDMuMTQxNTkyNjUzNTg5NzkzLCA1LjAgKTtcbiogLy8gcmV0dXJucyB+MzA2LjAxOTdcbipcbiogQGV4YW1wbGVcbiogdmFyIHYgPSBwb3coIDMuMTQxNTkyNjUzNTg5NzkzLCAtMC4yICk7XG4qIC8vIHJldHVybnMgfjAuNzk1NFxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgdiA9IHBvdyggTmFOLCAzLjAgKTtcbiogLy8gcmV0dXJucyBOYU5cbipcbiogQGV4YW1wbGVcbiogdmFyIHYgPSBwb3coIDUuMCwgTmFOICk7XG4qIC8vIHJldHVybnMgTmFOXG4qXG4qIEBleGFtcGxlXG4qIHZhciB2ID0gcG93KCBOYU4sIE5hTiApO1xuKiAvLyByZXR1cm5zIE5hTlxuKi9cbmZ1bmN0aW9uIHBvdyggeCwgeSApIHtcblx0dmFyIGFoeDsgLy8gYWJzb2x1dGUgdmFsdWUgaGlnaCB3b3JkIGB4YFxuXHR2YXIgYWh5OyAvLyBhYnNvbHV0ZSB2YWx1ZSBoaWdoIHdvcmQgYHlgXG5cdHZhciBheDsgIC8vIGFic29sdXRlIHZhbHVlIGB4YFxuXHR2YXIgaHg7ICAvLyBoaWdoIHdvcmQgYHhgXG5cdHZhciBseDsgIC8vIGxvdyB3b3JkIGB4YFxuXHR2YXIgaHk7ICAvLyBoaWdoIHdvcmQgYHlgXG5cdHZhciBseTsgIC8vIGxvdyB3b3JkIGB5YFxuXHR2YXIgc3g7ICAvLyBzaWduIGB4YFxuXHR2YXIgc3k7ICAvLyBzaWduIGB5YFxuXHR2YXIgeTE7XG5cdHZhciBocDtcblx0dmFyIGxwO1xuXHR2YXIgdDtcblx0dmFyIHo7ICAgLy8geSBwcmltZVxuXHR2YXIgajtcblx0dmFyIGk7XG5cdGlmICggaXNuYW4oIHggKSB8fCBpc25hbiggeSApICkge1xuXHRcdHJldHVybiBOYU47XG5cdH1cblx0Ly8gU3BsaXQgYHlgIGludG8gaGlnaCBhbmQgbG93IHdvcmRzOlxuXHR0b1dvcmRzKCBXT1JEUywgeSApO1xuXHRoeSA9IFdPUkRTWyAwIF07XG5cdGx5ID0gV09SRFNbIDEgXTtcblxuXHQvLyBTcGVjaWFsIGNhc2VzIGB5YC4uLlxuXHRpZiAoIGx5ID09PSAwICkge1xuXHRcdGlmICggeSA9PT0gMC4wICkge1xuXHRcdFx0cmV0dXJuIDEuMDtcblx0XHR9XG5cdFx0aWYgKCB5ID09PSAxLjAgKSB7XG5cdFx0XHRyZXR1cm4geDtcblx0XHR9XG5cdFx0aWYgKCB5ID09PSAtMS4wICkge1xuXHRcdFx0cmV0dXJuIDEuMCAvIHg7XG5cdFx0fVxuXHRcdGlmICggeSA9PT0gMC41ICkge1xuXHRcdFx0cmV0dXJuIHNxcnQoIHggKTtcblx0XHR9XG5cdFx0aWYgKCB5ID09PSAtMC41ICkge1xuXHRcdFx0cmV0dXJuIDEuMCAvIHNxcnQoIHggKTtcblx0XHR9XG5cdFx0aWYgKCB5ID09PSAyLjAgKSB7XG5cdFx0XHRyZXR1cm4geCAqIHg7XG5cdFx0fVxuXHRcdGlmICggeSA9PT0gMy4wICkge1xuXHRcdFx0cmV0dXJuIHggKiB4ICogeDtcblx0XHR9XG5cdFx0aWYgKCB5ID09PSA0LjAgKSB7XG5cdFx0XHR4ICo9IHg7XG5cdFx0XHRyZXR1cm4geCAqIHg7XG5cdFx0fVxuXHRcdGlmICggaXNJbmZpbml0ZSggeSApICkge1xuXHRcdFx0cmV0dXJuIHlJc0luZmluaXRlKCB4LCB5ICk7XG5cdFx0fVxuXHR9XG5cdC8vIFNwbGl0IGB4YCBpbnRvIGhpZ2ggYW5kIGxvdyB3b3Jkczpcblx0dG9Xb3JkcyggV09SRFMsIHggKTtcblx0aHggPSBXT1JEU1sgMCBdO1xuXHRseCA9IFdPUkRTWyAxIF07XG5cblx0Ly8gU3BlY2lhbCBjYXNlcyBgeGAuLi5cblx0aWYgKCBseCA9PT0gMCApIHtcblx0XHRpZiAoIGh4ID09PSAwICkge1xuXHRcdFx0cmV0dXJuIHhJc1plcm8oIHgsIHkgKTtcblx0XHR9XG5cdFx0aWYgKCB4ID09PSAxLjAgKSB7XG5cdFx0XHRyZXR1cm4gMS4wO1xuXHRcdH1cblx0XHRpZiAoXG5cdFx0XHR4ID09PSAtMS4wICYmXG5cdFx0XHRpc09kZCggeSApXG5cdFx0KSB7XG5cdFx0XHRyZXR1cm4gLTEuMDtcblx0XHR9XG5cdFx0aWYgKCBpc0luZmluaXRlKCB4ICkgKSB7XG5cdFx0XHRpZiAoIHggPT09IE5JTkYgKSB7XG5cdFx0XHRcdC8vIGBwb3coIDEveCwgLXkgKWBcblx0XHRcdFx0cmV0dXJuIHBvdyggLTAuMCwgLXkgKTtcblx0XHRcdH1cblx0XHRcdGlmICggeSA8IDAuMCApIHtcblx0XHRcdFx0cmV0dXJuIDAuMDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBQSU5GO1xuXHRcdH1cblx0fVxuXHRpZiAoXG5cdFx0eCA8IDAuMCAmJlxuXHRcdGlzSW50ZWdlciggeSApID09PSBmYWxzZVxuXHQpIHtcblx0XHQvLyBTaWduYWwgTmFOLi4uXG5cdFx0cmV0dXJuICh4LXgpLyh4LXgpO1xuXHR9XG5cdGF4ID0gYWJzKCB4ICk7XG5cblx0Ly8gUmVtb3ZlIHRoZSBzaWduIGJpdHMgKGkuZS4sIGdldCBhYnNvbHV0ZSB2YWx1ZXMpOlxuXHRhaHggPSAoaHggJiBBQlNfTUFTSyl8MDsgLy8gYXNtIHR5cGUgYW5ub3RhdGlvblxuXHRhaHkgPSAoaHkgJiBBQlNfTUFTSyl8MDsgLy8gYXNtIHR5cGUgYW5ub3RhdGlvblxuXG5cdC8vIEV4dHJhY3QgdGhlIHNpZ24gYml0czpcblx0c3ggPSAoaHggPj4+IEhJR0hfTlVNX05PTlNJR05fQklUUyl8MDsgLy8gYXNtIHR5cGUgYW5ub3RhdGlvblxuXHRzeSA9IChoeSA+Pj4gSElHSF9OVU1fTk9OU0lHTl9CSVRTKXwwOyAvLyBhc20gdHlwZSBhbm5vdGF0aW9uXG5cblx0Ly8gRGV0ZXJtaW5lIHRoZSBzaWduIG9mIHRoZSByZXN1bHQuLi5cblx0aWYgKCBzeCAmJiBpc09kZCggeSApICkge1xuXHRcdHN4ID0gLTEuMDtcblx0fSBlbHNlIHtcblx0XHRzeCA9IDEuMDtcblx0fVxuXHQvLyBDYXNlIDE6IGB8eXxgIGlzIGh1Z2UuLi5cblxuXHQvLyB8eXwgPiAyXjMxXG5cdGlmICggYWh5ID4gSElHSF9CSUFTRURfRVhQXzMxICkge1xuXHRcdC8vIGB8eXwgPiAyXjY0YCwgdGhlbiBtdXN0IG92ZXItIG9yIHVuZGVyZmxvdy4uLlxuXHRcdGlmICggYWh5ID4gSElHSF9CSUFTRURfRVhQXzY0ICkge1xuXHRcdFx0cmV0dXJuIHlJc0h1Z2UoIHgsIHkgKTtcblx0XHR9XG5cdFx0Ly8gT3Zlci0gb3IgdW5kZXJmbG93IGlmIGB4YCBpcyBub3QgY2xvc2UgdG8gdW5pdHkuLi5cblxuXHRcdGlmICggYWh4IDwgSElHSF9NQVhfTkVBUl9VTklUWSApIHtcblx0XHRcdC8vIHkgPCAwXG5cdFx0XHRpZiAoIHN5ID09PSAxICkge1xuXHRcdFx0XHQvLyBTaWduYWwgb3ZlcmZsb3cuLi5cblx0XHRcdFx0cmV0dXJuIHN4ICogSFVHRSAqIEhVR0U7XG5cdFx0XHR9XG5cdFx0XHQvLyBTaWduYWwgdW5kZXJmbG93Li4uXG5cdFx0XHRyZXR1cm4gc3ggKiBUSU5ZICogVElOWTtcblx0XHR9XG5cdFx0aWYgKCBhaHggPiBISUdIX0JJQVNFRF9FWFBfMCApIHtcblx0XHRcdC8vIHkgPiAwXG5cdFx0XHRpZiAoIHN5ID09PSAwICkge1xuXHRcdFx0XHQvLyBTaWduYWwgb3ZlcmZsb3cuLi5cblx0XHRcdFx0cmV0dXJuIHN4ICogSFVHRSAqIEhVR0U7XG5cdFx0XHR9XG5cdFx0XHQvLyBTaWduYWwgdW5kZXJmbG93Li4uXG5cdFx0XHRyZXR1cm4gc3ggKiBUSU5ZICogVElOWTtcblx0XHR9XG5cdFx0Ly8gQXQgdGhpcyBwb2ludCwgYHwxLXh8YCBpcyB0aW55IChgPD0gMl4tMjBgKS4gU3VmZmljZSB0byBjb21wdXRlIGBsb2coeClgIGJ5IGB4IC0geF4yLzIgKyB4XjMvMyAtIHheNC80YC5cblx0XHR0ID0gbG9neCggTE9HX1dPUktTUEFDRSwgYXggKTtcblx0fVxuXHQvLyBDYXNlIDI6IGB8eXxgIGlzIG5vdCBodWdlLi4uXG5cdGVsc2Uge1xuXHRcdHQgPSBsb2cyYXgoIExPR19XT1JLU1BBQ0UsIGF4LCBhaHggKTtcblx0fVxuXHQvLyBTcGxpdCBgeWAgaW50byBgeTEgKyB5MmAgYW5kIGNvbXB1dGUgYCh5MSt5MikgKiAodDErdDIpYC4uLlxuXHR5MSA9IHNldExvd1dvcmQoIHksIDAgKTtcblx0bHAgPSAoICh5LXkxKSp0WzBdICkgKyAoIHkqdFsxXSApO1xuXHRocCA9IHkxICogdFswXTtcblx0eiA9IGxwICsgaHA7XG5cblx0Ly8gTm90ZTogKmNhbiogYmUgbW9yZSBwZXJmb3JtYW50IHRvIHVzZSBgZ2V0SGlnaFdvcmRgIGFuZCBgZ2V0TG93V29yZGAgZGlyZWN0bHksIGJ1dCB1c2luZyBgdG9Xb3Jkc2AgbG9va3MgY2xlYW5lci5cblx0dG9Xb3JkcyggV09SRFMsIHogKTtcblx0aiA9IHVpbnQzMlRvSW50MzIoIFdPUkRTWzBdICk7XG5cdGkgPSB1aW50MzJUb0ludDMyKCBXT1JEU1sxXSApO1xuXG5cdC8vIHogPj0gMTAyNFxuXHRpZiAoIGogPj0gSElHSF9CSUFTRURfRVhQXzEwICkge1xuXHRcdC8vIHogPiAxMDI0XG5cdFx0aWYgKCAoKGotSElHSF9CSUFTRURfRVhQXzEwKXxpKSAhPT0gMCApIHtcblx0XHRcdC8vIFNpZ25hbCBvdmVyZmxvdy4uLlxuXHRcdFx0cmV0dXJuIHN4ICogSFVHRSAqIEhVR0U7XG5cdFx0fVxuXHRcdGlmICggKGxwK09WVCkgPiAoei1ocCkgKSB7XG5cdFx0XHQvLyBTaWduYWwgb3ZlcmZsb3cuLi5cblx0XHRcdHJldHVybiBzeCAqIEhVR0UgKiBIVUdFO1xuXHRcdH1cblx0fVxuXHQvLyB6IDw9IC0xMDc1XG5cdGVsc2UgaWYgKCAoaiZBQlNfTUFTSykgPj0gSElHSF8xMDc1ICkge1xuXHRcdC8vIHogPCAtMTA3NVxuXHRcdGlmICggKChqLUhJR0hfTkVHXzEwNzUpfGkpICE9PSAwICkge1xuXHRcdFx0Ly8gc2lnbmFsIHVuZGVyZmxvdy4uLlxuXHRcdFx0cmV0dXJuIHN4ICogVElOWSAqIFRJTlk7XG5cdFx0fVxuXHRcdGlmICggbHAgPD0gKHotaHApICkge1xuXHRcdFx0Ly8gc2lnbmFsIHVuZGVyZmxvdy4uLlxuXHRcdFx0cmV0dXJuIHN4ICogVElOWSAqIFRJTlk7XG5cdFx0fVxuXHR9XG5cdC8vIENvbXB1dGUgYDJeKGhwK2xwKWAuLi5cblx0eiA9IHBvdzIoIGosIGhwLCBscCApO1xuXG5cdHJldHVybiBzeCAqIHo7XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBvdztcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogRXZhbHVhdGUgdGhlIGV4cG9uZW50aWFsIGZ1bmN0aW9uLlxuKlxuKiBAbW9kdWxlIEBzdGRsaWIvbWF0aC1iYXNlLXNwZWNpYWwtcG93XG4qXG4qIEBleGFtcGxlXG4qIHZhciBwb3cgPSByZXF1aXJlKCAnQHN0ZGxpYi9tYXRoLWJhc2Utc3BlY2lhbC1wb3cnICk7XG4qXG4qIHZhciB2ID0gcG93KCAyLjAsIDMuMCApO1xuKiAvLyByZXR1cm5zIDguMFxuKlxuKiB2ID0gcG93KCA0LjAsIDAuNSApO1xuKiAvLyByZXR1cm5zIDIuMFxuKlxuKiB2ID0gcG93KCAxMDAuMCwgMC4wICk7XG4qIC8vIHJldHVybnMgMS4wXG4qXG4qIHYgPSBwb3coIDMuMTQxNTkyNjUzNTg5NzkzLCA1LjAgKTtcbiogLy8gcmV0dXJucyB+MzA2LjAxOTdcbipcbiogdiA9IHBvdyggMy4xNDE1OTI2NTM1ODk3OTMsIC0wLjIgKTtcbiogLy8gcmV0dXJucyB+MC43OTU0XG4qXG4qIHYgPSBwb3coIE5hTiwgMy4wICk7XG4qIC8vIHJldHVybnMgTmFOXG4qXG4qIHYgPSBwb3coIDUuMCwgTmFOICk7XG4qIC8vIHJldHVybnMgTmFOXG4qXG4qIHYgPSBwb3coIE5hTiwgTmFOICk7XG4qIC8vIHJldHVybnMgTmFOXG4qL1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBwb3cgPSByZXF1aXJlKCAnLi9wb3cuanMnICk7XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBvdztcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUT0RPOiBpbXBsZW1lbnRhdGlvblxuXG4vKipcbiogUm91bmRzIGEgbnVtZXJpYyB2YWx1ZSB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyLlxuKlxuKiBAcGFyYW0ge251bWJlcn0geCAtIGlucHV0IHZhbHVlXG4qIEByZXR1cm5zIHtudW1iZXJ9IGZ1bmN0aW9uIHZhbHVlXG4qXG4qIEBleGFtcGxlXG4qIHZhciB2ID0gcm91bmQoIC00LjIgKTtcbiogLy8gcmV0dXJucyAtNC4wXG4qXG4qIEBleGFtcGxlXG4qIHZhciB2ID0gcm91bmQoIC00LjUgKTtcbiogLy8gcmV0dXJucyAtNC4wXG4qXG4qIEBleGFtcGxlXG4qIHZhciB2ID0gcm91bmQoIC00LjYgKTtcbiogLy8gcmV0dXJucyAtNS4wXG4qXG4qIEBleGFtcGxlXG4qIHZhciB2ID0gcm91bmQoIDkuOTk5OTkgKTtcbiogLy8gcmV0dXJucyAxMC4wXG4qXG4qIEBleGFtcGxlXG4qIHZhciB2ID0gcm91bmQoIDkuNSApO1xuKiAvLyByZXR1cm5zIDEwLjBcbipcbiogQGV4YW1wbGVcbiogdmFyIHYgPSByb3VuZCggOS4yICk7XG4qIC8vIHJldHVybnMgOS4wXG4qXG4qIEBleGFtcGxlXG4qIHZhciB2ID0gcm91bmQoIDAuMCApO1xuKiAvLyByZXR1cm5zIDAuMFxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgdiA9IHJvdW5kKCAtMC4wICk7XG4qIC8vIHJldHVybnMgLTAuMFxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgdiA9IHJvdW5kKCBJbmZpbml0eSApO1xuKiAvLyByZXR1cm5zIEluZmluaXR5XG4qXG4qIEBleGFtcGxlXG4qIHZhciB2ID0gcm91bmQoIC1JbmZpbml0eSApO1xuKiAvLyByZXR1cm5zIC1JbmZpbml0eVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgdiA9IHJvdW5kKCBOYU4gKTtcbiogLy8gcmV0dXJucyBOYU5cbiovXG52YXIgcm91bmQgPSBNYXRoLnJvdW5kOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHN0ZGxpYi9uby1idWlsdGluLW1hdGhcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gcm91bmQ7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gVE9ETzogaW1wbGVtZW50YXRpb25cblxuLyoqXG4qIFJvdW5kIGEgbnVtZXJpYyB2YWx1ZSB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyLlxuKlxuKiBAbW9kdWxlIEBzdGRsaWIvbWF0aC1iYXNlLXNwZWNpYWwtcm91bmRcbipcbiogQGV4YW1wbGVcbiogdmFyIHJvdW5kID0gcmVxdWlyZSggJ0BzdGRsaWIvbWF0aC1iYXNlLXNwZWNpYWwtcm91bmQnICk7XG4qXG4qIHZhciB2ID0gcm91bmQoIC00LjIgKTtcbiogLy8gcmV0dXJucyAtNC4wXG4qXG4qIHYgPSByb3VuZCggLTQuNSApO1xuKiAvLyByZXR1cm5zIC00LjBcbipcbiogdiA9IHJvdW5kKCAtNC42ICk7XG4qIC8vIHJldHVybnMgLTUuMFxuKlxuKiB2ID0gcm91bmQoIDkuOTk5OTkgKTtcbiogLy8gcmV0dXJucyAxMC4wXG4qXG4qIHYgPSByb3VuZCggOS41ICk7XG4qIC8vIHJldHVybnMgMTAuMFxuKlxuKiB2ID0gcm91bmQoIDkuMiApO1xuKiAvLyByZXR1cm5zIDkuMFxuKlxuKiB2ID0gcm91bmQoIDAuMCApO1xuKiAvLyByZXR1cm5zIDAuMFxuKlxuKiB2ID0gcm91bmQoIC0wLjAgKTtcbiogLy8gcmV0dXJucyAtMC4wXG4qXG4qIHYgPSByb3VuZCggSW5maW5pdHkgKTtcbiogLy8gcmV0dXJucyBJbmZpbml0eVxuKlxuKiB2ID0gcm91bmQoIC1JbmZpbml0eSApO1xuKiAvLyByZXR1cm5zIC1JbmZpbml0eVxuKlxuKiB2ID0gcm91bmQoIE5hTiApO1xuKiAvLyByZXR1cm5zIE5hTlxuKi9cblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgcm91bmQgPSByZXF1aXJlKCAnLi9yb3VuZC5qcycgKTtcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gcm91bmQ7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIE1heGltdW0gc2FmZSBkb3VibGUtcHJlY2lzaW9uIGZsb2F0aW5nLXBvaW50IGludGVnZXIuXG4qXG4qIEBtb2R1bGUgQHN0ZGxpYi9jb25zdGFudHMtZmxvYXQ2NC1tYXgtc2FmZS1pbnRlZ2VyXG4qIEB0eXBlIHtudW1iZXJ9XG4qXG4qIEBleGFtcGxlXG4qIHZhciBGTE9BVDY0X01BWF9TQUZFX0lOVEVHRVIgPSByZXF1aXJlKCAnQHN0ZGxpYi9jb25zdGFudHMtZmxvYXQ2NC1tYXgtc2FmZS1pbnRlZ2VyJyApO1xuKiAvLyByZXR1cm5zIDkwMDcxOTkyNTQ3NDA5OTFcbiovXG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogTWF4aW11bSBzYWZlIGRvdWJsZS1wcmVjaXNpb24gZmxvYXRpbmctcG9pbnQgaW50ZWdlci5cbipcbiogIyMgTm90ZXNcbipcbiogVGhlIGludGVnZXIgaGFzIHRoZSB2YWx1ZVxuKlxuKiBgYGB0ZXhcbiogMl57NTN9IC0gMVxuKiBgYGBcbipcbiogQGNvbnN0YW50XG4qIEB0eXBlIHtudW1iZXJ9XG4qIEBkZWZhdWx0IDkwMDcxOTkyNTQ3NDA5OTFcbiogQHNlZSBbU2FmZSBJbnRlZ2Vyc117QGxpbmsgaHR0cDovL3d3dy4yYWxpdHkuY29tLzIwMTMvMTAvc2FmZS1pbnRlZ2Vycy5odG1sfVxuKiBAc2VlIFtJRUVFIDc1NF17QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSUVFRV83NTQtMTk4NX1cbiovXG52YXIgRkxPQVQ2NF9NQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gRkxPQVQ2NF9NQVhfU0FGRV9JTlRFR0VSO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBUaGUgbWF4aW11bSBiYXNlIDEwIGV4cG9uZW50IGZvciBhIGRvdWJsZS1wcmVjaXNpb24gZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxuKlxuKiBAbW9kdWxlIEBzdGRsaWIvY29uc3RhbnRzLWZsb2F0NjQtbWF4LWJhc2UxMC1leHBvbmVudFxuKiBAdHlwZSB7aW50ZWdlcjMyfVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgRkxPQVQ2NF9NQVhfQkFTRTEwX0VYUE9ORU5UID0gcmVxdWlyZSggJ0BzdGRsaWIvY29uc3RhbnRzLWZsb2F0NjQtbWF4LWJhc2UxMC1leHBvbmVudCcgKTtcbiogLy8gcmV0dXJucyAzMDhcbiovXG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogVGhlIG1heGltdW0gYmFzZSAxMCBleHBvbmVudCBmb3IgYSBkb3VibGUtcHJlY2lzaW9uIGZsb2F0aW5nLXBvaW50IG51bWJlci5cbipcbiogQGNvbnN0YW50XG4qIEB0eXBlIHtpbnRlZ2VyMzJ9XG4qIEBkZWZhdWx0IDMwOFxuKiBAc2VlIFtJRUVFIDc1NF17QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSUVFRV83NTQtMTk4NX1cbiovXG52YXIgRkxPQVQ2NF9NQVhfQkFTRTEwX0VYUE9ORU5UID0gMzA4fDA7IC8vIGFzbSB0eXBlIGFubm90YXRpb25cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gRkxPQVQ2NF9NQVhfQkFTRTEwX0VYUE9ORU5UO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBUaGUgbWluaW11bSBiYXNlIDEwIGV4cG9uZW50IGZvciBhIG5vcm1hbCBkb3VibGUtcHJlY2lzaW9uIGZsb2F0aW5nLXBvaW50IG51bWJlci5cbipcbiogQG1vZHVsZSBAc3RkbGliL2NvbnN0YW50cy1mbG9hdDY0LW1pbi1iYXNlMTAtZXhwb25lbnRcbiogQHR5cGUge2ludGVnZXIzMn1cbipcbiogQGV4YW1wbGVcbiogdmFyIEZMT0FUNjRfTUlOX0JBU0UxMF9FWFBPTkVOVCA9IHJlcXVpcmUoICdAc3RkbGliL2NvbnN0YW50cy1mbG9hdDY0LW1pbi1iYXNlMTAtZXhwb25lbnQnICk7XG4qIC8vIHJldHVybnMgLTMwOFxuKi9cblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBUaGUgbWluaW11bSBiYXNlIDEwIGV4cG9uZW50IGZvciBhIG5vcm1hbCBkb3VibGUtcHJlY2lzaW9uIGZsb2F0aW5nLXBvaW50IG51bWJlci5cbipcbiogYGBgdGV4dFxuKiAyXi0xMDIyID0gMi4yMjUwNzM4NTg1MDcyMDE0ZS0zMDggPT4gLTMwOFxuKiBgYGBcbipcbiogQGNvbnN0YW50XG4qIEB0eXBlIHtpbnRlZ2VyMzJ9XG4qIEBkZWZhdWx0IC0zMDhcbiogQHNlZSBbSUVFRSA3NTRde0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lFRUVfNzU0LTE5ODV9XG4qL1xudmFyIEZMT0FUNjRfTUlOX0JBU0UxMF9FWFBPTkVOVCA9IC0zMDh8MDsgLy8gYXNtIHR5cGUgYW5ub3RhdGlvblxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBGTE9BVDY0X01JTl9CQVNFMTBfRVhQT05FTlQ7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIFRoZSBtaW5pbXVtIGJhc2UgMTAgZXhwb25lbnQgZm9yIGEgc3Vibm9ybWFsIGRvdWJsZS1wcmVjaXNpb24gZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxuKlxuKiBAbW9kdWxlIEBzdGRsaWIvY29uc3RhbnRzLWZsb2F0NjQtbWluLWJhc2UxMC1leHBvbmVudC1zdWJub3JtYWxcbiogQHR5cGUge2ludGVnZXIzMn1cbipcbiogQGV4YW1wbGVcbiogdmFyIEZMT0FUNjRfTUlOX0JBU0UxMF9FWFBPTkVOVF9TVUJOT1JNQUwgPSByZXF1aXJlKCAnQHN0ZGxpYi9jb25zdGFudHMtZmxvYXQ2NC1taW4tYmFzZTEwLWV4cG9uZW50LXN1Ym5vcm1hbCcgKTtcbiogLy8gcmV0dXJucyAtMzI0XG4qL1xuXG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIFRoZSBtaW5pbXVtIGJhc2UgMTAgZXhwb25lbnQgZm9yIGEgc3Vibm9ybWFsIGRvdWJsZS1wcmVjaXNpb24gZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxuKlxuKiBAY29uc3RhbnRcbiogQHR5cGUge2ludGVnZXIzMn1cbiogQGRlZmF1bHQgLTMyNFxuKiBAc2VlIFtJRUVFIDc1NF17QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSUVFRV83NTQtMTk4NX1cbiovXG52YXIgRkxPQVQ2NF9NSU5fQkFTRTEwX0VYUE9ORU5UX1NVQk5PUk1BTCA9IC0zMjR8MDsgLy8gYXNtIHR5cGUgYW5ub3RhdGlvblxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBGTE9BVDY0X01JTl9CQVNFMTBfRVhQT05FTlRfU1VCTk9STUFMO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGlzbmFuID0gcmVxdWlyZSggJ0BzdGRsaWIvbWF0aC1iYXNlLWFzc2VydC1pcy1uYW4nICk7XG52YXIgaXNJbmZpbml0ZSA9IHJlcXVpcmUoICdAc3RkbGliL21hdGgtYmFzZS1hc3NlcnQtaXMtaW5maW5pdGUnICk7XG52YXIgcG93ID0gcmVxdWlyZSggJ0BzdGRsaWIvbWF0aC1iYXNlLXNwZWNpYWwtcG93JyApO1xudmFyIGFicyA9IHJlcXVpcmUoICdAc3RkbGliL21hdGgtYmFzZS1zcGVjaWFsLWFicycgKTtcbnZhciByb3VuZCA9IHJlcXVpcmUoICdAc3RkbGliL21hdGgtYmFzZS1zcGVjaWFsLXJvdW5kJyApO1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSByZXF1aXJlKCAnQHN0ZGxpYi9jb25zdGFudHMtZmxvYXQ2NC1tYXgtc2FmZS1pbnRlZ2VyJyApO1xudmFyIE1BWF9FWFAgPSByZXF1aXJlKCAnQHN0ZGxpYi9jb25zdGFudHMtZmxvYXQ2NC1tYXgtYmFzZTEwLWV4cG9uZW50JyApO1xudmFyIE1JTl9FWFAgPSByZXF1aXJlKCAnQHN0ZGxpYi9jb25zdGFudHMtZmxvYXQ2NC1taW4tYmFzZTEwLWV4cG9uZW50JyApO1xudmFyIE1JTl9FWFBfU1VCTk9STUFMID0gcmVxdWlyZSggJ0BzdGRsaWIvY29uc3RhbnRzLWZsb2F0NjQtbWluLWJhc2UxMC1leHBvbmVudC1zdWJub3JtYWwnICk7XG5cblxuLy8gVkFSSUFCTEVTIC8vXG5cbnZhciBNQVhfSU5UID0gTUFYX1NBRkVfSU5URUdFUiArIDE7XG52YXIgSFVHRSA9IDEuMGUrMzA4O1xuXG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIFJvdW5kcyBhIG51bWVyaWMgdmFsdWUgdG8gdGhlIG5lYXJlc3QgbXVsdGlwbGUgb2YgXFxcXCgxMF5uXFxcXCkuXG4qXG4qICMjIE1ldGhvZFxuKlxuKiAxLiAgSWYgXFxcXCh8eHwgPD0gMl57NTN9XFxcXCkgYW5kIFxcXFwofG58IDw9IDMwOFxcXFwpLCB3ZSBjYW4gdXNlIHRoZSBmb3JtdWxhXG4qXG4qICAgICBgYGB0ZXhcbiogICAgIFxcb3BlcmF0b3JuYW1le3JvdW5kbn0oeCxuKSA9IFxcZnJhY3tcXG9wZXJhdG9ybmFtZXtyb3VuZH0oeCBcXGNkb3QgMTBeey1ufSl9ezEwXnstbn19XG4qICAgICBgYGBcbipcbiogICAgIHdoaWNoIHNoaWZ0cyB0aGUgZGVjaW1hbCB0byB0aGUgbmVhcmVzdCBtdWx0aXBsZSBvZiBcXFxcKDEwXm5cXFxcKSwgcGVyZm9ybXMgYSBzdGFuZGFyZCBcXFxcKFxcbWF0aHJte3JvdW5kfVxcXFwpIG9wZXJhdGlvbiwgYW5kIHRoZW4gc2hpZnRzIHRoZSBkZWNpbWFsIHRvIGl0cyBvcmlnaW5hbCBwb3NpdGlvbi5cbipcbiogICAgIDwhLS0gPG5vdGU+IC0tPlxuKlxuKiAgICAgSWYgXFxcXCh4IFxcY2RvdCAxMF57LW59XFxcXCkgb3ZlcmZsb3dzLCBcXFxcKHhcXFxcKSBsYWNrcyBhIHN1ZmZpY2llbnQgbnVtYmVyIG9mIGRlY2ltYWwgZGlnaXRzIHRvIGhhdmUgYW55IGVmZmVjdCB3aGVuIHJvdW5kaW5nLiBBY2NvcmRpbmdseSwgdGhlIHJvdW5kZWQgdmFsdWUgaXMgXFxcXCh4XFxcXCkuXG4qXG4qICAgICA8IS0tIDwvbm90ZT4gLS0+XG4qXG4qICAgICA8IS0tIDxub3RlPiAtLT5cbipcbiogICAgIE5vdGUgdGhhdCByZXNjYWxpbmcgXFxcXCh4XFxcXCkgY2FuIHJlc3VsdCBpbiB1bmV4cGVjdGVkIGJlaGF2aW9yLiBGb3IgaW5zdGFuY2UsIHRoZSByZXN1bHQgb2YgXFxcXChcXG9wZXJhdG9ybmFtZXtyb3VuZG59KDAuMiswLjEsLTE2KVxcXFwpIGlzIFxcXFwoMC4zMDAwMDAwMDAwMDAwMDAxXFxcXCkgYW5kIG5vdCBcXFxcKDAuM1xcXFwpLiBXaGlsZSBwb3NzaWJseSB1bmV4cGVjdGVkLCB0aGlzIGlzIG5vdCBhIGJ1Zy4gVGhlIGJlaGF2aW9yIHN0ZW1zIGZyb20gdGhlIGZhY3QgdGhhdCBtb3N0IGRlY2ltYWwgZnJhY3Rpb25zIGNhbm5vdCBiZSBleGFjdGx5IHJlcHJlc2VudGVkIGFzIGZsb2F0aW5nLXBvaW50IG51bWJlcnMuIEFuZCBmdXJ0aGVyLCByZXNjYWxpbmcgY2FuIGxlYWQgdG8gc2xpZ2h0bHkgZGlmZmVyZW50IGZyYWN0aW9uYWwgdmFsdWVzLCB3aGljaCwgaW4gdHVybiwgYWZmZWN0cyB0aGUgcmVzdWx0IG9mIFxcXFwoXFxtYXRocm17cm91bmR9XFxcXCkuXG4qXG4qICAgICA8IS0tIDwvbm90ZT4gLS0+XG4qXG4qIDIuICBJZiBcXFxcKG4gPiAzMDhcXFxcKSwgd2UgcmVjb2duaXplIHRoYXQgdGhlIG1heGltdW0gYWJzb2x1dGUgZG91YmxlLXByZWNpc2lvbiBmbG9hdGluZy1wb2ludCBudW1iZXIgaXMgXFxcXChcXGFwcHJveCAxLjhcXG1ib3h7ZX0zMDhcXFxcKSBhbmQsIHRodXMsIHRoZSByZXN1bHQgb2Ygcm91bmRpbmcgYW55IHBvc3NpYmxlIGZpbml0ZSBudW1iZXIgXFxcXCh4XFxcXCkgdG8gdGhlIG5lYXJlc3QgXFxcXCgxMF5uXFxcXCkgaXMgXFxcXCgwLjBcXFxcKS4gVG8gZW5zdXJlIGNvbnNpc3RlbnQgYmVoYXZpb3Igd2l0aCBcXFxcKFxcb3BlcmF0b3JuYW1le3JvdW5kfSh4KVxcXFwpLCB0aGUgc2lnbiBvZiBcXFxcKHhcXFxcKSBpcyBwcmVzZXJ2ZWQuXG4qXG4qIDMuICBJZiBcXFxcKG4gPCAtMzI0XFxcXCksIFxcXFwoblxcXFwpIGV4Y2VlZHMgdGhlIG1heGltdW0gbnVtYmVyIG9mIHBvc3NpYmxlIGRlY2ltYWwgcGxhY2VzIChzdWNoIGFzIHdpdGggc3Vibm9ybWFsIG51bWJlcnMpLCBhbmQsIHRodXMsIHRoZSByb3VuZGVkIHZhbHVlIGlzIFxcXFwoeFxcXFwpLlxuKlxuKiA0LiAgSWYgXFxcXCh4ID4gMl57NTN9XFxcXCksIFxcXFwoeFxcXFwpIGlzICoqYWx3YXlzKiogYW4gaW50ZWdlciAoaS5lLiwgXFxcXCh4XFxcXCkgaGFzIG5vIGRlY2ltYWwgZGlnaXRzKS4gSWYgXFxcXChuIDw9IDBcXFxcKSwgdGhlIHJvdW5kZWQgdmFsdWUgaXMgXFxcXCh4XFxcXCkuXG4qXG4qIDUuICBJZiBcXFxcKG4gPCAtMzA4XFxcXCksIHdlIGxldCBcXFxcKG0gPSBuICsgMzA4XFxcXCkgYW5kIG1vZGlmeSB0aGUgYWJvdmUgZm9ybXVsYSB0byBhdm9pZCBvdmVyZmxvdy5cbipcbiogICAgIGBgYHRleFxuKiAgICAgXFxvcGVyYXRvcm5hbWV7cm91bmRufSh4LG4pID0gXFxmcmFje1xcYmlnZ2woXFxmcmFje1xcb3BlcmF0b3JuYW1le3JvdW5kfSggKHggXFxjZG90IDEwXnszMDh9KSAxMF57LW19KX17MTBeezMwOH19XFxiaWdncil9ezEwXnstbX19XG4qICAgICBgYGBcbipcbiogICAgIElmIG92ZXJmbG93IG9jY3VycywgdGhlIHJvdW5kZWQgdmFsdWUgaXMgXFxcXCh4XFxcXCkuXG4qXG4qXG4qICMjIFNwZWNpYWwgQ2FzZXNcbipcbiogYGBgdGV4XG4qIFxcYmVnaW57YWxpZ24qfVxuKiBcXG9wZXJhdG9ybmFtZXtyb3VuZG59KFxcbWF0aHJte05hTn0sIG4pICY9IFxcbWF0aHJte05hTn0gXFxcXFxuKiBcXG9wZXJhdG9ybmFtZXtyb3VuZG59KHgsIFxcbWF0aHJte05hTn0pICY9IFxcbWF0aHJte05hTn0gXFxcXFxuKiBcXG9wZXJhdG9ybmFtZXtyb3VuZG59KHgsIFxccG1cXGluZnR5KSAmPSBcXG1hdGhybXtOYU59IFxcXFxcbiogXFxvcGVyYXRvcm5hbWV7cm91bmRufShcXHBtXFxpbmZ0eSwgbikgJj0gXFxwbVxcaW5mdHkgXFxcXFxuKiBcXG9wZXJhdG9ybmFtZXtyb3VuZG59KFxccG0gMCwgbikgJj0gXFxwbSAwXG4qIFxcZW5ke2FsaWduKn1cbiogYGBgXG4qXG4qICMjIE5vdGVzXG4qXG4qIDEuICBBbHRlcm5hdGl2ZSBhbGdvcml0aG1zOlxuKlxuKiAgICAgLSAgIFJvdW5kIGJ5IFtjYXN0aW5nXVsxXSBcXFxcKHhcXFxcKSB0byBhbiBleHBvbmVudGlhbCBzdHJpbmcuXG4qICAgICAtICAgTmF0aXZlIFB5dGhvbiBpbXBsZW1lbnRhdGlvbiBbMV1bMl0gYW5kIFsyXVszXS5cbipcbiogWzFdOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL3JvdW5kXG4qIFsyXTogaHR0cHM6Ly9oZy5weXRob24ub3JnL3JlbGVhc2luZy8yLjcuOS9maWxlL3RpcC9PYmplY3RzL2Zsb2F0b2JqZWN0LmMjbDEwODJcbiogWzNdOiBodHRwczovL2hnLnB5dGhvbi5vcmcvcmVsZWFzaW5nLzIuNy45L2ZpbGUvdGlwL09iamVjdHMvZmxvYXRvYmplY3QuYyNsMTIyNlxuKlxuKlxuKiBAcGFyYW0ge251bWJlcn0geCAtIGlucHV0IHZhbHVlXG4qIEBwYXJhbSB7aW50ZWdlcn0gbiAtIGludGVnZXIgcG93ZXIgb2YgYDEwYFxuKiBAcmV0dXJucyB7bnVtYmVyfSByb3VuZGVkIHZhbHVlXG4qXG4qIEBleGFtcGxlXG4qIC8vIFJvdW5kIGEgdmFsdWUgdG8gMiBkZWNpbWFsIHBsYWNlczpcbiogdmFyIHYgPSByb3VuZG4oIDMuMTQxNTkyNjUzNTg5NzkzLCAtMiApO1xuKiAvLyByZXR1cm5zIDMuMTRcbipcbiogQGV4YW1wbGVcbiogLy8gSWYgbiA9IDAsIGByb3VuZG5gIGJlaGF2ZXMgbGlrZSBgcm91bmRgOlxuKiB2YXIgdiA9IHJvdW5kbiggMy4xNDE1OTI2NTM1ODk3OTMsIDAgKTtcbiogLy8gcmV0dXJucyAzLjBcbipcbiogQGV4YW1wbGVcbiogLy8gUm91bmQgYSB2YWx1ZSB0byB0aGUgbmVhcmVzdCB0aG91c2FuZDpcbiogdmFyIHYgPSByb3VuZG4oIDEyMzY4LjAsIDMgKTtcbiogLy8gcmV0dXJucyAxMjAwMC4wXG4qL1xuZnVuY3Rpb24gcm91bmRuKCB4LCBuICkge1xuXHR2YXIgcztcblx0dmFyIHk7XG5cdGlmIChcblx0XHRpc25hbiggeCApIHx8XG5cdFx0aXNuYW4oIG4gKSB8fFxuXHRcdGlzSW5maW5pdGUoIG4gKVxuXHQpIHtcblx0XHRyZXR1cm4gTmFOO1xuXHR9XG5cdGlmIChcblx0XHQvLyBIYW5kbGUgaW5maW5pdGllcy4uLlxuXHRcdGlzSW5maW5pdGUoIHggKSB8fFxuXG5cdFx0Ly8gSGFuZGxlICstMC4uLlxuXHRcdHggPT09IDAuMCB8fFxuXG5cdFx0Ly8gSWYgYG5gIGV4Y2VlZHMgdGhlIG1heGltdW0gbnVtYmVyIG9mIGZlYXNpYmxlIGRlY2ltYWwgcGxhY2VzIChzdWNoIGFzIHdpdGggc3Vibm9ybWFsIG51bWJlcnMpLCBub3RoaW5nIHRvIHJvdW5kLi4uXG5cdFx0biA8IE1JTl9FWFBfU1VCTk9STUFMIHx8XG5cblx0XHQvLyBJZiBgfHh8YCBpcyBsYXJnZSBlbm91Z2gsIG5vIGRlY2ltYWxzIHRvIHJvdW5kLi4uXG5cdFx0KCBhYnMoIHggKSA+IE1BWF9JTlQgJiYgbiA8PSAwIClcblx0KSB7XG5cdFx0cmV0dXJuIHg7XG5cdH1cblx0Ly8gVGhlIG1heGltdW0gYWJzb2x1dGUgZG91YmxlIGlzIH4xLjhlMzA4LiBBY2NvcmRpbmdseSwgYW55IHBvc3NpYmxlIGZpbml0ZSBgeGAgcm91bmRlZCB0byB0aGUgbmVhcmVzdCA+PTEwXjMwOSBpcyAwLjAuXG5cdGlmICggbiA+IE1BWF9FWFAgKSB7XG5cdFx0cmV0dXJuIDAuMCAqIHg7IC8vIHByZXNlcnZlIHRoZSBzaWduIChzYW1lIGJlaGF2aW9yIGFzIHJvdW5kKVxuXHR9XG5cdC8vIElmIHdlIG92ZXJmbG93LCByZXR1cm4gYHhgLCBhcyB0aGUgbnVtYmVyIG9mIGRpZ2l0cyB0byB0aGUgcmlnaHQgb2YgdGhlIGRlY2ltYWwgaXMgdG9vIHNtYWxsIChpLmUuLCBgeGAgaXMgdG9vIGxhcmdlIC8gbGFja3Mgc3VmZmljaWVudCBmcmFjdGlvbmFsIHByZWNpc2lvbikgZm9yIHRoZXJlIHRvIGJlIGFueSBlZmZlY3Qgd2hlbiByb3VuZGluZy4uLlxuXHRpZiAoIG4gPCBNSU5fRVhQICkge1xuXHRcdHMgPSBwb3coIDEwLjAsIC0obiArIE1BWF9FWFApICk7XG5cdFx0eSA9ICh4KkhVR0UpICogczsgLy8gb3JkZXIgb2Ygb3BlcmF0aW9uIG1hdHRlcnMhXG5cdFx0aWYgKCBpc0luZmluaXRlKCB5ICkgKSB7XG5cdFx0XHRyZXR1cm4geDtcblx0XHR9XG5cdFx0cmV0dXJuICggcm91bmQoeSkvSFVHRSApIC8gcztcblx0fVxuXHRzID0gcG93KCAxMC4wLCAtbiApO1xuXHR5ID0geCAqIHM7XG5cdGlmICggaXNJbmZpbml0ZSggeSApICkge1xuXHRcdHJldHVybiB4O1xuXHR9XG5cdHJldHVybiByb3VuZCggeSApIC8gcztcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gcm91bmRuO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBSb3VuZCBhIG51bWVyaWMgdmFsdWUgdG8gdGhlIG5lYXJlc3QgbXVsdGlwbGUgb2YgYDEwXm5gLlxuKlxuKiBAbW9kdWxlIEBzdGRsaWIvbWF0aC1iYXNlLXNwZWNpYWwtcm91bmRuXG4qXG4qIEBleGFtcGxlXG4qIHZhciByb3VuZG4gPSByZXF1aXJlKCAnQHN0ZGxpYi9tYXRoLWJhc2Utc3BlY2lhbC1yb3VuZG4nICk7XG4qXG4qIC8vIFJvdW5kIGEgdmFsdWUgdG8gMiBkZWNpbWFsIHBsYWNlczpcbiogdmFyIHYgPSByb3VuZG4oIDMuMTQxNTkyNjUzNTg5NzkzLCAtMiApO1xuKiAvLyByZXR1cm5zIDMuMTRcbipcbiogLy8gSWYgbiA9IDAsIGByb3VuZG5gIGJlaGF2ZXMgbGlrZSBgcm91bmRgOlxuKiB2ID0gcm91bmRuKCAzLjE0MTU5MjY1MzU4OTc5MywgMCApO1xuKiAvLyByZXR1cm5zIDMuMFxuKlxuKiAvLyBSb3VuZCBhIHZhbHVlIHRvIHRoZSBuZWFyZXN0IHRob3VzYW5kOlxuKiB2ID0gcm91bmRuKCAxMjM2OC4wLCAzICk7XG4qIC8vIHJldHVybnMgMTIwMDAuMFxuKi9cblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgcm91bmRuID0gcmVxdWlyZSggJy4vcm91bmRuLmpzJyApO1xuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSByb3VuZG47XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgZGF0YSA9IHJlcXVpcmUoICcuLy4uL2RhdGEvd29yZHMuanNvbicgKTtcblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBSZXR1cm5zIGEgbGlzdCBvZiBFbmdsaXNoIHN0b3Agd29yZHMuXG4qXG4qIEByZXR1cm5zIHtTdHJpbmdBcnJheX0gc3RvcCB3b3Jkc1xuKlxuKiBAZXhhbXBsZVxuKiB2YXIgbGlzdCA9IHN0b3B3b3JkcygpO1xuKiAvLyByZXR1cm5zIFsgJ2EnLCAnYWJvdXQnLCAnYWJvdmUnLCAnYWNyb3NzJywgJ2FjdHVhbGx5JywgLi4uIF1cbiovXG5mdW5jdGlvbiBzdG9wd29yZHMoKSB7XG5cdHJldHVybiBkYXRhLnNsaWNlKCk7XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0b3B3b3JkcztcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMjEgVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNQUlOIC8vXG5cbnZhciBtYWluID0gKCB0eXBlb2YgT2JqZWN0LmRlZmluZVByb3BlcnR5ID09PSAnZnVuY3Rpb24nICkgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBudWxsO1xuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBtYWluO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAyMSBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSggJy4vZGVmaW5lX3Byb3BlcnR5LmpzJyApO1xuXG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIFRlc3RzIGZvciBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBzdXBwb3J0LlxuKlxuKiBAcHJpdmF0ZVxuKiBAcmV0dXJucyB7Ym9vbGVhbn0gYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGFuIGVudmlyb25tZW50IGhhcyBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBzdXBwb3J0XG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaGFzRGVmaW5lUHJvcGVydHlTdXBwb3J0KCk7XG4qIC8vIHJldHVybnMgPGJvb2xlYW4+XG4qL1xuZnVuY3Rpb24gaGFzRGVmaW5lUHJvcGVydHlTdXBwb3J0KCkge1xuXHQvLyBUZXN0IGJhc2ljIHN1cHBvcnQuLi5cblx0dHJ5IHtcblx0XHRkZWZpbmVQcm9wZXJ0eSgge30sICd4Jywge30gKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoIGVyciApIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNEZWZpbmVQcm9wZXJ0eVN1cHBvcnQ7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTUFJTiAvL1xuXG4vKipcbiogRGVmaW5lcyAob3IgbW9kaWZpZXMpIGFuIG9iamVjdCBwcm9wZXJ0eS5cbipcbiogIyMgTm90ZXNcbipcbiogLSAgIFByb3BlcnR5IGRlc2NyaXB0b3JzIGNvbWUgaW4gdHdvIGZsYXZvcnM6ICoqZGF0YSBkZXNjcmlwdG9ycyoqIGFuZCAqKmFjY2Vzc29yIGRlc2NyaXB0b3JzKiouIEEgZGF0YSBkZXNjcmlwdG9yIGlzIGEgcHJvcGVydHkgdGhhdCBoYXMgYSB2YWx1ZSwgd2hpY2ggbWF5IG9yIG1heSBub3QgYmUgd3JpdGFibGUuIEFuIGFjY2Vzc29yIGRlc2NyaXB0b3IgaXMgYSBwcm9wZXJ0eSBkZXNjcmliZWQgYnkgYSBnZXR0ZXItc2V0dGVyIGZ1bmN0aW9uIHBhaXIuIEEgZGVzY3JpcHRvciBtdXN0IGJlIG9uZSBvZiB0aGVzZSB0d28gZmxhdm9ycyBhbmQgY2Fubm90IGJlIGJvdGguXG4qXG4qIEBuYW1lIGRlZmluZVByb3BlcnR5XG4qIEB0eXBlIHtGdW5jdGlvbn1cbiogQHBhcmFtIHtPYmplY3R9IG9iaiAtIG9iamVjdCBvbiB3aGljaCB0byBkZWZpbmUgdGhlIHByb3BlcnR5XG4qIEBwYXJhbSB7KHN0cmluZ3xzeW1ib2wpfSBwcm9wIC0gcHJvcGVydHkgbmFtZVxuKiBAcGFyYW0ge09iamVjdH0gZGVzY3JpcHRvciAtIHByb3BlcnR5IGRlc2NyaXB0b3JcbiogQHBhcmFtIHtib29sZWFufSBbZGVzY3JpcHRvci5jb25maWd1cmFibGU9ZmFsc2VdIC0gYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHByb3BlcnR5IGRlc2NyaXB0b3IgY2FuIGJlIGNoYW5nZWQgYW5kIGlmIHRoZSBwcm9wZXJ0eSBjYW4gYmUgZGVsZXRlZCBmcm9tIHRoZSBwcm92aWRlZCBvYmplY3RcbiogQHBhcmFtIHtib29sZWFufSBbZGVzY3JpcHRvci5lbnVtZXJhYmxlPWZhbHNlXSAtIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgcHJvcGVydHkgc2hvd3MgdXAgd2hlbiBlbnVtZXJhdGluZyBvYmplY3QgcHJvcGVydGllc1xuKiBAcGFyYW0ge2Jvb2xlYW59IFtkZXNjcmlwdG9yLndyaXRhYmxlPWZhbHNlXSAtIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBwcm9wZXJ0eSBjYW4gYmUgY2hhbmdlZCB3aXRoIGFuIGFzc2lnbm1lbnQgb3BlcmF0b3JcbiogQHBhcmFtIHsqfSBbZGVzY3JpcHRvci52YWx1ZV0gLSBwcm9wZXJ0eSB2YWx1ZVxuKiBAcGFyYW0geyhGdW5jdGlvbnx2b2lkKX0gW2Rlc2NyaXB0b3IuZ2V0PXVuZGVmaW5lZF0gLSBmdW5jdGlvbiB3aGljaCBzZXJ2ZXMgYXMgYSBnZXR0ZXIgZm9yIHRoZSBwcm9wZXJ0eSwgb3IsIGlmIG5vIGdldHRlciwgdW5kZWZpbmVkLiBXaGVuIHRoZSBwcm9wZXJ0eSBpcyBhY2Nlc3NlZCwgYSBnZXR0ZXIgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGhvdXQgYXJndW1lbnRzIGFuZCB3aXRoIHRoZSBgdGhpc2AgY29udGV4dCBzZXQgdG8gdGhlIG9iamVjdCB0aHJvdWdoIHdoaWNoIHRoZSBwcm9wZXJ0eSBpcyBhY2Nlc3NlZCAod2hpY2ggbWF5IG5vdCBiZSB0aGUgb2JqZWN0IG9uIHdoaWNoIHRoZSBwcm9wZXJ0eSBpcyBkZWZpbmVkIGR1ZSB0byBpbmhlcml0YW5jZSkuIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSB1c2VkIGFzIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiogQHBhcmFtIHsoRnVuY3Rpb258dm9pZCl9IFtkZXNjcmlwdG9yLnNldD11bmRlZmluZWRdIC0gZnVuY3Rpb24gd2hpY2ggc2VydmVzIGFzIGEgc2V0dGVyIGZvciB0aGUgcHJvcGVydHksIG9yLCBpZiBubyBzZXR0ZXIsIHVuZGVmaW5lZC4gV2hlbiBhc3NpZ25pbmcgYSBwcm9wZXJ0eSB2YWx1ZSwgYSBzZXR0ZXIgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggb25lIGFyZ3VtZW50ICh0aGUgdmFsdWUgYmVpbmcgYXNzaWduZWQgdG8gdGhlIHByb3BlcnR5KSBhbmQgd2l0aCB0aGUgYHRoaXNgIGNvbnRleHQgc2V0IHRvIHRoZSBvYmplY3QgdGhyb3VnaCB3aGljaCB0aGUgcHJvcGVydHkgaXMgYXNzaWduZWQuXG4qIEB0aHJvd3Mge1R5cGVFcnJvcn0gZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBvYmplY3RcbiogQHRocm93cyB7VHlwZUVycm9yfSB0aGlyZCBhcmd1bWVudCBtdXN0IGJlIGFuIG9iamVjdFxuKiBAdGhyb3dzIHtFcnJvcn0gcHJvcGVydHkgZGVzY3JpcHRvciBjYW5ub3QgaGF2ZSBib3RoIGEgdmFsdWUgYW5kIGEgc2V0dGVyIGFuZC9vciBnZXR0ZXJcbiogQHJldHVybnMge09iamVjdH0gb2JqZWN0IHdpdGggYWRkZWQgcHJvcGVydHlcbipcbiogQGV4YW1wbGVcbiogdmFyIG9iaiA9IHt9O1xuKlxuKiBkZWZpbmVQcm9wZXJ0eSggb2JqLCAnZm9vJywge1xuKiAgICAgJ3ZhbHVlJzogJ2JhcidcbiogfSk7XG4qXG4qIHZhciBzdHIgPSBvYmouZm9vO1xuKiAvLyByZXR1cm5zICdiYXInXG4qL1xudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVQcm9wZXJ0eTtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZXJzY29yZS1kYW5nbGUsIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gVkFSSUFCTEVTIC8vXG5cbnZhciBvYmplY3RQcm90b3lwZSA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgdG9TdHIgPSBvYmplY3RQcm90b3lwZS50b1N0cmluZztcbnZhciBkZWZpbmVHZXR0ZXIgPSBvYmplY3RQcm90b3lwZS5fX2RlZmluZUdldHRlcl9fO1xudmFyIGRlZmluZVNldHRlciA9IG9iamVjdFByb3RveXBlLl9fZGVmaW5lU2V0dGVyX187XG52YXIgbG9va3VwR2V0dGVyID0gb2JqZWN0UHJvdG95cGUuX19sb29rdXBHZXR0ZXJfXztcbnZhciBsb29rdXBTZXR0ZXIgPSBvYmplY3RQcm90b3lwZS5fX2xvb2t1cFNldHRlcl9fO1xuXG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIERlZmluZXMgKG9yIG1vZGlmaWVzKSBhbiBvYmplY3QgcHJvcGVydHkuXG4qXG4qICMjIE5vdGVzXG4qXG4qIC0gICBQcm9wZXJ0eSBkZXNjcmlwdG9ycyBjb21lIGluIHR3byBmbGF2b3JzOiAqKmRhdGEgZGVzY3JpcHRvcnMqKiBhbmQgKiphY2Nlc3NvciBkZXNjcmlwdG9ycyoqLiBBIGRhdGEgZGVzY3JpcHRvciBpcyBhIHByb3BlcnR5IHRoYXQgaGFzIGEgdmFsdWUsIHdoaWNoIG1heSBvciBtYXkgbm90IGJlIHdyaXRhYmxlLiBBbiBhY2Nlc3NvciBkZXNjcmlwdG9yIGlzIGEgcHJvcGVydHkgZGVzY3JpYmVkIGJ5IGEgZ2V0dGVyLXNldHRlciBmdW5jdGlvbiBwYWlyLiBBIGRlc2NyaXB0b3IgbXVzdCBiZSBvbmUgb2YgdGhlc2UgdHdvIGZsYXZvcnMgYW5kIGNhbm5vdCBiZSBib3RoLlxuKlxuKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gb2JqZWN0IG9uIHdoaWNoIHRvIGRlZmluZSB0aGUgcHJvcGVydHlcbiogQHBhcmFtIHtzdHJpbmd9IHByb3AgLSBwcm9wZXJ0eSBuYW1lXG4qIEBwYXJhbSB7T2JqZWN0fSBkZXNjcmlwdG9yIC0gcHJvcGVydHkgZGVzY3JpcHRvclxuKiBAcGFyYW0ge2Jvb2xlYW59IFtkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZT1mYWxzZV0gLSBib29sZWFuIGluZGljYXRpbmcgaWYgcHJvcGVydHkgZGVzY3JpcHRvciBjYW4gYmUgY2hhbmdlZCBhbmQgaWYgdGhlIHByb3BlcnR5IGNhbiBiZSBkZWxldGVkIGZyb20gdGhlIHByb3ZpZGVkIG9iamVjdFxuKiBAcGFyYW0ge2Jvb2xlYW59IFtkZXNjcmlwdG9yLmVudW1lcmFibGU9ZmFsc2VdIC0gYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSBwcm9wZXJ0eSBzaG93cyB1cCB3aGVuIGVudW1lcmF0aW5nIG9iamVjdCBwcm9wZXJ0aWVzXG4qIEBwYXJhbSB7Ym9vbGVhbn0gW2Rlc2NyaXB0b3Iud3JpdGFibGU9ZmFsc2VdIC0gYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIHByb3BlcnR5IGNhbiBiZSBjaGFuZ2VkIHdpdGggYW4gYXNzaWdubWVudCBvcGVyYXRvclxuKiBAcGFyYW0geyp9IFtkZXNjcmlwdG9yLnZhbHVlXSAtIHByb3BlcnR5IHZhbHVlXG4qIEBwYXJhbSB7KEZ1bmN0aW9ufHZvaWQpfSBbZGVzY3JpcHRvci5nZXQ9dW5kZWZpbmVkXSAtIGZ1bmN0aW9uIHdoaWNoIHNlcnZlcyBhcyBhIGdldHRlciBmb3IgdGhlIHByb3BlcnR5LCBvciwgaWYgbm8gZ2V0dGVyLCB1bmRlZmluZWQuIFdoZW4gdGhlIHByb3BlcnR5IGlzIGFjY2Vzc2VkLCBhIGdldHRlciBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aG91dCBhcmd1bWVudHMgYW5kIHdpdGggdGhlIGB0aGlzYCBjb250ZXh0IHNldCB0byB0aGUgb2JqZWN0IHRocm91Z2ggd2hpY2ggdGhlIHByb3BlcnR5IGlzIGFjY2Vzc2VkICh3aGljaCBtYXkgbm90IGJlIHRoZSBvYmplY3Qgb24gd2hpY2ggdGhlIHByb3BlcnR5IGlzIGRlZmluZWQgZHVlIHRvIGluaGVyaXRhbmNlKS4gVGhlIHJldHVybiB2YWx1ZSB3aWxsIGJlIHVzZWQgYXMgdGhlIHByb3BlcnR5IHZhbHVlLlxuKiBAcGFyYW0geyhGdW5jdGlvbnx2b2lkKX0gW2Rlc2NyaXB0b3Iuc2V0PXVuZGVmaW5lZF0gLSBmdW5jdGlvbiB3aGljaCBzZXJ2ZXMgYXMgYSBzZXR0ZXIgZm9yIHRoZSBwcm9wZXJ0eSwgb3IsIGlmIG5vIHNldHRlciwgdW5kZWZpbmVkLiBXaGVuIGFzc2lnbmluZyBhIHByb3BlcnR5IHZhbHVlLCBhIHNldHRlciBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQgKHRoZSB2YWx1ZSBiZWluZyBhc3NpZ25lZCB0byB0aGUgcHJvcGVydHkpIGFuZCB3aXRoIHRoZSBgdGhpc2AgY29udGV4dCBzZXQgdG8gdGhlIG9iamVjdCB0aHJvdWdoIHdoaWNoIHRoZSBwcm9wZXJ0eSBpcyBhc3NpZ25lZC5cbiogQHRocm93cyB7VHlwZUVycm9yfSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGFuIG9iamVjdFxuKiBAdGhyb3dzIHtUeXBlRXJyb3J9IHRoaXJkIGFyZ3VtZW50IG11c3QgYmUgYW4gb2JqZWN0XG4qIEB0aHJvd3Mge0Vycm9yfSBwcm9wZXJ0eSBkZXNjcmlwdG9yIGNhbm5vdCBoYXZlIGJvdGggYSB2YWx1ZSBhbmQgYSBzZXR0ZXIgYW5kL29yIGdldHRlclxuKiBAcmV0dXJucyB7T2JqZWN0fSBvYmplY3Qgd2l0aCBhZGRlZCBwcm9wZXJ0eVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgb2JqID0ge307XG4qXG4qIGRlZmluZVByb3BlcnR5KCBvYmosICdmb28nLCB7XG4qICAgICAndmFsdWUnOiAnYmFyJ1xuKiB9KTtcbipcbiogdmFyIHN0ciA9IG9iai5mb287XG4qIC8vIHJldHVybnMgJ2JhcidcbiovXG5mdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eSggb2JqLCBwcm9wLCBkZXNjcmlwdG9yICkge1xuXHR2YXIgcHJvdG90eXBlO1xuXHR2YXIgaGFzVmFsdWU7XG5cdHZhciBoYXNHZXQ7XG5cdHZhciBoYXNTZXQ7XG5cblx0aWYgKCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwgfHwgdG9TdHIuY2FsbCggb2JqICkgPT09ICdbb2JqZWN0IEFycmF5XScgKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ2ludmFsaWQgYXJndW1lbnQuIEZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYW4gb2JqZWN0LiBWYWx1ZTogYCcgKyBvYmogKyAnYC4nICk7XG5cdH1cblx0aWYgKCB0eXBlb2YgZGVzY3JpcHRvciAhPT0gJ29iamVjdCcgfHwgZGVzY3JpcHRvciA9PT0gbnVsbCB8fCB0b1N0ci5jYWxsKCBkZXNjcmlwdG9yICkgPT09ICdbb2JqZWN0IEFycmF5XScgKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ2ludmFsaWQgYXJndW1lbnQuIFByb3BlcnR5IGRlc2NyaXB0b3IgbXVzdCBiZSBhbiBvYmplY3QuIFZhbHVlOiBgJyArIGRlc2NyaXB0b3IgKyAnYC4nICk7XG5cdH1cblx0aGFzVmFsdWUgPSAoICd2YWx1ZScgaW4gZGVzY3JpcHRvciApO1xuXHRpZiAoIGhhc1ZhbHVlICkge1xuXHRcdGlmIChcblx0XHRcdGxvb2t1cEdldHRlci5jYWxsKCBvYmosIHByb3AgKSB8fFxuXHRcdFx0bG9va3VwU2V0dGVyLmNhbGwoIG9iaiwgcHJvcCApXG5cdFx0KSB7XG5cdFx0XHQvLyBPdmVycmlkZSBgX19wcm90b19fYCB0byBhdm9pZCB0b3VjaGluZyBpbmhlcml0ZWQgYWNjZXNzb3JzOlxuXHRcdFx0cHJvdG90eXBlID0gb2JqLl9fcHJvdG9fXztcblx0XHRcdG9iai5fX3Byb3RvX18gPSBvYmplY3RQcm90b3lwZTtcblxuXHRcdFx0Ly8gRGVsZXRlIHByb3BlcnR5IGFzIGV4aXN0aW5nIGdldHRlcnMvc2V0dGVycyBwcmV2ZW50IGFzc2lnbmluZyB2YWx1ZSB0byBzcGVjaWZpZWQgcHJvcGVydHk6XG5cdFx0XHRkZWxldGUgb2JqWyBwcm9wIF07XG5cdFx0XHRvYmpbIHByb3AgXSA9IGRlc2NyaXB0b3IudmFsdWU7XG5cblx0XHRcdC8vIFJlc3RvcmUgb3JpZ2luYWwgcHJvdG90eXBlOlxuXHRcdFx0b2JqLl9fcHJvdG9fXyA9IHByb3RvdHlwZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0b2JqWyBwcm9wIF0gPSBkZXNjcmlwdG9yLnZhbHVlO1xuXHRcdH1cblx0fVxuXHRoYXNHZXQgPSAoICdnZXQnIGluIGRlc2NyaXB0b3IgKTtcblx0aGFzU2V0ID0gKCAnc2V0JyBpbiBkZXNjcmlwdG9yICk7XG5cblx0aWYgKCBoYXNWYWx1ZSAmJiAoIGhhc0dldCB8fCBoYXNTZXQgKSApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoICdpbnZhbGlkIGFyZ3VtZW50LiBDYW5ub3Qgc3BlY2lmeSBvbmUgb3IgbW9yZSBhY2Nlc3NvcnMgYW5kIGEgdmFsdWUgb3Igd3JpdGFibGUgYXR0cmlidXRlIGluIHRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yLicgKTtcblx0fVxuXG5cdGlmICggaGFzR2V0ICYmIGRlZmluZUdldHRlciApIHtcblx0XHRkZWZpbmVHZXR0ZXIuY2FsbCggb2JqLCBwcm9wLCBkZXNjcmlwdG9yLmdldCApO1xuXHR9XG5cdGlmICggaGFzU2V0ICYmIGRlZmluZVNldHRlciApIHtcblx0XHRkZWZpbmVTZXR0ZXIuY2FsbCggb2JqLCBwcm9wLCBkZXNjcmlwdG9yLnNldCApO1xuXHR9XG5cdHJldHVybiBvYmo7XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmluZVByb3BlcnR5O1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBEZWZpbmUgKG9yIG1vZGlmeSkgYW4gb2JqZWN0IHByb3BlcnR5LlxuKlxuKiBAbW9kdWxlIEBzdGRsaWIvdXRpbHMtZGVmaW5lLXByb3BlcnR5XG4qXG4qIEBleGFtcGxlXG4qIHZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoICdAc3RkbGliL3V0aWxzLWRlZmluZS1wcm9wZXJ0eScgKTtcbipcbiogdmFyIG9iaiA9IHt9O1xuKiBkZWZpbmVQcm9wZXJ0eSggb2JqLCAnZm9vJywge1xuKiAgICAgJ3ZhbHVlJzogJ2JhcicsXG4qICAgICAnd3JpdGFibGUnOiBmYWxzZSxcbiogICAgICdjb25maWd1cmFibGUnOiBmYWxzZSxcbiogICAgICdlbnVtZXJhYmxlJzogZmFsc2VcbiogfSk7XG4qIG9iai5mb28gPSAnYm9vcCc7IC8vID0+IHRocm93c1xuKi9cblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgaGFzRGVmaW5lUHJvcGVydHlTdXBwb3J0ID0gcmVxdWlyZSggJy4vaGFzX2RlZmluZV9wcm9wZXJ0eV9zdXBwb3J0LmpzJyApO1xudmFyIGJ1aWx0aW4gPSByZXF1aXJlKCAnLi9idWlsdGluLmpzJyApO1xudmFyIHBvbHlmaWxsID0gcmVxdWlyZSggJy4vcG9seWZpbGwuanMnICk7XG5cblxuLy8gTUFJTiAvL1xuXG52YXIgZGVmaW5lUHJvcGVydHk7XG5pZiAoIGhhc0RlZmluZVByb3BlcnR5U3VwcG9ydCgpICkge1xuXHRkZWZpbmVQcm9wZXJ0eSA9IGJ1aWx0aW47XG59IGVsc2Uge1xuXHRkZWZpbmVQcm9wZXJ0eSA9IHBvbHlmaWxsO1xufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVQcm9wZXJ0eTtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoICdAc3RkbGliL3V0aWxzLWRlZmluZS1wcm9wZXJ0eScgKTtcblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBEZWZpbmVzIGEgbm9uLWVudW1lcmFibGUgcmVhZC1vbmx5IHByb3BlcnR5LlxuKlxuKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gb2JqZWN0IG9uIHdoaWNoIHRvIGRlZmluZSB0aGUgcHJvcGVydHlcbiogQHBhcmFtIHsoc3RyaW5nfHN5bWJvbCl9IHByb3AgLSBwcm9wZXJ0eSBuYW1lXG4qIEBwYXJhbSB7Kn0gdmFsdWUgLSB2YWx1ZSB0byBzZXRcbipcbiogQGV4YW1wbGVcbiogdmFyIG9iaiA9IHt9O1xuKlxuKiBzZXROb25FbnVtZXJhYmxlUmVhZE9ubHkoIG9iaiwgJ2ZvbycsICdiYXInICk7XG4qXG4qIHRyeSB7XG4qICAgICBvYmouZm9vID0gJ2Jvb3AnO1xuKiB9IGNhdGNoICggZXJyICkge1xuKiAgICAgY29uc29sZS5lcnJvciggZXJyLm1lc3NhZ2UgKTtcbiogfVxuKi9cbmZ1bmN0aW9uIHNldE5vbkVudW1lcmFibGVSZWFkT25seSggb2JqLCBwcm9wLCB2YWx1ZSApIHtcblx0ZGVmaW5lUHJvcGVydHkoIG9iaiwgcHJvcCwge1xuXHRcdCdjb25maWd1cmFibGUnOiBmYWxzZSxcblx0XHQnZW51bWVyYWJsZSc6IGZhbHNlLFxuXHRcdCd3cml0YWJsZSc6IGZhbHNlLFxuXHRcdCd2YWx1ZSc6IHZhbHVlXG5cdH0pO1xufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBzZXROb25FbnVtZXJhYmxlUmVhZE9ubHk7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIERlZmluZSBhIG5vbi1lbnVtZXJhYmxlIHJlYWQtb25seSBwcm9wZXJ0eS5cbipcbiogQG1vZHVsZSBAc3RkbGliL3V0aWxzLWRlZmluZS1ub25lbnVtZXJhYmxlLXJlYWQtb25seS1wcm9wZXJ0eVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgc2V0Tm9uRW51bWVyYWJsZVJlYWRPbmx5ID0gcmVxdWlyZSggJ0BzdGRsaWIvdXRpbHMtZGVmaW5lLW5vbmVudW1lcmFibGUtcmVhZC1vbmx5LXByb3BlcnR5JyApO1xuKlxuKiB2YXIgb2JqID0ge307XG4qXG4qIHNldE5vbkVudW1lcmFibGVSZWFkT25seSggb2JqLCAnZm9vJywgJ2JhcicgKTtcbipcbiogdHJ5IHtcbiogICAgIG9iai5mb28gPSAnYm9vcCc7XG4qIH0gY2F0Y2ggKCBlcnIgKSB7XG4qICAgICBjb25zb2xlLmVycm9yKCBlcnIubWVzc2FnZSApO1xuKiB9XG4qL1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBzZXROb25FbnVtZXJhYmxlUmVhZE9ubHkgPSByZXF1aXJlKCAnLi9tYWluLmpzJyApO1xuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBzZXROb25FbnVtZXJhYmxlUmVhZE9ubHk7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIFRlc3RzIGlmIGEgdmFsdWUgaXMgYSBudW1iZXIgcHJpbWl0aXZlLlxuKlxuKiBAcGFyYW0geyp9IHZhbHVlIC0gdmFsdWUgdG8gdGVzdFxuKiBAcmV0dXJucyB7Ym9vbGVhbn0gYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGEgdmFsdWUgaXMgYSBudW1iZXIgcHJpbWl0aXZlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaXNOdW1iZXIoIDMuMTQgKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaXNOdW1iZXIoIE5hTiApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBpc051bWJlciggbmV3IE51bWJlciggMy4xNCApICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbiovXG5mdW5jdGlvbiBpc051bWJlciggdmFsdWUgKSB7XG5cdHJldHVybiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgKTtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNOdW1iZXI7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgTnVtYmVyID0gcmVxdWlyZSggJ0BzdGRsaWIvbnVtYmVyLWN0b3InICk7XG5cblxuLy8gTUFJTiAvL1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgc3RkbGliL25vLXJlZGVjbGFyZVxudmFyIHRvU3RyaW5nID0gTnVtYmVyLnByb3RvdHlwZS50b1N0cmluZzsgLy8gbm9uLWdlbmVyaWNcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gdG9TdHJpbmc7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgdG9TdHJpbmcgPSByZXF1aXJlKCAnLi90b3N0cmluZy5qcycgKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBzdGRsaWIvbm8tcmVkZWNsYXJlXG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogQXR0ZW1wdHMgdG8gc2VyaWFsaXplIGEgdmFsdWUgdG8gYSBzdHJpbmcuXG4qXG4qIEBwcml2YXRlXG4qIEBwYXJhbSB7Kn0gdmFsdWUgLSB2YWx1ZSB0byB0ZXN0XG4qIEByZXR1cm5zIHtib29sZWFufSBib29sZWFuIGluZGljYXRpbmcgaWYgYSB2YWx1ZSBjYW4gYmUgc2VyaWFsaXplZFxuKi9cbmZ1bmN0aW9uIHRlc3QoIHZhbHVlICkge1xuXHR0cnkge1xuXHRcdHRvU3RyaW5nLmNhbGwoIHZhbHVlICk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKCBlcnIgKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gdGVzdDtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBoYXNUb1N0cmluZ1RhZyA9IHJlcXVpcmUoICdAc3RkbGliL2Fzc2VydC1oYXMtdG9zdHJpbmd0YWctc3VwcG9ydCcgKTtcbnZhciBuYXRpdmVDbGFzcyA9IHJlcXVpcmUoICdAc3RkbGliL3V0aWxzLW5hdGl2ZS1jbGFzcycgKTtcbnZhciBOdW1iZXIgPSByZXF1aXJlKCAnQHN0ZGxpYi9udW1iZXItY3RvcicgKTtcbnZhciB0ZXN0ID0gcmVxdWlyZSggJy4vdHJ5MnNlcmlhbGl6ZS5qcycgKTtcblxuXG4vLyBWQVJJQUJMRVMgLy9cblxudmFyIEZMRyA9IGhhc1RvU3RyaW5nVGFnKCk7XG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogVGVzdHMgaWYgYSB2YWx1ZSBpcyBhIG51bWJlciBvYmplY3QuXG4qXG4qIEBwYXJhbSB7Kn0gdmFsdWUgLSB2YWx1ZSB0byB0ZXN0XG4qIEByZXR1cm5zIHtib29sZWFufSBib29sZWFuIGluZGljYXRpbmcgaWYgYSB2YWx1ZSBpcyBhIG51bWJlciBvYmplY3RcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBpc051bWJlciggMy4xNCApO1xuKiAvLyByZXR1cm5zIGZhbHNlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaXNOdW1iZXIoIG5ldyBOdW1iZXIoIDMuMTQgKSApO1xuKiAvLyByZXR1cm5zIHRydWVcbiovXG5mdW5jdGlvbiBpc051bWJlciggdmFsdWUgKSB7XG5cdGlmICggdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyApIHtcblx0XHRpZiAoIHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdGlmICggRkxHICkge1xuXHRcdFx0cmV0dXJuIHRlc3QoIHZhbHVlICk7XG5cdFx0fVxuXHRcdHJldHVybiAoIG5hdGl2ZUNsYXNzKCB2YWx1ZSApID09PSAnW29iamVjdCBOdW1iZXJdJyApO1xuXHR9XG5cdHJldHVybiBmYWxzZTtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNOdW1iZXI7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgaXNQcmltaXRpdmUgPSByZXF1aXJlKCAnLi9wcmltaXRpdmUuanMnICk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCAnLi9vYmplY3QuanMnICk7XG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogVGVzdHMgaWYgYSB2YWx1ZSBpcyBhIG51bWJlci5cbipcbiogQHBhcmFtIHsqfSB2YWx1ZSAtIHZhbHVlIHRvIHRlc3RcbiogQHJldHVybnMge2Jvb2xlYW59IGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHZhbHVlIGlzIGEgbnVtYmVyXG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaXNOdW1iZXIoIDMuMTQgKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaXNOdW1iZXIoIG5ldyBOdW1iZXIoIDMuMTQgKSApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBpc051bWJlciggTmFOICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgYm9vbCA9IGlzTnVtYmVyKCBudWxsICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbiovXG5mdW5jdGlvbiBpc051bWJlciggdmFsdWUgKSB7XG5cdHJldHVybiAoIGlzUHJpbWl0aXZlKCB2YWx1ZSApIHx8IGlzT2JqZWN0KCB2YWx1ZSApICk7XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTnVtYmVyO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBUZXN0IGlmIGEgdmFsdWUgaXMgYSBudW1iZXIuXG4qXG4qIEBtb2R1bGUgQHN0ZGxpYi9hc3NlcnQtaXMtbnVtYmVyXG4qXG4qIEBleGFtcGxlXG4qIHZhciBpc051bWJlciA9IHJlcXVpcmUoICdAc3RkbGliL2Fzc2VydC1pcy1udW1iZXInICk7XG4qXG4qIHZhciBib29sID0gaXNOdW1iZXIoIDMuMTQgKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qXG4qIGJvb2wgPSBpc051bWJlciggbmV3IE51bWJlciggMy4xNCApICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKlxuKiBib29sID0gaXNOdW1iZXIoIE5hTiApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogYm9vbCA9IGlzTnVtYmVyKCBudWxsICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbipcbiogQGV4YW1wbGVcbiogdmFyIGlzTnVtYmVyID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLW51bWJlcicgKS5pc1ByaW1pdGl2ZTtcbipcbiogdmFyIGJvb2wgPSBpc051bWJlciggMy4xNCApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogYm9vbCA9IGlzTnVtYmVyKCBOYU4gKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qXG4qIGJvb2wgPSBpc051bWJlciggbmV3IE51bWJlciggMy4xNCApICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbipcbiogQGV4YW1wbGVcbiogdmFyIGlzTnVtYmVyID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLW51bWJlcicgKS5pc09iamVjdDtcbipcbiogdmFyIGJvb2wgPSBpc051bWJlciggMy4xNCApO1xuKiAvLyByZXR1cm5zIGZhbHNlXG4qXG4qIGJvb2wgPSBpc051bWJlciggbmV3IE51bWJlciggMy4xNCApICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKi9cblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgc2V0UmVhZE9ubHkgPSByZXF1aXJlKCAnQHN0ZGxpYi91dGlscy1kZWZpbmUtbm9uZW51bWVyYWJsZS1yZWFkLW9ubHktcHJvcGVydHknICk7XG52YXIgaXNOdW1iZXIgPSByZXF1aXJlKCAnLi9tYWluLmpzJyApO1xudmFyIGlzUHJpbWl0aXZlID0gcmVxdWlyZSggJy4vcHJpbWl0aXZlLmpzJyApO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSggJy4vb2JqZWN0LmpzJyApO1xuXG5cbi8vIE1BSU4gLy9cblxuc2V0UmVhZE9ubHkoIGlzTnVtYmVyLCAnaXNQcmltaXRpdmUnLCBpc1ByaW1pdGl2ZSApO1xuc2V0UmVhZE9ubHkoIGlzTnVtYmVyLCAnaXNPYmplY3QnLCBpc09iamVjdCApO1xuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBpc051bWJlcjtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBQSU5GID0gcmVxdWlyZSggJ0BzdGRsaWIvY29uc3RhbnRzLWZsb2F0NjQtcGluZicgKTtcbnZhciBOSU5GID0gcmVxdWlyZSggJ0BzdGRsaWIvY29uc3RhbnRzLWZsb2F0NjQtbmluZicgKTtcbnZhciBpc0ludCA9IHJlcXVpcmUoICdAc3RkbGliL21hdGgtYmFzZS1hc3NlcnQtaXMtaW50ZWdlcicgKTtcblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBUZXN0cyBpZiBhIG51bWJlciBwcmltaXRpdmUgaXMgYW4gaW50ZWdlciB2YWx1ZS5cbipcbiogQHByaXZhdGVcbiogQHBhcmFtIHsqfSB2YWx1ZSAtIHZhbHVlIHRvIHRlc3RcbiogQHJldHVybnMge2Jvb2xlYW59IGJvb2xlYW4gaW5kaWNhdGluZyBpZiBhIG51bWJlciBwcmltaXRpdmUgaXMgYW4gaW50ZWdlciB2YWx1ZVxuKi9cbmZ1bmN0aW9uIGlzSW50ZWdlciggdmFsdWUgKSB7XG5cdHJldHVybiAoXG5cdFx0dmFsdWUgPCBQSU5GICYmXG5cdFx0dmFsdWUgPiBOSU5GICYmXG5cdFx0aXNJbnQoIHZhbHVlIClcblx0KTtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNJbnRlZ2VyO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGlzTnVtYmVyID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLW51bWJlcicgKS5pc1ByaW1pdGl2ZTtcbnZhciBpc0ludCA9IHJlcXVpcmUoICcuL2ludGVnZXIuanMnICk7XG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogVGVzdHMgaWYgYSB2YWx1ZSBpcyBhIG51bWJlciBwcmltaXRpdmUgaGF2aW5nIGFuIGludGVnZXIgdmFsdWUuXG4qXG4qIEBwYXJhbSB7Kn0gdmFsdWUgLSB2YWx1ZSB0byB0ZXN0XG4qIEByZXR1cm5zIHtib29sZWFufSBib29sZWFuIGluZGljYXRpbmcgaWYgYSB2YWx1ZSBpcyBhIG51bWJlciBwcmltaXRpdmUgaGF2aW5nIGFuIGludGVnZXIgdmFsdWVcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBpc0ludGVnZXIoIC0zLjAgKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaXNJbnRlZ2VyKCBuZXcgTnVtYmVyKCAtMy4wICkgKTtcbiogLy8gcmV0dXJucyBmYWxzZVxuKi9cbmZ1bmN0aW9uIGlzSW50ZWdlciggdmFsdWUgKSB7XG5cdHJldHVybiAoXG5cdFx0aXNOdW1iZXIoIHZhbHVlICkgJiZcblx0XHRpc0ludCggdmFsdWUgKVxuXHQpO1xufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBpc0ludGVnZXI7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgaXNOdW1iZXIgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaXMtbnVtYmVyJyApLmlzT2JqZWN0O1xudmFyIGlzSW50ID0gcmVxdWlyZSggJy4vaW50ZWdlci5qcycgKTtcblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBUZXN0cyBpZiBhIHZhbHVlIGlzIGEgbnVtYmVyIG9iamVjdCBoYXZpbmcgYW4gaW50ZWdlciB2YWx1ZS5cbipcbiogQHBhcmFtIHsqfSB2YWx1ZSAtIHZhbHVlIHRvIHRlc3RcbiogQHJldHVybnMge2Jvb2xlYW59IGJvb2xlYW4gaW5kaWNhdGluZyBpZiBhIHZhbHVlIGlzIGEgbnVtYmVyIG9iamVjdCBoYXZpbmcgYW4gaW50ZWdlciB2YWx1ZVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgYm9vbCA9IGlzSW50ZWdlciggMy4wICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBpc0ludGVnZXIoIG5ldyBOdW1iZXIoIDMuMCApICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKi9cbmZ1bmN0aW9uIGlzSW50ZWdlciggdmFsdWUgKSB7XG5cdHJldHVybiAoXG5cdFx0aXNOdW1iZXIoIHZhbHVlICkgJiZcblx0XHRpc0ludCggdmFsdWUudmFsdWVPZigpIClcblx0KTtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNJbnRlZ2VyO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGlzUHJpbWl0aXZlID0gcmVxdWlyZSggJy4vcHJpbWl0aXZlLmpzJyApO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSggJy4vb2JqZWN0LmpzJyApO1xuXG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIFRlc3RzIGlmIGEgdmFsdWUgaXMgYW4gaW50ZWdlci5cbipcbiogQHBhcmFtIHsqfSB2YWx1ZSAtIHZhbHVlIHRvIHRlc3RcbiogQHJldHVybnMge2Jvb2xlYW59IGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHZhbHVlIGlzIGFuIGludGVnZXJcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBpc0ludGVnZXIoIDUuMCApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBpc0ludGVnZXIoIG5ldyBOdW1iZXIoIDUuMCApICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgYm9vbCA9IGlzSW50ZWdlciggLTMuMTQgKTtcbiogLy8gcmV0dXJucyBmYWxzZVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgYm9vbCA9IGlzSW50ZWdlciggbnVsbCApO1xuKiAvLyByZXR1cm5zIGZhbHNlXG4qL1xuZnVuY3Rpb24gaXNJbnRlZ2VyKCB2YWx1ZSApIHtcblx0cmV0dXJuICggaXNQcmltaXRpdmUoIHZhbHVlICkgfHwgaXNPYmplY3QoIHZhbHVlICkgKTtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNJbnRlZ2VyO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBUZXN0IGlmIGEgdmFsdWUgaXMgYW4gaW50ZWdlci5cbipcbiogQG1vZHVsZSBAc3RkbGliL2Fzc2VydC1pcy1pbnRlZ2VyXG4qXG4qIEBleGFtcGxlXG4qIHZhciBpc0ludGVnZXIgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaXMtaW50ZWdlcicgKTtcbipcbiogdmFyIGJvb2wgPSBpc0ludGVnZXIoIDUuMCApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogYm9vbCA9IGlzSW50ZWdlciggbmV3IE51bWJlciggNS4wICkgKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qXG4qIGJvb2wgPSBpc0ludGVnZXIoIC0zLjE0ICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbipcbiogYm9vbCA9IGlzSW50ZWdlciggbnVsbCApO1xuKiAvLyByZXR1cm5zIGZhbHNlXG4qXG4qIEBleGFtcGxlXG4qIC8vIFVzZSBpbnRlcmZhY2UgdG8gY2hlY2sgZm9yIGludGVnZXIgcHJpbWl0aXZlcy4uLlxuKiB2YXIgaXNJbnRlZ2VyID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLWludGVnZXInICkuaXNQcmltaXRpdmU7XG4qXG4qIHZhciBib29sID0gaXNJbnRlZ2VyKCAtMy4wICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKlxuKiBib29sID0gaXNJbnRlZ2VyKCBuZXcgTnVtYmVyKCAtMy4wICkgKTtcbiogLy8gcmV0dXJucyBmYWxzZVxuKlxuKiBAZXhhbXBsZVxuKiAvLyBVc2UgaW50ZXJmYWNlIHRvIGNoZWNrIGZvciBpbnRlZ2VyIG9iamVjdHMuLi5cbiogdmFyIGlzSW50ZWdlciA9IHJlcXVpcmUoICdAc3RkbGliL2Fzc2VydC1pcy1pbnRlZ2VyJyApLmlzT2JqZWN0O1xuKlxuKiB2YXIgYm9vbCA9IGlzSW50ZWdlciggMy4wICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbipcbiogYm9vbCA9IGlzSW50ZWdlciggbmV3IE51bWJlciggMy4wICkgKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qL1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBzZXRSZWFkT25seSA9IHJlcXVpcmUoICdAc3RkbGliL3V0aWxzLWRlZmluZS1ub25lbnVtZXJhYmxlLXJlYWQtb25seS1wcm9wZXJ0eScgKTtcbnZhciBpc0ludGVnZXIgPSByZXF1aXJlKCAnLi9tYWluLmpzJyApO1xudmFyIGlzUHJpbWl0aXZlID0gcmVxdWlyZSggJy4vcHJpbWl0aXZlLmpzJyApO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSggJy4vb2JqZWN0LmpzJyApO1xuXG5cbi8vIE1BSU4gLy9cblxuc2V0UmVhZE9ubHkoIGlzSW50ZWdlciwgJ2lzUHJpbWl0aXZlJywgaXNQcmltaXRpdmUgKTtcbnNldFJlYWRPbmx5KCBpc0ludGVnZXIsICdpc09iamVjdCcsIGlzT2JqZWN0ICk7XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSW50ZWdlcjtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBpc0ludGVnZXIgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaXMtaW50ZWdlcicgKS5pc1ByaW1pdGl2ZTtcblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBUZXN0cyBpZiBhIHZhbHVlIGlzIGEgbnVtYmVyIHByaW1pdGl2ZSBoYXZpbmcgYSBub25uZWdhdGl2ZSBpbnRlZ2VyIHZhbHVlLlxuKlxuKiBAcGFyYW0geyp9IHZhbHVlIC0gdmFsdWUgdG8gdGVzdFxuKiBAcmV0dXJucyB7Ym9vbGVhbn0gYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGEgdmFsdWUgaXMgYSBudW1iZXIgcHJpbWl0aXZlIGhhdmluZyBhIG5vbm5lZ2F0aXZlIGludGVnZXIgdmFsdWVcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBpc05vbk5lZ2F0aXZlSW50ZWdlciggMy4wICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgYm9vbCA9IGlzTm9uTmVnYXRpdmVJbnRlZ2VyKCBuZXcgTnVtYmVyKCAzLjAgKSApO1xuKiAvLyByZXR1cm5zIGZhbHNlXG4qL1xuZnVuY3Rpb24gaXNOb25OZWdhdGl2ZUludGVnZXIoIHZhbHVlICkge1xuXHRyZXR1cm4gKFxuXHRcdGlzSW50ZWdlciggdmFsdWUgKSAmJlxuXHRcdHZhbHVlID49IDBcblx0KTtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNOb25OZWdhdGl2ZUludGVnZXI7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgaXNJbnRlZ2VyID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLWludGVnZXInICkuaXNPYmplY3Q7XG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogVGVzdHMgaWYgYSB2YWx1ZSBpcyBhIG51bWJlciBvYmplY3QgaGF2aW5nIGEgbm9ubmVnYXRpdmUgaW50ZWdlciB2YWx1ZS5cbipcbiogQHBhcmFtIHsqfSB2YWx1ZSAtIHZhbHVlIHRvIHRlc3RcbiogQHJldHVybnMge2Jvb2xlYW59IGJvb2xlYW4gaW5kaWNhdGluZyBpZiBhIHZhbHVlIGlzIGEgbnVtYmVyIG9iamVjdCBoYXZpbmcgYSBub25uZWdhdGl2ZSBpbnRlZ2VyIHZhbHVlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaXNOb25OZWdhdGl2ZUludGVnZXIoIDMuMCApO1xuKiAvLyByZXR1cm5zIGZhbHNlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaXNOb25OZWdhdGl2ZUludGVnZXIoIG5ldyBOdW1iZXIoIDMuMCApICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKi9cbmZ1bmN0aW9uIGlzTm9uTmVnYXRpdmVJbnRlZ2VyKCB2YWx1ZSApIHtcblx0cmV0dXJuIChcblx0XHRpc0ludGVnZXIoIHZhbHVlICkgJiZcblx0XHR2YWx1ZS52YWx1ZU9mKCkgPj0gMFxuXHQpO1xufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBpc05vbk5lZ2F0aXZlSW50ZWdlcjtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBpc1ByaW1pdGl2ZSA9IHJlcXVpcmUoICcuL3ByaW1pdGl2ZS5qcycgKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoICcuL29iamVjdC5qcycgKTtcblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBUZXN0cyBpZiBhIHZhbHVlIGlzIGEgbm9ubmVnYXRpdmUgaW50ZWdlci5cbipcbiogQHBhcmFtIHsqfSB2YWx1ZSAtIHZhbHVlIHRvIHRlc3RcbiogQHJldHVybnMge2Jvb2xlYW59IGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHZhbHVlIGlzIGEgbm9ubmVnYXRpdmUgaW50ZWdlclxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgYm9vbCA9IGlzTm9uTmVnYXRpdmVJbnRlZ2VyKCA1LjAgKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaXNOb25OZWdhdGl2ZUludGVnZXIoIG5ldyBOdW1iZXIoIDUuMCApICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgYm9vbCA9IGlzTm9uTmVnYXRpdmVJbnRlZ2VyKCAtNS4wICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBpc05vbk5lZ2F0aXZlSW50ZWdlciggMy4xNCApO1xuKiAvLyByZXR1cm5zIGZhbHNlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaXNOb25OZWdhdGl2ZUludGVnZXIoIG51bGwgKTtcbiogLy8gcmV0dXJucyBmYWxzZVxuKi9cbmZ1bmN0aW9uIGlzTm9uTmVnYXRpdmVJbnRlZ2VyKCB2YWx1ZSApIHtcblx0cmV0dXJuICggaXNQcmltaXRpdmUoIHZhbHVlICkgfHwgaXNPYmplY3QoIHZhbHVlICkgKTtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNOb25OZWdhdGl2ZUludGVnZXI7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIFRlc3QgaWYgYSB2YWx1ZSBpcyBhIG5vbm5lZ2F0aXZlIGludGVnZXIuXG4qXG4qIEBtb2R1bGUgQHN0ZGxpYi9hc3NlcnQtaXMtbm9ubmVnYXRpdmUtaW50ZWdlclxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgaXNOb25OZWdhdGl2ZUludGVnZXIgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaXMtbm9ubmVnYXRpdmUtaW50ZWdlcicgKTtcbipcbiogdmFyIGJvb2wgPSBpc05vbk5lZ2F0aXZlSW50ZWdlciggNS4wICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKlxuKiBib29sID0gaXNOb25OZWdhdGl2ZUludGVnZXIoIG5ldyBOdW1iZXIoIDUuMCApICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKlxuKiBib29sID0gaXNOb25OZWdhdGl2ZUludGVnZXIoIC01LjAgKTtcbiogLy8gcmV0dXJucyBmYWxzZVxuKlxuKiBib29sID0gaXNOb25OZWdhdGl2ZUludGVnZXIoIDMuMTQgKTtcbiogLy8gcmV0dXJucyBmYWxzZVxuKlxuKiBib29sID0gaXNOb25OZWdhdGl2ZUludGVnZXIoIG51bGwgKTtcbiogLy8gcmV0dXJucyBmYWxzZVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgaXNOb25OZWdhdGl2ZUludGVnZXIgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaXMtbm9ubmVnYXRpdmUtaW50ZWdlcicgKS5pc1ByaW1pdGl2ZTtcbipcbiogdmFyIGJvb2wgPSBpc05vbk5lZ2F0aXZlSW50ZWdlciggMy4wICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKlxuKiBib29sID0gaXNOb25OZWdhdGl2ZUludGVnZXIoIG5ldyBOdW1iZXIoIDMuMCApICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbipcbiogQGV4YW1wbGVcbiogdmFyIGlzTm9uTmVnYXRpdmVJbnRlZ2VyID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLW5vbm5lZ2F0aXZlLWludGVnZXInICkuaXNPYmplY3Q7XG4qXG4qIHZhciBib29sID0gaXNOb25OZWdhdGl2ZUludGVnZXIoIDMuMCApO1xuKiAvLyByZXR1cm5zIGZhbHNlXG4qXG4qIGJvb2wgPSBpc05vbk5lZ2F0aXZlSW50ZWdlciggbmV3IE51bWJlciggMy4wICkgKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qL1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBzZXRSZWFkT25seSA9IHJlcXVpcmUoICdAc3RkbGliL3V0aWxzLWRlZmluZS1ub25lbnVtZXJhYmxlLXJlYWQtb25seS1wcm9wZXJ0eScgKTtcbnZhciBpc05vbk5lZ2F0aXZlSW50ZWdlciA9IHJlcXVpcmUoICcuL21haW4uanMnICk7XG52YXIgaXNQcmltaXRpdmUgPSByZXF1aXJlKCAnLi9wcmltaXRpdmUuanMnICk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCAnLi9vYmplY3QuanMnICk7XG5cblxuLy8gTUFJTiAvL1xuXG5zZXRSZWFkT25seSggaXNOb25OZWdhdGl2ZUludGVnZXIsICdpc1ByaW1pdGl2ZScsIGlzUHJpbWl0aXZlICk7XG5zZXRSZWFkT25seSggaXNOb25OZWdhdGl2ZUludGVnZXIsICdpc09iamVjdCcsIGlzT2JqZWN0ICk7XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTm9uTmVnYXRpdmVJbnRlZ2VyO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGlzSW50ZWdlciA9IHJlcXVpcmUoICdAc3RkbGliL2Fzc2VydC1pcy1pbnRlZ2VyJyApLmlzUHJpbWl0aXZlO1xuXG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIFRlc3RzIGlmIGEgdmFsdWUgaXMgYSBudW1iZXIgcHJpbWl0aXZlIGhhdmluZyBhIHBvc2l0aXZlIGludGVnZXIgdmFsdWUuXG4qXG4qIEBwYXJhbSB7Kn0gdmFsdWUgLSB2YWx1ZSB0byB0ZXN0XG4qIEByZXR1cm5zIHtib29sZWFufSBib29sZWFuIGluZGljYXRpbmcgaWYgYSB2YWx1ZSBpcyBhIG51bWJlciBwcmltaXRpdmUgaGF2aW5nIGEgcG9zaXRpdmUgaW50ZWdlciB2YWx1ZVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgYm9vbCA9IGlzUG9zaXRpdmVJbnRlZ2VyKCAzLjAgKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaXNQb3NpdGl2ZUludGVnZXIoIG5ldyBOdW1iZXIoIDMuMCApICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbiovXG5mdW5jdGlvbiBpc1Bvc2l0aXZlSW50ZWdlciggdmFsdWUgKSB7XG5cdHJldHVybiAoXG5cdFx0aXNJbnRlZ2VyKCB2YWx1ZSApICYmXG5cdFx0dmFsdWUgPiAwLjBcblx0KTtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNQb3NpdGl2ZUludGVnZXI7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgaXNJbnRlZ2VyID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLWludGVnZXInICkuaXNPYmplY3Q7XG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogVGVzdHMgaWYgYSB2YWx1ZSBpcyBhIG51bWJlciBvYmplY3QgaGF2aW5nIGEgcG9zaXRpdmUgaW50ZWdlciB2YWx1ZS5cbipcbiogQHBhcmFtIHsqfSB2YWx1ZSAtIHZhbHVlIHRvIHRlc3RcbiogQHJldHVybnMge2Jvb2xlYW59IGJvb2xlYW4gaW5kaWNhdGluZyBpZiBhIHZhbHVlIGlzIGEgbnVtYmVyIG9iamVjdCBoYXZpbmcgYSBwb3NpdGl2ZSBpbnRlZ2VyIHZhbHVlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaXNQb3NpdGl2ZUludGVnZXIoIDMuMCApO1xuKiAvLyByZXR1cm5zIGZhbHNlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaXNQb3NpdGl2ZUludGVnZXIoIG5ldyBOdW1iZXIoIDMuMCApICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKi9cbmZ1bmN0aW9uIGlzUG9zaXRpdmVJbnRlZ2VyKCB2YWx1ZSApIHtcblx0cmV0dXJuIChcblx0XHRpc0ludGVnZXIoIHZhbHVlICkgJiZcblx0XHR2YWx1ZS52YWx1ZU9mKCkgPiAwLjBcblx0KTtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNQb3NpdGl2ZUludGVnZXI7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgaXNQcmltaXRpdmUgPSByZXF1aXJlKCAnLi9wcmltaXRpdmUuanMnICk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCAnLi9vYmplY3QuanMnICk7XG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogVGVzdHMgaWYgYSB2YWx1ZSBpcyBhIHBvc2l0aXZlIGludGVnZXIuXG4qXG4qIEBwYXJhbSB7Kn0gdmFsdWUgLSB2YWx1ZSB0byB0ZXN0XG4qIEByZXR1cm5zIHtib29sZWFufSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB2YWx1ZSBpcyBhIHBvc2l0aXZlIGludGVnZXJcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBpc1Bvc2l0aXZlSW50ZWdlciggNS4wICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgYm9vbCA9IGlzUG9zaXRpdmVJbnRlZ2VyKCBuZXcgTnVtYmVyKCA1LjAgKSApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBpc1Bvc2l0aXZlSW50ZWdlciggMC4wICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBpc1Bvc2l0aXZlSW50ZWdlciggLTUuMCApO1xuKiAvLyByZXR1cm5zIGZhbHNlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaXNQb3NpdGl2ZUludGVnZXIoIDMuMTQgKTtcbiogLy8gcmV0dXJucyBmYWxzZVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgYm9vbCA9IGlzUG9zaXRpdmVJbnRlZ2VyKCBudWxsICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbiovXG5mdW5jdGlvbiBpc1Bvc2l0aXZlSW50ZWdlciggdmFsdWUgKSB7XG5cdHJldHVybiAoIGlzUHJpbWl0aXZlKCB2YWx1ZSApIHx8IGlzT2JqZWN0KCB2YWx1ZSApICk7XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUG9zaXRpdmVJbnRlZ2VyO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBUZXN0IGlmIGEgdmFsdWUgaXMgYSBwb3NpdGl2ZSBpbnRlZ2VyLlxuKlxuKiBAbW9kdWxlIEBzdGRsaWIvYXNzZXJ0LWlzLXBvc2l0aXZlLWludGVnZXJcbipcbiogQGV4YW1wbGVcbiogdmFyIGlzUG9zaXRpdmVJbnRlZ2VyID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLXBvc2l0aXZlLWludGVnZXInICk7XG4qXG4qIHZhciBib29sID0gaXNQb3NpdGl2ZUludGVnZXIoIDUuMCApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogYm9vbCA9IGlzUG9zaXRpdmVJbnRlZ2VyKCBuZXcgTnVtYmVyKCA1LjAgKSApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogYm9vbCA9IGlzUG9zaXRpdmVJbnRlZ2VyKCAtNS4wICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbipcbiogYm9vbCA9IGlzUG9zaXRpdmVJbnRlZ2VyKCAzLjE0ICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbipcbiogYm9vbCA9IGlzUG9zaXRpdmVJbnRlZ2VyKCBudWxsICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbipcbiogQGV4YW1wbGVcbiogdmFyIGlzUG9zaXRpdmVJbnRlZ2VyID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLXBvc2l0aXZlLWludGVnZXInICkuaXNQcmltaXRpdmU7XG4qXG4qIHZhciBib29sID0gaXNQb3NpdGl2ZUludGVnZXIoIDMuMCApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogYm9vbCA9IGlzUG9zaXRpdmVJbnRlZ2VyKCBuZXcgTnVtYmVyKCAzLjAgKSApO1xuKiAvLyByZXR1cm5zIGZhbHNlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBpc1Bvc2l0aXZlSW50ZWdlciA9IHJlcXVpcmUoICdAc3RkbGliL2Fzc2VydC1pcy1wb3NpdGl2ZS1pbnRlZ2VyJyApLmlzT2JqZWN0O1xuKlxuKiB2YXIgYm9vbCA9IGlzUG9zaXRpdmVJbnRlZ2VyKCAzLjAgKTtcbiogLy8gcmV0dXJucyBmYWxzZVxuKlxuKiBib29sID0gaXNQb3NpdGl2ZUludGVnZXIoIG5ldyBOdW1iZXIoIDMuMCApICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKi9cblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgc2V0UmVhZE9ubHkgPSByZXF1aXJlKCAnQHN0ZGxpYi91dGlscy1kZWZpbmUtbm9uZW51bWVyYWJsZS1yZWFkLW9ubHktcHJvcGVydHknICk7XG52YXIgaXNQb3NpdGl2ZUludGVnZXIgPSByZXF1aXJlKCAnLi9tYWluLmpzJyApO1xudmFyIGlzUHJpbWl0aXZlID0gcmVxdWlyZSggJy4vcHJpbWl0aXZlLmpzJyApO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSggJy4vb2JqZWN0LmpzJyApO1xuXG5cbi8vIE1BSU4gLy9cblxuc2V0UmVhZE9ubHkoIGlzUG9zaXRpdmVJbnRlZ2VyLCAnaXNQcmltaXRpdmUnLCBpc1ByaW1pdGl2ZSApO1xuc2V0UmVhZE9ubHkoIGlzUG9zaXRpdmVJbnRlZ2VyLCAnaXNPYmplY3QnLCBpc09iamVjdCApO1xuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBpc1Bvc2l0aXZlSW50ZWdlcjtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBuYXRpdmVDbGFzcyA9IHJlcXVpcmUoICdAc3RkbGliL3V0aWxzLW5hdGl2ZS1jbGFzcycgKTtcblxuXG4vLyBWQVJJQUJMRVMgLy9cblxudmFyIGY7XG5cblxuLy8gRlVOQ1RJT05TIC8vXG5cbi8qKlxuKiBUZXN0cyBpZiBhIHZhbHVlIGlzIGFuIGFycmF5LlxuKlxuKiBAcGFyYW0geyp9IHZhbHVlIC0gdmFsdWUgdG8gdGVzdFxuKiBAcmV0dXJucyB7Ym9vbGVhbn0gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdmFsdWUgaXMgYW4gYXJyYXlcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBpc0FycmF5KCBbXSApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBpc0FycmF5KCB7fSApO1xuKiAvLyByZXR1cm5zIGZhbHNlXG4qL1xuZnVuY3Rpb24gaXNBcnJheSggdmFsdWUgKSB7XG5cdHJldHVybiAoIG5hdGl2ZUNsYXNzKCB2YWx1ZSApID09PSAnW29iamVjdCBBcnJheV0nICk7XG59XG5cblxuLy8gTUFJTiAvL1xuXG5pZiAoIEFycmF5LmlzQXJyYXkgKSB7XG5cdGYgPSBBcnJheS5pc0FycmF5O1xufSBlbHNlIHtcblx0ZiA9IGlzQXJyYXk7XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGY7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIFRlc3QgaWYgYSB2YWx1ZSBpcyBhbiBhcnJheS5cbipcbiogQG1vZHVsZSBAc3RkbGliL2Fzc2VydC1pcy1hcnJheVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgaXNBcnJheSA9IHJlcXVpcmUoICdAc3RkbGliL2Fzc2VydC1pcy1hcnJheScgKTtcbipcbiogdmFyIGJvb2wgPSBpc0FycmF5KCBbXSApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogYm9vbCA9IGlzQXJyYXkoIHt9ICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbiovXG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCAnLi9tYWluLmpzJyApO1xuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5O1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaXMtYXJyYXknICk7XG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogUmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIHRlc3RzIGlmIGV2ZXJ5IGVsZW1lbnQgaW4gYW4gYXJyYXkgcGFzc2VzIGEgdGVzdCBjb25kaXRpb24uXG4qXG4qIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSAtIGZ1bmN0aW9uIHRvIGFwcGx5XG4qIEB0aHJvd3Mge1R5cGVFcnJvcn0gbXVzdCBwcm92aWRlIGEgZnVuY3Rpb25cbiogQHJldHVybnMge0Z1bmN0aW9ufSBhbiBhcnJheSBmdW5jdGlvblxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgaXNPZGQgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaXMtb2RkJyApO1xuKlxuKiB2YXIgYXJyMSA9IFsgMSwgMywgNSwgNyBdO1xuKiB2YXIgYXJyMiA9IFsgMywgNSwgOCBdO1xuKlxuKiB2YXIgdmFsaWRhdGUgPSBhcnJheWZjbiggaXNPZGQgKTtcbipcbiogdmFyIGJvb2wgPSB2YWxpZGF0ZSggYXJyMSApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogYm9vbCA9IHZhbGlkYXRlKCBhcnIyICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbiovXG5mdW5jdGlvbiBhcnJheWZjbiggcHJlZGljYXRlICkge1xuXHRpZiAoIHR5cGVvZiBwcmVkaWNhdGUgIT09ICdmdW5jdGlvbicgKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ2ludmFsaWQgYXJndW1lbnQuIE11c3QgcHJvdmlkZSBhIGZ1bmN0aW9uLiBWYWx1ZTogYCcgKyBwcmVkaWNhdGUgKyAnYC4nICk7XG5cdH1cblx0cmV0dXJuIGV2ZXJ5O1xuXG5cdC8qKlxuXHQqIFRlc3RzIGlmIGV2ZXJ5IGVsZW1lbnQgaW4gYW4gYXJyYXkgcGFzc2VzIGEgdGVzdCBjb25kaXRpb24uXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqIEBwYXJhbSB7Kn0gdmFsdWUgLSB2YWx1ZSB0byB0ZXN0XG5cdCogQHJldHVybnMge2Jvb2xlYW59IGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGEgdmFsdWUgaXMgYW4gYXJyYXkgZm9yIHdoaWNoIGFsbCBlbGVtZW50cyBwYXNzIGEgdGVzdCBjb25kaXRpb25cblx0Ki9cblx0ZnVuY3Rpb24gZXZlcnkoIHZhbHVlICkge1xuXHRcdHZhciBsZW47XG5cdFx0dmFyIGk7XG5cdFx0aWYgKCAhaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0bGVuID0gdmFsdWUubGVuZ3RoO1xuXHRcdGlmICggbGVuID09PSAwICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0aWYgKCBwcmVkaWNhdGUoIHZhbHVlWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlmY247XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIFJldHVybiBhIGZ1bmN0aW9uIHdoaWNoIHRlc3RzIGlmIGV2ZXJ5IGVsZW1lbnQgaW4gYW4gYXJyYXkgcGFzc2VzIGEgdGVzdCBjb25kaXRpb24uXG4qXG4qIEBtb2R1bGUgQHN0ZGxpYi9hc3NlcnQtdG9vbHMtYXJyYXktZnVuY3Rpb25cbipcbiogQGV4YW1wbGVcbiogdmFyIGlzT2RkID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLW9kZCcgKTtcbiogdmFyIGFycmF5ZmNuID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LXRvb2xzLWFycmF5LWZ1bmN0aW9uJyApO1xuKlxuKiB2YXIgYXJyMSA9IFsgMSwgMywgNSwgNyBdO1xuKiB2YXIgYXJyMiA9IFsgMywgNSwgOCBdO1xuKlxuKiB2YXIgdmFsaWRhdGUgPSBhcnJheWZjbiggaXNPZGQgKTtcbipcbiogdmFyIGJvb2wgPSB2YWxpZGF0ZSggYXJyMSApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogYm9vbCA9IHZhbGlkYXRlKCBhcnIyICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbiovXG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGFycmF5ZmNuID0gcmVxdWlyZSggJy4vYXJyYXlmY24uanMnICk7XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5ZmNuO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBUZXN0cyBpZiBhIHZhbHVlIGlzIGEgc3RyaW5nIHByaW1pdGl2ZS5cbipcbiogQHBhcmFtIHsqfSB2YWx1ZSAtIHZhbHVlIHRvIHRlc3RcbiogQHJldHVybnMge2Jvb2xlYW59IGJvb2xlYW4gaW5kaWNhdGluZyBpZiBhIHZhbHVlIGlzIGEgc3RyaW5nIHByaW1pdGl2ZVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgYm9vbCA9IGlzU3RyaW5nKCAnYmVlcCcgKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaXNTdHJpbmcoIG5ldyBTdHJpbmcoICdiZWVwJyApICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbiovXG5mdW5jdGlvbiBpc1N0cmluZyggdmFsdWUgKSB7XG5cdHJldHVybiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgKTtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNTdHJpbmc7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHN0ZGxpYi9uby1yZWRlY2xhcmVcbnZhciB2YWx1ZU9mID0gU3RyaW5nLnByb3RvdHlwZS52YWx1ZU9mOyAvLyBub24tZ2VuZXJpY1xuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSB2YWx1ZU9mO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIHZhbHVlT2YgPSByZXF1aXJlKCAnLi92YWx1ZW9mLmpzJyApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHN0ZGxpYi9uby1yZWRlY2xhcmVcblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBBdHRlbXB0cyB0byBleHRyYWN0IGEgc3RyaW5nIHZhbHVlLlxuKlxuKiBAcHJpdmF0ZVxuKiBAcGFyYW0geyp9IHZhbHVlIC0gdmFsdWUgdG8gdGVzdFxuKiBAcmV0dXJucyB7Ym9vbGVhbn0gYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGEgc3RyaW5nIGNhbiBiZSBleHRyYWN0ZWRcbiovXG5mdW5jdGlvbiB0ZXN0KCB2YWx1ZSApIHtcblx0dHJ5IHtcblx0XHR2YWx1ZU9mLmNhbGwoIHZhbHVlICk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKCBlcnIgKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gdGVzdDtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBoYXNUb1N0cmluZ1RhZyA9IHJlcXVpcmUoICdAc3RkbGliL2Fzc2VydC1oYXMtdG9zdHJpbmd0YWctc3VwcG9ydCcgKTtcbnZhciBuYXRpdmVDbGFzcyA9IHJlcXVpcmUoICdAc3RkbGliL3V0aWxzLW5hdGl2ZS1jbGFzcycgKTtcbnZhciB0ZXN0ID0gcmVxdWlyZSggJy4vdHJ5MnZhbHVlb2YuanMnICk7XG5cblxuLy8gVkFSSUFCTEVTIC8vXG5cbnZhciBGTEcgPSBoYXNUb1N0cmluZ1RhZygpO1xuXG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIFRlc3RzIGlmIGEgdmFsdWUgaXMgYSBzdHJpbmcgb2JqZWN0LlxuKlxuKiBAcGFyYW0geyp9IHZhbHVlIC0gdmFsdWUgdG8gdGVzdFxuKiBAcmV0dXJucyB7Ym9vbGVhbn0gYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGEgdmFsdWUgaXMgYSBzdHJpbmcgb2JqZWN0XG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaXNTdHJpbmcoIG5ldyBTdHJpbmcoICdiZWVwJyApICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgYm9vbCA9IGlzU3RyaW5nKCAnYmVlcCcgKTtcbiogLy8gcmV0dXJucyBmYWxzZVxuKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKCB2YWx1ZSApIHtcblx0aWYgKCB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICkge1xuXHRcdGlmICggdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcgKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0aWYgKCBGTEcgKSB7XG5cdFx0XHRyZXR1cm4gdGVzdCggdmFsdWUgKTtcblx0XHR9XG5cdFx0cmV0dXJuICggbmF0aXZlQ2xhc3MoIHZhbHVlICkgPT09ICdbb2JqZWN0IFN0cmluZ10nICk7XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N0cmluZztcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBpc1ByaW1pdGl2ZSA9IHJlcXVpcmUoICcuL3ByaW1pdGl2ZS5qcycgKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoICcuL29iamVjdC5qcycgKTtcblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBUZXN0cyBpZiBhIHZhbHVlIGlzIGEgc3RyaW5nLlxuKlxuKiBAcGFyYW0geyp9IHZhbHVlIC0gdmFsdWUgdG8gdGVzdFxuKiBAcmV0dXJucyB7Ym9vbGVhbn0gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdmFsdWUgaXMgYSBzdHJpbmdcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBpc1N0cmluZyggbmV3IFN0cmluZyggJ2JlZXAnICkgKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaXNTdHJpbmcoICdiZWVwJyApO1xuKiAvLyByZXR1cm5zIHRydWVcbiovXG5mdW5jdGlvbiBpc1N0cmluZyggdmFsdWUgKSB7XG5cdHJldHVybiAoIGlzUHJpbWl0aXZlKCB2YWx1ZSApIHx8IGlzT2JqZWN0KCB2YWx1ZSApICk7XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3RyaW5nO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBUZXN0IGlmIGEgdmFsdWUgaXMgYSBzdHJpbmcuXG4qXG4qIEBtb2R1bGUgQHN0ZGxpYi9hc3NlcnQtaXMtc3RyaW5nXG4qXG4qIEBleGFtcGxlXG4qIHZhciBpc1N0cmluZyA9IHJlcXVpcmUoICdAc3RkbGliL2Fzc2VydC1pcy1zdHJpbmcnICk7XG4qXG4qIHZhciBib29sID0gaXNTdHJpbmcoICdiZWVwJyApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogYm9vbCA9IGlzU3RyaW5nKCBuZXcgU3RyaW5nKCAnYmVlcCcgKSApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogYm9vbCA9IGlzU3RyaW5nKCA1ICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbipcbiogQGV4YW1wbGVcbiogdmFyIGlzU3RyaW5nID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLXN0cmluZycgKS5pc09iamVjdDtcbipcbiogdmFyIGJvb2wgPSBpc1N0cmluZyggbmV3IFN0cmluZyggJ2JlZXAnICkgKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qXG4qIGJvb2wgPSBpc1N0cmluZyggJ2JlZXAnICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbipcbiogQGV4YW1wbGVcbiogdmFyIGlzU3RyaW5nID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLXN0cmluZycgKS5pc1ByaW1pdGl2ZTtcbipcbiogdmFyIGJvb2wgPSBpc1N0cmluZyggJ2JlZXAnICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKlxuKiBib29sID0gaXNTdHJpbmcoIG5ldyBTdHJpbmcoICdiZWVwJyApICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbiovXG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIHNldFJlYWRPbmx5ID0gcmVxdWlyZSggJ0BzdGRsaWIvdXRpbHMtZGVmaW5lLW5vbmVudW1lcmFibGUtcmVhZC1vbmx5LXByb3BlcnR5JyApO1xudmFyIGlzU3RyaW5nID0gcmVxdWlyZSggJy4vbWFpbi5qcycgKTtcbnZhciBpc1ByaW1pdGl2ZSA9IHJlcXVpcmUoICcuL3ByaW1pdGl2ZS5qcycgKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoICcuL29iamVjdC5qcycgKTtcblxuXG4vLyBNQUlOIC8vXG5cbnNldFJlYWRPbmx5KCBpc1N0cmluZywgJ2lzUHJpbWl0aXZlJywgaXNQcmltaXRpdmUgKTtcbnNldFJlYWRPbmx5KCBpc1N0cmluZywgJ2lzT2JqZWN0JywgaXNPYmplY3QgKTtcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNTdHJpbmc7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIFRlc3QgaWYgYSB2YWx1ZSBpcyBhbiBhcnJheSBvZiBzdHJpbmdzLlxuKlxuKiBAbW9kdWxlIEBzdGRsaWIvYXNzZXJ0LWlzLXN0cmluZy1hcnJheVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgaXNTdHJpbmdBcnJheSA9IHJlcXVpcmUoICdAc3RkbGliL2Fzc2VydC1pcy1zdHJpbmctYXJyYXknICk7XG4qXG4qIHZhciBib29sID0gaXNTdHJpbmdBcnJheSggWyAnYWJjJywgJ2RlZicgXSApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogYm9vbCA9IGlzU3RyaW5nQXJyYXkoIFsgJ2FiYycsIDEyMyBdICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbipcbiogQGV4YW1wbGVcbiogdmFyIGlzU3RyaW5nQXJyYXkgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaXMtc3RyaW5nLWFycmF5JyApLnByaW1pdGl2ZXM7XG4qXG4qIHZhciBib29sID0gaXNTdHJpbmdBcnJheSggWyAnYWJjJywgJ2RlZicgXSApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogYm9vbCA9IGlzU3RyaW5nQXJyYXkoIFsgJ2FiYycsIG5ldyBTdHJpbmcoICdkZWYnICkgXSApO1xuKiAvLyByZXR1cm5zIGZhbHNlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBpc1N0cmluZ0FycmF5ID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLXN0cmluZy1hcnJheScgKS5vYmplY3RzO1xuKlxuKiB2YXIgYm9vbCA9IGlzU3RyaW5nQXJyYXkoIFsgbmV3IFN0cmluZyggJ2FiYycgKSwgbmV3IFN0cmluZyggJ2RlZicgKSBdICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKlxuKiBib29sID0gaXNTdHJpbmdBcnJheSggWyBuZXcgU3RyaW5nKCAnYWJjJyApLCAnZGVmJyBdICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbiovXG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIHNldFJlYWRPbmx5ID0gcmVxdWlyZSggJ0BzdGRsaWIvdXRpbHMtZGVmaW5lLW5vbmVudW1lcmFibGUtcmVhZC1vbmx5LXByb3BlcnR5JyApO1xudmFyIGFycmF5ZnVuID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LXRvb2xzLWFycmF5LWZ1bmN0aW9uJyApO1xudmFyIGlzU3RyaW5nID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLXN0cmluZycgKTtcblxuXG4vLyBNQUlOIC8vXG5cbnZhciBpc1N0cmluZ0FycmF5ID0gYXJyYXlmdW4oIGlzU3RyaW5nICk7XG5zZXRSZWFkT25seSggaXNTdHJpbmdBcnJheSwgJ3ByaW1pdGl2ZXMnLCBhcnJheWZ1biggaXNTdHJpbmcuaXNQcmltaXRpdmUgKSApO1xuc2V0UmVhZE9ubHkoIGlzU3RyaW5nQXJyYXksICdvYmplY3RzJywgYXJyYXlmdW4oIGlzU3RyaW5nLmlzT2JqZWN0ICkgKTtcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNTdHJpbmdBcnJheTtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoICdAc3RkbGliL3V0aWxzLWRlZmluZS1wcm9wZXJ0eScgKTtcblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBEZWZpbmVzIGEgcmVhZC1vbmx5IHByb3BlcnR5LlxuKlxuKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gb2JqZWN0IG9uIHdoaWNoIHRvIGRlZmluZSB0aGUgcHJvcGVydHlcbiogQHBhcmFtIHsoc3RyaW5nfHN5bWJvbCl9IHByb3AgLSBwcm9wZXJ0eSBuYW1lXG4qIEBwYXJhbSB7Kn0gdmFsdWUgLSB2YWx1ZSB0byBzZXRcbipcbiogQGV4YW1wbGVcbiogdmFyIG9iaiA9IHt9O1xuKlxuKiBzZXRSZWFkT25seSggb2JqLCAnZm9vJywgJ2JhcicgKTtcbipcbiogdHJ5IHtcbiogICAgIG9iai5mb28gPSAnYm9vcCc7XG4qIH0gY2F0Y2ggKCBlcnIgKSB7XG4qICAgICBjb25zb2xlLmVycm9yKCBlcnIubWVzc2FnZSApO1xuKiB9XG4qL1xuZnVuY3Rpb24gc2V0UmVhZE9ubHkoIG9iaiwgcHJvcCwgdmFsdWUgKSB7XG5cdGRlZmluZVByb3BlcnR5KCBvYmosIHByb3AsIHtcblx0XHQnY29uZmlndXJhYmxlJzogZmFsc2UsXG5cdFx0J2VudW1lcmFibGUnOiB0cnVlLFxuXHRcdCd3cml0YWJsZSc6IGZhbHNlLFxuXHRcdCd2YWx1ZSc6IHZhbHVlXG5cdH0pO1xufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRSZWFkT25seTtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogRGVmaW5lIGEgcmVhZC1vbmx5IHByb3BlcnR5LlxuKlxuKiBAbW9kdWxlIEBzdGRsaWIvdXRpbHMtZGVmaW5lLXJlYWQtb25seS1wcm9wZXJ0eVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgc2V0UmVhZE9ubHkgPSByZXF1aXJlKCAnQHN0ZGxpYi91dGlscy1kZWZpbmUtcmVhZC1vbmx5LXByb3BlcnR5JyApO1xuKlxuKiB2YXIgb2JqID0ge307XG4qXG4qIHNldFJlYWRPbmx5KCBvYmosICdmb28nLCAnYmFyJyApO1xuKlxuKiB0cnkge1xuKiAgICAgb2JqLmZvbyA9ICdib29wJztcbiogfSBjYXRjaCAoIGVyciApIHtcbiogICAgIGNvbnNvbGUuZXJyb3IoIGVyci5tZXNzYWdlICk7XG4qIH1cbiovXG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIHNldFJlYWRPbmx5ID0gcmVxdWlyZSggJy4vbWFpbi5qcycgKTtcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gc2V0UmVhZE9ubHk7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIE1heGltdW0gbGVuZ3RoIG9mIGEgdHlwZWQgYXJyYXkuXG4qXG4qIEBtb2R1bGUgQHN0ZGxpYi9jb25zdGFudHMtYXJyYXktbWF4LXR5cGVkLWFycmF5LWxlbmd0aFxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgTUFYX1RZUEVEX0FSUkFZX0xFTkdUSCA9IHJlcXVpcmUoICdAc3RkbGliL2NvbnN0YW50cy1hcnJheS1tYXgtdHlwZWQtYXJyYXktbGVuZ3RoJyApO1xuKiAvLyByZXR1cm5zIDkwMDcxOTkyNTQ3NDA5OTFcbiovXG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIE1heGltdW0gbGVuZ3RoIG9mIGEgdHlwZWQgYXJyYXkuXG4qXG4qIGBgYHRleFxuKiAyXns1M30gLSAxXG4qIGBgYFxuKlxuKiBAY29uc3RhbnRcbiogQHR5cGUge251bWJlcn1cbiogQGRlZmF1bHQgOTAwNzE5OTI1NDc0MDk5MVxuKi9cbnZhciBNQVhfVFlQRURfQVJSQVlfTEVOR1RIID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gTUFYX1RZUEVEX0FSUkFZX0xFTkdUSDtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBpc0ludGVnZXIgPSByZXF1aXJlKCAnQHN0ZGxpYi9tYXRoLWJhc2UtYXNzZXJ0LWlzLWludGVnZXInICk7XG52YXIgTUFYX0xFTkdUSCA9IHJlcXVpcmUoICdAc3RkbGliL2NvbnN0YW50cy1hcnJheS1tYXgtdHlwZWQtYXJyYXktbGVuZ3RoJyApO1xuXG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIFRlc3RzIGlmIGEgdmFsdWUgaXMgYSBjb2xsZWN0aW9uLlxuKlxuKiBAcGFyYW0geyp9IHZhbHVlIC0gdmFsdWUgdG8gdGVzdFxuKiBAcmV0dXJucyB7Ym9vbGVhbn0gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgYSB2YWx1ZSBpcyBhIGNvbGxlY3Rpb25cbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBpc0NvbGxlY3Rpb24oIFtdICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgYm9vbCA9IGlzQ29sbGVjdGlvbigge30gKTtcbiogLy8gcmV0dXJucyBmYWxzZVxuKi9cbmZ1bmN0aW9uIGlzQ29sbGVjdGlvbiggdmFsdWUgKSB7XG5cdHJldHVybiAoXG5cdFx0dHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuXHRcdHZhbHVlICE9PSBudWxsICYmXG5cdFx0dHlwZW9mIHZhbHVlLmxlbmd0aCA9PT0gJ251bWJlcicgJiZcblx0XHRpc0ludGVnZXIoIHZhbHVlLmxlbmd0aCApICYmXG5cdFx0dmFsdWUubGVuZ3RoID49IDAgJiZcblx0XHR2YWx1ZS5sZW5ndGggPD0gTUFYX0xFTkdUSFxuXHQpO1xufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBpc0NvbGxlY3Rpb247XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIFRlc3QgaWYgYSB2YWx1ZSBpcyBhIGNvbGxlY3Rpb24uXG4qXG4qIEBtb2R1bGUgQHN0ZGxpYi9hc3NlcnQtaXMtY29sbGVjdGlvblxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgaXNDb2xsZWN0aW9uID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLWNvbGxlY3Rpb24nICk7XG4qXG4qIHZhciBib29sID0gaXNDb2xsZWN0aW9uKCBbXSApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogYm9vbCA9IGlzQ29sbGVjdGlvbigge30gKTtcbiogLy8gcmV0dXJucyBmYWxzZVxuKi9cblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgaXNDb2xsZWN0aW9uID0gcmVxdWlyZSggJy4vbWFpbi5qcycgKTtcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNDb2xsZWN0aW9uO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGlzTnVtYmVyID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLW51bWJlcicgKS5pc1ByaW1pdGl2ZTtcbnZhciBpc05hbiA9IHJlcXVpcmUoICdAc3RkbGliL21hdGgtYmFzZS1hc3NlcnQtaXMtbmFuJyApO1xuXG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIFRlc3RzIGlmIGEgdmFsdWUgaXMgYSBgTmFOYCBudW1iZXIgcHJpbWl0aXZlLlxuKlxuKiBAcGFyYW0geyp9IHZhbHVlIC0gdmFsdWUgdG8gdGVzdFxuKiBAcmV0dXJucyB7Ym9vbGVhbn0gYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGEgdmFsdWUgaXMgYSBgTmFOYCBudW1iZXIgcHJpbWl0aXZlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaXNuYW4oIE5hTiApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBpc25hbiggMy4xNCApO1xuKiAvLyByZXR1cm5zIGZhbHNlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaXNuYW4oIG5ldyBOdW1iZXIoIE5hTiApICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbiovXG5mdW5jdGlvbiBpc25hbiggdmFsdWUgKSB7XG5cdHJldHVybiAoXG5cdFx0aXNOdW1iZXIoIHZhbHVlICkgJiZcblx0XHRpc05hbiggdmFsdWUgKVxuXHQpO1xufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBpc25hbjtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBpc051bWJlciA9IHJlcXVpcmUoICdAc3RkbGliL2Fzc2VydC1pcy1udW1iZXInICkuaXNPYmplY3Q7XG52YXIgaXNOYW4gPSByZXF1aXJlKCAnQHN0ZGxpYi9tYXRoLWJhc2UtYXNzZXJ0LWlzLW5hbicgKTtcblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBUZXN0cyBpZiBhIHZhbHVlIGlzIGEgbnVtYmVyIG9iamVjdCBoYXZpbmcgYSB2YWx1ZSBvZiBgTmFOYC5cbipcbiogQHBhcmFtIHsqfSB2YWx1ZSAtIHZhbHVlIHRvIHRlc3RcbiogQHJldHVybnMge2Jvb2xlYW59IGJvb2xlYW4gaW5kaWNhdGluZyBpZiBhIHZhbHVlIGlzIGEgbnVtYmVyIG9iamVjdCBoYXZpbmcgYSB2YWx1ZSBvZiBgTmFOYFxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgYm9vbCA9IGlzbmFuKCBOYU4gKTtcbiogLy8gcmV0dXJucyBmYWxzZVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgYm9vbCA9IGlzbmFuKCBuZXcgTnVtYmVyKCBOYU4gKSApO1xuKiAvLyByZXR1cm5zIHRydWVcbiovXG5mdW5jdGlvbiBpc25hbiggdmFsdWUgKSB7XG5cdHJldHVybiAoXG5cdFx0aXNOdW1iZXIoIHZhbHVlICkgJiZcblx0XHRpc05hbiggdmFsdWUudmFsdWVPZigpIClcblx0KTtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNuYW47XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgaXNQcmltaXRpdmUgPSByZXF1aXJlKCAnLi9wcmltaXRpdmUuanMnICk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCAnLi9vYmplY3QuanMnICk7XG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogVGVzdHMgaWYgYSB2YWx1ZSBpcyBgTmFOYC5cbipcbiogQHBhcmFtIHsqfSB2YWx1ZSAtIHZhbHVlIHRvIHRlc3RcbiogQHJldHVybnMge2Jvb2xlYW59IGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHZhbHVlIGlzIGBOYU5gXG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaXNuYW4oIE5hTiApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBpc25hbiggbmV3IE51bWJlciggTmFOICkgKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaXNuYW4oIDMuMTQgKTtcbiogLy8gcmV0dXJucyBmYWxzZVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgYm9vbCA9IGlzbmFuKCBudWxsICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbiovXG5mdW5jdGlvbiBpc25hbiggdmFsdWUgKSB7XG5cdHJldHVybiAoIGlzUHJpbWl0aXZlKCB2YWx1ZSApIHx8IGlzT2JqZWN0KCB2YWx1ZSApICk7XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzbmFuO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBUZXN0IGlmIGEgdmFsdWUgaXMgYE5hTmAuXG4qXG4qIEBtb2R1bGUgQHN0ZGxpYi9hc3NlcnQtaXMtbmFuXG4qXG4qIEBleGFtcGxlXG4qIHZhciBpc25hbiA9IHJlcXVpcmUoICdAc3RkbGliL2Fzc2VydC1pcy1uYW4nICk7XG4qXG4qIHZhciBib29sID0gaXNuYW4oIE5hTiApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogYm9vbCA9IGlzbmFuKCBuZXcgTnVtYmVyKCBOYU4gKSApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogYm9vbCA9IGlzbmFuKCAzLjE0ICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbipcbiogYm9vbCA9IGlzbmFuKCBudWxsICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbipcbiogQGV4YW1wbGVcbiogdmFyIGlzbmFuID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLW5hbicgKS5pc1ByaW1pdGl2ZTtcbipcbiogdmFyIGJvb2wgPSBpc25hbiggTmFOICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKlxuKiBib29sID0gaXNuYW4oIDMuMTQgKTtcbiogLy8gcmV0dXJucyBmYWxzZVxuKlxuKiBib29sID0gaXNuYW4oIG5ldyBOdW1iZXIoIE5hTiApICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbipcbiogQGV4YW1wbGVcbiogdmFyIGlzbmFuID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLW5hbicgKS5pc09iamVjdDtcbipcbiogdmFyIGJvb2wgPSBpc25hbiggTmFOICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbipcbiogYm9vbCA9IGlzbmFuKCBuZXcgTnVtYmVyKCBOYU4gKSApO1xuKiAvLyByZXR1cm5zIHRydWVcbiovXG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIHNldFJlYWRPbmx5ID0gcmVxdWlyZSggJ0BzdGRsaWIvdXRpbHMtZGVmaW5lLW5vbmVudW1lcmFibGUtcmVhZC1vbmx5LXByb3BlcnR5JyApO1xudmFyIGlzbmFuID0gcmVxdWlyZSggJy4vbWFpbi5qcycgKTtcbnZhciBpc1ByaW1pdGl2ZSA9IHJlcXVpcmUoICcuL3ByaW1pdGl2ZS5qcycgKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoICcuL29iamVjdC5qcycgKTtcblxuXG4vLyBNQUlOIC8vXG5cbnNldFJlYWRPbmx5KCBpc25hbiwgJ2lzUHJpbWl0aXZlJywgaXNQcmltaXRpdmUgKTtcbnNldFJlYWRPbmx5KCBpc25hbiwgJ2lzT2JqZWN0JywgaXNPYmplY3QgKTtcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNuYW47XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgaXNDb2xsZWN0aW9uID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLWNvbGxlY3Rpb24nICk7XG52YXIgaXNJbnRlZ2VyID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLWludGVnZXInICkuaXNQcmltaXRpdmU7XG52YXIgaXNTdHJpbmcgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaXMtc3RyaW5nJyApLmlzUHJpbWl0aXZlO1xudmFyIGlzbmFuID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLW5hbicgKS5pc1ByaW1pdGl2ZTtcblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBUZXN0cyBpZiBhbiBhcnJheS1saWtlIHZhbHVlIGNvbnRhaW5zIGEgc2VhcmNoIHZhbHVlLlxuKlxuKiBAcGFyYW0geyhDb2xsZWN0aW9ufHN0cmluZyl9IHZhbCAtIGlucHV0IHZhbHVlXG4qIEBwYXJhbSB7Kn0gc2VhcmNoVmFsdWUgLSBzZWFyY2ggdmFsdWVcbiogQHBhcmFtIHtpbnRlZ2VyfSBbcG9zaXRpb249MF0gLSBwb3NpdGlvbiBhdCB3aGljaCB0byBzdGFydCBzZWFyY2hpbmcgZm9yIGBzZWFyY2hWYWx1ZWBcbiogQHRocm93cyB7VHlwZUVycm9yfSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGFycmF5LWxpa2VcbiogQHRocm93cyB7RXJyb3J9IG11c3QgcHJvdmlkZSBhIHNlYXJjaCB2YWx1ZVxuKiBAdGhyb3dzIHtUeXBlRXJyb3J9IHNlY29uZCBhcmd1bWVudCBtdXN0IGJlIGEgcHJpbWl0aXZlIHN0cmluZyBwcmltaXRpdmUgd2hlbiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYSBzdHJpbmdcbiogQHRocm93cyB7VHlwZUVycm9yfSB0aGlyZCBhcmd1bWVudCBtdXN0IGJlIGFuIGludGVnZXJcbiogQHJldHVybnMge2Jvb2xlYW59IGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIG9uZSB2YWx1ZSBjb250YWlucyBhbm90aGVyXG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gY29udGFpbnMoICdsYXN0IG1hbiBzdGFuZGluZycsICdzdGFuZCcgKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gY29udGFpbnMoIFsgMSwgMiwgMywgNCBdLCAyICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgYm9vbCA9IGNvbnRhaW5zKCAncHJlc2lkZW50aWFsIGVsZWN0aW9uJywgJ3ByZXNpZGVudCcgKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gY29udGFpbnMoIFsgTmFOLCAyLCAzLCA0IF0sIE5hTiApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBjb250YWlucyggJ2phdmFTY3JpcHQnLCAnanMnICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBjb250YWlucyggWyAxLCAyLCAzLCB7fSBdLCB7fSApO1xuKiAvLyByZXR1cm5zIGZhbHNlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gY29udGFpbnMoICdIaWRkZW4gVHJlYXN1cmVzJywgJycgKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qL1xuZnVuY3Rpb24gY29udGFpbnMoIHZhbCwgc2VhcmNoVmFsdWUsIHBvc2l0aW9uICkge1xuXHR2YXIgbGVuO1xuXHR2YXIgcG9zO1xuXHR2YXIgaTtcblx0aWYgKCAhaXNDb2xsZWN0aW9uKCB2YWwgKSAmJiAhaXNTdHJpbmcoIHZhbCApICkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdpbnZhbGlkIGFyZ3VtZW50LiBGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGFycmF5LWxpa2UuIFZhbHVlOiBgJyArIHZhbCArICdgLicgKTtcblx0fVxuXHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPCAyICkge1xuXHRcdHRocm93IG5ldyBFcnJvciggJ2luc3VmZmljaWVudCBpbnB1dCBhcmd1bWVudHMuIE11c3QgcHJvdmlkZSBhIHNlYXJjaCB2YWx1ZS4nICk7XG5cdH1cblx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMiApIHtcblx0XHRpZiAoICFpc0ludGVnZXIoIHBvc2l0aW9uICkgKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnaW52YWxpZCBhcmd1bWVudC4gVGhpcmQgYXJndW1lbnQgbXVzdCBiZSBhbiBpbnRlZ2VyLiBWYWx1ZTogYCcgKyBwb3NpdGlvbiArICdgLicgKTtcblx0XHR9XG5cdFx0cG9zID0gcG9zaXRpb247XG5cdFx0aWYgKCBwb3MgPCAwICkge1xuXHRcdFx0cG9zID0gMDtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0cG9zID0gMDtcblx0fVxuXHRpZiAoIGlzU3RyaW5nKCB2YWwgKSApIHtcblx0XHRpZiAoICFpc1N0cmluZyggc2VhcmNoVmFsdWUgKSApIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdpbnZhbGlkIGFyZ3VtZW50LiBTZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZyBwcmltaXRpdmUuIFZhbHVlOiBgJyArIHNlYXJjaFZhbHVlICsgJ2AuJyApO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsLmluZGV4T2YoIHNlYXJjaFZhbHVlLCBwb3MgKSAhPT0gLTE7XG5cdH1cblx0bGVuID0gdmFsLmxlbmd0aDtcblx0aWYgKCBpc25hbiggc2VhcmNoVmFsdWUgKSApIHtcblx0XHRmb3IgKCBpID0gcG9zOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRpZiAoIGlzbmFuKCB2YWxbIGkgXSApICkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdGZvciAoIGkgPSBwb3M7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoIHZhbFsgaSBdID09PSBzZWFyY2hWYWx1ZSApIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRhaW5zO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBUZXN0IGlmIGFuIGFycmF5LWxpa2UgdmFsdWUgY29udGFpbnMgYW5vdGhlciB2YWx1ZS5cbipcbiogQG1vZHVsZSBAc3RkbGliL2Fzc2VydC1jb250YWluc1xuKlxuKiBAZXhhbXBsZVxuKiB2YXIgY29udGFpbnMgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtY29udGFpbnMnICk7XG4qXG4qIHZhciBib29sID0gY29udGFpbnMoICdIZWxsbyBXb3JsZCcsICdXb3JsZCcgKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qXG4qIGJvb2wgPSBjb250YWlucyggJ0hlbGxvIFdvcmxkJywgJ3dvcmxkJyApO1xuKiAvLyByZXR1cm5zIGZhbHNlXG4qXG4qIGJvb2wgPSBjb250YWlucyggWyAxLCAyLCAzLCA0IF0sIDIgKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qXG4qIGJvb2wgPSBjb250YWlucyggWyBOYU4sIDIsIDMsIDQgXSwgTmFOICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKi9cblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgY29udGFpbnMgPSByZXF1aXJlKCAnLi9jb250YWlucy5qcycgKTtcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gY29udGFpbnM7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIFRlc3RzIGlmIGEgdmFsdWUgaXMgYSBib29sZWFuIHByaW1pdGl2ZS5cbipcbiogQHBhcmFtIHsqfSB2YWx1ZSAtIHZhbHVlIHRvIHRlc3RcbiogQHJldHVybnMge2Jvb2xlYW59IGJvb2xlYW4gaW5kaWNhdGluZyBpZiBhIHZhbHVlIGlzIGEgYm9vbGVhbiBwcmltaXRpdmVcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBpc0Jvb2xlYW4oIHRydWUgKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaXNCb29sZWFuKCBmYWxzZSApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBpc0Jvb2xlYW4oIG5ldyBCb29sZWFuKCB0cnVlICkgKTtcbiogLy8gcmV0dXJucyBmYWxzZVxuKi9cbmZ1bmN0aW9uIGlzQm9vbGVhbiggdmFsdWUgKSB7XG5cdHJldHVybiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nICk7XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQm9vbGVhbjtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgc3RkbGliL25vLXJlZGVjbGFyZVxudmFyIHRvU3RyaW5nID0gQm9vbGVhbi5wcm90b3R5cGUudG9TdHJpbmc7IC8vIG5vbi1nZW5lcmljXG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU3RyaW5nO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIHRvU3RyaW5nID0gcmVxdWlyZSggJy4vdG9zdHJpbmcuanMnICk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgc3RkbGliL25vLXJlZGVjbGFyZVxuXG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIEF0dGVtcHRzIHRvIHNlcmlhbGl6ZSBhIHZhbHVlIHRvIGEgc3RyaW5nLlxuKlxuKiBAcHJpdmF0ZVxuKiBAcGFyYW0geyp9IHZhbHVlIC0gdmFsdWUgdG8gdGVzdFxuKiBAcmV0dXJucyB7Ym9vbGVhbn0gYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGEgdmFsdWUgY2FuIGJlIHNlcmlhbGl6ZWRcbiovXG5mdW5jdGlvbiB0ZXN0KCB2YWx1ZSApIHtcblx0dHJ5IHtcblx0XHR0b1N0cmluZy5jYWxsKCB2YWx1ZSApO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoICggZXJyICkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHRlc3Q7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgaGFzVG9TdHJpbmdUYWcgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaGFzLXRvc3RyaW5ndGFnLXN1cHBvcnQnICk7XG52YXIgbmF0aXZlQ2xhc3MgPSByZXF1aXJlKCAnQHN0ZGxpYi91dGlscy1uYXRpdmUtY2xhc3MnICk7XG52YXIgdGVzdCA9IHJlcXVpcmUoICcuL3RyeTJzZXJpYWxpemUuanMnICk7XG5cblxuLy8gVkFSSUFCTEVTIC8vXG5cbnZhciBGTEcgPSBoYXNUb1N0cmluZ1RhZygpO1xuXG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIFRlc3RzIGlmIGEgdmFsdWUgaXMgYSBib29sZWFuIG9iamVjdC5cbipcbiogQHBhcmFtIHsqfSB2YWx1ZSAtIHZhbHVlIHRvIHRlc3RcbiogQHJldHVybnMge2Jvb2xlYW59IGJvb2xlYW4gaW5kaWNhdGluZyBpZiBhIHZhbHVlIGlzIGEgYm9vbGVhbiBvYmplY3RcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBpc0Jvb2xlYW4oIHRydWUgKTtcbiogLy8gcmV0dXJucyBmYWxzZVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgYm9vbCA9IGlzQm9vbGVhbiggbmV3IEJvb2xlYW4oIGZhbHNlICkgKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qL1xuZnVuY3Rpb24gaXNCb29sZWFuKCB2YWx1ZSApIHtcblx0aWYgKCB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICkge1xuXHRcdGlmICggdmFsdWUgaW5zdGFuY2VvZiBCb29sZWFuICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdGlmICggRkxHICkge1xuXHRcdFx0cmV0dXJuIHRlc3QoIHZhbHVlICk7XG5cdFx0fVxuXHRcdHJldHVybiAoIG5hdGl2ZUNsYXNzKCB2YWx1ZSApID09PSAnW29iamVjdCBCb29sZWFuXScgKTtcblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQm9vbGVhbjtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBpc1ByaW1pdGl2ZSA9IHJlcXVpcmUoICcuL3ByaW1pdGl2ZS5qcycgKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoICcuL29iamVjdC5qcycgKTtcblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBUZXN0cyBpZiBhIHZhbHVlIGlzIGEgYm9vbGVhbi5cbipcbiogQHBhcmFtIHsqfSB2YWx1ZSAtIHZhbHVlIHRvIHRlc3RcbiogQHJldHVybnMge2Jvb2xlYW59IGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHZhbHVlIGlzIGEgYm9vbGVhblxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgYm9vbCA9IGlzQm9vbGVhbiggZmFsc2UgKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaXNCb29sZWFuKCB0cnVlICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgYm9vbCA9IGlzQm9vbGVhbiggbmV3IEJvb2xlYW4oIGZhbHNlICkgKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaXNCb29sZWFuKCBuZXcgQm9vbGVhbiggdHJ1ZSApICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKi9cbmZ1bmN0aW9uIGlzQm9vbGVhbiggdmFsdWUgKSB7XG5cdHJldHVybiAoIGlzUHJpbWl0aXZlKCB2YWx1ZSApIHx8IGlzT2JqZWN0KCB2YWx1ZSApICk7XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQm9vbGVhbjtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogVGVzdCBpZiBhIHZhbHVlIGlzIGEgYm9vbGVhbi5cbipcbiogQG1vZHVsZSBAc3RkbGliL2Fzc2VydC1pcy1ib29sZWFuXG4qXG4qIEBleGFtcGxlXG4qIHZhciBpc0Jvb2xlYW4gPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaXMtYm9vbGVhbicgKTtcbipcbiogdmFyIGJvb2wgPSBpc0Jvb2xlYW4oIGZhbHNlICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKlxuKiBib29sID0gaXNCb29sZWFuKCBuZXcgQm9vbGVhbiggZmFsc2UgKSApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogQGV4YW1wbGVcbiogLy8gVXNlIGludGVyZmFjZSB0byBjaGVjayBmb3IgYm9vbGVhbiBwcmltaXRpdmVzLi4uXG4qIHZhciBpc0Jvb2xlYW4gPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaXMtYm9vbGVhbicgKS5pc1ByaW1pdGl2ZTtcbipcbiogdmFyIGJvb2wgPSBpc0Jvb2xlYW4oIGZhbHNlICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKlxuKiBib29sID0gaXNCb29sZWFuKCBuZXcgQm9vbGVhbiggdHJ1ZSApICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbipcbiogQGV4YW1wbGVcbiogLy8gVXNlIGludGVyZmFjZSB0byBjaGVjayBmb3IgYm9vbGVhbiBvYmplY3RzLi4uXG4qIHZhciBpc0Jvb2xlYW4gPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaXMtYm9vbGVhbicgKS5pc09iamVjdDtcbipcbiogdmFyIGJvb2wgPSBpc0Jvb2xlYW4oIHRydWUgKTtcbiogLy8gcmV0dXJucyBmYWxzZVxuKlxuKiBib29sID0gaXNCb29sZWFuKCBuZXcgQm9vbGVhbiggZmFsc2UgKSApO1xuKiAvLyByZXR1cm5zIHRydWVcbiovXG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIHNldFJlYWRPbmx5ID0gcmVxdWlyZSggJ0BzdGRsaWIvdXRpbHMtZGVmaW5lLW5vbmVudW1lcmFibGUtcmVhZC1vbmx5LXByb3BlcnR5JyApO1xudmFyIGlzQm9vbGVhbiA9IHJlcXVpcmUoICcuL21haW4uanMnICk7XG52YXIgaXNQcmltaXRpdmUgPSByZXF1aXJlKCAnLi9wcmltaXRpdmUuanMnICk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCAnLi9vYmplY3QuanMnICk7XG5cblxuLy8gTUFJTiAvL1xuXG5zZXRSZWFkT25seSggaXNCb29sZWFuLCAnaXNQcmltaXRpdmUnLCBpc1ByaW1pdGl2ZSApO1xuc2V0UmVhZE9ubHkoIGlzQm9vbGVhbiwgJ2lzT2JqZWN0JywgaXNPYmplY3QgKTtcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNCb29sZWFuO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGlzQm9vbGVhbiA9IHJlcXVpcmUoICdAc3RkbGliL2Fzc2VydC1pcy1ib29sZWFuJyApLmlzUHJpbWl0aXZlO1xudmFyIGlzU3RyaW5nID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLXN0cmluZycgKS5pc1ByaW1pdGl2ZTtcbnZhciBoYXNPd25Qcm9wID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWhhcy1vd24tcHJvcGVydHknICk7XG52YXIgQUJCUlMgPSByZXF1aXJlKCAnLi9hYmJyZXZpYXRpb25zLmpzb24nICk7XG52YXIgRU1PSklTID0gcmVxdWlyZSggJy4vZW1vamlzLmpzb24nICk7XG52YXIgQ09OVFJBQ1QgPSByZXF1aXJlKCAnLi9jb250cmFjdGlvbnMuanNvbicgKTtcblxuXG4vLyBWQVJJQUJMRVMgLy9cblxudmFyIFJFR0VYUF9QUkVGSVhFUyA9IC9eKFssKFt7KjxcIlx1MjAxQydgXHUyMDE4Ll0pL2dpO1xudmFyIFJFR0VYUF9TVUZGSVhFUyA9IC8oWywuIT8lKj46O1wiJ1x1MjAxRGApXFxdfV0pJC9naTtcblxuXG4vLyBGVU5DVElPTlMgLy9cblxuLyoqXG4qIEV4dGVuZHMgYW4gYXJyYXkgYnkgdGhlIGVsZW1lbnRzIG9mIGFub3RoZXIgYXJyYXkuXG4qXG4qIEBwcml2YXRlXG4qIEBwYXJhbSB7QXJyYXl9IGFyciAtIGlucHV0IGFycmF5XG4qIEBwYXJhbSB7QXJyYXl9IGV4dCAtIGFycmF5IHRvIGV4dGVuZCBgYXJyYCB3aXRoXG4qIEByZXR1cm5zIHtBcnJheX0gbXV0YXRlZCBpbnB1dCBhcnJheVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgYXJyID0gWyAxLCAyLCAzIF07XG4qIHZhciBvdXQgPSBleHRlbmQoIGFyciwgWyA0LCA1IF0gKTtcbiogLy8gcmV0dXJucyBbIDEsIDIsIDMsIDQsIDUgXVxuKi9cbmZ1bmN0aW9uIGV4dGVuZCggYXJyLCBleHQgKSB7XG5cdHZhciBpO1xuXHRmb3IgKCBpID0gMDsgaSA8IGV4dC5sZW5ndGg7IGkrKyApIHtcblx0XHRhcnIucHVzaCggZXh0WyBpIF0gKTtcblx0fVxuXHRyZXR1cm4gYXJyO1xufVxuXG4vKipcbiogVG9rZW5pemVzIGEgc3Vic3RyaW5nLlxuKlxuKiBAcHJpdmF0ZVxuKiBAcGFyYW0ge3N0cmluZ30gc3Vic3RyIC0gaW5wdXQgc3RyaW5nXG4qIEByZXR1cm5zIHtBcnJheX0gdG9rZW4gYXJyYXlcbipcbiogQGV4YW1wbGVcbiogdmFyIHN0ciA9ICcobmV2ZXIpJztcbiogdmFyIG91dCA9IHRva2VuaXplU3Vic3RyaW5nKCBzdHIgKTtcbiogLy8gcmV0dXJucyBbICcoJywgJ25ldmVyJywgJyknIF1cbiovXG5mdW5jdGlvbiB0b2tlbml6ZVN1YnN0cmluZyggc3Vic3RyICkge1xuXHR2YXIgcHJlZml4ZXMgPSBbXTtcblx0dmFyIHN1ZmZpeGVzID0gW107XG5cdHZhciBtYXRjaDtcblx0dmFyIGRvbmU7XG5cdHZhciByZXM7XG5cblx0ZG8ge1xuXHRcdGlmIChcblx0XHRcdCFFTU9KSVNbIHN1YnN0ciBdICYmXG5cdFx0XHQhQUJCUlNbIHN1YnN0ciBdICYmXG5cdFx0XHQhQ09OVFJBQ1RbIHN1YnN0ciBdXG5cdFx0KSB7XG5cdFx0XHRtYXRjaCA9IHN1YnN0ci5zcGxpdCggUkVHRVhQX1BSRUZJWEVTICk7XG5cdFx0XHRpZiAoIG1hdGNoLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdHByZWZpeGVzLnB1c2goIG1hdGNoWyAxIF0gKTtcblx0XHRcdFx0c3Vic3RyID0gbWF0Y2hbIDIgXTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRtYXRjaCA9IHN1YnN0ci5zcGxpdCggUkVHRVhQX1NVRkZJWEVTICk7XG5cdFx0XHRcdGlmICggbWF0Y2gubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0XHRzdWJzdHIgPSBtYXRjaFsgMCBdO1xuXHRcdFx0XHRcdHN1ZmZpeGVzLnB1c2goIG1hdGNoWyAxIF0gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkb25lID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGRvbmUgPSB0cnVlO1xuXHRcdH1cblx0fSB3aGlsZSAoICFkb25lICk7XG5cblx0cmVzID0gcHJlZml4ZXM7XG5cdHJlcy5wdXNoKCBzdWJzdHIgKTtcblx0ZXh0ZW5kKCByZXMsIHN1ZmZpeGVzICk7XG5cdHJldHVybiByZXM7XG59XG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogVG9rZW5pemUgYSBzdHJpbmcuXG4qXG4qIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBpbnB1dCBzdHJpbmdcbiogQHBhcmFtIHtib29sZWFufSBba2VlcFdoaXRlc3BhY2U9ZmFsc2VdIC0gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHNob3VsZCBiZSByZXR1cm5lZCBhcyBwYXJ0IG9mIHRoZSB0b2tlbiBhcnJheVxuKiBAdGhyb3dzIHtUeXBlRXJyb3J9IGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcgcHJpbWl0aXZlXG4qIEB0aHJvd3Mge1R5cGVFcnJvcn0gc2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgYSBib29sZWFuIHByaW1pdGl2ZVxuKiBAcmV0dXJucyB7QXJyYXl9IGFycmF5IG9mIHRva2Vuc1xuKlxuKiBAZXhhbXBsZVxuKiB2YXIgc3RyID0gJ0hlbGxvIFdvcmxkISc7XG4qIHZhciBvdXQgPSB0b2tlbml6ZSggc3RyICk7XG4qIC8vIHJldHVybnMgWyAnSGVsbG8nLCAnV29ybGQnLCAnIScgXVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgc3RyID0gJyc7XG4qIHZhciBvdXQgPSB0b2tlbml6ZSggc3RyICk7XG4qIC8vIHJldHVybnMgW11cbipcbiogQGV4YW1wbGVcbiogdmFyIHN0ciA9ICdIZWxsbyBNcnMuIE1hcGxlLCBjb3VsZCB5b3UgY2FsbCBtZSBiYWNrPyc7XG4qIHZhciBvdXQgPSB0b2tlbml6ZSggc3RyICk7XG4qIC8vIHJldHVybnMgWyAnSGVsbG8nLCAnTXJzLicsICdNYXBsZScsICcsJywgJ2NvdWxkJywgJ3lvdScsICdjYWxsJywgJ21lJywgJ2JhY2snLCAnPycgXVxuKi9cbmZ1bmN0aW9uIHRva2VuaXplKCBzdHIsIGtlZXBXaGl0ZXNwYWNlICkge1xuXHR2YXIgc3VidGtucztcblx0dmFyIHN1YnN0cnM7XG5cdHZhciB0b2tlbnM7XG5cdHZhciBzdWJzdHI7XG5cdHZhciBjYWNoZTtcblx0dmFyIGk7XG5cdGlmICggIWlzU3RyaW5nKCBzdHIgKSApIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnaW52YWxpZCBhcmd1bWVudC4gRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZyBwcmltaXRpdmUuIFZhbHVlOiBgJyArIHN0ciArICdgLicgKTtcblx0fVxuXHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAxICkge1xuXHRcdGlmICggIWlzQm9vbGVhbigga2VlcFdoaXRlc3BhY2UgKSApIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdpbnZhbGlkIGFyZ3VtZW50LiBTZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBhIGJvb2xlYW4gcHJpbWl0aXZlLiBWYWx1ZTogYCcgKyBrZWVwV2hpdGVzcGFjZSArICdgLicgKTtcblx0XHR9XG5cdH1cblx0aWYgKCAhc3RyICkge1xuXHRcdHJldHVybiBbXTtcblx0fVxuXG5cdC8vIFNwbGl0IG9uIHdoaXRlc3BhY2U6XG5cdGlmICgga2VlcFdoaXRlc3BhY2UgKSB7XG5cdFx0c3Vic3RycyA9IHN0ci5zcGxpdCggLyhcXHMrKS8gKTtcblx0fSBlbHNlIHtcblx0XHRzdWJzdHJzID0gc3RyLnNwbGl0KCAvXFxzKy8gKTtcblx0fVxuXG5cdC8vIFNldCB1cCBjYWNoZSB0byBob2xkIHRva2VucyBmb3Igc3Vic3RyaW5nIG1hdGNoZXM6XG5cdGNhY2hlID0ge307XG5cblx0Ly8gSW5pdGlhbGl6ZSB0b2tlbiBhcnJheTpcblx0dG9rZW5zID0gW107XG5cblx0Zm9yICggaSA9IDA7IGkgPCBzdWJzdHJzLmxlbmd0aDsgaSsrICkge1xuXHRcdHN1YnN0ciA9IHN1YnN0cnNbIGkgXTtcblx0XHRpZiAoIGhhc093blByb3AoIGNhY2hlLCBzdWJzdHIgKSApIHtcblx0XHRcdGV4dGVuZCggdG9rZW5zLCBjYWNoZVsgc3Vic3RyIF0gKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRzdWJ0a25zID0gdG9rZW5pemVTdWJzdHJpbmcoIHN1YnN0ciApO1xuXHRcdFx0ZXh0ZW5kKCB0b2tlbnMsIHN1YnRrbnMgKTtcblx0XHRcdGNhY2hlWyBzdWJzdHIgXSA9IHN1YnRrbnM7XG5cdFx0fVxuXHR9XG5cdHJldHVybiB0b2tlbnM7XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHRva2VuaXplO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBUb2tlbml6ZSBhIHN0cmluZy5cbipcbiogQG1vZHVsZSBAc3RkbGliL25scC10b2tlbml6ZVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgdG9rZW5pemUgPSByZXF1aXJlKCAnQHN0ZGxpYi9ubHAtdG9rZW5pemUnICk7XG4qXG4qIHZhciBzdHIgPSAnSGVsbG8gTXJzLiBNYXBsZSwgY291bGQgeW91IGNhbGwgbWUgYmFjaz8nO1xuKiB2YXIgb3V0ID0gdG9rZW5pemUoIHN0ciApO1xuKiAvLyByZXR1cm5zIFsgJ0hlbGxvJywgJ01ycy4nLCAnTWFwbGUnLCAnLCcsICdjb3VsZCcsICd5b3UnLCAnY2FsbCcsICdtZScsICdiYWNrJywgJz8nIF1cbipcbiogc3RyID0gJ0hlbGxvIFdvcmxkISc7XG4qIG91dCA9IHRva2VuaXplKCBzdHIgKTtcbiogLy8gcmV0dXJucyBbICdIZWxsbycsICdXb3JsZCcsICchJyBdXG4qL1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciB0b2tlbml6ZSA9IHJlcXVpcmUoICcuL3Rva2VuaXplLmpzJyApO1xuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSB0b2tlbml6ZTtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBuYXRpdmVDbGFzcyA9IHJlcXVpcmUoICdAc3RkbGliL3V0aWxzLW5hdGl2ZS1jbGFzcycgKTtcblxuXG4vLyBWQVJJQUJMRVMgLy9cblxudmFyIGhhc0ludDMyQXJyYXkgPSAoIHR5cGVvZiBJbnQzMkFycmF5ID09PSAnZnVuY3Rpb24nICk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgc3RkbGliL3JlcXVpcmUtZ2xvYmFsc1xuXG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIFRlc3RzIGlmIGEgdmFsdWUgaXMgYW4gSW50MzJBcnJheS5cbipcbiogQHBhcmFtIHsqfSB2YWx1ZSAtIHZhbHVlIHRvIHRlc3RcbiogQHJldHVybnMge2Jvb2xlYW59IGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHZhbHVlIGlzIGFuIEludDMyQXJyYXlcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBpc0ludDMyQXJyYXkoIG5ldyBJbnQzMkFycmF5KCAxMCApICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgYm9vbCA9IGlzSW50MzJBcnJheSggW10gKTtcbiogLy8gcmV0dXJucyBmYWxzZVxuKi9cbmZ1bmN0aW9uIGlzSW50MzJBcnJheSggdmFsdWUgKSB7XG5cdHJldHVybiAoXG5cdFx0KCBoYXNJbnQzMkFycmF5ICYmIHZhbHVlIGluc3RhbmNlb2YgSW50MzJBcnJheSApIHx8IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgc3RkbGliL3JlcXVpcmUtZ2xvYmFsc1xuXHRcdG5hdGl2ZUNsYXNzKCB2YWx1ZSApID09PSAnW29iamVjdCBJbnQzMkFycmF5XSdcblx0KTtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNJbnQzMkFycmF5O1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBUZXN0IGlmIGEgdmFsdWUgaXMgYW4gSW50MzJBcnJheS5cbipcbiogQG1vZHVsZSBAc3RkbGliL2Fzc2VydC1pcy1pbnQzMmFycmF5XG4qXG4qIEBleGFtcGxlXG4qIHZhciBpc0ludDMyQXJyYXkgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaXMtaW50MzJhcnJheScgKTtcbipcbiogdmFyIGJvb2wgPSBpc0ludDMyQXJyYXkoIG5ldyBJbnQzMkFycmF5KCAxMCApICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKlxuKiBib29sID0gaXNJbnQzMkFycmF5KCBbXSApO1xuKiAvLyByZXR1cm5zIGZhbHNlXG4qL1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBpc0ludDMyQXJyYXkgPSByZXF1aXJlKCAnLi9tYWluLmpzJyApO1xuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBpc0ludDMyQXJyYXk7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIE1heGltdW0gc2lnbmVkIDMyLWJpdCBpbnRlZ2VyLlxuKlxuKiBAbW9kdWxlIEBzdGRsaWIvY29uc3RhbnRzLWludDMyLW1heFxuKiBAdHlwZSB7aW50ZWdlcjMyfVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgSU5UMzJfTUFYID0gcmVxdWlyZSggJ0BzdGRsaWIvY29uc3RhbnRzLWludDMyLW1heCcgKTtcbiogLy8gcmV0dXJucyAyMTQ3NDgzNjQ3XG4qL1xuXG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIE1heGltdW0gc2lnbmVkIDMyLWJpdCBpbnRlZ2VyLlxuKlxuKiAjIyBOb3Rlc1xuKlxuKiBUaGUgbnVtYmVyIGhhcyB0aGUgdmFsdWVcbipcbiogYGBgdGV4XG4qIDJeezMxfSAtIDFcbiogYGBgXG4qXG4qIHdoaWNoIGNvcnJlc3BvbmRzIHRvIHRoZSBiaXQgc2VxdWVuY2VcbipcbiogYGBgYmluYXJ5c3RyaW5nXG4qIDAxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExXG4qIGBgYFxuKlxuKiBAY29uc3RhbnRcbiogQHR5cGUge2ludGVnZXIzMn1cbiogQGRlZmF1bHQgMjE0NzQ4MzY0N1xuKi9cbnZhciBJTlQzMl9NQVggPSAyMTQ3NDgzNjQ3fDA7IC8vIGFzbSB0eXBlIGFubm90YXRpb25cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gSU5UMzJfTUFYO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBNaW5pbXVtIHNpZ25lZCAzMi1iaXQgaW50ZWdlci5cbipcbiogQG1vZHVsZSBAc3RkbGliL2NvbnN0YW50cy1pbnQzMi1taW5cbiogQHR5cGUge2ludGVnZXIzMn1cbipcbiogQGV4YW1wbGVcbiogdmFyIElOVDMyX01JTiA9IHJlcXVpcmUoICdAc3RkbGliL2NvbnN0YW50cy1pbnQzMi1taW4nICk7XG4qIC8vIHJldHVybnMgLTIxNDc0ODM2NDhcbiovXG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogTWluaW11bSBzaWduZWQgMzItYml0IGludGVnZXIuXG4qXG4qICMjIE5vdGVzXG4qXG4qIFRoZSBudW1iZXIgaGFzIHRoZSB2YWx1ZVxuKlxuKiBgYGB0ZXhcbiogLSgyXnszMX0pXG4qIGBgYFxuKlxuKiB3aGljaCBjb3JyZXNwb25kcyB0byB0aGUgdHdvJ3MgY29tcGxlbWVudCBiaXQgc2VxdWVuY2VcbipcbiogYGBgYmluYXJ5c3RyaW5nXG4qIDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXG4qIGBgYFxuKlxuKiBAY29uc3RhbnRcbiogQHR5cGUge2ludGVnZXIzMn1cbiogQGRlZmF1bHQgLTIxNDc0ODM2NDhcbiovXG52YXIgSU5UMzJfTUlOID0gLTIxNDc0ODM2NDh8MDsgLy8gYXNtIHR5cGUgYW5ub3RhdGlvblxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBJTlQzMl9NSU47XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTUFJTiAvL1xuXG52YXIgbWFpbiA9ICggdHlwZW9mIEludDMyQXJyYXkgPT09ICdmdW5jdGlvbicgKSA/IEludDMyQXJyYXkgOiBudWxsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHN0ZGxpYi9yZXF1aXJlLWdsb2JhbHNcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gbWFpbjtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBpc0ludDMyQXJyYXkgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaXMtaW50MzJhcnJheScgKTtcbnZhciBJTlQzMl9NQVggPSByZXF1aXJlKCAnQHN0ZGxpYi9jb25zdGFudHMtaW50MzItbWF4JyApO1xudmFyIElOVDMyX01JTiA9IHJlcXVpcmUoICdAc3RkbGliL2NvbnN0YW50cy1pbnQzMi1taW4nICk7XG52YXIgR2xvYmFsSW50MzJBcnJheSA9IHJlcXVpcmUoICcuL2ludDMyYXJyYXkuanMnICk7XG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogVGVzdHMgZm9yIG5hdGl2ZSBgSW50MzJBcnJheWAgc3VwcG9ydC5cbipcbiogQHJldHVybnMge2Jvb2xlYW59IGJvb2xlYW4gaW5kaWNhdGluZyBpZiBhbiBlbnZpcm9ubWVudCBoYXMgYEludDMyQXJyYXlgIHN1cHBvcnRcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBoYXNJbnQzMkFycmF5U3VwcG9ydCgpO1xuKiAvLyByZXR1cm5zIDxib29sZWFuPlxuKi9cbmZ1bmN0aW9uIGhhc0ludDMyQXJyYXlTdXBwb3J0KCkge1xuXHR2YXIgYm9vbDtcblx0dmFyIGFycjtcblxuXHRpZiAoIHR5cGVvZiBHbG9iYWxJbnQzMkFycmF5ICE9PSAnZnVuY3Rpb24nICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHQvLyBUZXN0IGJhc2ljIHN1cHBvcnQuLi5cblx0dHJ5IHtcblx0XHRhcnIgPSBuZXcgR2xvYmFsSW50MzJBcnJheSggWyAxLCAzLjE0LCAtMy4xNCwgSU5UMzJfTUFYKzEgXSApO1xuXHRcdGJvb2wgPSAoXG5cdFx0XHRpc0ludDMyQXJyYXkoIGFyciApICYmXG5cdFx0XHRhcnJbIDAgXSA9PT0gMSAmJlxuXHRcdFx0YXJyWyAxIF0gPT09IDMgJiYgICAgICAvLyB0cnVuY2F0aW9uXG5cdFx0XHRhcnJbIDIgXSA9PT0gLTMgJiYgICAgIC8vIHRydW5jYXRpb25cblx0XHRcdGFyclsgMyBdID09PSBJTlQzMl9NSU4gLy8gd3JhcCBhcm91bmRcblx0XHQpO1xuXHR9IGNhdGNoICggZXJyICkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cdFx0Ym9vbCA9IGZhbHNlO1xuXHR9XG5cdHJldHVybiBib29sO1xufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNJbnQzMkFycmF5U3VwcG9ydDtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogVGVzdCBmb3IgbmF0aXZlIGBJbnQzMkFycmF5YCBzdXBwb3J0LlxuKlxuKiBAbW9kdWxlIEBzdGRsaWIvYXNzZXJ0LWhhcy1pbnQzMmFycmF5LXN1cHBvcnRcbipcbiogQGV4YW1wbGVcbiogdmFyIGhhc0ludDMyQXJyYXlTdXBwb3J0ID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWhhcy1pbnQzMmFycmF5LXN1cHBvcnQnICk7XG4qXG4qIHZhciBib29sID0gaGFzSW50MzJBcnJheVN1cHBvcnQoKTtcbiogLy8gcmV0dXJucyA8Ym9vbGVhbj5cbiovXG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGhhc0ludDMyQXJyYXlTdXBwb3J0ID0gcmVxdWlyZSggJy4vbWFpbi5qcycgKTtcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaGFzSW50MzJBcnJheVN1cHBvcnQ7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTUFJTiAvL1xuXG52YXIgY3RvciA9ICggdHlwZW9mIEludDMyQXJyYXkgPT09ICdmdW5jdGlvbicgKSA/IEludDMyQXJyYXkgOiB2b2lkIDA7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgc3RkbGliL3JlcXVpcmUtZ2xvYmFsc1xuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBjdG9yO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIFRPRE86IHdyaXRlIHBvbHlmaWxsXG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIFR5cGVkIGFycmF5IHdoaWNoIHJlcHJlc2VudHMgYW4gYXJyYXkgb2YgdHdvcy1jb21wbGVtZW50IDMyLWJpdCBzaWduZWQgaW50ZWdlcnMgaW4gdGhlIHBsYXRmb3JtIGJ5dGUgb3JkZXIuXG4qXG4qIEB0aHJvd3Mge0Vycm9yfSBub3QgaW1wbGVtZW50ZWRcbiovXG5mdW5jdGlvbiBwb2x5ZmlsbCgpIHtcblx0dGhyb3cgbmV3IEVycm9yKCAnbm90IGltcGxlbWVudGVkJyApO1xufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBwb2x5ZmlsbDtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogVHlwZWQgYXJyYXkgY29uc3RydWN0b3Igd2hpY2ggcmV0dXJucyBhIHR5cGVkIGFycmF5IHJlcHJlc2VudGluZyBhbiBhcnJheSBvZiB0d29zLWNvbXBsZW1lbnQgMzItYml0IHNpZ25lZCBpbnRlZ2VycyBpbiB0aGUgcGxhdGZvcm0gYnl0ZSBvcmRlci5cbipcbiogQG1vZHVsZSBAc3RkbGliL2FycmF5LWludDMyXG4qXG4qIEBleGFtcGxlXG4qIHZhciBjdG9yID0gcmVxdWlyZSggJ0BzdGRsaWIvYXJyYXktaW50MzInICk7XG4qXG4qIHZhciBhcnIgPSBuZXcgY3RvciggMTAgKTtcbiogLy8gcmV0dXJucyA8SW50MzJBcnJheT5cbiovXG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGhhc0ludDMyQXJyYXlTdXBwb3J0ID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWhhcy1pbnQzMmFycmF5LXN1cHBvcnQnICk7XG52YXIgYnVpbHRpbiA9IHJlcXVpcmUoICcuL2ludDMyYXJyYXkuanMnICk7XG52YXIgcG9seWZpbGwgPSByZXF1aXJlKCAnLi9wb2x5ZmlsbC5qcycgKTtcblxuXG4vLyBNQUlOIC8vXG5cbnZhciBjdG9yO1xuaWYgKCBoYXNJbnQzMkFycmF5U3VwcG9ydCgpICkge1xuXHRjdG9yID0gYnVpbHRpbjtcbn0gZWxzZSB7XG5cdGN0b3IgPSBwb2x5ZmlsbDtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gY3RvcjtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBJbnQzMkFycmF5ID0gcmVxdWlyZSggJ0BzdGRsaWIvYXJyYXktaW50MzInICk7XG52YXIgRmxvYXQ2NEFycmF5ID0gcmVxdWlyZSggJ0BzdGRsaWIvYXJyYXktZmxvYXQ2NCcgKTtcbnZhciBzZXRSZWFkT25seSA9IHJlcXVpcmUoICdAc3RkbGliL3V0aWxzLWRlZmluZS1ub25lbnVtZXJhYmxlLXJlYWQtb25seS1wcm9wZXJ0eScgKTtcblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBSZXR1cm5zIGEgTWF0cml4IGluc3RhbmNlLlxuKlxuKiBAcHJpdmF0ZVxuKiBAY29uc3RydWN0b3JcbiogQHBhcmFtIHtOdW1iZXJBcnJheX0gc2hhcGUgLSBtYXRyaXggZGltZW5zaW9ucy9zaGFwZVxuKiBAcGFyYW0ge3N0cmluZ30gW2R0eXBlPVwiZmxvYXQ2NFwiXSAtIG1hdHJpeCBkYXRhIHR5cGVcbiogQHJldHVybnMge01hdHJpeH0gTWF0cml4IGluc3RhbmNlXG4qL1xuZnVuY3Rpb24gbWF0cml4KCkge1xuXHR2YXIgZHR5cGU7XG5cdHZhciBuZGltcztcblx0dmFyIHNoYXBlO1xuXHR2YXIgZGF0YTtcblx0dmFyIGxlbjtcblx0dmFyIG1hdDtcblx0dmFyIGk7XG5cblx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID09PSAxICkge1xuXHRcdHNoYXBlID0gYXJndW1lbnRzWyAwIF07XG5cdH1cblx0ZWxzZSBpZiAoIGFyZ3VtZW50cy5sZW5ndGggPT09IDIgKSB7XG5cdFx0c2hhcGUgPSBhcmd1bWVudHNbIDAgXTtcblx0XHRkdHlwZSA9IGFyZ3VtZW50c1sgMSBdO1xuXHR9XG5cdG5kaW1zID0gc2hhcGUubGVuZ3RoO1xuXHRsZW4gPSAxO1xuXHRmb3IgKCBpID0gMDsgaSA8IG5kaW1zOyBpKysgKSB7XG5cdFx0bGVuICo9IHNoYXBlWyBpIF07XG5cdH1cblx0Ly8gSW5pdGlhbGl6ZSBhIHplcm8tZmlsbGVkIHR5cGVkIGFycmF5Li4uXG5cdGlmICggZHR5cGUgPT09ICdpbnQzMicgKSB7XG5cdFx0ZGF0YSA9IG5ldyBJbnQzMkFycmF5KCBsZW4gKTtcblx0fVxuXHRlbHNlIHtcblx0XHRkYXRhID0gbmV3IEZsb2F0NjRBcnJheSggbGVuICk7XG5cdH1cblxuXHQvLyBSZXR1cm4gYSBuZXcgTWF0cml4IGluc3RhbmNlOlxuXHRtYXQgPSB7fTtcblx0bWF0LmR0eXBlID0gZHR5cGU7XG5cdG1hdC5zaGFwZSA9IHNoYXBlO1xuXHRtYXQuc3RyaWRlcyA9IFsgc2hhcGVbMV0sIDEgXTtcblx0bWF0Lm9mZnNldCA9IDA7XG5cdG1hdC5uZGltcyA9IHNoYXBlLmxlbmd0aDtcblx0bWF0Lmxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuXHRtYXQubmJ5dGVzID0gZGF0YS5ieXRlTGVuZ3RoO1xuXHRtYXQuZGF0YSA9IGRhdGE7XG5cblx0c2V0UmVhZE9ubHkoIG1hdCwgJ2dldCcsIGdldCApO1xuXHRzZXRSZWFkT25seSggbWF0LCAnc2V0Jywgc2V0ICk7XG5cdHJldHVybiBtYXQ7XG5cblx0LyoqXG5cdCogUmV0dXJucyBhIG1hdHJpeCBlbGVtZW50IGJhc2VkIG9uIHRoZSBwcm92aWRlZCByb3cgYW5kIGNvbHVtbiBpbmRpY2VzLlxuXHQqXG5cdCogQHByaXZhdGVcblx0KiBAcGFyYW0ge2ludGVnZXJ9IGkgLSByb3cgaW5kZXhcblx0KiBAcGFyYW0ge2ludGVnZXJ9IGogLSBjb2x1bW4gaW5kZXhcblx0KiBAcmV0dXJucyB7KG51bWJlcnx1bmRlZmluZWQpfSBtYXRyaXggZWxlbWVudFxuXHQqL1xuXHRmdW5jdGlvbiBnZXQoIGksIGogKSB7XG5cdFx0LyogZXNsaW50LWRpc2FibGUgbm8taW52YWxpZC10aGlzICovXG5cdFx0dmFyIGlkeCA9IHRoaXMub2Zmc2V0ICsgKCBpKnRoaXMuc3RyaWRlc1swXSApICsgKCBqKnRoaXMuc3RyaWRlc1sxXSApO1xuXHRcdHJldHVybiB0aGlzLmRhdGFbIGlkeCBdO1xuXHR9XG5cblx0LyoqXG5cdCogU2V0cyBhIG1hdHJpeCBlbGVtZW50IGJhc2VkIG9uIHRoZSBwcm92aWRlZCByb3cgYW5kIGNvbHVtbiBpbmRpY2VzLlxuXHQqXG5cdCogQHByaXZhdGVcblx0KiBAcGFyYW0ge2ludGVnZXJ9IGkgLSByb3cgaW5kZXhcblx0KiBAcGFyYW0ge2ludGVnZXJ9IGogLSBjb2x1bW4gaW5kZXhcblx0KiBAcGFyYW0ge251bWJlcn0gdiAtIHZhbHVlIHRvIHNldFxuXHQqIEByZXR1cm5zIHtNYXRyaXh9IE1hdHJpeCBpbnN0YW5jZVxuXHQqL1xuXHRmdW5jdGlvbiBzZXQoIGksIGosIHYgKSB7XG5cdFx0LyogZXNsaW50LWRpc2FibGUgbm8taW52YWxpZC10aGlzICovXG5cdFx0aSA9IHRoaXMub2Zmc2V0ICsgKCBpKnRoaXMuc3RyaWRlc1swXSApICsgKCBqKnRoaXMuc3RyaWRlc1sxXSApO1xuXHRcdGlmICggaSA+PSAwICkge1xuXHRcdFx0dGhpcy5kYXRhWyBpIF0gPSB2O1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBtYXRyaXg7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgbWF0cml4ID0gcmVxdWlyZSggJy4vbWF0cml4LmpzJyApO1xuXG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIEdldCB0aGV0YSBtYXRyaXguIEl0cyByb3dzIGNvcnJlc3BvbmQgdG8gZG9jdW1lbnQgZGlzdHJpYnV0aW9ucyBvdmVyIHRvcGljcy5cbipcbiogQHByaXZhdGVcbiogQHJldHVybnMge01hdHJpeH0gdGhldGEgcGFyYW1ldGVyIG1hdHJpeFxuKi9cbmZ1bmN0aW9uIGdldFRoZXRhcygpIHtcblx0LyogZXNsaW50LWRpc2FibGUgbm8taW52YWxpZC10aGlzICovXG5cdHZhciBUaGV0YTtcblx0dmFyIHZhbDtcblx0dmFyIGQ7XG5cdHZhciBrO1xuXG5cdFRoZXRhID0gbWF0cml4KCBbIHRoaXMuRCwgdGhpcy5LIF0gKTtcblx0Zm9yICggZCA9IDA7IGQgPCB0aGlzLkQ7IGQrKyApIHtcblx0XHRmb3IgKCBrID0gMDsgayA8IHRoaXMuSzsgaysrICkge1xuXHRcdFx0dmFsID0gKCB0aGlzLm5kLmdldCggZCwgayApICsgdGhpcy5hbHBoYSApIC9cblx0XHRcdFx0KCB0aGlzLm5kU3VtWyBkIF0gKyAoIHRoaXMuSyp0aGlzLmFscGhhICkgKTtcblx0XHRcdFRoZXRhLnNldCggZCwgaywgdmFsICk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBUaGV0YTtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VGhldGFzO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGlzTnVtYmVyID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLW51bWJlcicgKS5pc1ByaW1pdGl2ZTtcblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBUZXN0cyBpZiBhIHZhbHVlIGlzIGEgbnVtYmVyIHByaW1pdGl2ZSBoYXZpbmcgYSBwb3NpdGl2ZSB2YWx1ZS5cbipcbiogQHBhcmFtIHsqfSB2YWx1ZSAtIHZhbHVlIHRvIHRlc3RcbiogQHJldHVybnMge2Jvb2xlYW59IGJvb2xlYW4gaW5kaWNhdGluZyBpZiBhIHZhbHVlIGlzIGEgbnVtYmVyIHByaW1pdGl2ZSBoYXZpbmcgYSBwb3NpdGl2ZSB2YWx1ZVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgYm9vbCA9IGlzUG9zaXRpdmVOdW1iZXIoIDMuMCApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBpc1Bvc2l0aXZlTnVtYmVyKCBuZXcgTnVtYmVyKCAzLjAgKSApO1xuKiAvLyByZXR1cm5zIGZhbHNlXG4qL1xuZnVuY3Rpb24gaXNQb3NpdGl2ZU51bWJlciggdmFsdWUgKSB7XG5cdHJldHVybiAoXG5cdFx0aXNOdW1iZXIoIHZhbHVlICkgJiZcblx0XHR2YWx1ZSA+IDAuMFxuXHQpO1xufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBpc1Bvc2l0aXZlTnVtYmVyO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGlzTnVtYmVyID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLW51bWJlcicgKS5pc09iamVjdDtcblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBUZXN0cyBpZiBhIHZhbHVlIGlzIGEgbnVtYmVyIG9iamVjdCBoYXZpbmcgYSBwb3NpdGl2ZSB2YWx1ZS5cbipcbiogQHBhcmFtIHsqfSB2YWx1ZSAtIHZhbHVlIHRvIHRlc3RcbiogQHJldHVybnMge2Jvb2xlYW59IGJvb2xlYW4gaW5kaWNhdGluZyBpZiBhIHZhbHVlIGlzIGEgbnVtYmVyIG9iamVjdCBoYXZpbmcgYSBwb3NpdGl2ZSB2YWx1ZVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgYm9vbCA9IGlzUG9zaXRpdmVOdW1iZXIoIDMuMCApO1xuKiAvLyByZXR1cm5zIGZhbHNlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaXNQb3NpdGl2ZU51bWJlciggbmV3IE51bWJlciggMy4wICkgKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qL1xuZnVuY3Rpb24gaXNQb3NpdGl2ZU51bWJlciggdmFsdWUgKSB7XG5cdHJldHVybiAoXG5cdFx0aXNOdW1iZXIoIHZhbHVlICkgJiZcblx0XHR2YWx1ZS52YWx1ZU9mKCkgPiAwLjBcblx0KTtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNQb3NpdGl2ZU51bWJlcjtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBpc1ByaW1pdGl2ZSA9IHJlcXVpcmUoICcuL3ByaW1pdGl2ZS5qcycgKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoICcuL29iamVjdC5qcycgKTtcblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBUZXN0cyBpZiBhIHZhbHVlIGlzIGEgcG9zaXRpdmUgbnVtYmVyLlxuKlxuKiBAcGFyYW0geyp9IHZhbHVlIC0gdmFsdWUgdG8gdGVzdFxuKiBAcmV0dXJucyB7Ym9vbGVhbn0gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdmFsdWUgaXMgYSBwb3NpdGl2ZSBudW1iZXJcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBpc1Bvc2l0aXZlTnVtYmVyKCA1LjAgKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaXNQb3NpdGl2ZU51bWJlciggbmV3IE51bWJlciggNS4wICkgKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaXNQb3NpdGl2ZU51bWJlciggMy4xNCApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBpc1Bvc2l0aXZlTnVtYmVyKCAtNS4wICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBpc1Bvc2l0aXZlTnVtYmVyKCBudWxsICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbiovXG5mdW5jdGlvbiBpc1Bvc2l0aXZlTnVtYmVyKCB2YWx1ZSApIHtcblx0cmV0dXJuICggaXNQcmltaXRpdmUoIHZhbHVlICkgfHwgaXNPYmplY3QoIHZhbHVlICkgKTtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNQb3NpdGl2ZU51bWJlcjtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogVGVzdCBpZiBhIHZhbHVlIGlzIGEgcG9zaXRpdmUgbnVtYmVyLlxuKlxuKiBAbW9kdWxlIEBzdGRsaWIvYXNzZXJ0LWlzLXBvc2l0aXZlLW51bWJlclxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgaXNQb3NpdGl2ZU51bWJlciA9IHJlcXVpcmUoICdAc3RkbGliL2Fzc2VydC1pcy1wb3NpdGl2ZS1udW1iZXInICk7XG4qXG4qIHZhciBib29sID0gaXNQb3NpdGl2ZU51bWJlciggNS4wICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKlxuKiBib29sID0gaXNQb3NpdGl2ZU51bWJlciggbmV3IE51bWJlciggNS4wICkgKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qXG4qIGJvb2wgPSBpc1Bvc2l0aXZlTnVtYmVyKCAzLjE0ICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKlxuKiBib29sID0gaXNQb3NpdGl2ZU51bWJlciggLTUuMCApO1xuKiAvLyByZXR1cm5zIGZhbHNlXG4qXG4qIGJvb2wgPSBpc1Bvc2l0aXZlTnVtYmVyKCBudWxsICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbipcbiogQGV4YW1wbGVcbiogdmFyIGlzUG9zaXRpdmVOdW1iZXIgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaXMtcG9zaXRpdmUtbnVtYmVyJyApLmlzUHJpbWl0aXZlO1xuKlxuKiB2YXIgYm9vbCA9IGlzUG9zaXRpdmVOdW1iZXIoIDMuMCApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogYm9vbCA9IGlzUG9zaXRpdmVOdW1iZXIoIG5ldyBOdW1iZXIoIDMuMCApICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbipcbiogQGV4YW1wbGVcbiogdmFyIGlzUG9zaXRpdmVOdW1iZXIgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaXMtcG9zaXRpdmUtbnVtYmVyJyApLmlzT2JqZWN0O1xuKlxuKiB2YXIgYm9vbCA9IGlzUG9zaXRpdmVOdW1iZXIoIDMuMCApO1xuKiAvLyByZXR1cm5zIGZhbHNlXG4qXG4qIGJvb2wgPSBpc1Bvc2l0aXZlTnVtYmVyKCBuZXcgTnVtYmVyKCAzLjAgKSApO1xuKiAvLyByZXR1cm5zIHRydWVcbiovXG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIHNldFJlYWRPbmx5ID0gcmVxdWlyZSggJ0BzdGRsaWIvdXRpbHMtZGVmaW5lLW5vbmVudW1lcmFibGUtcmVhZC1vbmx5LXByb3BlcnR5JyApO1xudmFyIGlzUG9zaXRpdmVOdW1iZXIgPSByZXF1aXJlKCAnLi9tYWluLmpzJyApO1xudmFyIGlzUHJpbWl0aXZlID0gcmVxdWlyZSggJy4vcHJpbWl0aXZlLmpzJyApO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSggJy4vb2JqZWN0LmpzJyApO1xuXG5cbi8vIE1BSU4gLy9cblxuc2V0UmVhZE9ubHkoIGlzUG9zaXRpdmVOdW1iZXIsICdpc1ByaW1pdGl2ZScsIGlzUHJpbWl0aXZlICk7XG5zZXRSZWFkT25seSggaXNQb3NpdGl2ZU51bWJlciwgJ2lzT2JqZWN0JywgaXNPYmplY3QgKTtcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNQb3NpdGl2ZU51bWJlcjtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBpc0FycmF5ID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLWFycmF5JyApO1xuXG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIFRlc3RzIGlmIGEgdmFsdWUgaXMgYW4gb2JqZWN0OyBlLmcuLCBge31gLlxuKlxuKiBAcGFyYW0geyp9IHZhbHVlIC0gdmFsdWUgdG8gdGVzdFxuKiBAcmV0dXJucyB7Ym9vbGVhbn0gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdmFsdWUgaXMgYW4gb2JqZWN0XG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaXNPYmplY3QoIHt9ICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgYm9vbCA9IGlzT2JqZWN0KCBudWxsICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbiovXG5mdW5jdGlvbiBpc09iamVjdCggdmFsdWUgKSB7XG5cdHJldHVybiAoXG5cdFx0dHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuXHRcdHZhbHVlICE9PSBudWxsICYmXG5cdFx0IWlzQXJyYXkoIHZhbHVlIClcblx0KTtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIFRlc3QgaWYgYSB2YWx1ZSBpcyBhbiBvYmplY3QuXG4qXG4qIEBtb2R1bGUgQHN0ZGxpYi9hc3NlcnQtaXMtb2JqZWN0XG4qXG4qIEBleGFtcGxlXG4qIHZhciBpc09iamVjdCA9IHJlcXVpcmUoICdAc3RkbGliL2Fzc2VydC1pcy1vYmplY3QnICk7XG4qXG4qIHZhciBib29sID0gaXNPYmplY3QoIHt9ICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKlxuKiBib29sID0gaXNPYmplY3QoIHRydWUgKTtcbiogLy8gcmV0dXJucyBmYWxzZVxuKi9cblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCAnLi9tYWluLmpzJyApO1xuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdDtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUkUgPSAvLi87XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJFO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIFJldHVybnMgdGhlIGdsb2JhbCBvYmplY3QgdXNpbmcgY29kZSBnZW5lcmF0aW9uLlxuKlxuKiBAcHJpdmF0ZVxuKiBAcmV0dXJucyB7T2JqZWN0fSBnbG9iYWwgb2JqZWN0XG4qL1xuZnVuY3Rpb24gZ2V0R2xvYmFsKCkge1xuXHRyZXR1cm4gbmV3IEZ1bmN0aW9uKCAncmV0dXJuIHRoaXM7JyApKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LWZ1bmNcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0R2xvYmFsO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1BSU4gLy9cblxudmFyIG9iaiA9ICggdHlwZW9mIHNlbGYgPT09ICdvYmplY3QnICkgPyBzZWxmIDogbnVsbDtcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gb2JqO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1BSU4gLy9cblxudmFyIG9iaiA9ICggdHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgKSA/IHdpbmRvdyA6IG51bGw7XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IG9iajtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNQUlOIC8vXG5cbnZhciBvYmogPSAoIHR5cGVvZiBnbG9iYWwgPT09ICdvYmplY3QnICkgPyBnbG9iYWwgOiBudWxsO1xuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBvYmo7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgaXNCb29sZWFuID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLWJvb2xlYW4nICkuaXNQcmltaXRpdmU7XG52YXIgZ2V0VGhpcyA9IHJlcXVpcmUoICcuL2NvZGVnZW4uanMnICk7XG52YXIgU2VsZiA9IHJlcXVpcmUoICcuL3NlbGYuanMnICk7XG52YXIgV2luID0gcmVxdWlyZSggJy4vd2luZG93LmpzJyApO1xudmFyIEdsb2JhbCA9IHJlcXVpcmUoICcuL2dsb2JhbC5qcycgKTtcblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBSZXR1cm5zIHRoZSBnbG9iYWwgb2JqZWN0LlxuKlxuKiAjIyBOb3Rlc1xuKlxuKiAtICAgVXNpbmcgY29kZSBnZW5lcmF0aW9uIGlzIHRoZSAqKm1vc3QqKiByZWxpYWJsZSB3YXkgdG8gcmVzb2x2ZSB0aGUgZ2xvYmFsIG9iamVjdDsgaG93ZXZlciwgZG9pbmcgc28gaXMgbGlrZWx5IHRvIHZpb2xhdGUgY29udGVudCBzZWN1cml0eSBwb2xpY2llcyAoQ1NQcykgaW4sIGUuZy4sIENocm9tZSBBcHBzIGFuZCBlbHNld2hlcmUuXG4qXG4qIEBwYXJhbSB7Ym9vbGVhbn0gW2NvZGVnZW49ZmFsc2VdIC0gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdG8gdXNlIGNvZGUgZ2VuZXJhdGlvbiB0byByZXNvbHZlIHRoZSBnbG9iYWwgb2JqZWN0XG4qIEB0aHJvd3Mge1R5cGVFcnJvcn0gbXVzdCBwcm92aWRlIGEgYm9vbGVhblxuKiBAdGhyb3dzIHtFcnJvcn0gdW5hYmxlIHRvIHJlc29sdmUgZ2xvYmFsIG9iamVjdFxuKiBAcmV0dXJucyB7T2JqZWN0fSBnbG9iYWwgb2JqZWN0XG4qXG4qIEBleGFtcGxlXG4qIHZhciBnID0gZ2V0R2xvYmFsKCk7XG4qIC8vIHJldHVybnMgey4uLn1cbiovXG5mdW5jdGlvbiBnZXRHbG9iYWwoIGNvZGVnZW4gKSB7XG5cdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRpZiAoICFpc0Jvb2xlYW4oIGNvZGVnZW4gKSApIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdpbnZhbGlkIGFyZ3VtZW50LiBNdXN0IHByb3ZpZGUgYSBib29sZWFuIHByaW1pdGl2ZS4gVmFsdWU6IGAnK2NvZGVnZW4rJ2AuJyApO1xuXHRcdH1cblx0XHRpZiAoIGNvZGVnZW4gKSB7XG5cdFx0XHRyZXR1cm4gZ2V0VGhpcygpO1xuXHRcdH1cblx0XHQvLyBGYWxsIHRocm91Z2guLi5cblx0fVxuXHQvLyBDYXNlOiBicm93c2VycyBhbmQgd2ViIHdvcmtlcnNcblx0aWYgKCBTZWxmICkge1xuXHRcdHJldHVybiBTZWxmO1xuXHR9XG5cdC8vIENhc2U6IGJyb3dzZXJzXG5cdGlmICggV2luICkge1xuXHRcdHJldHVybiBXaW47XG5cdH1cblx0Ly8gQ2FzZTogTm9kZS5qc1xuXHRpZiAoIEdsb2JhbCApIHtcblx0XHRyZXR1cm4gR2xvYmFsO1xuXHR9XG5cdC8vIENhc2U6IHVua25vd25cblx0dGhyb3cgbmV3IEVycm9yKCAndW5leHBlY3RlZCBlcnJvci4gVW5hYmxlIHRvIHJlc29sdmUgZ2xvYmFsIG9iamVjdC4nICk7XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEdsb2JhbDtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogUmV0dXJuIHRoZSBnbG9iYWwgb2JqZWN0LlxuKlxuKiBAbW9kdWxlIEBzdGRsaWIvdXRpbHMtZ2xvYmFsXG4qXG4qIEBleGFtcGxlXG4qIHZhciBnZXRHbG9iYWwgPSByZXF1aXJlKCAnQHN0ZGxpYi91dGlscy1nbG9iYWwnICk7XG4qXG4qIHZhciBnID0gZ2V0R2xvYmFsKCk7XG4qIC8vIHJldHVybnMgey4uLn1cbiovXG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGdldEdsb2JhbCA9IHJlcXVpcmUoICcuL21haW4uanMnICk7XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEdsb2JhbDtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBnZXRHbG9iYWwgPSByZXF1aXJlKCAnQHN0ZGxpYi91dGlscy1nbG9iYWwnICk7XG5cblxuLy8gTUFJTiAvL1xuXG52YXIgcm9vdCA9IGdldEdsb2JhbCgpO1xudmFyIG5vZGVMaXN0ID0gcm9vdC5kb2N1bWVudCAmJiByb290LmRvY3VtZW50LmNoaWxkTm9kZXM7XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5vZGVMaXN0O1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB0eXBlZGFycmF5ID0gSW50OEFycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHN0ZGxpYi9yZXF1aXJlLWdsb2JhbHNcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gdHlwZWRhcnJheTtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBSRSA9IHJlcXVpcmUoICcuL2ZpeHR1cmVzL3JlLmpzJyApO1xudmFyIG5vZGVMaXN0ID0gcmVxdWlyZSggJy4vZml4dHVyZXMvbm9kZWxpc3QuanMnICk7XG52YXIgdHlwZWRhcnJheSA9IHJlcXVpcmUoICcuL2ZpeHR1cmVzL3R5cGVkYXJyYXkuanMnICk7XG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogQ2hlY2tzIHdoZXRoZXIgYSBwb2x5ZmlsbCBpcyBuZWVkZWQgd2hlbiB1c2luZyB0aGUgYHR5cGVvZmAgb3BlcmF0b3IuXG4qXG4qIEBwcml2YXRlXG4qIEByZXR1cm5zIHtib29sZWFufSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBhIHBvbHlmaWxsIGlzIG5lZWRlZFxuKi9cbmZ1bmN0aW9uIGNoZWNrKCkge1xuXHRpZiAoXG5cdFx0Ly8gQ2hyb21lIDEtMTIgcmV0dXJucyAnZnVuY3Rpb24nIGZvciByZWd1bGFyIGV4cHJlc3Npb24gaW5zdGFuY2VzIChzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL3R5cGVvZik6XG5cdFx0dHlwZW9mIFJFID09PSAnZnVuY3Rpb24nIHx8XG5cblx0XHQvLyBTYWZhcmkgOCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheSBhbmQgd2VhayBtYXAgY29uc3RydWN0b3JzICh1bmRlcnNjb3JlICMxOTI5KTpcblx0XHR0eXBlb2YgdHlwZWRhcnJheSA9PT0gJ29iamVjdCcgfHxcblxuXHRcdC8vIFBoYW50b21KUyAxLjkgcmV0dXJucyAnZnVuY3Rpb24nIGZvciBgTm9kZUxpc3RgIGluc3RhbmNlcyAodW5kZXJzY29yZSAjMjIzNik6XG5cdFx0dHlwZW9mIG5vZGVMaXN0ID09PSAnZnVuY3Rpb24nXG5cdCkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdHJldHVybiBmYWxzZTtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gY2hlY2s7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDIxIFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTUFJTiAvL1xuXG4vKipcbiogUmV0dXJucyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBjYXB0dXJlIGV2ZXJ5dGhpbmcgdGhhdCBpcyBub3QgYSBzcGFjZSBpbW1lZGlhdGVseSBhZnRlciB0aGUgYGZ1bmN0aW9uYCBrZXl3b3JkIGFuZCBiZWZvcmUgdGhlIGZpcnN0IGxlZnQgcGFyZW50aGVzaXMuXG4qXG4qIEByZXR1cm5zIHtSZWdFeHB9IHJlZ3VsYXIgZXhwcmVzc2lvblxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgUkVfRlVOQ1RJT05fTkFNRSA9IHJlRnVuY3Rpb25OYW1lKCk7XG4qXG4qIGZ1bmN0aW9uIGZuYW1lKCBmY24gKSB7XG4qICAgICByZXR1cm4gUkVfRlVOQ1RJT05fTkFNRS5leGVjKCBmY24udG9TdHJpbmcoKSApWyAxIF07XG4qIH1cbipcbiogdmFyIGZuID0gZm5hbWUoIE1hdGguc3FydCApO1xuKiAvLyByZXR1cm5zICdzcXJ0J1xuKlxuKiBmbiA9IGZuYW1lKCBJbnQ4QXJyYXkgKTtcbiogLy8gcmV0dXJucyAnSW50OEFycmF5J1xuKlxuKiBmbiA9IGZuYW1lKCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nICk7XG4qIC8vIHJldHVybnMgJ3RvU3RyaW5nJ1xuKlxuKiBmbiA9IGZuYW1lKCBmdW5jdGlvbigpe30gKTtcbiogLy8gcmV0dXJucyAnJ1xuKi9cbmZ1bmN0aW9uIHJlRnVuY3Rpb25OYW1lKCkge1xuXHRyZXR1cm4gL15cXHMqZnVuY3Rpb25cXHMqKFteKF0qKS9pO1xufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSByZUZ1bmN0aW9uTmFtZTtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciByZUZ1bmN0aW9uTmFtZSA9IHJlcXVpcmUoICcuL21haW4uanMnICk7XG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogQ2FwdHVyZXMgZXZlcnl0aGluZyB0aGF0IGlzIG5vdCBhIHNwYWNlIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBgZnVuY3Rpb25gIGtleXdvcmQgYW5kIGJlZm9yZSB0aGUgZmlyc3QgbGVmdCBwYXJlbnRoZXNpcy5cbipcbiogUmVndWxhciBleHByZXNzaW9uOiBgL15cXHMqZnVuY3Rpb25cXHMqKFteKF0qKS9pYFxuKlxuKiAtICAgYC9eXFxzKmBcbiogICAgIC0gICBNYXRjaCB6ZXJvIG9yIG1vcmUgc3BhY2VzIGF0IGJlZ2lubmluZ1xuKlxuKiAtICAgYGZ1bmN0aW9uYFxuKiAgICAgLSAgIE1hdGNoIHRoZSB3b3JkIGBmdW5jdGlvbmBcbipcbiogLSAgIGBcXHMqYFxuKiAgICAgLSAgIE1hdGNoIHplcm8gb3IgbW9yZSBzcGFjZXMgYWZ0ZXIgdGhlIHdvcmQgYGZ1bmN0aW9uYFxuKlxuKiAtICAgYCgpYFxuKiAgICAgLSAgIENhcHR1cmVcbipcbiogLSAgIGBbXihdKmBcbiogICAgIC0gICBNYXRjaCBhbnl0aGluZyBleGNlcHQgYSBsZWZ0IHBhcmVudGhlc2lzIGAoYCB6ZXJvIG9yIG1vcmUgdGltZXNcbipcbiogLSAgIGAvaWBcbiogICAgIC0gICBpZ25vcmUgY2FzZVxuKlxuKiBAY29uc3RhbnRcbiogQHR5cGUge1JlZ0V4cH1cbiogQGRlZmF1bHQgL15cXHMqZnVuY3Rpb25cXHMqKFteKF0qKS9pXG4qL1xudmFyIFJFX0ZVTkNUSU9OX05BTUUgPSByZUZ1bmN0aW9uTmFtZSgpO1xuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBSRV9GVU5DVElPTl9OQU1FO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAyMSBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBSZWd1bGFyIGV4cHJlc3Npb24gdG8gY2FwdHVyZSBldmVyeXRoaW5nIHRoYXQgaXMgbm90IGEgc3BhY2UgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGBmdW5jdGlvbmAga2V5d29yZCBhbmQgYmVmb3JlIHRoZSBmaXJzdCBsZWZ0IHBhcmVudGhlc2lzLlxuKlxuKiBAbW9kdWxlIEBzdGRsaWIvcmVnZXhwLWZ1bmN0aW9uLW5hbWVcbipcbiogQGV4YW1wbGVcbiogdmFyIHJlRnVuY3Rpb25OYW1lID0gcmVxdWlyZSggJ0BzdGRsaWIvcmVnZXhwLWZ1bmN0aW9uLW5hbWUnICk7XG4qIHZhciBSRV9GVU5DVElPTl9OQU1FID0gcmVGdW5jdGlvbk5hbWUoKTtcbipcbiogZnVuY3Rpb24gZm5hbWUoIGZjbiApIHtcbiogICAgIHJldHVybiBSRV9GVU5DVElPTl9OQU1FLmV4ZWMoIGZjbi50b1N0cmluZygpIClbIDEgXTtcbiogfVxuKlxuKiB2YXIgZm4gPSBmbmFtZSggTWF0aC5zcXJ0ICk7XG4qIC8vIHJldHVybnMgJ3NxcnQnXG4qXG4qIGZuID0gZm5hbWUoIEludDhBcnJheSApO1xuKiAvLyByZXR1cm5zICdJbnQ4QXJyYXknXG4qXG4qIGZuID0gZm5hbWUoIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgKTtcbiogLy8gcmV0dXJucyAndG9TdHJpbmcnXG4qXG4qIGZuID0gZm5hbWUoIGZ1bmN0aW9uKCl7fSApO1xuKiAvLyByZXR1cm5zICcnXG4qL1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBzZXRSZWFkT25seSA9IHJlcXVpcmUoICdAc3RkbGliL3V0aWxzLWRlZmluZS1ub25lbnVtZXJhYmxlLXJlYWQtb25seS1wcm9wZXJ0eScgKTtcbnZhciByZUZ1bmN0aW9uTmFtZSA9IHJlcXVpcmUoICcuL21haW4uanMnICk7XG52YXIgUkVHRVhQID0gcmVxdWlyZSggJy4vcmVnZXhwLmpzJyApO1xuXG5cbi8vIE1BSU4gLy9cblxuc2V0UmVhZE9ubHkoIHJlRnVuY3Rpb25OYW1lLCAnUkVHRVhQJywgUkVHRVhQICk7XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlRnVuY3Rpb25OYW1lO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBUZXN0cyBpZiBhIHZhbHVlIGlzIG9iamVjdC1saWtlLlxuKlxuKiBAcGFyYW0geyp9IHZhbHVlIC0gdmFsdWUgdG8gdGVzdFxuKiBAcmV0dXJucyB7Ym9vbGVhbn0gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgYSB2YWx1ZSBpcyBvYmplY3QtbGlrZVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgYm9vbCA9IGlzT2JqZWN0TGlrZSgge30gKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaXNPYmplY3RMaWtlKCBbXSApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBpc09iamVjdExpa2UoIG51bGwgKTtcbiogLy8gcmV0dXJucyBmYWxzZVxuKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSggdmFsdWUgKSB7XG5cdHJldHVybiAoXG5cdFx0dmFsdWUgIT09IG51bGwgJiZcblx0XHR0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnXG5cdCk7XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogVGVzdCBpZiBhIHZhbHVlIGlzIG9iamVjdC1saWtlLlxuKlxuKiBAbW9kdWxlIEBzdGRsaWIvYXNzZXJ0LWlzLW9iamVjdC1saWtlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBpc09iamVjdExpa2UgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaXMtb2JqZWN0LWxpa2UnICk7XG4qXG4qIHZhciBib29sID0gaXNPYmplY3RMaWtlKCB7fSApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogYm9vbCA9IGlzT2JqZWN0TGlrZSggW10gKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qXG4qIGJvb2wgPSBpc09iamVjdExpa2UoIG51bGwgKTtcbiogLy8gcmV0dXJucyBmYWxzZVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgaXNPYmplY3RMaWtlID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLW9iamVjdC1saWtlJyApLmlzT2JqZWN0TGlrZUFycmF5O1xuKlxuKiB2YXIgYm9vbCA9IGlzT2JqZWN0TGlrZSggWyB7fSwgW10gXSApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogYm9vbCA9IGlzT2JqZWN0TGlrZSggWyB7fSwgJzMuMCcgXSApO1xuKiAvLyByZXR1cm5zIGZhbHNlXG4qL1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBzZXRSZWFkT25seSA9IHJlcXVpcmUoICdAc3RkbGliL3V0aWxzLWRlZmluZS1ub25lbnVtZXJhYmxlLXJlYWQtb25seS1wcm9wZXJ0eScgKTtcbnZhciBhcnJheWZ1biA9IHJlcXVpcmUoICdAc3RkbGliL2Fzc2VydC10b29scy1hcnJheS1mdW5jdGlvbicgKTtcbnZhciBpc09iamVjdExpa2UgPSByZXF1aXJlKCAnLi9tYWluLmpzJyApO1xuXG5cbi8vIE1BSU4gLy9cblxuc2V0UmVhZE9ubHkoIGlzT2JqZWN0TGlrZSwgJ2lzT2JqZWN0TGlrZUFycmF5JywgYXJyYXlmdW4oIGlzT2JqZWN0TGlrZSApICk7XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBpc09iamVjdExpa2UgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaXMtb2JqZWN0LWxpa2UnICk7XG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogVGVzdHMgaWYgYSB2YWx1ZSBpcyBhIEJ1ZmZlciBpbnN0YW5jZS5cbipcbiogQHBhcmFtIHsqfSB2YWx1ZSAtIHZhbHVlIHRvIHZhbGlkYXRlXG4qIEByZXR1cm5zIHtib29sZWFufSBib29sZWFuIGluZGljYXRpbmcgaWYgYSB2YWx1ZSBpcyBhIEJ1ZmZlciBpbnN0YW5jZVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgdiA9IGlzQnVmZmVyKCBuZXcgQnVmZmVyKCAnYmVlcCcgKSApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogQGV4YW1wbGVcbiogdmFyIHYgPSBpc0J1ZmZlciggbmV3IEJ1ZmZlciggWzEsMiwzLDRdICkgKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qXG4qIEBleGFtcGxlXG4qIHZhciB2ID0gaXNCdWZmZXIoIHt9ICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbipcbiogQGV4YW1wbGVcbiogdmFyIHYgPSBpc0J1ZmZlciggW10gKTtcbiogLy8gcmV0dXJucyBmYWxzZVxuKi9cbmZ1bmN0aW9uIGlzQnVmZmVyKCB2YWx1ZSApIHtcblx0cmV0dXJuIChcblx0XHRpc09iamVjdExpa2UoIHZhbHVlICkgJiZcblx0XHQoXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZXJzY29yZS1kYW5nbGVcblx0XHRcdHZhbHVlLl9pc0J1ZmZlciB8fCAvLyBmb3IgZW52cyBtaXNzaW5nIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IgKGUuZy4sIFNhZmFyaSA1LTcpXG5cdFx0XHQoXG5cdFx0XHRcdHZhbHVlLmNvbnN0cnVjdG9yICYmXG5cblx0XHRcdFx0Ly8gV0FSTklORzogYHR5cGVvZmAgaXMgbm90IGEgZm9vbHByb29mIGNoZWNrLCBhcyBjZXJ0YWluIGVudnMgY29uc2lkZXIgUmVnRXhwIGFuZCBOb2RlTGlzdCBpbnN0YW5jZXMgdG8gYmUgZnVuY3Rpb25zXG5cdFx0XHRcdHR5cGVvZiB2YWx1ZS5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdFx0XHR2YWx1ZS5jb25zdHJ1Y3Rvci5pc0J1ZmZlciggdmFsdWUgKVxuXHRcdFx0KVxuXHRcdClcblx0KTtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNCdWZmZXI7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIFRlc3QgaWYgYSB2YWx1ZSBpcyBhIEJ1ZmZlciBpbnN0YW5jZS5cbipcbiogQG1vZHVsZSBAc3RkbGliL2Fzc2VydC1pcy1idWZmZXJcbipcbiogQGV4YW1wbGVcbiogdmFyIGlzQnVmZmVyID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLWJ1ZmZlcicgKTtcbipcbiogdmFyIHYgPSBpc0J1ZmZlciggbmV3IEJ1ZmZlciggJ2JlZXAnICkgKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qXG4qIHYgPSBpc0J1ZmZlcigge30gKTtcbiogLy8gcmV0dXJucyBmYWxzZVxuKi9cblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgaXNCdWZmZXIgPSByZXF1aXJlKCAnLi9tYWluLmpzJyApO1xuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBpc0J1ZmZlcjtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBuYXRpdmVDbGFzcyA9IHJlcXVpcmUoICdAc3RkbGliL3V0aWxzLW5hdGl2ZS1jbGFzcycgKTtcbnZhciBSRSA9IHJlcXVpcmUoICdAc3RkbGliL3JlZ2V4cC1mdW5jdGlvbi1uYW1lJyApLlJFR0VYUDtcbnZhciBpc0J1ZmZlciA9IHJlcXVpcmUoICdAc3RkbGliL2Fzc2VydC1pcy1idWZmZXInICk7XG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogRGV0ZXJtaW5lcyB0aGUgbmFtZSBvZiBhIHZhbHVlJ3MgY29uc3RydWN0b3IuXG4qXG4qIEBwYXJhbSB7Kn0gdiAtIGlucHV0IHZhbHVlXG4qIEByZXR1cm5zIHtzdHJpbmd9IG5hbWUgb2YgYSB2YWx1ZSdzIGNvbnN0cnVjdG9yXG4qXG4qIEBleGFtcGxlXG4qIHZhciB2ID0gY29uc3RydWN0b3JOYW1lKCAnYScgKTtcbiogLy8gcmV0dXJucyAnU3RyaW5nJ1xuKlxuKiBAZXhhbXBsZVxuKiB2YXIgdiA9IGNvbnN0cnVjdG9yTmFtZSggNSApO1xuKiAvLyByZXR1cm5zICdOdW1iZXInXG4qXG4qIEBleGFtcGxlXG4qIHZhciB2ID0gY29uc3RydWN0b3JOYW1lKCBudWxsICk7XG4qIC8vIHJldHVybnMgJ051bGwnXG4qXG4qIEBleGFtcGxlXG4qIHZhciB2ID0gY29uc3RydWN0b3JOYW1lKCB1bmRlZmluZWQgKTtcbiogLy8gcmV0dXJucyAnVW5kZWZpbmVkJ1xuKlxuKiBAZXhhbXBsZVxuKiB2YXIgdiA9IGNvbnN0cnVjdG9yTmFtZSggZnVuY3Rpb24gbm9vcCgpIHt9ICk7XG4qIC8vIHJldHVybnMgJ0Z1bmN0aW9uJ1xuKi9cbmZ1bmN0aW9uIGNvbnN0cnVjdG9yTmFtZSggdiApIHtcblx0dmFyIG1hdGNoO1xuXHR2YXIgbmFtZTtcblx0dmFyIGN0b3I7XG5cdG5hbWUgPSBuYXRpdmVDbGFzcyggdiApLnNsaWNlKCA4LCAtMSApO1xuXHRpZiAoIChuYW1lID09PSAnT2JqZWN0JyB8fCBuYW1lID09PSAnRXJyb3InKSAmJiB2LmNvbnN0cnVjdG9yICkge1xuXHRcdGN0b3IgPSB2LmNvbnN0cnVjdG9yO1xuXHRcdGlmICggdHlwZW9mIGN0b3IubmFtZSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRyZXR1cm4gY3Rvci5uYW1lO1xuXHRcdH1cblx0XHRtYXRjaCA9IFJFLmV4ZWMoIGN0b3IudG9TdHJpbmcoKSApO1xuXHRcdGlmICggbWF0Y2ggKSB7XG5cdFx0XHRyZXR1cm4gbWF0Y2hbIDEgXTtcblx0XHR9XG5cdH1cblx0aWYgKCBpc0J1ZmZlciggdiApICkge1xuXHRcdHJldHVybiAnQnVmZmVyJztcblx0fVxuXHRyZXR1cm4gbmFtZTtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gY29uc3RydWN0b3JOYW1lO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBEZXRlcm1pbmUgdGhlIG5hbWUgb2YgYSB2YWx1ZSdzIGNvbnN0cnVjdG9yLlxuKlxuKiBAbW9kdWxlIEBzdGRsaWIvdXRpbHMtY29uc3RydWN0b3ItbmFtZVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgY29uc3RydWN0b3JOYW1lID0gcmVxdWlyZSggJ0BzdGRsaWIvdXRpbHMtY29uc3RydWN0b3ItbmFtZScgKTtcbipcbiogdmFyIHYgPSBjb25zdHJ1Y3Rvck5hbWUoICdhJyApO1xuKiAvLyByZXR1cm5zICdTdHJpbmcnXG4qXG4qIHYgPSBjb25zdHJ1Y3Rvck5hbWUoIHt9ICk7XG4qIC8vIHJldHVybnMgJ09iamVjdCdcbipcbiogdiA9IGNvbnN0cnVjdG9yTmFtZSggdHJ1ZSApO1xuKiAvLyByZXR1cm5zICdCb29sZWFuJ1xuKi9cblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgY29uc3RydWN0b3JOYW1lID0gcmVxdWlyZSggJy4vbWFpbi5qcycgKTtcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gY29uc3RydWN0b3JOYW1lO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGN0b3JOYW1lID0gcmVxdWlyZSggJ0BzdGRsaWIvdXRpbHMtY29uc3RydWN0b3ItbmFtZScgKTtcblxuXG4vLyBOT1RFUyAvL1xuXG4vKlxuKiBCdWlsdC1pbiBgdHlwZW9mYCBvcGVyYXRvciBiZWhhdmlvcjpcbipcbiogYGBgdGV4dFxuKiB0eXBlb2YgbnVsbCA9PiAnb2JqZWN0J1xuKiB0eXBlb2YgdW5kZWZpbmVkID0+ICd1bmRlZmluZWQnXG4qIHR5cGVvZiAnYScgPT4gJ3N0cmluZydcbiogdHlwZW9mIDUgPT4gJ251bWJlcidcbiogdHlwZW9mIE5hTiA9PiAnbnVtYmVyJ1xuKiB0eXBlb2YgdHJ1ZSA9PiAnYm9vbGVhbidcbiogdHlwZW9mIGZhbHNlID0+ICdib29sZWFuJ1xuKiB0eXBlb2Yge30gPT4gJ29iamVjdCdcbiogdHlwZW9mIFtdID0+ICdvYmplY3QnXG4qIHR5cGVvZiBmdW5jdGlvbiBmb28oKXt9ID0+ICdmdW5jdGlvbidcbiogdHlwZW9mIGZ1bmN0aW9uKiBmb28oKXt9ID0+ICdvYmplY3QnXG4qIHR5cGVvZiBTeW1ib2woKSA9PiAnc3ltYm9sJ1xuKiBgYGBcbipcbiovXG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogRGV0ZXJtaW5lcyBhIHZhbHVlJ3MgdHlwZS5cbipcbiogQHBhcmFtIHsqfSB2IC0gaW5wdXQgdmFsdWVcbiogQHJldHVybnMge3N0cmluZ30gc3RyaW5nIGluZGljYXRpbmcgdGhlIHZhbHVlJ3MgdHlwZVxuKi9cbmZ1bmN0aW9uIHR5cGVPZiggdiApIHtcblx0dmFyIHR5cGU7XG5cblx0Ly8gQWRkcmVzcyBgdHlwZW9mIG51bGxgID0+IGBvYmplY3RgIChzZWUgaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9aGFybW9ueTp0eXBlb2ZfbnVsbCk6XG5cdGlmICggdiA9PT0gbnVsbCApIHtcblx0XHRyZXR1cm4gJ251bGwnO1xuXHR9XG5cdHR5cGUgPSB0eXBlb2YgdjtcblxuXHQvLyBJZiB0aGUgYHR5cGVvZmAgb3BlcmF0b3IgcmV0dXJuZWQgc29tZXRoaW5nIG90aGVyIHRoYW4gYG9iamVjdGAsIHdlIGFyZSBkb25lLiBPdGhlcndpc2UsIHdlIG5lZWQgdG8gY2hlY2sgZm9yIGFuIGludGVybmFsIGNsYXNzIG5hbWUgb3Igc2VhcmNoIGZvciBhIGNvbnN0cnVjdG9yLlxuXHRpZiAoIHR5cGUgPT09ICdvYmplY3QnICkge1xuXHRcdHJldHVybiBjdG9yTmFtZSggdiApLnRvTG93ZXJDYXNlKCk7XG5cdH1cblx0cmV0dXJuIHR5cGU7XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVPZjtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBjdG9yTmFtZSA9IHJlcXVpcmUoICdAc3RkbGliL3V0aWxzLWNvbnN0cnVjdG9yLW5hbWUnICk7XG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogRGV0ZXJtaW5lcyBhIHZhbHVlJ3MgdHlwZS5cbipcbiogQHBhcmFtIHsqfSB2IC0gaW5wdXQgdmFsdWVcbiogQHJldHVybnMge3N0cmluZ30gc3RyaW5nIGluZGljYXRpbmcgdGhlIHZhbHVlJ3MgdHlwZVxuKi9cbmZ1bmN0aW9uIHR5cGVPZiggdiApIHtcblx0cmV0dXJuIGN0b3JOYW1lKCB2ICkudG9Mb3dlckNhc2UoKTtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gdHlwZU9mO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBEZXRlcm1pbmUgYSB2YWx1ZSdzIHR5cGUuXG4qXG4qIEBtb2R1bGUgQHN0ZGxpYi91dGlscy10eXBlLW9mXG4qXG4qIEBleGFtcGxlXG4qIHZhciB0eXBlT2YgPSByZXF1aXJlKCAnQHN0ZGxpYi91dGlscy10eXBlLW9mJyApO1xuKlxuKiB2YXIgc3RyID0gdHlwZU9mKCAnYScgKTtcbiogLy8gcmV0dXJucyAnc3RyaW5nJ1xuKlxuKiBzdHIgPSB0eXBlT2YoIDUgKTtcbiogLy8gcmV0dXJucyAnbnVtYmVyJ1xuKi9cblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgdXNlUG9seWZpbGwgPSByZXF1aXJlKCAnLi9jaGVjay5qcycgKTtcbnZhciB0eXBlT2YgPSByZXF1aXJlKCAnLi90eXBlb2YuanMnICk7XG52YXIgcG9seWZpbGwgPSByZXF1aXJlKCAnLi9wb2x5ZmlsbC5qcycgKTtcblxuXG4vLyBNQUlOIC8vXG5cbnZhciBtYWluID0gKCB1c2VQb2x5ZmlsbCgpICkgPyBwb2x5ZmlsbCA6IHR5cGVPZjtcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gbWFpbjtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciB0eXBlT2YgPSByZXF1aXJlKCAnQHN0ZGxpYi91dGlscy10eXBlLW9mJyApO1xuXG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIFRlc3RzIGlmIGEgdmFsdWUgaXMgYSBmdW5jdGlvbi5cbipcbiogQHBhcmFtIHsqfSB2YWx1ZSAtIHZhbHVlIHRvIHRlc3RcbiogQHJldHVybnMge2Jvb2xlYW59IGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHZhbHVlIGlzIGEgZnVuY3Rpb25cbipcbiogQGV4YW1wbGVcbiogZnVuY3Rpb24gYmVlcCgpIHtcbiogICAgIHJldHVybiAnYmVlcCc7XG4qIH1cbipcbiogdmFyIGJvb2wgPSBpc0Z1bmN0aW9uKCBiZWVwICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oIHZhbHVlICkge1xuXHQvLyBOb3RlOiBjYW5ub3QgdXNlIGB0eXBlb2ZgIGRpcmVjdGx5LCBhcyB2YXJpb3VzIGJyb3dzZXIgZW5naW5lcyBpbmNvcnJlY3RseSByZXR1cm4gYCdmdW5jdGlvbidgIHdoZW4gb3BlcmF0aW5nIG9uIG5vbi1mdW5jdGlvbiBvYmplY3RzLCBzdWNoIGFzIHJlZ3VsYXIgZXhwcmVzc2lvbnMgYW5kIE5vZGVMaXN0cy5cblx0cmV0dXJuICggdHlwZU9mKCB2YWx1ZSApID09PSAnZnVuY3Rpb24nICk7XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb247XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIFRlc3QgaWYgYSB2YWx1ZSBpcyBhIGZ1bmN0aW9uLlxuKlxuKiBAbW9kdWxlIEBzdGRsaWIvYXNzZXJ0LWlzLWZ1bmN0aW9uXG4qXG4qIEBleGFtcGxlXG4qIHZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLWZ1bmN0aW9uJyApO1xuKlxuKiBmdW5jdGlvbiBiZWVwKCkge1xuKiAgICAgcmV0dXJuICdiZWVwJztcbiogfVxuKlxuKiB2YXIgYm9vbCA9IGlzRnVuY3Rpb24oIGJlZXAgKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qL1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSggJy4vbWFpbi5qcycgKTtcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNGdW5jdGlvbjtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNQUlOIC8vXG5cbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UHJvdG87XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBgX19wcm90b19fYCBwcm9wZXJ0eS5cbipcbiogQHByaXZhdGVcbiogQHBhcmFtIHtPYmplY3R9IG9iaiAtIGlucHV0IG9iamVjdFxuKiBAcmV0dXJucyB7Kn0gdmFsdWUgb2YgYF9fcHJvdG9fX2AgcHJvcGVydHlcbiovXG5mdW5jdGlvbiBnZXRQcm90byggb2JqICkge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG9cblx0cmV0dXJuIG9iai5fX3Byb3RvX187XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFByb3RvO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIG5hdGl2ZUNsYXNzID0gcmVxdWlyZSggJ0BzdGRsaWIvdXRpbHMtbmF0aXZlLWNsYXNzJyApO1xudmFyIGdldFByb3RvID0gcmVxdWlyZSggJy4vcHJvdG8uanMnICk7XG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogUmV0dXJucyB0aGUgcHJvdG90eXBlIG9mIGEgcHJvdmlkZWQgb2JqZWN0LlxuKlxuKiBAcHJpdmF0ZVxuKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gaW5wdXQgb2JqZWN0XG4qIEByZXR1cm5zIHsoT2JqZWN0fG51bGwpfSBwcm90b3R5cGVcbiovXG5mdW5jdGlvbiBnZXRQcm90b3R5cGVPZiggb2JqICkge1xuXHR2YXIgcHJvdG8gPSBnZXRQcm90byggb2JqICk7XG5cdGlmICggcHJvdG8gfHwgcHJvdG8gPT09IG51bGwgKSB7XG5cdFx0cmV0dXJuIHByb3RvO1xuXHR9XG5cdGlmICggbmF0aXZlQ2xhc3MoIG9iai5jb25zdHJ1Y3RvciApID09PSAnW29iamVjdCBGdW5jdGlvbl0nICkge1xuXHRcdC8vIE1heSBicmVhayBpZiB0aGUgY29uc3RydWN0b3IgaGFzIGJlZW4gdGFtcGVyZWQgd2l0aC4uLlxuXHRcdHJldHVybiBvYmouY29uc3RydWN0b3IucHJvdG90eXBlO1xuXHR9XG5cdGlmICggb2JqIGluc3RhbmNlb2YgT2JqZWN0ICkge1xuXHRcdHJldHVybiBPYmplY3QucHJvdG90eXBlO1xuXHR9XG5cdC8vIFJldHVybiBgbnVsbGAgZm9yIG9iamVjdHMgY3JlYXRlZCB2aWEgYE9iamVjdC5jcmVhdGUoIG51bGwgKWAuIEFsc28gcmV0dXJuIGBudWxsYCBmb3IgY3Jvc3MtcmVhbG0gb2JqZWN0cyBvbiBicm93c2VycyB0aGF0IGxhY2sgYF9fcHJvdG9fX2Agc3VwcG9ydCwgc3VjaCBhcyBJRSA8IDExLlxuXHRyZXR1cm4gbnVsbDtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UHJvdG90eXBlT2Y7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoICdAc3RkbGliL2Fzc2VydC1pcy1mdW5jdGlvbicgKTtcbnZhciBidWlsdGluID0gcmVxdWlyZSggJy4vbmF0aXZlLmpzJyApO1xudmFyIHBvbHlmaWxsID0gcmVxdWlyZSggJy4vcG9seWZpbGwuanMnICk7XG5cblxuLy8gTUFJTiAvL1xuXG52YXIgZ2V0UHJvdG87XG5pZiAoIGlzRnVuY3Rpb24oIE9iamVjdC5nZXRQcm90b3R5cGVPZiApICkge1xuXHRnZXRQcm90byA9IGJ1aWx0aW47XG59IGVsc2Uge1xuXHRnZXRQcm90byA9IHBvbHlmaWxsO1xufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRQcm90bztcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBnZXRQcm90byA9IHJlcXVpcmUoICcuL2RldGVjdC5qcycgKTtcblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBSZXR1cm5zIHRoZSBwcm90b3R5cGUgb2YgYSBwcm92aWRlZCBvYmplY3QuXG4qXG4qIEBwYXJhbSB7Kn0gdmFsdWUgLSBpbnB1dCB2YWx1ZVxuKiBAcmV0dXJucyB7KE9iamVjdHxudWxsKX0gcHJvdG90eXBlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBwcm90byA9IGdldFByb3RvdHlwZU9mKCB7fSApO1xuKiAvLyByZXR1cm5zIHt9XG4qL1xuZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YoIHZhbHVlICkge1xuXHRpZiAoXG5cdFx0dmFsdWUgPT09IG51bGwgfHxcblx0XHR2YWx1ZSA9PT0gdm9pZCAwXG5cdCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdC8vIEluIG9yZGVyIHRvIGVuc3VyZSBjb25zaXN0ZW50IEVTNS9FUzYgYmVoYXZpb3IsIGNhc3QgaW5wdXQgdmFsdWUgdG8gYW4gb2JqZWN0IChzdHJpbmdzLCBudW1iZXJzLCBib29sZWFucyk7IEVTNSBgT2JqZWN0LmdldFByb3RvdHlwZU9mYCB0aHJvd3Mgd2hlbiBwcm92aWRlZCBwcmltaXRpdmVzIGFuZCBFUzYgYE9iamVjdC5nZXRQcm90b3R5cGVPZmAgY2FzdHM6XG5cdHZhbHVlID0gT2JqZWN0KCB2YWx1ZSApO1xuXG5cdHJldHVybiBnZXRQcm90byggdmFsdWUgKTtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UHJvdG90eXBlT2Y7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIFJldHVybiB0aGUgcHJvdG90eXBlIG9mIGEgcHJvdmlkZWQgb2JqZWN0LlxuKlxuKiBAbW9kdWxlIEBzdGRsaWIvdXRpbHMtZ2V0LXByb3RvdHlwZS1vZlxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSggJ0BzdGRsaWIvdXRpbHMtZ2V0LXByb3RvdHlwZS1vZicgKTtcbipcbiogdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlKCB7fSApO1xuKiAvLyByZXR1cm5zIHt9XG4qL1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCAnLi9nZXRfcHJvdG90eXBlX29mLmpzJyApO1xuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRQcm90b3R5cGU7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaXMtb2JqZWN0JyApO1xudmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaXMtZnVuY3Rpb24nICk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCAnQHN0ZGxpYi91dGlscy1nZXQtcHJvdG90eXBlLW9mJyApO1xudmFyIGhhc093blByb3AgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaGFzLW93bi1wcm9wZXJ0eScgKTtcbnZhciBuYXRpdmVDbGFzcyA9IHJlcXVpcmUoICdAc3RkbGliL3V0aWxzLW5hdGl2ZS1jbGFzcycgKTtcblxuXG4vLyBWQVJJQUJMRVMgLy9cblxudmFyIG9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG5cblxuLy8gRlVOQ1RJT05TIC8vXG5cbi8qKlxuKiBUZXN0cyB0aGF0IGFuIG9iamVjdCBvbmx5IGhhcyBvd24gcHJvcGVydGllcy5cbipcbiogQHByaXZhdGVcbiogQHBhcmFtIHtPYmplY3R9IG9iaiAtIHZhbHVlIHRvIHRlc3RcbiogQHJldHVybnMge2Jvb2xlYW59IGJvb2xlYW4gaW5kaWNhdGluZyBpZiBhbiBvYmplY3Qgb25seSBoYXMgb3duIHByb3BlcnRpZXNcbiovXG5mdW5jdGlvbiBvd25Qcm9wcyggb2JqICkge1xuXHR2YXIga2V5O1xuXG5cdC8vIE5PVEU6IHBvc3NpYmlsaXR5IG9mIHBlcmYgYm9vc3QgaWYga2V5IGVudW1lcmF0aW9uIG9yZGVyIGlzIGtub3duIChzZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xODUzMTYyNC9pc3BsYWlub2JqZWN0LXRoaW5nKS5cblx0Zm9yICgga2V5IGluIG9iaiApIHtcblx0XHRpZiAoICFoYXNPd25Qcm9wKCBvYmosIGtleSApICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBUZXN0cyBpZiBhIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LlxuKlxuKiBAcGFyYW0geyp9IHZhbHVlIC0gdmFsdWUgdG8gdGVzdFxuKiBAcmV0dXJucyB7Ym9vbGVhbn0gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdmFsdWUgaXMgYSBwbGFpbiBvYmplY3RcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBpc1BsYWluT2JqZWN0KCB7fSApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBpc1BsYWluT2JqZWN0KCBudWxsICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbiovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KCB2YWx1ZSApIHtcblx0dmFyIHByb3RvO1xuXG5cdC8vIFNjcmVlbiBmb3Igb2J2aW91cyBub24tb2JqZWN0cy4uLlxuXHRpZiAoICFpc09iamVjdCggdmFsdWUgKSApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0Ly8gT2JqZWN0cyB3aXRoIG5vIHByb3RvdHlwZSAoZS5nLiwgYE9iamVjdC5jcmVhdGUoIG51bGwgKWApIGFyZSBwbGFpbi4uLlxuXHRwcm90byA9IGdldFByb3RvdHlwZU9mKCB2YWx1ZSApO1xuXHRpZiAoICFwcm90byApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHQvLyBPYmplY3RzIGhhdmluZyBhIHByb3RvdHlwZSBhcmUgcGxhaW4gaWYgYW5kIG9ubHkgaWYgdGhleSBhcmUgY29uc3RydWN0ZWQgd2l0aCBhIGdsb2JhbCBgT2JqZWN0YCBmdW5jdGlvbiBhbmQgdGhlIHByb3RvdHlwZSBwb2ludHMgdG8gdGhlIHByb3RvdHlwZSBvZiBhIHBsYWluIG9iamVjdC4uLlxuXHRyZXR1cm4gKFxuXHRcdC8vIENhbm5vdCBoYXZlIG93biBgY29uc3RydWN0b3JgIHByb3BlcnR5OlxuXHRcdCFoYXNPd25Qcm9wKCB2YWx1ZSwgJ2NvbnN0cnVjdG9yJyApICYmXG5cblx0XHQvLyBQcm90b3R5cGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSBtdXN0IGJlIGEgZnVuY3Rpb24gKHNlZSBhbHNvIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC85ODk3IGFuZCBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE4NTMxNjI0L2lzcGxhaW5vYmplY3QtdGhpbmcpOlxuXHRcdGhhc093blByb3AoIHByb3RvLCAnY29uc3RydWN0b3InICkgJiZcblx0XHRpc0Z1bmN0aW9uKCBwcm90by5jb25zdHJ1Y3RvciApICYmXG5cdFx0bmF0aXZlQ2xhc3MoIHByb3RvLmNvbnN0cnVjdG9yICkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXScgJiZcblxuXHRcdC8vIFRlc3QgZm9yIG9iamVjdC1zcGVjaWZpYyBtZXRob2Q6XG5cdFx0aGFzT3duUHJvcCggcHJvdG8sICdpc1Byb3RvdHlwZU9mJyApICYmXG5cdFx0aXNGdW5jdGlvbiggcHJvdG8uaXNQcm90b3R5cGVPZiApICYmXG5cblx0XHQoXG5cdFx0XHQvLyBUZXN0IGlmIHRoZSBwcm90b3R5cGUgbWF0Y2hlcyB0aGUgZ2xvYmFsIGBPYmplY3RgIHByb3RvdHlwZSAoc2FtZSByZWFsbSk6XG5cdFx0XHRwcm90byA9PT0gb2JqZWN0UHJvdG90eXBlIHx8XG5cblx0XHRcdC8vIFRlc3QgdGhhdCBhbGwgcHJvcGVydGllcyBhcmUgb3duIHByb3BlcnRpZXMgKGNyb3NzLXJlYWxtOyAqbW9zdCogbGlrZWx5IGEgcGxhaW4gb2JqZWN0KTpcblx0XHRcdG93blByb3BzKCB2YWx1ZSApXG5cdFx0KVxuXHQpO1xufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBpc1BsYWluT2JqZWN0O1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBUZXN0IGlmIGEgdmFsdWUgaXMgYSBwbGFpbiBvYmplY3QuXG4qXG4qIEBtb2R1bGUgQHN0ZGxpYi9hc3NlcnQtaXMtcGxhaW4tb2JqZWN0XG4qXG4qIEBleGFtcGxlXG4qIHZhciBpc1BsYWluT2JqZWN0ID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLXBsYWluLW9iamVjdCcgKTtcbipcbiogdmFyIGJvb2wgPSBpc1BsYWluT2JqZWN0KCB7fSApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogYm9vbCA9IGlzUGxhaW5PYmplY3QoIG51bGwgKTtcbiogLy8gcmV0dXJucyBmYWxzZVxuKi9cblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoICcuL21haW4uanMnICk7XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUGxhaW5PYmplY3Q7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgaXNQb3NpdGl2ZSA9IHJlcXVpcmUoICdAc3RkbGliL2Fzc2VydC1pcy1wb3NpdGl2ZS1udW1iZXInICkuaXNQcmltaXRpdmU7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaXMtcGxhaW4tb2JqZWN0JyApO1xudmFyIGhhc093blByb3AgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaGFzLW93bi1wcm9wZXJ0eScgKTtcblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBWYWxpZGF0ZXMgZnVuY3Rpb24gb3B0aW9ucy5cbipcbiogQHByaXZhdGVcbiogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBkZXN0aW5hdGlvbiBvYmplY3RcbiogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zIC0gZnVuY3Rpb24gb3B0aW9uc1xuKiBAcGFyYW0ge1Bvc2l0aXZlTnVtYmVyfSBbb3B0aW9ucy5hbHBoYV0gLSBEaXJpY2hsZXQgaHlwZXItcGFyYW1ldGVyIG9mIHRvcGljIHZlY3RvciB0aGV0YTpcbiogQHBhcmFtIHtQb3NpdGl2ZU51bWJlcn0gW29wdGlvbnMuYmV0YV0gLSBEaXJpY2hsZXQgaHlwZXItcGFyYW1ldGVyIGZvciB3b3JkIHZlY3RvciBwaGlcbiogQHJldHVybnMgeyhFcnJvcnxudWxsKX0gbnVsbCBvciBhbiBlcnJvciBvYmplY3RcbipcbipcbiogQGV4YW1wbGVcbiogdmFyIG9wdHMgPSB7fTtcbiogdmFyIG9wdGlvbnMgPSB7fTtcbiogdmFyIGVyciA9IHZhbGlkYXRlKCBvcHRzLCBvcHRpb25zICk7XG4qIGlmICggZXJyICkge1xuKiAgICAgdGhyb3cgZXJyO1xuKiB9XG4qL1xuZnVuY3Rpb24gdmFsaWRhdGUoIG9wdHMsIG9wdGlvbnMgKSB7XG5cdGlmICggIWlzT2JqZWN0KCBvcHRpb25zICkgKSB7XG5cdFx0cmV0dXJuIG5ldyBUeXBlRXJyb3IoICdpbnZhbGlkIGFyZ3VtZW50LiBPcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0LiBWYWx1ZTogYCcgKyBvcHRpb25zICsgJ2AuJyApO1xuXHR9XG5cdGlmICggaGFzT3duUHJvcCggb3B0aW9ucywgJ2FscGhhJyApICkge1xuXHRcdG9wdHMuYWxwaGEgPSBvcHRpb25zLmFscGhhO1xuXHRcdGlmICggIWlzUG9zaXRpdmUoIG9wdHMuYWxwaGEgKSApIHtcblx0XHRcdHJldHVybiBuZXcgVHlwZUVycm9yKCAnaW52YWxpZCBvcHRpb24uIGBhbHBoYWAgb3B0aW9uIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXIuIE9wdGlvbjogYCcgKyBvcHRzLmFscGhhICsgJ2AuJyApO1xuXHRcdH1cblx0fVxuXHRpZiAoIGhhc093blByb3AoIG9wdGlvbnMsICdiZXRhJyApICkge1xuXHRcdG9wdHMuYmV0YSA9IG9wdGlvbnMuYmV0YTtcblx0XHRpZiAoICFpc1Bvc2l0aXZlKCBvcHRzLmJldGEgKSApIHtcblx0XHRcdHJldHVybiBuZXcgVHlwZUVycm9yKCAnaW52YWxpZCBvcHRpb24uIGBiZXRhYCBvcHRpb24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlci4gT3B0aW9uOiBgJyArIG9wdHMuYmV0YSArICdgLicgKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG51bGw7XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHZhbGlkYXRlO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIG1hdHJpeCA9IHJlcXVpcmUoICcuL21hdHJpeC5qcycgKTtcblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBHZXQgdGhlIHBoaSBtYXRyaXguIEVhY2ggcm93IGlzIGEgdG9waWMgZGlzdHJpYnV0aW9uIG92ZXIgd29yZHMuXG4qXG4qIEBwcml2YXRlXG4qIEByZXR1cm5zIHtNYXRyaXh9IHBoaSBwYXJhbWV0ZXIgbWF0cml4XG4qL1xuZnVuY3Rpb24gZ2V0UGhpcygpIHtcblx0LyogZXNsaW50LWRpc2FibGUgbm8taW52YWxpZC10aGlzICovXG5cdHZhciBQaGk7XG5cdHZhciB2YWw7XG5cdHZhciBrO1xuXHR2YXIgdztcblxuXHRQaGkgPSBtYXRyaXgoIFsgdGhpcy5LLCB0aGlzLlcgXSApO1xuXHRmb3IgKCBrID0gMDsgayA8IHRoaXMuSzsgaysrICkge1xuXHRcdGZvciAoIHcgPSAwOyB3IDwgdGhpcy5XOyB3KysgKSB7XG5cdFx0XHR2YWwgPSAoIHRoaXMubncuZ2V0KCB3LCBrICkgKyB0aGlzLmJldGEgKSAvXG5cdFx0XHRcdCggdGhpcy5ud1N1bVsgayBdICsgKCB0aGlzLlcqdGhpcy5iZXRhICkgKTtcblx0XHRcdFBoaS5zZXQoIGssIHcsIHZhbCApO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gUGhpO1xufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRQaGlzO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSggJ0BzdGRsaWIvdXRpbHMtZGVmaW5lLXByb3BlcnR5JyApO1xuXG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIERlZmluZXMgYSBub24tZW51bWVyYWJsZSByZWFkLW9ubHkgYWNjZXNzb3IuXG4qXG4qIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBvYmplY3Qgb24gd2hpY2ggdG8gZGVmaW5lIHRoZSBwcm9wZXJ0eVxuKiBAcGFyYW0geyhzdHJpbmd8c3ltYm9sKX0gcHJvcCAtIHByb3BlcnR5IG5hbWVcbiogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0dGVyIC0gYWNjZXNzb3JcbipcbiogQGV4YW1wbGVcbiogZnVuY3Rpb24gZ2V0dGVyKCkge1xuKiAgICAgcmV0dXJuICdiYXInO1xuKiB9XG4qXG4qIHZhciBvYmogPSB7fTtcbipcbiogc2V0Tm9uRW51bWVyYWJsZVJlYWRPbmx5QWNjZXNzb3IoIG9iaiwgJ2ZvbycsIGdldHRlciApO1xuKlxuKiB0cnkge1xuKiAgICAgb2JqLmZvbyA9ICdib29wJztcbiogfSBjYXRjaCAoIGVyciApIHtcbiogICAgIGNvbnNvbGUuZXJyb3IoIGVyci5tZXNzYWdlICk7XG4qIH1cbiovXG5mdW5jdGlvbiBzZXROb25FbnVtZXJhYmxlUmVhZE9ubHlBY2Nlc3Nvciggb2JqLCBwcm9wLCBnZXR0ZXIgKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgaWQtbGVuZ3RoXG5cdGRlZmluZVByb3BlcnR5KCBvYmosIHByb3AsIHtcblx0XHQnY29uZmlndXJhYmxlJzogZmFsc2UsXG5cdFx0J2VudW1lcmFibGUnOiBmYWxzZSxcblx0XHQnZ2V0JzogZ2V0dGVyXG5cdH0pO1xufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBzZXROb25FbnVtZXJhYmxlUmVhZE9ubHlBY2Nlc3NvcjtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogRGVmaW5lIGEgbm9uLWVudW1lcmFibGUgcmVhZC1vbmx5IGFjY2Vzc29yLlxuKlxuKiBAbW9kdWxlIEBzdGRsaWIvdXRpbHMtZGVmaW5lLW5vbmVudW1lcmFibGUtcmVhZC1vbmx5LWFjY2Vzc29yXG4qXG4qIEBleGFtcGxlXG4qIHZhciBzZXROb25FbnVtZXJhYmxlUmVhZE9ubHlBY2Nlc3NvciA9IHJlcXVpcmUoICdAc3RkbGliL3V0aWxzLWRlZmluZS1ub25lbnVtZXJhYmxlLXJlYWQtb25seS1hY2Nlc3NvcicgKTtcbipcbiogZnVuY3Rpb24gZ2V0dGVyKCkge1xuKiAgICAgcmV0dXJuICdiYXInO1xuKiB9XG4qXG4qIHZhciBvYmogPSB7fTtcbipcbiogc2V0Tm9uRW51bWVyYWJsZVJlYWRPbmx5QWNjZXNzb3IoIG9iaiwgJ2ZvbycsIGdldHRlciApO1xuKlxuKiB0cnkge1xuKiAgICAgb2JqLmZvbyA9ICdib29wJztcbiogfSBjYXRjaCAoIGVyciApIHtcbiogICAgIGNvbnNvbGUuZXJyb3IoIGVyci5tZXNzYWdlICk7XG4qIH1cbiovXG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIHNldE5vbkVudW1lcmFibGVSZWFkT25seUFjY2Vzc29yID0gcmVxdWlyZSggJy4vbWFpbi5qcycgKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBpZC1sZW5ndGhcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gc2V0Tm9uRW51bWVyYWJsZVJlYWRPbmx5QWNjZXNzb3I7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCAnQHN0ZGxpYi91dGlscy1kZWZpbmUtcHJvcGVydHknICk7XG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogRGVmaW5lcyBhIG5vbi1lbnVtZXJhYmxlIHJlYWQtd3JpdGUgYWNjZXNzb3IuXG4qXG4qIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBvYmplY3Qgb24gd2hpY2ggdG8gZGVmaW5lIHRoZSBwcm9wZXJ0eVxuKiBAcGFyYW0geyhzdHJpbmd8c3ltYm9sKX0gcHJvcCAtIHByb3BlcnR5IG5hbWVcbiogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0dGVyIC0gZ2V0IGFjY2Vzc29yXG4qIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciAtIHNldCBhY2Nlc3NvclxuKlxuKiBAZXhhbXBsZVxuKiBmdW5jdGlvbiBnZXR0ZXIoKSB7XG4qICAgICByZXR1cm4gbmFtZSArICcgZm9vJztcbiogfVxuKlxuKiBmdW5jdGlvbiBzZXR0ZXIoIHYgKSB7XG4qICAgICBuYW1lID0gdjtcbiogfVxuKlxuKiB2YXIgbmFtZSA9ICdiYXInO1xuKiB2YXIgb2JqID0ge307XG4qXG4qIHNldE5vbkVudW1lcmFibGVSZWFkV3JpdGVBY2Nlc3Nvciggb2JqLCAnZm9vJywgZ2V0dGVyLCBzZXR0ZXIgKTtcbipcbiogdmFyIHYgPSBvYmouZm9vO1xuKiAvLyByZXR1cm5zICdiYXIgZm9vJ1xuKlxuKiBvYmouZm9vID0gJ2JlZXAnO1xuKlxuKiB2ID0gb2JqLmZvbztcbiogLy8gcmV0dXJucyAnYmVlcCBmb28nXG4qL1xuZnVuY3Rpb24gc2V0Tm9uRW51bWVyYWJsZVJlYWRXcml0ZUFjY2Vzc29yKCBvYmosIHByb3AsIGdldHRlciwgc2V0dGVyICkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGlkLWxlbmd0aFxuXHRkZWZpbmVQcm9wZXJ0eSggb2JqLCBwcm9wLCB7XG5cdFx0J2NvbmZpZ3VyYWJsZSc6IGZhbHNlLFxuXHRcdCdlbnVtZXJhYmxlJzogZmFsc2UsXG5cdFx0J2dldCc6IGdldHRlcixcblx0XHQnc2V0Jzogc2V0dGVyXG5cdH0pO1xufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBzZXROb25FbnVtZXJhYmxlUmVhZFdyaXRlQWNjZXNzb3I7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIERlZmluZSBhIG5vbi1lbnVtZXJhYmxlIHJlYWQtd3JpdGUgYWNjZXNzb3IuXG4qXG4qIEBtb2R1bGUgQHN0ZGxpYi91dGlscy1kZWZpbmUtbm9uZW51bWVyYWJsZS1yZWFkLXdyaXRlLWFjY2Vzc29yXG4qXG4qIEBleGFtcGxlXG4qIHZhciBzZXROb25FbnVtZXJhYmxlUmVhZFdyaXRlQWNjZXNzb3IgPSByZXF1aXJlKCAnQHN0ZGxpYi91dGlscy1kZWZpbmUtbm9uZW51bWVyYWJsZS1yZWFkLXdyaXRlLWFjY2Vzc29yJyApO1xuKlxuKiBmdW5jdGlvbiBnZXR0ZXIoKSB7XG4qICAgICByZXR1cm4gbmFtZSArICcgZm9vJztcbiogfVxuKlxuKiBmdW5jdGlvbiBzZXR0ZXIoIHYgKSB7XG4qICAgICBuYW1lID0gdjtcbiogfVxuKlxuKiB2YXIgbmFtZSA9ICdiYXInO1xuKiB2YXIgb2JqID0ge307XG4qXG4qIHNldE5vbkVudW1lcmFibGVSZWFkV3JpdGVBY2Nlc3Nvciggb2JqLCAnZm9vJywgZ2V0dGVyLCBzZXR0ZXIgKTtcbipcbiogdmFyIHYgPSBvYmouZm9vO1xuKiAvLyByZXR1cm5zICdiYXIgZm9vJ1xuKlxuKiBvYmouZm9vID0gJ2JlZXAnO1xuKlxuKiB2ID0gb2JqLmZvbztcbiogLy8gcmV0dXJucyAnYmVlcCBmb28nXG4qL1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBzZXROb25FbnVtZXJhYmxlUmVhZFdyaXRlQWNjZXNzb3IgPSByZXF1aXJlKCAnLi9tYWluLmpzJyApO1xuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBzZXROb25FbnVtZXJhYmxlUmVhZFdyaXRlQWNjZXNzb3I7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIER1bW15IGZ1bmN0aW9uLlxuKlxuKiBAcHJpdmF0ZVxuKi9cbmZ1bmN0aW9uIGZvbygpIHtcblx0Ly8gTm8tb3AuLi5cbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gZm9vO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGZvbyA9IHJlcXVpcmUoICcuL2Zvby5qcycgKTtcblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBUZXN0cyBmb3IgbmF0aXZlIGZ1bmN0aW9uIGBuYW1lYCBzdXBwb3J0LlxuKlxuKiBAcmV0dXJucyB7Ym9vbGVhbn0gYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGFuIGVudmlyb25tZW50IGhhcyBmdW5jdGlvbiBgbmFtZWAgc3VwcG9ydFxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgYm9vbCA9IGhhc0Z1bmN0aW9uTmFtZVN1cHBvcnQoKTtcbiogLy8gcmV0dXJucyA8Ym9vbGVhbj5cbiovXG5mdW5jdGlvbiBoYXNGdW5jdGlvbk5hbWVTdXBwb3J0KCkge1xuXHRyZXR1cm4gKCBmb28ubmFtZSA9PT0gJ2ZvbycgKTtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaGFzRnVuY3Rpb25OYW1lU3VwcG9ydDtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogVGVzdCBmb3IgbmF0aXZlIGZ1bmN0aW9uIGBuYW1lYCBzdXBwb3J0LlxuKlxuKiBAbW9kdWxlIEBzdGRsaWIvYXNzZXJ0LWhhcy1mdW5jdGlvbi1uYW1lLXN1cHBvcnRcbipcbiogQGV4YW1wbGVcbiogdmFyIGhhc0Z1bmN0aW9uTmFtZVN1cHBvcnQgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaGFzLWZ1bmN0aW9uLW5hbWUtc3VwcG9ydCcgKTtcbipcbiogdmFyIGJvb2wgPSBoYXNGdW5jdGlvbk5hbWVTdXBwb3J0KCk7XG4qIC8vIHJldHVybnMgPGJvb2xlYW4+XG4qL1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBoYXNGdW5jdGlvbk5hbWVTdXBwb3J0ID0gcmVxdWlyZSggJy4vbWFpbi5qcycgKTtcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaGFzRnVuY3Rpb25OYW1lU3VwcG9ydDtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLWZ1bmN0aW9uJyApO1xudmFyIGhhc0Z1bmN0aW9uTmFtZVN1cHBvcnQgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaGFzLWZ1bmN0aW9uLW5hbWUtc3VwcG9ydCcgKTtcbnZhciBSRSA9IHJlcXVpcmUoICdAc3RkbGliL3JlZ2V4cC1mdW5jdGlvbi1uYW1lJyApLlJFR0VYUDtcblxuXG4vLyBWQVJJQUJMRVMgLy9cblxudmFyIGlzRnVuY3Rpb25OYW1lU3VwcG9ydGVkID0gaGFzRnVuY3Rpb25OYW1lU3VwcG9ydCgpO1xuXG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIFJldHVybnMgdGhlIG5hbWUgb2YgYSBmdW5jdGlvbi5cbipcbiogQHBhcmFtIHtGdW5jdGlvbn0gZmNuIC0gaW5wdXQgZnVuY3Rpb25cbiogQHRocm93cyB7VHlwZUVycm9yfSBtdXN0IHByb3ZpZGUgYSBmdW5jdGlvblxuKiBAcmV0dXJucyB7c3RyaW5nfSBmdW5jdGlvbiBuYW1lXG4qXG4qIEBleGFtcGxlXG4qIHZhciB2ID0gZnVuY3Rpb25OYW1lKCBNYXRoLnNxcnQgKTtcbiogLy8gcmV0dXJucyAnc3FydCdcbipcbiogQGV4YW1wbGVcbiogdmFyIHYgPSBmdW5jdGlvbk5hbWUoIGZ1bmN0aW9uIGZvbygpe30gKTtcbiogLy8gcmV0dXJucyAnZm9vJ1xuKlxuKiBAZXhhbXBsZVxuKiB2YXIgdiA9IGZ1bmN0aW9uTmFtZSggZnVuY3Rpb24oKXt9ICk7XG4qIC8vIHJldHVybnMgJycgfHwgJ2Fub255bW91cydcbipcbiogQGV4YW1wbGVcbiogdmFyIHYgPSBmdW5jdGlvbk5hbWUoIFN0cmluZyApO1xuKiAvLyByZXR1cm5zICdTdHJpbmcnXG4qL1xuZnVuY3Rpb24gZnVuY3Rpb25OYW1lKCBmY24gKSB7XG5cdC8vIFRPRE86IGFkZCBzdXBwb3J0IGZvciBnZW5lcmF0b3IgZnVuY3Rpb25zP1xuXHRpZiAoIGlzRnVuY3Rpb24oIGZjbiApID09PSBmYWxzZSApIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnaW52YWxpZCBhcmd1bWVudC4gTXVzdCBwcm92aWRlIGEgZnVuY3Rpb24uIFZhbHVlOiBgJyArIGZjbiArICdgLicgKTtcblx0fVxuXHRpZiAoIGlzRnVuY3Rpb25OYW1lU3VwcG9ydGVkICkge1xuXHRcdHJldHVybiBmY24ubmFtZTtcblx0fVxuXHRyZXR1cm4gUkUuZXhlYyggZmNuLnRvU3RyaW5nKCkgKVsgMSBdO1xufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbk5hbWU7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIFJldHVybiB0aGUgbmFtZSBvZiBhIGZ1bmN0aW9uLlxuKlxuKiBAbW9kdWxlIEBzdGRsaWIvdXRpbHMtZnVuY3Rpb24tbmFtZVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgZnVuY3Rpb25OYW1lID0gcmVxdWlyZSggJ0BzdGRsaWIvdXRpbHMtZnVuY3Rpb24tbmFtZScgKTtcbipcbiogdmFyIHYgPSBmdW5jdGlvbk5hbWUoIFN0cmluZyApO1xuKiAvLyByZXR1cm5zICdTdHJpbmcnXG4qXG4qIHYgPSBmdW5jdGlvbk5hbWUoIGZ1bmN0aW9uIGZvbygpe30gKTtcbiogLy8gcmV0dXJucyAnZm9vJ1xuKlxuKiB2ID0gZnVuY3Rpb25OYW1lKCBmdW5jdGlvbigpe30gKTtcbiogLy8gcmV0dXJucyAnJyB8fCAnYW5vbnltb3VzJ1xuKi9cblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgZnVuY3Rpb25OYW1lID0gcmVxdWlyZSggJy4vZnVuY3Rpb25fbmFtZS5qcycgKTtcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb25OYW1lO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIG5hdGl2ZUNsYXNzID0gcmVxdWlyZSggJ0BzdGRsaWIvdXRpbHMtbmF0aXZlLWNsYXNzJyApO1xuXG5cbi8vIFZBUklBQkxFUyAvL1xuXG52YXIgaGFzSW50OEFycmF5ID0gKCB0eXBlb2YgSW50OEFycmF5ID09PSAnZnVuY3Rpb24nICk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgc3RkbGliL3JlcXVpcmUtZ2xvYmFsc1xuXG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIFRlc3RzIGlmIGEgdmFsdWUgaXMgYW4gSW50OEFycmF5LlxuKlxuKiBAcGFyYW0geyp9IHZhbHVlIC0gdmFsdWUgdG8gdGVzdFxuKiBAcmV0dXJucyB7Ym9vbGVhbn0gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdmFsdWUgaXMgYW4gSW50OEFycmF5XG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaXNJbnQ4QXJyYXkoIG5ldyBJbnQ4QXJyYXkoIDEwICkgKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaXNJbnQ4QXJyYXkoIFtdICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbiovXG5mdW5jdGlvbiBpc0ludDhBcnJheSggdmFsdWUgKSB7XG5cdHJldHVybiAoXG5cdFx0KCBoYXNJbnQ4QXJyYXkgJiYgdmFsdWUgaW5zdGFuY2VvZiBJbnQ4QXJyYXkgKSB8fCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHN0ZGxpYi9yZXF1aXJlLWdsb2JhbHNcblx0XHRuYXRpdmVDbGFzcyggdmFsdWUgKSA9PT0gJ1tvYmplY3QgSW50OEFycmF5XSdcblx0KTtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNJbnQ4QXJyYXk7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIFRlc3QgaWYgYSB2YWx1ZSBpcyBhbiBJbnQ4QXJyYXkuXG4qXG4qIEBtb2R1bGUgQHN0ZGxpYi9hc3NlcnQtaXMtaW50OGFycmF5XG4qXG4qIEBleGFtcGxlXG4qIHZhciBpc0ludDhBcnJheSA9IHJlcXVpcmUoICdAc3RkbGliL2Fzc2VydC1pcy1pbnQ4YXJyYXknICk7XG4qXG4qIHZhciBib29sID0gaXNJbnQ4QXJyYXkoIG5ldyBJbnQ4QXJyYXkoIDEwICkgKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qXG4qIGJvb2wgPSBpc0ludDhBcnJheSggW10gKTtcbiogLy8gcmV0dXJucyBmYWxzZVxuKi9cblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgaXNJbnQ4QXJyYXkgPSByZXF1aXJlKCAnLi9tYWluLmpzJyApO1xuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBpc0ludDhBcnJheTtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogTWF4aW11bSBzaWduZWQgOC1iaXQgaW50ZWdlci5cbipcbiogQG1vZHVsZSBAc3RkbGliL2NvbnN0YW50cy1pbnQ4LW1heFxuKiBAdHlwZSB7aW50ZWdlcjMyfVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgSU5UOF9NQVggPSByZXF1aXJlKCAnQHN0ZGxpYi9jb25zdGFudHMtaW50OC1tYXgnICk7XG4qIC8vIHJldHVybnMgMTI3XG4qL1xuXG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIE1heGltdW0gc2lnbmVkIDgtYml0IGludGVnZXIuXG4qXG4qICMjIE5vdGVzXG4qXG4qIFRoZSBudW1iZXIgaXMgZ2l2ZW4gYnlcbipcbiogYGBgdGV4XG4qIDJeezd9IC0gMVxuKiBgYGBcbipcbiogd2hpY2ggY29ycmVzcG9uZHMgdG8gdGhlIGJpdCBzZXF1ZW5jZVxuKlxuKiBgYGBiaW5hcnlzdHJpbmdcbiogMDExMTExMTFcbiogYGBgXG4qXG4qIEBjb25zdGFudFxuKiBAdHlwZSB7aW50ZWdlcjMyfVxuKiBAZGVmYXVsdCAxMjdcbiovXG52YXIgSU5UOF9NQVggPSAxMjd8MDsgLy8gYXNtIHR5cGUgYW5ub3RhdGlvblxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBJTlQ4X01BWDtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogTWluaW11bSBzaWduZWQgOC1iaXQgaW50ZWdlci5cbipcbiogQG1vZHVsZSBAc3RkbGliL2NvbnN0YW50cy1pbnQ4LW1pblxuKiBAdHlwZSB7aW50ZWdlcjMyfVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgSU5UOF9NSU4gPSByZXF1aXJlKCAnQHN0ZGxpYi9jb25zdGFudHMtaW50OC1taW4nICk7XG4qIC8vIHJldHVybnMgLTEyOFxuKi9cblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBNaW5pbXVtIHNpZ25lZCA4LWJpdCBpbnRlZ2VyLlxuKlxuKiAjIyBOb3Rlc1xuKlxuKiBUaGUgbnVtYmVyIGlzIGdpdmVuIGJ5XG4qXG4qIGBgYHRleFxuKiAtKDJeezd9KVxuKiBgYGBcbipcbiogd2hpY2ggY29ycmVzcG9uZHMgdG8gdGhlIHR3bydzIGNvbXBsZW1lbnQgYml0IHNlcXVlbmNlXG4qXG4qIGBgYGJpbmFyeXN0cmluZ1xuKiAxMDAwMDAwMFxuKiBgYGBcbipcbiogQGNvbnN0YW50XG4qIEB0eXBlIHtpbnRlZ2VyMzJ9XG4qIEBkZWZhdWx0IC0xMjhcbiovXG52YXIgSU5UOF9NSU4gPSAtMTI4fDA7IC8vIGFzbSB0eXBlIGFubm90YXRpb25cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gSU5UOF9NSU47XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTUFJTiAvL1xuXG52YXIgbWFpbiA9ICggdHlwZW9mIEludDhBcnJheSA9PT0gJ2Z1bmN0aW9uJyApID8gSW50OEFycmF5IDogbnVsbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBzdGRsaWIvcmVxdWlyZS1nbG9iYWxzXG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1haW47XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgaXNJbnQ4QXJyYXkgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaXMtaW50OGFycmF5JyApO1xudmFyIElOVDhfTUFYID0gcmVxdWlyZSggJ0BzdGRsaWIvY29uc3RhbnRzLWludDgtbWF4JyApO1xudmFyIElOVDhfTUlOID0gcmVxdWlyZSggJ0BzdGRsaWIvY29uc3RhbnRzLWludDgtbWluJyApO1xudmFyIEdsb2JhbEludDhBcnJheSA9IHJlcXVpcmUoICcuL2ludDhhcnJheS5qcycgKTtcblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBUZXN0cyBmb3IgbmF0aXZlIGBJbnQ4QXJyYXlgIHN1cHBvcnQuXG4qXG4qIEByZXR1cm5zIHtib29sZWFufSBib29sZWFuIGluZGljYXRpbmcgaWYgYW4gZW52aXJvbm1lbnQgaGFzIGBJbnQ4QXJyYXlgIHN1cHBvcnRcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBoYXNJbnQ4QXJyYXlTdXBwb3J0KCk7XG4qIC8vIHJldHVybnMgPGJvb2xlYW4+XG4qL1xuZnVuY3Rpb24gaGFzSW50OEFycmF5U3VwcG9ydCgpIHtcblx0dmFyIGJvb2w7XG5cdHZhciBhcnI7XG5cblx0aWYgKCB0eXBlb2YgR2xvYmFsSW50OEFycmF5ICE9PSAnZnVuY3Rpb24nICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHQvLyBUZXN0IGJhc2ljIHN1cHBvcnQuLi5cblx0dHJ5IHtcblx0XHRhcnIgPSBuZXcgR2xvYmFsSW50OEFycmF5KCBbIDEsIDMuMTQsIC0zLjE0LCBJTlQ4X01BWCsxIF0gKTtcblx0XHRib29sID0gKFxuXHRcdFx0aXNJbnQ4QXJyYXkoIGFyciApICYmXG5cdFx0XHRhcnJbIDAgXSA9PT0gMSAmJlxuXHRcdFx0YXJyWyAxIF0gPT09IDMgJiYgICAgIC8vIHRydW5jYXRpb25cblx0XHRcdGFyclsgMiBdID09PSAtMyAmJiAgICAvLyB0cnVuY2F0aW9uXG5cdFx0XHRhcnJbIDMgXSA9PT0gSU5UOF9NSU4gLy8gd3JhcCBhcm91bmRcblx0XHQpO1xuXHR9IGNhdGNoICggZXJyICkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cdFx0Ym9vbCA9IGZhbHNlO1xuXHR9XG5cdHJldHVybiBib29sO1xufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNJbnQ4QXJyYXlTdXBwb3J0O1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBUZXN0IGZvciBuYXRpdmUgYEludDhBcnJheWAgc3VwcG9ydC5cbipcbiogQG1vZHVsZSBAc3RkbGliL2Fzc2VydC1oYXMtaW50OGFycmF5LXN1cHBvcnRcbipcbiogQGV4YW1wbGVcbiogdmFyIGhhc0ludDhBcnJheVN1cHBvcnQgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaGFzLWludDhhcnJheS1zdXBwb3J0JyApO1xuKlxuKiB2YXIgYm9vbCA9IGhhc0ludDhBcnJheVN1cHBvcnQoKTtcbiogLy8gcmV0dXJucyA8Ym9vbGVhbj5cbiovXG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGhhc0ludDhBcnJheVN1cHBvcnQgPSByZXF1aXJlKCAnLi9tYWluLmpzJyApO1xuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNJbnQ4QXJyYXlTdXBwb3J0O1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1BSU4gLy9cblxudmFyIGN0b3IgPSAoIHR5cGVvZiBJbnQ4QXJyYXkgPT09ICdmdW5jdGlvbicgKSA/IEludDhBcnJheSA6IHZvaWQgMDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBzdGRsaWIvcmVxdWlyZS1nbG9iYWxzXG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGN0b3I7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gVE9ETzogd3JpdGUgcG9seWZpbGxcblxuLy8gTUFJTiAvL1xuXG4vKipcbiogVHlwZWQgYXJyYXkgd2hpY2ggcmVwcmVzZW50cyBhbiBhcnJheSBvZiB0d29zLWNvbXBsZW1lbnQgOC1iaXQgc2lnbmVkIGludGVnZXJzIGluIHRoZSBwbGF0Zm9ybSBieXRlIG9yZGVyLlxuKlxuKiBAdGhyb3dzIHtFcnJvcn0gbm90IGltcGxlbWVudGVkXG4qL1xuZnVuY3Rpb24gcG9seWZpbGwoKSB7XG5cdHRocm93IG5ldyBFcnJvciggJ25vdCBpbXBsZW1lbnRlZCcgKTtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gcG9seWZpbGw7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIFR5cGVkIGFycmF5IGNvbnN0cnVjdG9yIHdoaWNoIHJldHVybnMgYSB0eXBlZCBhcnJheSByZXByZXNlbnRpbmcgYW4gYXJyYXkgb2YgdHdvcy1jb21wbGVtZW50IDgtYml0IHNpZ25lZCBpbnRlZ2VycyBpbiB0aGUgcGxhdGZvcm0gYnl0ZSBvcmRlci5cbipcbiogQG1vZHVsZSBAc3RkbGliL2FycmF5LWludDhcbipcbiogQGV4YW1wbGVcbiogdmFyIGN0b3IgPSByZXF1aXJlKCAnQHN0ZGxpYi9hcnJheS1pbnQ4JyApO1xuKlxuKiB2YXIgYXJyID0gbmV3IGN0b3IoIDEwICk7XG4qIC8vIHJldHVybnMgPEludDhBcnJheT5cbiovXG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGhhc0ludDhBcnJheVN1cHBvcnQgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaGFzLWludDhhcnJheS1zdXBwb3J0JyApO1xudmFyIGJ1aWx0aW4gPSByZXF1aXJlKCAnLi9pbnQ4YXJyYXkuanMnICk7XG52YXIgcG9seWZpbGwgPSByZXF1aXJlKCAnLi9wb2x5ZmlsbC5qcycgKTtcblxuXG4vLyBNQUlOIC8vXG5cbnZhciBjdG9yO1xuaWYgKCBoYXNJbnQ4QXJyYXlTdXBwb3J0KCkgKSB7XG5cdGN0b3IgPSBidWlsdGluO1xufSBlbHNlIHtcblx0Y3RvciA9IHBvbHlmaWxsO1xufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBjdG9yO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIG5hdGl2ZUNsYXNzID0gcmVxdWlyZSggJ0BzdGRsaWIvdXRpbHMtbmF0aXZlLWNsYXNzJyApO1xuXG5cbi8vIFZBUklBQkxFUyAvL1xuXG52YXIgaGFzVWludDhDbGFtcGVkQXJyYXkgPSAoIHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSA9PT0gJ2Z1bmN0aW9uJyApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHN0ZGxpYi9yZXF1aXJlLWdsb2JhbHNcblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBUZXN0cyBpZiBhIHZhbHVlIGlzIGEgVWludDhDbGFtcGVkQXJyYXkuXG4qXG4qIEBwYXJhbSB7Kn0gdmFsdWUgLSB2YWx1ZSB0byB0ZXN0XG4qIEByZXR1cm5zIHtib29sZWFufSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB2YWx1ZSBpcyBhIFVpbnQ4Q2xhbXBlZEFycmF5XG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaXNVaW50OENsYW1wZWRBcnJheSggbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KCAxMCApICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgYm9vbCA9IGlzVWludDhDbGFtcGVkQXJyYXkoIFtdICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbiovXG5mdW5jdGlvbiBpc1VpbnQ4Q2xhbXBlZEFycmF5KCB2YWx1ZSApIHtcblx0cmV0dXJuIChcblx0XHQoIGhhc1VpbnQ4Q2xhbXBlZEFycmF5ICYmIHZhbHVlIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkgKSB8fCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHN0ZGxpYi9yZXF1aXJlLWdsb2JhbHNcblx0XHRuYXRpdmVDbGFzcyggdmFsdWUgKSA9PT0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJ1xuXHQpO1xufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBpc1VpbnQ4Q2xhbXBlZEFycmF5O1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBUZXN0IGlmIGEgdmFsdWUgaXMgYSBVaW50OENsYW1wZWRBcnJheS5cbipcbiogQG1vZHVsZSBAc3RkbGliL2Fzc2VydC1pcy11aW50OGNsYW1wZWRhcnJheVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgaXNVaW50OENsYW1wZWRBcnJheSA9IHJlcXVpcmUoICdAc3RkbGliL2Fzc2VydC1pcy11aW50OGNsYW1wZWRhcnJheScgKTtcbipcbiogdmFyIGJvb2wgPSBpc1VpbnQ4Q2xhbXBlZEFycmF5KCBuZXcgVWludDhDbGFtcGVkQXJyYXkoIDEwICkgKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qXG4qIGJvb2wgPSBpc1VpbnQ4Q2xhbXBlZEFycmF5KCBbXSApO1xuKiAvLyByZXR1cm5zIGZhbHNlXG4qL1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBpc1VpbnQ4Q2xhbXBlZEFycmF5ID0gcmVxdWlyZSggJy4vbWFpbi5qcycgKTtcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNVaW50OENsYW1wZWRBcnJheTtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNQUlOIC8vXG5cbnZhciBtYWluID0gKCB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgPT09ICdmdW5jdGlvbicgKSA/IFVpbnQ4Q2xhbXBlZEFycmF5IDogbnVsbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBzdGRsaWIvcmVxdWlyZS1nbG9iYWxzXG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1haW47XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgaXNVaW50OENsYW1wZWRBcnJheSA9IHJlcXVpcmUoICdAc3RkbGliL2Fzc2VydC1pcy11aW50OGNsYW1wZWRhcnJheScgKTtcbnZhciBHbG9iYWxVaW50OENsYW1wZWRBcnJheSA9IHJlcXVpcmUoICcuL3VpbnQ4Y2xhbXBlZGFycmF5LmpzJyApO1xuXG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIFRlc3RzIGZvciBuYXRpdmUgYFVpbnQ4Q2xhbXBlZEFycmF5YCBzdXBwb3J0LlxuKlxuKiBAcmV0dXJucyB7Ym9vbGVhbn0gYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGFuIGVudmlyb25tZW50IGhhcyBgVWludDhDbGFtcGVkQXJyYXlgIHN1cHBvcnRcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBoYXNVaW50OENsYW1wZWRBcnJheVN1cHBvcnQoKTtcbiogLy8gcmV0dXJucyA8Ym9vbGVhbj5cbiovXG5mdW5jdGlvbiBoYXNVaW50OENsYW1wZWRBcnJheVN1cHBvcnQoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgaWQtbGVuZ3RoXG5cdHZhciBib29sO1xuXHR2YXIgYXJyO1xuXG5cdGlmICggdHlwZW9mIEdsb2JhbFVpbnQ4Q2xhbXBlZEFycmF5ICE9PSAnZnVuY3Rpb24nICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHQvLyBUZXN0IGJhc2ljIHN1cHBvcnQuLi5cblx0dHJ5IHtcblx0XHRhcnIgPSBuZXcgR2xvYmFsVWludDhDbGFtcGVkQXJyYXkoIFsgLTEsIDAsIDEsIDMuMTQsIDQuOTksIDI1NSwgMjU2IF0gKTtcblx0XHRib29sID0gKFxuXHRcdFx0aXNVaW50OENsYW1wZWRBcnJheSggYXJyICkgJiZcblx0XHRcdGFyclsgMCBdID09PSAwICYmICAgLy8gY2xhbXBlZFxuXHRcdFx0YXJyWyAxIF0gPT09IDAgJiZcblx0XHRcdGFyclsgMiBdID09PSAxICYmXG5cdFx0XHRhcnJbIDMgXSA9PT0gMyAmJiAgIC8vIHJvdW5kIHRvIG5lYXJlc3Rcblx0XHRcdGFyclsgNCBdID09PSA1ICYmICAgLy8gcm91bmQgdG8gbmVhcmVzdFxuXHRcdFx0YXJyWyA1IF0gPT09IDI1NSAmJlxuXHRcdFx0YXJyWyA2IF0gPT09IDI1NSAgICAvLyBjbGFtcGVkXG5cdFx0KTtcblx0fSBjYXRjaCAoIGVyciApIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXHRcdGJvb2wgPSBmYWxzZTtcblx0fVxuXHRyZXR1cm4gYm9vbDtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaGFzVWludDhDbGFtcGVkQXJyYXlTdXBwb3J0O1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBUZXN0IGZvciBuYXRpdmUgYFVpbnQ4Q2xhbXBlZEFycmF5YCBzdXBwb3J0LlxuKlxuKiBAbW9kdWxlIEBzdGRsaWIvYXNzZXJ0LWhhcy11aW50OGNsYW1wZWRhcnJheS1zdXBwb3J0XG4qXG4qIEBleGFtcGxlXG4qIHZhciBoYXNVaW50OENsYW1wZWRBcnJheVN1cHBvcnQgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaGFzLXVpbnQ4Y2xhbXBlZGFycmF5LXN1cHBvcnQnICk7XG4qXG4qIHZhciBib29sID0gaGFzVWludDhDbGFtcGVkQXJyYXlTdXBwb3J0KCk7XG4qIC8vIHJldHVybnMgPGJvb2xlYW4+XG4qL1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBoYXNVaW50OENsYW1wZWRBcnJheVN1cHBvcnQgPSByZXF1aXJlKCAnLi9tYWluLmpzJyApO1xuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNVaW50OENsYW1wZWRBcnJheVN1cHBvcnQ7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTUFJTiAvL1xuXG52YXIgY3RvciA9ICggdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ID09PSAnZnVuY3Rpb24nICkgPyBVaW50OENsYW1wZWRBcnJheSA6IHZvaWQgMDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBzdGRsaWIvcmVxdWlyZS1nbG9iYWxzXG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGN0b3I7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gVE9ETzogd3JpdGUgcG9seWZpbGxcblxuLy8gTUFJTiAvL1xuXG4vKipcbiogVHlwZWQgYXJyYXkgd2hpY2ggcmVwcmVzZW50cyBhbiBhcnJheSBvZiA4LWJpdCB1bnNpZ25lZCBpbnRlZ2VycyBpbiB0aGUgcGxhdGZvcm0gYnl0ZSBvcmRlciBjbGFtcGVkIHRvIDAtMjU1LlxuKlxuKiBAdGhyb3dzIHtFcnJvcn0gbm90IGltcGxlbWVudGVkXG4qL1xuZnVuY3Rpb24gcG9seWZpbGwoKSB7XG5cdHRocm93IG5ldyBFcnJvciggJ25vdCBpbXBsZW1lbnRlZCcgKTtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gcG9seWZpbGw7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIFR5cGVkIGFycmF5IGNvbnN0cnVjdG9yIHdoaWNoIHJldHVybnMgYSB0eXBlZCBhcnJheSByZXByZXNlbnRpbmcgYW4gYXJyYXkgb2YgOC1iaXQgdW5zaWduZWQgaW50ZWdlcnMgaW4gdGhlIHBsYXRmb3JtIGJ5dGUgb3JkZXIgY2xhbXBlZCB0byAwLTI1NS5cbipcbiogQG1vZHVsZSBAc3RkbGliL2FycmF5LXVpbnQ4Y1xuKlxuKiBAZXhhbXBsZVxuKiB2YXIgY3RvciA9IHJlcXVpcmUoICdAc3RkbGliL2FycmF5LXVpbnQ4YycgKTtcbipcbiogdmFyIGFyciA9IG5ldyBjdG9yKCAxMCApO1xuKiAvLyByZXR1cm5zIDxVaW50OENsYW1wZWRBcnJheT5cbiovXG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGhhc1VpbnQ4Q2xhbXBlZEFycmF5U3VwcG9ydCA9IHJlcXVpcmUoICdAc3RkbGliL2Fzc2VydC1oYXMtdWludDhjbGFtcGVkYXJyYXktc3VwcG9ydCcgKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBpZC1sZW5ndGhcbnZhciBidWlsdGluID0gcmVxdWlyZSggJy4vdWludDhjbGFtcGVkYXJyYXkuanMnICk7XG52YXIgcG9seWZpbGwgPSByZXF1aXJlKCAnLi9wb2x5ZmlsbC5qcycgKTtcblxuXG4vLyBNQUlOIC8vXG5cbnZhciBjdG9yO1xuaWYgKCBoYXNVaW50OENsYW1wZWRBcnJheVN1cHBvcnQoKSApIHtcblx0Y3RvciA9IGJ1aWx0aW47XG59IGVsc2Uge1xuXHRjdG9yID0gcG9seWZpbGw7XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGN0b3I7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgbmF0aXZlQ2xhc3MgPSByZXF1aXJlKCAnQHN0ZGxpYi91dGlscy1uYXRpdmUtY2xhc3MnICk7XG5cblxuLy8gVkFSSUFCTEVTIC8vXG5cbnZhciBoYXNJbnQxNkFycmF5ID0gKCB0eXBlb2YgSW50MTZBcnJheSA9PT0gJ2Z1bmN0aW9uJyApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHN0ZGxpYi9yZXF1aXJlLWdsb2JhbHNcblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBUZXN0cyBpZiBhIHZhbHVlIGlzIGFuIEludDE2QXJyYXkuXG4qXG4qIEBwYXJhbSB7Kn0gdmFsdWUgLSB2YWx1ZSB0byB0ZXN0XG4qIEByZXR1cm5zIHtib29sZWFufSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB2YWx1ZSBpcyBhbiBJbnQxNkFycmF5XG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaXNJbnQxNkFycmF5KCBuZXcgSW50MTZBcnJheSggMTAgKSApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBpc0ludDE2QXJyYXkoIFtdICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbiovXG5mdW5jdGlvbiBpc0ludDE2QXJyYXkoIHZhbHVlICkge1xuXHRyZXR1cm4gKFxuXHRcdCggaGFzSW50MTZBcnJheSAmJiB2YWx1ZSBpbnN0YW5jZW9mIEludDE2QXJyYXkgKSB8fCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHN0ZGxpYi9yZXF1aXJlLWdsb2JhbHNcblx0XHRuYXRpdmVDbGFzcyggdmFsdWUgKSA9PT0gJ1tvYmplY3QgSW50MTZBcnJheV0nXG5cdCk7XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSW50MTZBcnJheTtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogVGVzdCBpZiBhIHZhbHVlIGlzIGFuIEludDE2QXJyYXkuXG4qXG4qIEBtb2R1bGUgQHN0ZGxpYi9hc3NlcnQtaXMtaW50MTZhcnJheVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgaXNJbnQxNkFycmF5ID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLWludDE2YXJyYXknICk7XG4qXG4qIHZhciBib29sID0gaXNJbnQxNkFycmF5KCBuZXcgSW50MTZBcnJheSggMTAgKSApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogYm9vbCA9IGlzSW50MTZBcnJheSggW10gKTtcbiogLy8gcmV0dXJucyBmYWxzZVxuKi9cblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgaXNJbnQxNkFycmF5ID0gcmVxdWlyZSggJy4vbWFpbi5qcycgKTtcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNJbnQxNkFycmF5O1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBNYXhpbXVtIHNpZ25lZCAxNi1iaXQgaW50ZWdlci5cbipcbiogQG1vZHVsZSBAc3RkbGliL2NvbnN0YW50cy1pbnQxNi1tYXhcbiogQHR5cGUge2ludGVnZXIzMn1cbipcbiogQGV4YW1wbGVcbiogdmFyIElOVDE2X01BWCA9IHJlcXVpcmUoICdAc3RkbGliL2NvbnN0YW50cy1pbnQxNi1tYXgnICk7XG4qIC8vIHJldHVybnMgMzI3NjdcbiovXG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogTWF4aW11bSBzaWduZWQgMTYtYml0IGludGVnZXIuXG4qXG4qICMjIE5vdGVzXG4qXG4qIFRoZSBudW1iZXIgaGFzIHRoZSB2YWx1ZVxuKlxuKiBgYGB0ZXhcbiogMl57MTV9IC0gMVxuKiBgYGBcbipcbiogd2hpY2ggY29ycmVzcG9uZHMgdG8gdGhlIGJpdCBzZXF1ZW5jZVxuKlxuKiBgYGBiaW5hcnlzdHJpbmdcbiogMDExMTExMTExMTExMTExMVxuKiBgYGBcbipcbiogQGNvbnN0YW50XG4qIEB0eXBlIHtpbnRlZ2VyMzJ9XG4qIEBkZWZhdWx0IDMyNzY3XG4qL1xudmFyIElOVDE2X01BWCA9IDMyNzY3fDA7IC8vIGFzbSB0eXBlIGFubm90YXRpb25cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gSU5UMTZfTUFYO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBNaW5pbXVtIHNpZ25lZCAxNi1iaXQgaW50ZWdlci5cbipcbiogQG1vZHVsZSBAc3RkbGliL2NvbnN0YW50cy1pbnQxNi1taW5cbiogQHR5cGUge2ludGVnZXIzMn1cbipcbiogQGV4YW1wbGVcbiogdmFyIElOVDE2X01JTiA9IHJlcXVpcmUoICdAc3RkbGliL2NvbnN0YW50cy1pbnQxNi1taW4nICk7XG4qIC8vIHJldHVybnMgLTMyNzY4XG4qL1xuXG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIE1pbmltdW0gc2lnbmVkIDE2LWJpdCBpbnRlZ2VyLlxuKlxuKiAjIyBOb3Rlc1xuKlxuKiBUaGUgbnVtYmVyIGhhcyB0aGUgdmFsdWVcbipcbiogYGBgdGV4XG4qIC0oMl57MTV9KVxuKiBgYGBcbipcbiogd2hpY2ggY29ycmVzcG9uZHMgdG8gdGhlIHR3bydzIGNvbXBsZW1lbnQgYml0IHNlcXVlbmNlXG4qXG4qIGBgYGJpbmFyeXN0cmluZ1xuKiAxMDAwMDAwMDAwMDAwMDAwXG4qIGBgYFxuKlxuKiBAY29uc3RhbnRcbiogQHR5cGUge2ludGVnZXIzMn1cbiogQGRlZmF1bHQgLTMyNzY4XG4qL1xudmFyIElOVDE2X01JTiA9IC0zMjc2OHwwOyAvLyBhc20gdHlwZSBhbm5vdGF0aW9uXG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IElOVDE2X01JTjtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNQUlOIC8vXG5cbnZhciBtYWluID0gKCB0eXBlb2YgSW50MTZBcnJheSA9PT0gJ2Z1bmN0aW9uJyApID8gSW50MTZBcnJheSA6IG51bGw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgc3RkbGliL3JlcXVpcmUtZ2xvYmFsc1xuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBtYWluO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGlzSW50MTZBcnJheSA9IHJlcXVpcmUoICdAc3RkbGliL2Fzc2VydC1pcy1pbnQxNmFycmF5JyApO1xudmFyIElOVDE2X01BWCA9IHJlcXVpcmUoICdAc3RkbGliL2NvbnN0YW50cy1pbnQxNi1tYXgnICk7XG52YXIgSU5UMTZfTUlOID0gcmVxdWlyZSggJ0BzdGRsaWIvY29uc3RhbnRzLWludDE2LW1pbicgKTtcbnZhciBHbG9iYWxJbnQxNkFycmF5ID0gcmVxdWlyZSggJy4vaW50MTZhcnJheS5qcycgKTtcblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBUZXN0cyBmb3IgbmF0aXZlIGBJbnQxNkFycmF5YCBzdXBwb3J0LlxuKlxuKiBAcmV0dXJucyB7Ym9vbGVhbn0gYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGFuIGVudmlyb25tZW50IGhhcyBgSW50MTZBcnJheWAgc3VwcG9ydFxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgYm9vbCA9IGhhc0ludDE2QXJyYXlTdXBwb3J0KCk7XG4qIC8vIHJldHVybnMgPGJvb2xlYW4+XG4qL1xuZnVuY3Rpb24gaGFzSW50MTZBcnJheVN1cHBvcnQoKSB7XG5cdHZhciBib29sO1xuXHR2YXIgYXJyO1xuXG5cdGlmICggdHlwZW9mIEdsb2JhbEludDE2QXJyYXkgIT09ICdmdW5jdGlvbicgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdC8vIFRlc3QgYmFzaWMgc3VwcG9ydC4uLlxuXHR0cnkge1xuXHRcdGFyciA9IG5ldyBHbG9iYWxJbnQxNkFycmF5KCBbIDEsIDMuMTQsIC0zLjE0LCBJTlQxNl9NQVgrMSBdICk7XG5cdFx0Ym9vbCA9IChcblx0XHRcdGlzSW50MTZBcnJheSggYXJyICkgJiZcblx0XHRcdGFyclsgMCBdID09PSAxICYmXG5cdFx0XHRhcnJbIDEgXSA9PT0gMyAmJiAgICAgIC8vIHRydW5jYXRpb25cblx0XHRcdGFyclsgMiBdID09PSAtMyAmJiAgICAgLy8gdHJ1bmNhdGlvblxuXHRcdFx0YXJyWyAzIF0gPT09IElOVDE2X01JTiAvLyB3cmFwIGFyb3VuZFxuXHRcdCk7XG5cdH0gY2F0Y2ggKCBlcnIgKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblx0XHRib29sID0gZmFsc2U7XG5cdH1cblx0cmV0dXJuIGJvb2w7XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc0ludDE2QXJyYXlTdXBwb3J0O1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBUZXN0IGZvciBuYXRpdmUgYEludDE2QXJyYXlgIHN1cHBvcnQuXG4qXG4qIEBtb2R1bGUgQHN0ZGxpYi9hc3NlcnQtaGFzLWludDE2YXJyYXktc3VwcG9ydFxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgaGFzSW50MTZBcnJheVN1cHBvcnQgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaGFzLWludDE2YXJyYXktc3VwcG9ydCcgKTtcbipcbiogdmFyIGJvb2wgPSBoYXNJbnQxNkFycmF5U3VwcG9ydCgpO1xuKiAvLyByZXR1cm5zIDxib29sZWFuPlxuKi9cblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgaGFzSW50MTZBcnJheVN1cHBvcnQgPSByZXF1aXJlKCAnLi9tYWluLmpzJyApO1xuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNJbnQxNkFycmF5U3VwcG9ydDtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNQUlOIC8vXG5cbnZhciBjdG9yID0gKCB0eXBlb2YgSW50MTZBcnJheSA9PT0gJ2Z1bmN0aW9uJyApID8gSW50MTZBcnJheSA6IHZvaWQgMDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBzdGRsaWIvcmVxdWlyZS1nbG9iYWxzXG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGN0b3I7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gVE9ETzogd3JpdGUgcG9seWZpbGxcblxuLy8gTUFJTiAvL1xuXG4vKipcbiogVHlwZWQgYXJyYXkgd2hpY2ggcmVwcmVzZW50cyBhbiBhcnJheSBvZiB0d29zLWNvbXBsZW1lbnQgMTYtYml0IHNpZ25lZCBpbnRlZ2VycyBpbiB0aGUgcGxhdGZvcm0gYnl0ZSBvcmRlci5cbipcbiogQHRocm93cyB7RXJyb3J9IG5vdCBpbXBsZW1lbnRlZFxuKi9cbmZ1bmN0aW9uIHBvbHlmaWxsKCkge1xuXHR0aHJvdyBuZXcgRXJyb3IoICdub3QgaW1wbGVtZW50ZWQnICk7XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBvbHlmaWxsO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBUeXBlZCBhcnJheSBjb25zdHJ1Y3RvciB3aGljaCByZXR1cm5zIGEgdHlwZWQgYXJyYXkgcmVwcmVzZW50aW5nIGFuIGFycmF5IG9mIHR3b3MtY29tcGxlbWVudCAxNi1iaXQgc2lnbmVkIGludGVnZXJzIGluIHRoZSBwbGF0Zm9ybSBieXRlIG9yZGVyLlxuKlxuKiBAbW9kdWxlIEBzdGRsaWIvYXJyYXktaW50MTZcbipcbiogQGV4YW1wbGVcbiogdmFyIGN0b3IgPSByZXF1aXJlKCAnQHN0ZGxpYi9hcnJheS1pbnQxNicgKTtcbipcbiogdmFyIGFyciA9IG5ldyBjdG9yKCAxMCApO1xuKiAvLyByZXR1cm5zIDxJbnQxNkFycmF5PlxuKi9cblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgaGFzSW50MTZBcnJheVN1cHBvcnQgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaGFzLWludDE2YXJyYXktc3VwcG9ydCcgKTtcbnZhciBidWlsdGluID0gcmVxdWlyZSggJy4vaW50MTZhcnJheS5qcycgKTtcbnZhciBwb2x5ZmlsbCA9IHJlcXVpcmUoICcuL3BvbHlmaWxsLmpzJyApO1xuXG5cbi8vIE1BSU4gLy9cblxudmFyIGN0b3I7XG5pZiAoIGhhc0ludDE2QXJyYXlTdXBwb3J0KCkgKSB7XG5cdGN0b3IgPSBidWlsdGluO1xufSBlbHNlIHtcblx0Y3RvciA9IHBvbHlmaWxsO1xufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBjdG9yO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIG5hdGl2ZUNsYXNzID0gcmVxdWlyZSggJ0BzdGRsaWIvdXRpbHMtbmF0aXZlLWNsYXNzJyApO1xuXG5cbi8vIFZBUklBQkxFUyAvL1xuXG52YXIgaGFzRmxvYXQzMkFycmF5ID0gKCB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSAnZnVuY3Rpb24nICk7Ly8gZXNsaW50LWRpc2FibGUtbGluZSBzdGRsaWIvcmVxdWlyZS1nbG9iYWxzXG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogVGVzdHMgaWYgYSB2YWx1ZSBpcyBhIEZsb2F0MzJBcnJheS5cbipcbiogQHBhcmFtIHsqfSB2YWx1ZSAtIHZhbHVlIHRvIHRlc3RcbiogQHJldHVybnMge2Jvb2xlYW59IGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHZhbHVlIGlzIGEgRmxvYXQzMkFycmF5XG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaXNGbG9hdDMyQXJyYXkoIG5ldyBGbG9hdDMyQXJyYXkoIDEwICkgKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaXNGbG9hdDMyQXJyYXkoIFtdICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbiovXG5mdW5jdGlvbiBpc0Zsb2F0MzJBcnJheSggdmFsdWUgKSB7XG5cdHJldHVybiAoXG5cdFx0KCBoYXNGbG9hdDMyQXJyYXkgJiYgdmFsdWUgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgKSB8fCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHN0ZGxpYi9yZXF1aXJlLWdsb2JhbHNcblx0XHRuYXRpdmVDbGFzcyggdmFsdWUgKSA9PT0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XSdcblx0KTtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNGbG9hdDMyQXJyYXk7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIFRlc3QgaWYgYSB2YWx1ZSBpcyBhIEZsb2F0MzJBcnJheS5cbipcbiogQG1vZHVsZSBAc3RkbGliL2Fzc2VydC1pcy1mbG9hdDMyYXJyYXlcbipcbiogQGV4YW1wbGVcbiogdmFyIGlzRmxvYXQzMkFycmF5ID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLWZsb2F0MzJhcnJheScgKTtcbipcbiogdmFyIGJvb2wgPSBpc0Zsb2F0MzJBcnJheSggbmV3IEZsb2F0MzJBcnJheSggMTAgKSApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogYm9vbCA9IGlzRmxvYXQzMkFycmF5KCBbXSApO1xuKiAvLyByZXR1cm5zIGZhbHNlXG4qL1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBpc0Zsb2F0MzJBcnJheSA9IHJlcXVpcmUoICcuL21haW4uanMnICk7XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRmxvYXQzMkFycmF5O1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1BSU4gLy9cblxudmFyIG1haW4gPSAoIHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09ICdmdW5jdGlvbicgKSA/IEZsb2F0MzJBcnJheSA6IG51bGw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgc3RkbGliL3JlcXVpcmUtZ2xvYmFsc1xuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBtYWluO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGlzRmxvYXQzMkFycmF5ID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLWZsb2F0MzJhcnJheScgKTtcbnZhciBQSU5GID0gcmVxdWlyZSggJ0BzdGRsaWIvY29uc3RhbnRzLWZsb2F0NjQtcGluZicgKTtcbnZhciBHbG9iYWxGbG9hdDMyQXJyYXkgPSByZXF1aXJlKCAnLi9mbG9hdDMyYXJyYXkuanMnICk7XG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogVGVzdHMgZm9yIG5hdGl2ZSBgRmxvYXQzMkFycmF5YCBzdXBwb3J0LlxuKlxuKiBAcmV0dXJucyB7Ym9vbGVhbn0gYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGFuIGVudmlyb25tZW50IGhhcyBgRmxvYXQzMkFycmF5YCBzdXBwb3J0XG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaGFzRmxvYXQzMkFycmF5U3VwcG9ydCgpO1xuKiAvLyByZXR1cm5zIDxib29sZWFuPlxuKi9cbmZ1bmN0aW9uIGhhc0Zsb2F0MzJBcnJheVN1cHBvcnQoKSB7XG5cdHZhciBib29sO1xuXHR2YXIgYXJyO1xuXG5cdGlmICggdHlwZW9mIEdsb2JhbEZsb2F0MzJBcnJheSAhPT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0Ly8gVGVzdCBiYXNpYyBzdXBwb3J0Li4uXG5cdHRyeSB7XG5cdFx0YXJyID0gbmV3IEdsb2JhbEZsb2F0MzJBcnJheSggWyAxLjAsIDMuMTQsIC0zLjE0LCA1LjBlNDAgXSApO1xuXHRcdGJvb2wgPSAoXG5cdFx0XHRpc0Zsb2F0MzJBcnJheSggYXJyICkgJiZcblx0XHRcdGFyclsgMCBdID09PSAxLjAgJiZcblx0XHRcdGFyclsgMSBdID09PSAzLjE0MDAwMDEwNDkwNDE3NSAmJlxuXHRcdFx0YXJyWyAyIF0gPT09IC0zLjE0MDAwMDEwNDkwNDE3NSAmJlxuXHRcdFx0YXJyWyAzIF0gPT09IFBJTkZcblx0XHQpO1xuXHR9IGNhdGNoICggZXJyICkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cdFx0Ym9vbCA9IGZhbHNlO1xuXHR9XG5cdHJldHVybiBib29sO1xufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNGbG9hdDMyQXJyYXlTdXBwb3J0O1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBUZXN0IGZvciBuYXRpdmUgYEZsb2F0MzJBcnJheWAgc3VwcG9ydC5cbipcbiogQG1vZHVsZSBAc3RkbGliL2Fzc2VydC1oYXMtZmxvYXQzMmFycmF5LXN1cHBvcnRcbipcbiogQGV4YW1wbGVcbiogdmFyIGhhc0Zsb2F0MzJBcnJheVN1cHBvcnQgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaGFzLWZsb2F0MzJhcnJheS1zdXBwb3J0JyApO1xuKlxuKiB2YXIgYm9vbCA9IGhhc0Zsb2F0MzJBcnJheVN1cHBvcnQoKTtcbiogLy8gcmV0dXJucyA8Ym9vbGVhbj5cbiovXG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGhhc0Zsb2F0MzJBcnJheVN1cHBvcnQgPSByZXF1aXJlKCAnLi9tYWluLmpzJyApO1xuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNGbG9hdDMyQXJyYXlTdXBwb3J0O1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1BSU4gLy9cblxudmFyIGN0b3IgPSAoIHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09ICdmdW5jdGlvbicgKSA/IEZsb2F0MzJBcnJheSA6IHZvaWQgMDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBzdGRsaWIvcmVxdWlyZS1nbG9iYWxzXG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGN0b3I7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gVE9ETzogd3JpdGUgcG9seWZpbGxcblxuLy8gTUFJTiAvL1xuXG4vKipcbiogVHlwZWQgYXJyYXkgd2hpY2ggcmVwcmVzZW50cyBhbiBhcnJheSBvZiBzaW5nbGUtcHJlY2lzaW9uIGZsb2F0aW5nLXBvaW50IG51bWJlcnMgaW4gdGhlIHBsYXRmb3JtIGJ5dGUgb3JkZXIuXG4qXG4qIEB0aHJvd3Mge0Vycm9yfSBub3QgaW1wbGVtZW50ZWRcbiovXG5mdW5jdGlvbiBwb2x5ZmlsbCgpIHtcblx0dGhyb3cgbmV3IEVycm9yKCAnbm90IGltcGxlbWVudGVkJyApO1xufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBwb2x5ZmlsbDtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogVHlwZWQgYXJyYXkgY29uc3RydWN0b3Igd2hpY2ggcmV0dXJucyBhIHR5cGVkIGFycmF5IHJlcHJlc2VudGluZyBhbiBhcnJheSBvZiBzaW5nbGUtcHJlY2lzaW9uIGZsb2F0aW5nLXBvaW50IG51bWJlcnMgaW4gdGhlIHBsYXRmb3JtIGJ5dGUgb3JkZXIuXG4qXG4qIEBtb2R1bGUgQHN0ZGxpYi9hcnJheS1mbG9hdDMyXG4qXG4qIEBleGFtcGxlXG4qIHZhciBjdG9yID0gcmVxdWlyZSggJ0BzdGRsaWIvYXJyYXktZmxvYXQzMicgKTtcbipcbiogdmFyIGFyciA9IG5ldyBjdG9yKCAxMCApO1xuKiAvLyByZXR1cm5zIDxGbG9hdDMyQXJyYXk+XG4qL1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBoYXNGbG9hdDMyQXJyYXlTdXBwb3J0ID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWhhcy1mbG9hdDMyYXJyYXktc3VwcG9ydCcgKTtcbnZhciBidWlsdGluID0gcmVxdWlyZSggJy4vZmxvYXQzMmFycmF5LmpzJyApO1xudmFyIHBvbHlmaWxsID0gcmVxdWlyZSggJy4vcG9seWZpbGwuanMnICk7XG5cblxuLy8gTUFJTiAvL1xuXG52YXIgY3RvcjtcbmlmICggaGFzRmxvYXQzMkFycmF5U3VwcG9ydCgpICkge1xuXHRjdG9yID0gYnVpbHRpbjtcbn0gZWxzZSB7XG5cdGN0b3IgPSBwb2x5ZmlsbDtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gY3RvcjtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBJbnQ4QXJyYXkgPSByZXF1aXJlKCAnQHN0ZGxpYi9hcnJheS1pbnQ4JyApO1xudmFyIFVpbnQ4QXJyYXkgPSByZXF1aXJlKCAnQHN0ZGxpYi9hcnJheS11aW50OCcgKTtcbnZhciBVaW50OENsYW1wZWRBcnJheSA9IHJlcXVpcmUoICdAc3RkbGliL2FycmF5LXVpbnQ4YycgKTtcbnZhciBJbnQxNkFycmF5ID0gcmVxdWlyZSggJ0BzdGRsaWIvYXJyYXktaW50MTYnICk7XG52YXIgVWludDE2QXJyYXkgPSByZXF1aXJlKCAnQHN0ZGxpYi9hcnJheS11aW50MTYnICk7XG52YXIgSW50MzJBcnJheSA9IHJlcXVpcmUoICdAc3RkbGliL2FycmF5LWludDMyJyApO1xudmFyIFVpbnQzMkFycmF5ID0gcmVxdWlyZSggJ0BzdGRsaWIvYXJyYXktdWludDMyJyApO1xudmFyIEZsb2F0MzJBcnJheSA9IHJlcXVpcmUoICdAc3RkbGliL2FycmF5LWZsb2F0MzInICk7XG52YXIgRmxvYXQ2NEFycmF5ID0gcmVxdWlyZSggJ0BzdGRsaWIvYXJyYXktZmxvYXQ2NCcgKTtcblxuXG4vLyBNQUlOIC8vXG5cbnZhciBDVE9SUyA9IFtcblx0RmxvYXQ2NEFycmF5LFxuXHRGbG9hdDMyQXJyYXksXG5cdEludDMyQXJyYXksXG5cdFVpbnQzMkFycmF5LFxuXHRJbnQxNkFycmF5LFxuXHRVaW50MTZBcnJheSxcblx0SW50OEFycmF5LFxuXHRVaW50OEFycmF5LFxuXHRVaW50OENsYW1wZWRBcnJheVxuXTtcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gQ1RPUlM7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgY3Rvck5hbWUgPSByZXF1aXJlKCAnQHN0ZGxpYi91dGlscy1jb25zdHJ1Y3Rvci1uYW1lJyApO1xudmFyIGZjbk5hbWUgPSByZXF1aXJlKCAnQHN0ZGxpYi91dGlscy1mdW5jdGlvbi1uYW1lJyApO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSggJ0BzdGRsaWIvdXRpbHMtZ2V0LXByb3RvdHlwZS1vZicgKTtcbnZhciBoYXNGbG9hdDY0QXJyYXlTdXBwb3J0ID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWhhcy1mbG9hdDY0YXJyYXktc3VwcG9ydCcgKTtcbnZhciBGbG9hdDY0QXJyYXkgPSByZXF1aXJlKCAnQHN0ZGxpYi9hcnJheS1mbG9hdDY0JyApO1xudmFyIENUT1JTID0gcmVxdWlyZSggJy4vY3RvcnMuanMnICk7XG52YXIgTkFNRVMgPSByZXF1aXJlKCAnLi9uYW1lcy5qc29uJyApO1xuXG5cbi8vIFZBUklBQkxFUyAvL1xuXG4vLyBBYnN0cmFjdCBgVHlwZWRBcnJheWAgY2xhc3M6XG52YXIgVHlwZWRBcnJheSA9ICggaGFzRmxvYXQ2NEFycmF5U3VwcG9ydCgpICkgPyBnZXRQcm90b3R5cGVPZiggRmxvYXQ2NEFycmF5ICkgOiBEdW1teTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBtYXgtbGVuXG5cbi8vIEVuc3VyZSBhYnN0cmFjdCB0eXBlZCBhcnJheSBjbGFzcyBoYXMgZXhwZWN0ZWQgbmFtZTpcblR5cGVkQXJyYXkgPSAoIGZjbk5hbWUoIFR5cGVkQXJyYXkgKSA9PT0gJ1R5cGVkQXJyYXknICkgPyBUeXBlZEFycmF5IDogRHVtbXk7XG5cblxuLy8gRlVOQ1RJT05TIC8vXG5cbi8qKlxuKiBEdW1teSBjb25zdHJ1Y3Rvci5cbipcbiogQHByaXZhdGVcbiovXG5mdW5jdGlvbiBEdW1teSgpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHktZnVuY3Rpb25cblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBUZXN0cyBpZiBhIHZhbHVlIGlzIGEgdHlwZWQgYXJyYXkuXG4qXG4qIEBwYXJhbSB7Kn0gdmFsdWUgLSB2YWx1ZSB0byB0ZXN0XG4qIEByZXR1cm5zIHtib29sZWFufSBib29sZWFuIGluZGljYXRpbmcgaWYgYSB2YWx1ZSBpcyBhIHR5cGVkIGFycmF5XG4qXG4qIEBleGFtcGxlXG4qIHZhciBJbnQ4QXJyYXkgPSByZXF1aXJlKCAnQHN0ZGxpYi9hcnJheS1pbnQ4JyApO1xuKlxuKiB2YXIgYm9vbCA9IGlzVHlwZWRBcnJheSggbmV3IEludDhBcnJheSggMTAgKSApO1xuKiAvLyByZXR1cm5zIHRydWVcbiovXG5mdW5jdGlvbiBpc1R5cGVkQXJyYXkoIHZhbHVlICkge1xuXHR2YXIgdjtcblx0dmFyIGk7XG5cblx0aWYgKCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8IHZhbHVlID09PSBudWxsICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHQvLyBDaGVjayBmb3IgdGhlIGFic3RyYWN0IGNsYXNzLi4uXG5cdGlmICggdmFsdWUgaW5zdGFuY2VvZiBUeXBlZEFycmF5ICkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdC8vIENoZWNrIGZvciB0eXBlZCBhcnJheSBvYmplY3RzIGZyb20gdGhlIHNhbWUgcmVhbG0gKHNhbWUgTm9kZS5qcyBgdm1gIG9yIHNhbWUgYFdpbmRvd2Agb2JqZWN0KS4uLlxuXHRmb3IgKCBpID0gMDsgaSA8IENUT1JTLmxlbmd0aDsgaSsrICkge1xuXHRcdGlmICggdmFsdWUgaW5zdGFuY2VvZiBDVE9SU1sgaSBdICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9XG5cdC8vIFdhbGsgdGhlIHByb3RvdHlwZSB0cmVlIHVudGlsIHdlIGZpbmQgYW4gb2JqZWN0IGhhdmluZyBhIGRlc2lyZWQgY2xhc3MuLi5cblx0d2hpbGUgKCB2YWx1ZSApIHtcblx0XHR2ID0gY3Rvck5hbWUoIHZhbHVlICk7XG5cdFx0Zm9yICggaSA9IDA7IGkgPCBOQU1FUy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdGlmICggTkFNRVNbIGkgXSA9PT0gdiApIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhbHVlID0gZ2V0UHJvdG90eXBlT2YoIHZhbHVlICk7XG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVHlwZWRBcnJheTtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogVGVzdCBpZiBhIHZhbHVlIGlzIGEgdHlwZWQgYXJyYXkuXG4qXG4qIEBtb2R1bGUgQHN0ZGxpYi9hc3NlcnQtaXMtdHlwZWQtYXJyYXlcbipcbiogQGV4YW1wbGVcbiogdmFyIEludDhBcnJheSA9IHJlcXVpcmUoICdAc3RkbGliL2FycmF5LWludDgnICk7XG4qIHZhciBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaXMtdHlwZWQtYXJyYXknICk7XG4qXG4qIHZhciBib29sID0gaXNUeXBlZEFycmF5KCBuZXcgSW50OEFycmF5KCAxMCApICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKi9cblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSggJy4vbWFpbi5qcycgKTtcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNUeXBlZEFycmF5O1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIFRlc3RzIHdoZXRoZXIgYSB2YWx1ZSBoYXMgaW4gaXRzIHByb3RvdHlwZSBjaGFpbiBhIHNwZWNpZmllZCBjb25zdHJ1Y3RvciBhcyBhIHByb3RvdHlwZSBwcm9wZXJ0eS5cbipcbiogQHBhcmFtIHsqfSB2YWx1ZSAtIHZhbHVlIHRvIHRlc3RcbiogQHBhcmFtIHtGdW5jdGlvbn0gY29uc3RydWN0b3IgLSBjb25zdHJ1Y3RvciB0byB0ZXN0IGFnYWluc3RcbiogQHRocm93cyB7VHlwZUVycm9yfSBjb25zdHJ1Y3RvciBtdXN0IGJlIGNhbGxhYmxlXG4qIEByZXR1cm5zIHtib29sZWFufSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBhIHZhbHVlIGlzIGFuIGluc3RhbmNlIG9mIGEgcHJvdmlkZWQgY29uc3RydWN0b3JcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBpbnN0YW5jZU9mKCBbXSwgQXJyYXkgKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaW5zdGFuY2VPZigge30sIE9iamVjdCApOyAvLyBleGNlcHRpb25cbiogLy8gcmV0dXJucyB0cnVlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaW5zdGFuY2VPZiggJ2JlZXAnLCBTdHJpbmcgKTtcbiogLy8gcmV0dXJucyBmYWxzZVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgYm9vbCA9IGluc3RhbmNlT2YoIG51bGwsIE9iamVjdCApO1xuKiAvLyByZXR1cm5zIGZhbHNlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaW5zdGFuY2VPZiggNSwgT2JqZWN0ICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbiovXG5mdW5jdGlvbiBpbnN0YW5jZU9mKCB2YWx1ZSwgY29uc3RydWN0b3IgKSB7XG5cdC8vIFRPRE86IHJlcGxhY2Ugd2l0aCBgaXNDYWxsYWJsZWAgY2hlY2tcblx0aWYgKCB0eXBlb2YgY29uc3RydWN0b3IgIT09ICdmdW5jdGlvbicgKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ2ludmFsaWQgYXJndW1lbnQuIGBjb25zdHJ1Y3RvcmAgYXJndW1lbnQgbXVzdCBiZSBjYWxsYWJsZS4gVmFsdWU6IGAnK2NvbnN0cnVjdG9yKydgLicgKTtcblx0fVxuXHRyZXR1cm4gKCB2YWx1ZSBpbnN0YW5jZW9mIGNvbnN0cnVjdG9yICk7XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGluc3RhbmNlT2Y7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIFRlc3Qgd2hldGhlciBhIHZhbHVlIGhhcyBpbiBpdHMgcHJvdG90eXBlIGNoYWluIGEgc3BlY2lmaWVkIGNvbnN0cnVjdG9yIGFzIGEgcHJvdG90eXBlIHByb3BlcnR5LlxuKlxuKiBAbW9kdWxlIEBzdGRsaWIvYXNzZXJ0LWluc3RhbmNlLW9mXG4qXG4qIEBleGFtcGxlXG4qIHZhciBpbnN0YW5jZU9mID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWluc3RhbmNlLW9mJyApO1xuKlxuKiB2YXIgYm9vbCA9IGluc3RhbmNlT2YoIFtdLCBBcnJheSApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogYm9vbCA9IGluc3RhbmNlT2YoIHt9LCBPYmplY3QgKTsgLy8gZXhjZXB0aW9uXG4qIC8vIHJldHVybnMgdHJ1ZVxuKlxuKiBib29sID0gaW5zdGFuY2VPZiggJ2JlZXAnLCBTdHJpbmcgKTtcbiogLy8gcmV0dXJucyBmYWxzZVxuKlxuKiBib29sID0gaW5zdGFuY2VPZiggbnVsbCwgT2JqZWN0ICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbipcbiogYm9vbCA9IGluc3RhbmNlT2YoIDUsIE9iamVjdCApO1xuKiAvLyByZXR1cm5zIGZhbHNlXG4qL1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBpbnN0YW5jZU9mID0gcmVxdWlyZSggJy4vbWFpbi5qcycgKTtcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaW5zdGFuY2VPZjtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBJbnQ4QXJyYXkgPSByZXF1aXJlKCAnQHN0ZGxpYi9hcnJheS1pbnQ4JyApO1xudmFyIFVpbnQ4QXJyYXkgPSByZXF1aXJlKCAnQHN0ZGxpYi9hcnJheS11aW50OCcgKTtcbnZhciBVaW50OENsYW1wZWRBcnJheSA9IHJlcXVpcmUoICdAc3RkbGliL2FycmF5LXVpbnQ4YycgKTtcbnZhciBJbnQxNkFycmF5ID0gcmVxdWlyZSggJ0BzdGRsaWIvYXJyYXktaW50MTYnICk7XG52YXIgVWludDE2QXJyYXkgPSByZXF1aXJlKCAnQHN0ZGxpYi9hcnJheS11aW50MTYnICk7XG52YXIgSW50MzJBcnJheSA9IHJlcXVpcmUoICdAc3RkbGliL2FycmF5LWludDMyJyApO1xudmFyIFVpbnQzMkFycmF5ID0gcmVxdWlyZSggJ0BzdGRsaWIvYXJyYXktdWludDMyJyApO1xudmFyIEZsb2F0MzJBcnJheSA9IHJlcXVpcmUoICdAc3RkbGliL2FycmF5LWZsb2F0MzInICk7XG52YXIgRmxvYXQ2NEFycmF5ID0gcmVxdWlyZSggJ0BzdGRsaWIvYXJyYXktZmxvYXQ2NCcgKTtcblxuXG4vLyBNQUlOIC8vXG5cbnZhciBDVE9SUyA9IFtcblx0WyBGbG9hdDY0QXJyYXksICdGbG9hdDY0QXJyYXknIF0sXG5cdFsgRmxvYXQzMkFycmF5LCAnRmxvYXQzMkFycmF5JyBdLFxuXHRbIEludDMyQXJyYXksICdJbnQzMkFycmF5JyBdLFxuXHRbIFVpbnQzMkFycmF5LCAnVWludDMyQXJyYXknIF0sXG5cdFsgSW50MTZBcnJheSwgJ0ludDE2QXJyYXknIF0sXG5cdFsgVWludDE2QXJyYXksICdVaW50MTZBcnJheScgXSxcblx0WyBJbnQ4QXJyYXksICdJbnQ4QXJyYXknIF0sXG5cdFsgVWludDhBcnJheSwgJ1VpbnQ4QXJyYXknIF0sXG5cdFsgVWludDhDbGFtcGVkQXJyYXksICdVaW50OENsYW1wZWRBcnJheScgXVxuXTtcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gQ1RPUlM7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgaW5zdGFuY2VPZiA9IHJlcXVpcmUoICdAc3RkbGliL2Fzc2VydC1pbnN0YW5jZS1vZicgKTtcbnZhciBjdG9yTmFtZSA9IHJlcXVpcmUoICdAc3RkbGliL3V0aWxzLWNvbnN0cnVjdG9yLW5hbWUnICk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCAnQHN0ZGxpYi91dGlscy1nZXQtcHJvdG90eXBlLW9mJyApO1xudmFyIENUT1JTID0gcmVxdWlyZSggJy4vY3RvcnMuanMnICk7XG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogUmV0dXJucyB0aGUgdHlwZWQgYXJyYXkgdHlwZS5cbipcbiogQHByaXZhdGVcbiogQHBhcmFtIHtUeXBlZEFycmF5fSBhcnIgLSB0eXBlZCBhcnJheVxuKiBAcmV0dXJucyB7KHN0cmluZ3x2b2lkKX0gdHlwZWQgYXJyYXkgdHlwZVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgRmxvYXQ2NEFycmF5ID0gcmVxdWlyZSggJ0BzdGRsaWIvYXJyYXktZmxvYXQ2NCcgKTtcbipcbiogdmFyIGFyciA9IG5ldyBGbG9hdDY0QXJyYXkoIDUgKTtcbiogdmFyIHN0ciA9IHR5cGVOYW1lKCBhcnIgKTtcbiogLy8gcmV0dXJucyAnRmxvYXQ2NEFycmF5J1xuKi9cbmZ1bmN0aW9uIHR5cGVOYW1lKCBhcnIgKSB7XG5cdHZhciB2O1xuXHR2YXIgaTtcblxuXHQvLyBDaGVjayBmb3IgdHlwZWQgYXJyYXkgb2JqZWN0cyBmcm9tIHRoZSBzYW1lIHJlYWxtIChzYW1lIE5vZGUuanMgYHZtYCBvciBzYW1lIGBXaW5kb3dgIG9iamVjdCkuLi5cblx0Zm9yICggaSA9IDA7IGkgPCBDVE9SUy5sZW5ndGg7IGkrKyApIHtcblx0XHRpZiAoIGluc3RhbmNlT2YoIGFyciwgQ1RPUlNbIGkgXVsgMCBdICkgKSB7XG5cdFx0XHRyZXR1cm4gQ1RPUlNbIGkgXVsgMSBdO1xuXHRcdH1cblx0fVxuXHQvLyBXYWxrIHRoZSBwcm90b3R5cGUgdHJlZSB1bnRpbCB3ZSBmaW5kIGFuIG9iamVjdCBoYXZpbmcgYSBkZXNpcmVkIG5hdGl2ZSBjbGFzcy4uLlxuXHR3aGlsZSAoIGFyciApIHtcblx0XHR2ID0gY3Rvck5hbWUoIGFyciApO1xuXHRcdGZvciAoIGkgPSAwOyBpIDwgQ1RPUlMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRpZiAoIHYgPT09IENUT1JTWyBpIF1bIDEgXSApIHtcblx0XHRcdFx0cmV0dXJuIENUT1JTWyBpIF1bIDEgXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0YXJyID0gZ2V0UHJvdG90eXBlT2YoIGFyciApO1xuXHR9XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVOYW1lO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoICdAc3RkbGliL2Fzc2VydC1pcy10eXBlZC1hcnJheScgKTtcbnZhciB0eXBlTmFtZSA9IHJlcXVpcmUoICcuL3R5cGUuanMnICk7XG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogUmV0dXJucyBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYSB0eXBlZCBhcnJheS5cbipcbiogIyMgTm90ZXNcbipcbiogLSAgIFdlIGJ1aWxkIGEgSlNPTiBvYmplY3QgcmVwcmVzZW50aW5nIGEgdHlwZWQgYXJyYXkgc2ltaWxhciB0byBob3cgTm9kZS5qcyBgQnVmZmVyYCBvYmplY3RzIGFyZSByZXByZXNlbnRlZC4gU2VlIFtCdWZmZXJdWzFdLlxuKlxuKiBbMV06IGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvYnVmZmVyLmh0bWwjYnVmZmVyX2J1Zl90b2pzb25cbipcbiogQHBhcmFtIHtUeXBlZEFycmF5fSBhcnIgLSB0eXBlZCBhcnJheSB0byBzZXJpYWxpemVcbiogQHRocm93cyB7VHlwZUVycm9yfSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgdHlwZWQgYXJyYXlcbiogQHJldHVybnMge09iamVjdH0gSlNPTiByZXByZXNlbnRhdGlvblxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgRmxvYXQ2NEFycmF5ID0gcmVxdWlyZSggJ0BzdGRsaWIvYXJyYXktZmxvYXQ2NCcgKTtcbipcbiogdmFyIGFyciA9IG5ldyBGbG9hdDY0QXJyYXkoIFsgNS4wLCAzLjAgXSApO1xuKiB2YXIganNvbiA9IHRvSlNPTiggYXJyICk7XG4qIC8vIHJldHVybnMgeyAndHlwZSc6ICdGbG9hdDY0QXJyYXknLCAnZGF0YSc6IFsgNS4wLCAzLjAgXSB9XG4qL1xuZnVuY3Rpb24gdG9KU09OKCBhcnIgKSB7XG5cdHZhciBvdXQ7XG5cdHZhciBpO1xuXHRpZiAoICFpc1R5cGVkQXJyYXkoIGFyciApICkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdpbnZhbGlkIGFyZ3VtZW50LiBNdXN0IHByb3ZpZGUgYSB0eXBlZCBhcnJheS4gVmFsdWU6IGAnICsgYXJyICsgJ2AuJyApO1xuXHR9XG5cdG91dCA9IHt9O1xuXHRvdXQudHlwZSA9IHR5cGVOYW1lKCBhcnIgKTtcblx0b3V0LmRhdGEgPSBbXTtcblx0Zm9yICggaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKysgKSB7XG5cdFx0b3V0LmRhdGEucHVzaCggYXJyWyBpIF0gKTtcblx0fVxuXHRyZXR1cm4gb3V0O1xufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSB0b0pTT047XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIFJldHVybiBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYSB0eXBlZCBhcnJheS5cbipcbiogQG1vZHVsZSBAc3RkbGliL2FycmF5LXRvLWpzb25cbipcbiogQGV4YW1wbGVcbiogdmFyIEZsb2F0NjRBcnJheSA9IHJlcXVpcmUoICdAc3RkbGliL2FycmF5LWZsb2F0NjQnICk7XG4qIHZhciB0b0pTT04gPSByZXF1aXJlKCAnQHN0ZGxpYi9hcnJheS10by1qc29uJyApO1xuKlxuKiB2YXIgYXJyID0gbmV3IEZsb2F0NjRBcnJheSggWyA1LjAsIDMuMCBdICk7XG4qIHZhciBqc29uID0gdG9KU09OKCBhcnIgKTtcbiogLy8gcmV0dXJucyB7ICd0eXBlJzogJ0Zsb2F0NjRBcnJheScsICdkYXRhJzogWyA1LjAsIDMuMCBdIH1cbiovXG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIHRvSlNPTiA9IHJlcXVpcmUoICcuL3RvX2pzb24uanMnICk7XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHRvSlNPTjtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBWQVJJQUJMRVMgLy9cblxudmFyIE0gPSA4O1xuXG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIENvcGllcyB2YWx1ZXMgZnJvbSBgeGAgaW50byBgeWAuXG4qXG4qIEBwYXJhbSB7UG9zaXRpdmVJbnRlZ2VyfSBOIC0gbnVtYmVyIG9mIHZhbHVlcyB0byBjb3B5XG4qIEBwYXJhbSB7TnVtZXJpY0FycmF5fSB4IC0gaW5wdXQgYXJyYXlcbiogQHBhcmFtIHtpbnRlZ2VyfSBzdHJpZGVYIC0gYHhgIHN0cmlkZSBsZW5ndGhcbiogQHBhcmFtIHtOdW1lcmljQXJyYXl9IHkgLSBkZXN0aW5hdGlvbiBhcnJheVxuKiBAcGFyYW0ge2ludGVnZXJ9IHN0cmlkZVkgLSBgeWAgc3RyaWRlIGxlbmd0aFxuKiBAcmV0dXJucyB7TnVtZXJpY0FycmF5fSBgeWBcbipcbiogQGV4YW1wbGVcbiogdmFyIHggPSBbIDEuMCwgMi4wLCAzLjAsIDQuMCwgNS4wIF07XG4qIHZhciB5ID0gWyA2LjAsIDcuMCwgOC4wLCA5LjAsIDEwLjAgXTtcbipcbiogZ2NvcHkoIHgubGVuZ3RoLCB4LCAxLCB5LCAxICk7XG4qIC8vIHkgPT4gWyAxLjAsIDIuMCwgMy4wLCA0LjAsIDUuMCBdXG4qL1xuZnVuY3Rpb24gZ2NvcHkoIE4sIHgsIHN0cmlkZVgsIHksIHN0cmlkZVkgKSB7XG5cdHZhciBpeDtcblx0dmFyIGl5O1xuXHR2YXIgbTtcblx0dmFyIGk7XG5cdGlmICggTiA8PSAwICkge1xuXHRcdHJldHVybiB5O1xuXHR9XG5cdC8vIFVzZSB1bnJvbGxlZCBsb29wcyBpZiBib3RoIHN0cmlkZXMgYXJlIGVxdWFsIHRvIGAxYC4uLlxuXHRpZiAoIHN0cmlkZVggPT09IDEgJiYgc3RyaWRlWSA9PT0gMSApIHtcblx0XHRtID0gTiAlIE07XG5cblx0XHQvLyBJZiB3ZSBoYXZlIGEgcmVtYWluZGVyLCBydW4gYSBjbGVhbi11cCBsb29wLi4uXG5cdFx0aWYgKCBtID4gMCApIHtcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbTsgaSsrICkge1xuXHRcdFx0XHR5WyBpIF0gPSB4WyBpIF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICggTiA8IE0gKSB7XG5cdFx0XHRyZXR1cm4geTtcblx0XHR9XG5cdFx0Zm9yICggaSA9IG07IGkgPCBOOyBpICs9IE0gKSB7XG5cdFx0XHR5WyBpIF0gPSB4WyBpIF07XG5cdFx0XHR5WyBpKzEgXSA9IHhbIGkrMSBdO1xuXHRcdFx0eVsgaSsyIF0gPSB4WyBpKzIgXTtcblx0XHRcdHlbIGkrMyBdID0geFsgaSszIF07XG5cdFx0XHR5WyBpKzQgXSA9IHhbIGkrNCBdO1xuXHRcdFx0eVsgaSs1IF0gPSB4WyBpKzUgXTtcblx0XHRcdHlbIGkrNiBdID0geFsgaSs2IF07XG5cdFx0XHR5WyBpKzcgXSA9IHhbIGkrNyBdO1xuXHRcdH1cblx0XHRyZXR1cm4geTtcblx0fVxuXHRpZiAoIHN0cmlkZVggPCAwICkge1xuXHRcdGl4ID0gKDEtTikgKiBzdHJpZGVYO1xuXHR9IGVsc2Uge1xuXHRcdGl4ID0gMDtcblx0fVxuXHRpZiAoIHN0cmlkZVkgPCAwICkge1xuXHRcdGl5ID0gKDEtTikgKiBzdHJpZGVZO1xuXHR9IGVsc2Uge1xuXHRcdGl5ID0gMDtcblx0fVxuXHRmb3IgKCBpID0gMDsgaSA8IE47IGkrKyApIHtcblx0XHR5WyBpeSBdID0geFsgaXggXTtcblx0XHRpeCArPSBzdHJpZGVYO1xuXHRcdGl5ICs9IHN0cmlkZVk7XG5cdH1cblx0cmV0dXJuIHk7XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdjb3B5O1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIFZBUklBQkxFUyAvL1xuXG52YXIgTSA9IDg7XG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogQ29waWVzIHZhbHVlcyBmcm9tIGB4YCBpbnRvIGB5YC5cbipcbiogQHBhcmFtIHtQb3NpdGl2ZUludGVnZXJ9IE4gLSBudW1iZXIgb2YgdmFsdWVzIHRvIGNvcHlcbiogQHBhcmFtIHtOdW1lcmljQXJyYXl9IHggLSBpbnB1dCBhcnJheVxuKiBAcGFyYW0ge2ludGVnZXJ9IHN0cmlkZVggLSBgeGAgc3RyaWRlIGxlbmd0aFxuKiBAcGFyYW0ge05vbk5lZ2F0aXZlSW50ZWdlcn0gb2Zmc2V0WCAtIHN0YXJ0aW5nIGB4YCBpbmRleFxuKiBAcGFyYW0ge051bWVyaWNBcnJheX0geSAtIGRlc3RpbmF0aW9uIGFycmF5XG4qIEBwYXJhbSB7aW50ZWdlcn0gc3RyaWRlWSAtIGB5YCBzdHJpZGUgbGVuZ3RoXG4qIEBwYXJhbSB7Tm9uTmVnYXRpdmVJbnRlZ2VyfSBvZmZzZXRZIC0gc3RhcnRpbmcgYHlgIGluZGV4XG4qIEByZXR1cm5zIHtOdW1lcmljQXJyYXl9IGB5YFxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgeCA9IFsgMS4wLCAyLjAsIDMuMCwgNC4wLCA1LjAgXTtcbiogdmFyIHkgPSBbIDYuMCwgNy4wLCA4LjAsIDkuMCwgMTAuMCBdO1xuKlxuKiBnY29weSggeC5sZW5ndGgsIHgsIDEsIDAsIHksIDEsIDAgKTtcbiogLy8geSA9PiBbIDEuMCwgMi4wLCAzLjAsIDQuMCwgNS4wIF1cbiovXG5mdW5jdGlvbiBnY29weSggTiwgeCwgc3RyaWRlWCwgb2Zmc2V0WCwgeSwgc3RyaWRlWSwgb2Zmc2V0WSApIHtcblx0dmFyIGl4O1xuXHR2YXIgaXk7XG5cdHZhciBtO1xuXHR2YXIgaTtcblx0aWYgKCBOIDw9IDAgKSB7XG5cdFx0cmV0dXJuIHk7XG5cdH1cblx0aXggPSBvZmZzZXRYO1xuXHRpeSA9IG9mZnNldFk7XG5cblx0Ly8gVXNlIHVucm9sbGVkIGxvb3BzIGlmIGJvdGggc3RyaWRlcyBhcmUgZXF1YWwgdG8gYDFgLi4uXG5cdGlmICggc3RyaWRlWCA9PT0gMSAmJiBzdHJpZGVZID09PSAxICkge1xuXHRcdG0gPSBOICUgTTtcblxuXHRcdC8vIElmIHdlIGhhdmUgYSByZW1haW5kZXIsIHJ1biBhIGNsZWFuLXVwIGxvb3AuLi5cblx0XHRpZiAoIG0gPiAwICkge1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBtOyBpKysgKSB7XG5cdFx0XHRcdHlbIGl5IF0gPSB4WyBpeCBdO1xuXHRcdFx0XHRpeCArPSBzdHJpZGVYO1xuXHRcdFx0XHRpeSArPSBzdHJpZGVZO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIE4gPCBNICkge1xuXHRcdFx0cmV0dXJuIHk7XG5cdFx0fVxuXHRcdGZvciAoIGkgPSBtOyBpIDwgTjsgaSArPSBNICkge1xuXHRcdFx0eVsgaXkgXSA9IHhbIGl4IF07XG5cdFx0XHR5WyBpeSsxIF0gPSB4WyBpeCsxIF07XG5cdFx0XHR5WyBpeSsyIF0gPSB4WyBpeCsyIF07XG5cdFx0XHR5WyBpeSszIF0gPSB4WyBpeCszIF07XG5cdFx0XHR5WyBpeSs0IF0gPSB4WyBpeCs0IF07XG5cdFx0XHR5WyBpeSs1IF0gPSB4WyBpeCs1IF07XG5cdFx0XHR5WyBpeSs2IF0gPSB4WyBpeCs2IF07XG5cdFx0XHR5WyBpeSs3IF0gPSB4WyBpeCs3IF07XG5cdFx0XHRpeCArPSBNO1xuXHRcdFx0aXkgKz0gTTtcblx0XHR9XG5cdFx0cmV0dXJuIHk7XG5cdH1cblx0Zm9yICggaSA9IDA7IGkgPCBOOyBpKysgKSB7XG5cdFx0eVsgaXkgXSA9IHhbIGl4IF07XG5cdFx0aXggKz0gc3RyaWRlWDtcblx0XHRpeSArPSBzdHJpZGVZO1xuXHR9XG5cdHJldHVybiB5O1xufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBnY29weTtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogQkxBUyBsZXZlbCAxIHJvdXRpbmUgdG8gY29weSB2YWx1ZXMgZnJvbSBgeGAgaW50byBgeWAuXG4qXG4qIEBtb2R1bGUgQHN0ZGxpYi9ibGFzLWJhc2UtZ2NvcHlcbipcbiogQGV4YW1wbGVcbiogdmFyIGdjb3B5ID0gcmVxdWlyZSggJ0BzdGRsaWIvYmxhcy1iYXNlLWdjb3B5JyApO1xuKlxuKiB2YXIgeCA9IFsgMS4wLCAyLjAsIDMuMCwgNC4wLCA1LjAgXTtcbiogdmFyIHkgPSBbIDYuMCwgNy4wLCA4LjAsIDkuMCwgMTAuMCBdO1xuKlxuKiBnY29weSggeC5sZW5ndGgsIHgsIDEsIHksIDEgKTtcbiogLy8geSA9PiBbIDEuMCwgMi4wLCAzLjAsIDQuMCwgNS4wIF1cbipcbiogQGV4YW1wbGVcbiogdmFyIGdjb3B5ID0gcmVxdWlyZSggJ0BzdGRsaWIvYmxhcy1iYXNlLWdjb3B5JyApO1xuKlxuKiB2YXIgeCA9IFsgMS4wLCAyLjAsIDMuMCwgNC4wLCA1LjAgXTtcbiogdmFyIHkgPSBbIDYuMCwgNy4wLCA4LjAsIDkuMCwgMTAuMCBdO1xuKlxuKiBnY29weS5uZGFycmF5KCB4Lmxlbmd0aCwgeCwgMSwgMCwgeSwgMSwgMCApO1xuKiAvLyB5ID0+IFsgMS4wLCAyLjAsIDMuMCwgNC4wLCA1LjAgXVxuKi9cblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgc2V0UmVhZE9ubHkgPSByZXF1aXJlKCAnQHN0ZGxpYi91dGlscy1kZWZpbmUtbm9uZW51bWVyYWJsZS1yZWFkLW9ubHktcHJvcGVydHknICk7XG52YXIgZ2NvcHkgPSByZXF1aXJlKCAnLi9tYWluLmpzJyApO1xudmFyIG5kYXJyYXkgPSByZXF1aXJlKCAnLi9uZGFycmF5LmpzJyApO1xuXG5cbi8vIE1BSU4gLy9cblxuc2V0UmVhZE9ubHkoIGdjb3B5LCAnbmRhcnJheScsIG5kYXJyYXkgKTtcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gZ2NvcHk7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgSU5UMzJfTUFYID0gcmVxdWlyZSggJ0BzdGRsaWIvY29uc3RhbnRzLWludDMyLW1heCcgKTtcbnZhciBmbG9vciA9IHJlcXVpcmUoICdAc3RkbGliL21hdGgtYmFzZS1zcGVjaWFsLWZsb29yJyApO1xuXG5cbi8vIFZBUklBQkxFUyAvL1xuXG52YXIgTUFYID0gSU5UMzJfTUFYIC0gMTtcblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBSZXR1cm5zIGEgcHNldWRvcmFuZG9tIGludGVnZXIgb24gdGhlIGludGVydmFsIFxcXFwoWzEsIDJeezMxfS0xKVxcXFwpLlxuKlxuKiBAcHJpdmF0ZVxuKiBAcmV0dXJucyB7UG9zaXRpdmVJbnRlZ2VyfSBwc2V1ZG9yYW5kb20gaW50ZWdlclxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgdiA9IHJhbmRpbnQzMigpO1xuKiAvLyByZXR1cm5zIDxudW1iZXI+XG4qL1xuZnVuY3Rpb24gcmFuZGludDMyKCkge1xuXHR2YXIgdiA9IGZsb29yKCAxLjAgKyAoTUFYKk1hdGgucmFuZG9tKCkpICk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgc3RkbGliL25vLWJ1aWx0aW4tbWF0aFxuXHRyZXR1cm4gdnwwOyAvLyBhc20gdHlwZSBhbm5vdGF0aW9uXG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJhbmRpbnQzMjtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIHNldFJlYWRPbmx5ID0gcmVxdWlyZSggJ0BzdGRsaWIvdXRpbHMtZGVmaW5lLW5vbmVudW1lcmFibGUtcmVhZC1vbmx5LXByb3BlcnR5JyApO1xudmFyIHNldFJlYWRPbmx5QWNjZXNzb3IgPSByZXF1aXJlKCAnQHN0ZGxpYi91dGlscy1kZWZpbmUtbm9uZW51bWVyYWJsZS1yZWFkLW9ubHktYWNjZXNzb3InICk7XG52YXIgc2V0UmVhZFdyaXRlQWNjZXNzb3IgPSByZXF1aXJlKCAnQHN0ZGxpYi91dGlscy1kZWZpbmUtbm9uZW51bWVyYWJsZS1yZWFkLXdyaXRlLWFjY2Vzc29yJyApO1xudmFyIGhhc093blByb3AgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaGFzLW93bi1wcm9wZXJ0eScgKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoICdAc3RkbGliL2Fzc2VydC1pcy1wbGFpbi1vYmplY3QnICk7XG52YXIgaXNCb29sZWFuID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLWJvb2xlYW4nICkuaXNQcmltaXRpdmU7XG52YXIgaXNDb2xsZWN0aW9uID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLWNvbGxlY3Rpb24nICk7XG52YXIgaXNQb3NpdGl2ZUludGVnZXIgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaXMtcG9zaXRpdmUtaW50ZWdlcicgKS5pc1ByaW1pdGl2ZTtcbnZhciBpc0ludDMyQXJyYXkgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaXMtaW50MzJhcnJheScgKTtcbnZhciBJTlQzMl9NQVggPSByZXF1aXJlKCAnQHN0ZGxpYi9jb25zdGFudHMtaW50MzItbWF4JyApO1xudmFyIEludDMyQXJyYXkgPSByZXF1aXJlKCAnQHN0ZGxpYi9hcnJheS1pbnQzMicgKTtcbnZhciBnY29weSA9IHJlcXVpcmUoICdAc3RkbGliL2JsYXMtYmFzZS1nY29weScgKTtcbnZhciB0eXBlZGFycmF5Mmpzb24gPSByZXF1aXJlKCAnQHN0ZGxpYi9hcnJheS10by1qc29uJyApO1xudmFyIHJhbmRpbnQzMiA9IHJlcXVpcmUoICcuL3JhbmRfaW50MzIuanMnICk7XG5cblxuLy8gVkFSSUFCTEVTIC8vXG5cbnZhciBOT1JNQUxJWkFUSU9OX0NPTlNUQU5UID0gKElOVDMyX01BWCAtIDEpfDA7IC8vIGFzbSB0eXBlIGFubm90YXRpb25cbnZhciBNQVhfU0VFRCA9IChJTlQzMl9NQVggLSAxKXwwOyAvLyBhc20gdHlwZSBhbm5vdGF0aW9uXG52YXIgQSA9IDE2ODA3fDA7IC8vIGFzbSB0eXBlIGFubm90YXRpb25cblxuLy8gRGVmaW5lIHRoZSBzdGF0ZSBhcnJheSBzY2hlbWEgdmVyc2lvbjpcbnZhciBTVEFURV9BUlJBWV9WRVJTSU9OID0gMTsgLy8gTk9URTogYW55dGltZSB0aGUgc3RhdGUgYXJyYXkgc2NoZW1hIGNoYW5nZXMsIHRoaXMgdmFsdWUgc2hvdWxkIGJlIGluY3JlbWVudGVkISEhXG5cbi8vIERlZmluZSB0aGUgbnVtYmVyIG9mIHNlY3Rpb25zIGluIHRoZSBzdGF0ZSBhcnJheTpcbnZhciBOVU1fU1RBVEVfU0VDVElPTlMgPSAyOyAvLyBzdGF0ZSwgc2VlZFxuXG4vLyBEZWZpbmUgdGhlIGluZGV4IG9mZnNldCBvZiB0aGUgXCJzdGF0ZVwiIHNlY3Rpb24gaW4gdGhlIHN0YXRlIGFycmF5OlxudmFyIFNUQVRFX1NFQ1RJT05fT0ZGU0VUID0gMjsgLy8gfCB2ZXJzaW9uIHwgbnVtX3NlY3Rpb25zIHwgc3RhdGVfbGVuZ3RoIHwgLi4uc3RhdGUgfCBzZWVkX2xlbmd0aCB8IC4uLnNlZWQgfFxuXG4vLyBEZWZpbmUgdGhlIGluZGV4IG9mZnNldCBvZiB0aGUgc2VlZCBzZWN0aW9uIGluIHRoZSBzdGF0ZSBhcnJheTpcbnZhciBTRUVEX1NFQ1RJT05fT0ZGU0VUID0gNDsgLy8gfCB2ZXJzaW9uIHwgbnVtX3NlY3Rpb25zIHwgc3RhdGVfbGVuZ3RoIHwgLi4uc3RhdGUgfCBzZWVkX2xlbmd0aCB8IC4uLnNlZWQgfFxuXG4vLyBEZWZpbmUgdGhlIGxlbmd0aCBvZiB0aGUgXCJmaXhlZFwiIGxlbmd0aCBwb3J0aW9uIG9mIHRoZSBzdGF0ZSBhcnJheTpcbnZhciBTVEFURV9GSVhFRF9MRU5HVEggPSA1OyAvLyAxICh2ZXJzaW9uKSArIDEgKG51bV9zZWN0aW9ucykgKyAxIChzdGF0ZV9sZW5ndGgpICsgMSAoc3RhdGUpICsgMSAoc2VlZF9sZW5ndGgpXG5cblxuLy8gRlVOQ1RJT05TIC8vXG5cbi8qKlxuKiBWZXJpZmllcyBzdGF0ZSBhcnJheSBpbnRlZ3JpdHkuXG4qXG4qIEBwcml2YXRlXG4qIEBwYXJhbSB7SW50MzJBcnJheX0gc3RhdGUgLSBzdGF0ZSBhcnJheVxuKiBAcGFyYW0ge2Jvb2xlYW59IEZMRyAtIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBzdGF0ZSBhcnJheSB3YXMgcHJvdmlkZWQgYXMgYW4gb3B0aW9uICh0cnVlKSBvciBhbiBhcmd1bWVudCAoZmFsc2UpXG4qIEByZXR1cm5zIHsoRXJyb3J8bnVsbCl9IGFuIGVycm9yIG9yIGBudWxsYFxuKi9cbmZ1bmN0aW9uIHZlcmlmeVN0YXRlKCBzdGF0ZSwgRkxHICkge1xuXHR2YXIgczE7XG5cdGlmICggRkxHICkge1xuXHRcdHMxID0gJ29wdGlvbic7XG5cdH0gZWxzZSB7XG5cdFx0czEgPSAnYXJndW1lbnQnO1xuXHR9XG5cdC8vIFRoZSBzdGF0ZSBhcnJheSBtdXN0IGhhdmUgYSBtaW5pbXVtIGxlbmd0aC4uLlxuXHRpZiAoIHN0YXRlLmxlbmd0aCA8IFNUQVRFX0ZJWEVEX0xFTkdUSCsxICkge1xuXHRcdHJldHVybiBuZXcgUmFuZ2VFcnJvciggJ2ludmFsaWQgJytzMSsnLiBgc3RhdGVgIGFycmF5IGhhcyBpbnN1ZmZpY2llbnQgbGVuZ3RoLicgKTtcblx0fVxuXHQvLyBUaGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgc3RhdGUgYXJyYXkgbXVzdCBlcXVhbCB0aGUgc3VwcG9ydGVkIHN0YXRlIGFycmF5IHNjaGVtYSB2ZXJzaW9uLi4uXG5cdGlmICggc3RhdGVbIDAgXSAhPT0gU1RBVEVfQVJSQVlfVkVSU0lPTiApIHtcblx0XHRyZXR1cm4gbmV3IFJhbmdlRXJyb3IoICdpbnZhbGlkICcrczErJy4gYHN0YXRlYCBhcnJheSBoYXMgYW4gaW5jb21wYXRpYmxlIHNjaGVtYSB2ZXJzaW9uLiBFeHBlY3RlZDogJytTVEFURV9BUlJBWV9WRVJTSU9OKycuIEFjdHVhbDogJytzdGF0ZVsgMCBdKycuJyApO1xuXHR9XG5cdC8vIFRoZSBzZWNvbmQgZWxlbWVudCBvZiB0aGUgc3RhdGUgYXJyYXkgbXVzdCBjb250YWluIHRoZSBudW1iZXIgb2Ygc2VjdGlvbnMuLi5cblx0aWYgKCBzdGF0ZVsgMSBdICE9PSBOVU1fU1RBVEVfU0VDVElPTlMgKSB7XG5cdFx0cmV0dXJuIG5ldyBSYW5nZUVycm9yKCAnaW52YWxpZCAnK3MxKycuIGBzdGF0ZWAgYXJyYXkgaGFzIGFuIGluY29tcGF0aWJsZSBudW1iZXIgb2Ygc2VjdGlvbnMuIEV4cGVjdGVkOiAnK05VTV9TVEFURV9TRUNUSU9OUysnLiBBY3R1YWw6ICcrc3RhdGVbIDEgXSsnLicgKTtcblx0fVxuXHQvLyBUaGUgbGVuZ3RoIG9mIHRoZSBcInN0YXRlXCIgc2VjdGlvbiBtdXN0IGVxdWFsIGAxYC4uLlxuXHRpZiAoIHN0YXRlWyBTVEFURV9TRUNUSU9OX09GRlNFVCBdICE9PSAxICkge1xuXHRcdHJldHVybiBuZXcgUmFuZ2VFcnJvciggJ2ludmFsaWQgJytzMSsnLiBgc3RhdGVgIGFycmF5IGhhcyBhbiBpbmNvbXBhdGlibGUgc3RhdGUgbGVuZ3RoLiBFeHBlY3RlZDogJysoMSkudG9TdHJpbmcoKSsnLiBBY3R1YWw6ICcrc3RhdGVbIFNUQVRFX1NFQ1RJT05fT0ZGU0VUIF0rJy4nICk7XG5cdH1cblx0Ly8gVGhlIGxlbmd0aCBvZiB0aGUgXCJzZWVkXCIgc2VjdGlvbiBtdWNoIG1hdGNoIHRoZSBlbXBpcmljYWwgbGVuZ3RoLi4uXG5cdGlmICggc3RhdGVbIFNFRURfU0VDVElPTl9PRkZTRVQgXSAhPT0gc3RhdGUubGVuZ3RoLVNUQVRFX0ZJWEVEX0xFTkdUSCApIHtcblx0XHRyZXR1cm4gbmV3IFJhbmdlRXJyb3IoICdpbnZhbGlkICcrczErJy4gYHN0YXRlYCBhcnJheSBsZW5ndGggaXMgaW5jb21wYXRpYmxlIHdpdGggc2VlZCBzZWN0aW9uIGxlbmd0aC4gRXhwZWN0ZWQ6ICcrKHN0YXRlLmxlbmd0aC1TVEFURV9GSVhFRF9MRU5HVEgpKycuIEFjdHVhbDogJytzdGF0ZVsgU0VFRF9TRUNUSU9OX09GRlNFVCBdKycuJyApO1xuXHR9XG5cdHJldHVybiBudWxsO1xufVxuXG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIFJldHVybnMgYSBsaW5lYXIgY29uZ3J1ZW50aWFsIHBzZXVkb3JhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIChMQ0cpIGJhc2VkIG9uIFBhcmsgYW5kIE1pbGxlci5cbipcbiogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gLSBvcHRpb25zXG4qIEBwYXJhbSB7UFJOR1NlZWRNSU5TVER9IFtvcHRpb25zLnNlZWRdIC0gcHNldWRvcmFuZG9tIG51bWJlciBnZW5lcmF0b3Igc2VlZFxuKiBAcGFyYW0ge1BSTkdTdGF0ZU1JTlNURH0gW29wdGlvbnMuc3RhdGVdIC0gcHNldWRvcmFuZG9tIG51bWJlciBnZW5lcmF0b3Igc3RhdGVcbiogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jb3B5PXRydWVdIC0gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdG8gY29weSBhIHByb3ZpZGVkIHBzZXVkb3JhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIHN0YXRlXG4qIEB0aHJvd3Mge1R5cGVFcnJvcn0gb3B0aW9ucyBhcmd1bWVudCBtdXN0IGJlIGFuIG9iamVjdFxuKiBAdGhyb3dzIHtUeXBlRXJyb3J9IGEgc2VlZCBtdXN0IGJlIGVpdGhlciBhIHBvc2l0aXZlIGludGVnZXIgbGVzcyB0aGFuIHRoZSBtYXhpbXVtIHNpZ25lZCAzMi1iaXQgaW50ZWdlciBvciBhbiBhcnJheS1saWtlIG9iamVjdCBjb250YWluaW5nIGludGVnZXJzIGxlc3MgdGhhbiB0aGUgbWF4aW11bSBzaWduZWQgMzItYml0IGludGVnZXJcbiogQHRocm93cyB7UmFuZ2VFcnJvcn0gYSBudW1lcmljIHNlZWQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgbGVzcyB0aGFuIHRoZSBtYXhpbXVtIHNpZ25lZCAzMi1iaXQgaW50ZWdlclxuKiBAdGhyb3dzIHtUeXBlRXJyb3J9IHN0YXRlIG11c3QgYmUgYW4gYEludDMyQXJyYXlgXG4qIEB0aHJvd3Mge0Vycm9yfSBtdXN0IHByb3ZpZGUgYSB2YWxpZCBzdGF0ZVxuKiBAdGhyb3dzIHtUeXBlRXJyb3J9IGBjb3B5YCBvcHRpb24gbXVzdCBiZSBhIGJvb2xlYW5cbiogQHJldHVybnMge1BSTkd9IExDRyBQUk5HXG4qXG4qIEBleGFtcGxlXG4qIHZhciBtaW5zdGQgPSBmYWN0b3J5KCk7XG4qXG4qIHZhciB2ID0gbWluc3RkKCk7XG4qIC8vIHJldHVybnMgPG51bWJlcj5cbipcbiogQGV4YW1wbGVcbiogLy8gUmV0dXJuIGEgc2VlZGVkIExDRzpcbiogdmFyIG1pbnN0ZCA9IGZhY3Rvcnkoe1xuKiAgICAgJ3NlZWQnOiAxMjM0XG4qIH0pO1xuKlxuKiB2YXIgdiA9IG1pbnN0ZCgpO1xuKiAvLyByZXR1cm5zIDIwNzM5ODM4XG4qL1xuZnVuY3Rpb24gZmFjdG9yeSggb3B0aW9ucyApIHtcblx0dmFyIFNUQVRFO1xuXHR2YXIgc3RhdGU7XG5cdHZhciBvcHRzO1xuXHR2YXIgc2VlZDtcblx0dmFyIHNsZW47XG5cdHZhciBlcnI7XG5cblx0b3B0cyA9IHt9O1xuXHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0aWYgKCAhaXNPYmplY3QoIG9wdGlvbnMgKSApIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdpbnZhbGlkIGFyZ3VtZW50LiBPcHRpb25zIGFyZ3VtZW50IG11c3QgYmUgYW4gb2JqZWN0LiBWYWx1ZTogYCcgKyBvcHRpb25zICsgJ2AuJyApO1xuXHRcdH1cblx0XHRpZiAoIGhhc093blByb3AoIG9wdGlvbnMsICdjb3B5JyApICkge1xuXHRcdFx0b3B0cy5jb3B5ID0gb3B0aW9ucy5jb3B5O1xuXHRcdFx0aWYgKCAhaXNCb29sZWFuKCBvcHRpb25zLmNvcHkgKSApIHtcblx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ2ludmFsaWQgb3B0aW9uLiBgY29weWAgb3B0aW9uIG11c3QgYmUgYSBib29sZWFuLiBPcHRpb246IGAnICsgb3B0aW9ucy5jb3B5ICsgJ2AuJyApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIGhhc093blByb3AoIG9wdGlvbnMsICdzdGF0ZScgKSApIHtcblx0XHRcdHN0YXRlID0gb3B0aW9ucy5zdGF0ZTtcblx0XHRcdG9wdHMuc3RhdGUgPSB0cnVlO1xuXHRcdFx0aWYgKCAhaXNJbnQzMkFycmF5KCBzdGF0ZSApICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnaW52YWxpZCBvcHRpb24uIGBzdGF0ZWAgb3B0aW9uIG11c3QgYmUgYW4gSW50MzJBcnJheS4gT3B0aW9uOiBgJyArIHN0YXRlICsgJ2AuJyApO1xuXHRcdFx0fVxuXHRcdFx0ZXJyID0gdmVyaWZ5U3RhdGUoIHN0YXRlLCB0cnVlICk7XG5cdFx0XHRpZiAoIGVyciApIHtcblx0XHRcdFx0dGhyb3cgZXJyO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBvcHRzLmNvcHkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRTVEFURSA9IHN0YXRlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0U1RBVEUgPSBuZXcgSW50MzJBcnJheSggc3RhdGUubGVuZ3RoICk7XG5cdFx0XHRcdGdjb3B5KCBzdGF0ZS5sZW5ndGgsIHN0YXRlLCAxLCBTVEFURSwgMSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gQ3JlYXRlIGEgc3RhdGUgXCJ2aWV3XCI6XG5cdFx0XHRzdGF0ZSA9IG5ldyBJbnQzMkFycmF5KCBTVEFURS5idWZmZXIsIFNUQVRFLmJ5dGVPZmZzZXQrKChTVEFURV9TRUNUSU9OX09GRlNFVCsxKSpTVEFURS5CWVRFU19QRVJfRUxFTUVOVCksIDEgKTtcblxuXHRcdFx0Ly8gQ3JlYXRlIGEgc2VlZCBcInZpZXdcIjpcblx0XHRcdHNlZWQgPSBuZXcgSW50MzJBcnJheSggU1RBVEUuYnVmZmVyLCBTVEFURS5ieXRlT2Zmc2V0KygoU0VFRF9TRUNUSU9OX09GRlNFVCsxKSpTVEFURS5CWVRFU19QRVJfRUxFTUVOVCksIHN0YXRlWyBTRUVEX1NFQ1RJT05fT0ZGU0VUIF0gKTtcblx0XHR9XG5cdFx0Ly8gSWYgcHJvdmlkZWQgYSBQUk5HIHN0YXRlLCB3ZSBpZ25vcmUgdGhlIGBzZWVkYCBvcHRpb24uLi5cblx0XHRpZiAoIHNlZWQgPT09IHZvaWQgMCApIHtcblx0XHRcdGlmICggaGFzT3duUHJvcCggb3B0aW9ucywgJ3NlZWQnICkgKSB7XG5cdFx0XHRcdHNlZWQgPSBvcHRpb25zLnNlZWQ7XG5cdFx0XHRcdG9wdHMuc2VlZCA9IHRydWU7XG5cdFx0XHRcdGlmICggaXNQb3NpdGl2ZUludGVnZXIoIHNlZWQgKSApIHtcblx0XHRcdFx0XHRpZiAoIHNlZWQgPiBNQVhfU0VFRCApIHtcblx0XHRcdFx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKCAnaW52YWxpZCBvcHRpb24uIGBzZWVkYCBvcHRpb24gbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgbGVzcyB0aGFuIHRoZSBtYXhpbXVtIHNpZ25lZCAzMi1iaXQgaW50ZWdlci4gT3B0aW9uOiBgJyArIHNlZWQgKyAnYC4nICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNlZWQgfD0gMDsgLy8gYXNtIHR5cGUgYW5ub3RhdGlvblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBpc0NvbGxlY3Rpb24oIHNlZWQgKSAmJiBzZWVkLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRcdFx0c2xlbiA9IHNlZWQubGVuZ3RoO1xuXHRcdFx0XHRcdFNUQVRFID0gbmV3IEludDMyQXJyYXkoIFNUQVRFX0ZJWEVEX0xFTkdUSCtzbGVuICk7XG5cblx0XHRcdFx0XHQvLyBJbml0aWFsaXplIHNlY3Rpb25zOlxuXHRcdFx0XHRcdFNUQVRFWyAwIF0gPSBTVEFURV9BUlJBWV9WRVJTSU9OO1xuXHRcdFx0XHRcdFNUQVRFWyAxIF0gPSBOVU1fU1RBVEVfU0VDVElPTlM7XG5cdFx0XHRcdFx0U1RBVEVbIFNUQVRFX1NFQ1RJT05fT0ZGU0VUIF0gPSAxO1xuXHRcdFx0XHRcdFNUQVRFWyBTRUVEX1NFQ1RJT05fT0ZGU0VUIF0gPSBzbGVuO1xuXG5cdFx0XHRcdFx0Ly8gQ29weSB0aGUgcHJvdmlkZWQgc2VlZCBhcnJheSB0byBwcmV2ZW50IGV4dGVybmFsIG11dGF0aW9uLCBhcyBtdXRhdGlvbiB3b3VsZCBsZWFkIHRvIGFuIGluYWJpbGl0eSB0byByZXByb2R1Y2UgUFJORyB2YWx1ZXMgYWNjb3JkaW5nIHRvIHRoZSBQUk5HJ3Mgc3RhdGVkIHNlZWQ6XG5cdFx0XHRcdFx0Z2NvcHkubmRhcnJheSggc2xlbiwgc2VlZCwgMSwgMCwgU1RBVEUsIDEsIFNFRURfU0VDVElPTl9PRkZTRVQrMSApO1xuXG5cdFx0XHRcdFx0Ly8gQ3JlYXRlIGEgc3RhdGUgXCJ2aWV3XCI6XG5cdFx0XHRcdFx0c3RhdGUgPSBuZXcgSW50MzJBcnJheSggU1RBVEUuYnVmZmVyLCBTVEFURS5ieXRlT2Zmc2V0KygoU1RBVEVfU0VDVElPTl9PRkZTRVQrMSkqU1RBVEUuQllURVNfUEVSX0VMRU1FTlQpLCAxICk7XG5cblx0XHRcdFx0XHQvLyBDcmVhdGUgYSBzZWVkIFwidmlld1wiOlxuXHRcdFx0XHRcdHNlZWQgPSBuZXcgSW50MzJBcnJheSggU1RBVEUuYnVmZmVyLCBTVEFURS5ieXRlT2Zmc2V0KygoU0VFRF9TRUNUSU9OX09GRlNFVCsxKSpTVEFURS5CWVRFU19QRVJfRUxFTUVOVCksIHNsZW4gKTtcblxuXHRcdFx0XHRcdC8vIEluaXRpYWxpemUgdGhlIGludGVybmFsIFBSTkcgc3RhdGU6XG5cdFx0XHRcdFx0c3RhdGVbIDAgXSA9IHNlZWRbIDAgXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnaW52YWxpZCBvcHRpb24uIGBzZWVkYCBvcHRpb24gbXVzdCBiZSBlaXRoZXIgYSBwb3NpdGl2ZSBpbnRlZ2VyIGxlc3MgdGhhbiB0aGUgbWF4aW11bSBzaWduZWQgMzItYml0IGludGVnZXIgb3IgYW4gYXJyYXktbGlrZSBvYmplY3QgY29udGFpbmluZyBpbnRlZ2VyIHZhbHVlcyBsZXNzIHRoYW4gdGhlIG1heGltdW0gc2lnbmVkIDMyLWJpdCBpbnRlZ2VyLiBPcHRpb246IGAnICsgc2VlZCArICdgLicgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VlZCA9IHJhbmRpbnQzMigpfDA7IC8vIGFzbSB0eXBlIGFubm90YXRpb25cblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0c2VlZCA9IHJhbmRpbnQzMigpfDA7IC8vIGFzbSB0eXBlIGFubm90YXRpb25cblx0fVxuXHRpZiAoIHN0YXRlID09PSB2b2lkIDAgKSB7XG5cdFx0U1RBVEUgPSBuZXcgSW50MzJBcnJheSggU1RBVEVfRklYRURfTEVOR1RIKzEgKTtcblxuXHRcdC8vIEluaXRpYWxpemUgc2VjdGlvbnM6XG5cdFx0U1RBVEVbIDAgXSA9IFNUQVRFX0FSUkFZX1ZFUlNJT047XG5cdFx0U1RBVEVbIDEgXSA9IE5VTV9TVEFURV9TRUNUSU9OUztcblx0XHRTVEFURVsgU1RBVEVfU0VDVElPTl9PRkZTRVQgXSA9IDE7XG5cdFx0U1RBVEVbIFNFRURfU0VDVElPTl9PRkZTRVQgXSA9IDE7XG5cdFx0U1RBVEVbIFNFRURfU0VDVElPTl9PRkZTRVQrMSBdID0gc2VlZDtcblxuXHRcdC8vIENyZWF0ZSBhIHN0YXRlIFwidmlld1wiOlxuXHRcdHN0YXRlID0gbmV3IEludDMyQXJyYXkoIFNUQVRFLmJ1ZmZlciwgU1RBVEUuYnl0ZU9mZnNldCsoKFNUQVRFX1NFQ1RJT05fT0ZGU0VUKzEpKlNUQVRFLkJZVEVTX1BFUl9FTEVNRU5UKSwgMSApO1xuXG5cdFx0Ly8gQ3JlYXRlIGEgc2VlZCBcInZpZXdcIjpcblx0XHRzZWVkID0gbmV3IEludDMyQXJyYXkoIFNUQVRFLmJ1ZmZlciwgU1RBVEUuYnl0ZU9mZnNldCsoKFNFRURfU0VDVElPTl9PRkZTRVQrMSkqU1RBVEUuQllURVNfUEVSX0VMRU1FTlQpLCAxICk7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBpbnRlcm5hbCBQUk5HIHN0YXRlOlxuXHRcdHN0YXRlWyAwIF0gPSBzZWVkWyAwIF07XG5cdH1cblx0c2V0UmVhZE9ubHkoIG1pbnN0ZCwgJ05BTUUnLCAnbWluc3RkJyApO1xuXHRzZXRSZWFkT25seUFjY2Vzc29yKCBtaW5zdGQsICdzZWVkJywgZ2V0U2VlZCApO1xuXHRzZXRSZWFkT25seUFjY2Vzc29yKCBtaW5zdGQsICdzZWVkTGVuZ3RoJywgZ2V0U2VlZExlbmd0aCApO1xuXHRzZXRSZWFkV3JpdGVBY2Nlc3NvciggbWluc3RkLCAnc3RhdGUnLCBnZXRTdGF0ZSwgc2V0U3RhdGUgKTtcblx0c2V0UmVhZE9ubHlBY2Nlc3NvciggbWluc3RkLCAnc3RhdGVMZW5ndGgnLCBnZXRTdGF0ZUxlbmd0aCApO1xuXHRzZXRSZWFkT25seUFjY2Vzc29yKCBtaW5zdGQsICdieXRlTGVuZ3RoJywgZ2V0U3RhdGVTaXplICk7XG5cdHNldFJlYWRPbmx5KCBtaW5zdGQsICd0b0pTT04nLCB0b0pTT04gKTtcblx0c2V0UmVhZE9ubHkoIG1pbnN0ZCwgJ01JTicsIDEgKTtcblx0c2V0UmVhZE9ubHkoIG1pbnN0ZCwgJ01BWCcsIElOVDMyX01BWC0xICk7XG5cdHNldFJlYWRPbmx5KCBtaW5zdGQsICdub3JtYWxpemVkJywgbm9ybWFsaXplZCApO1xuXG5cdHNldFJlYWRPbmx5KCBub3JtYWxpemVkLCAnTkFNRScsIG1pbnN0ZC5OQU1FICk7XG5cdHNldFJlYWRPbmx5QWNjZXNzb3IoIG5vcm1hbGl6ZWQsICdzZWVkJywgZ2V0U2VlZCApO1xuXHRzZXRSZWFkT25seUFjY2Vzc29yKCBub3JtYWxpemVkLCAnc2VlZExlbmd0aCcsIGdldFNlZWRMZW5ndGggKTtcblx0c2V0UmVhZFdyaXRlQWNjZXNzb3IoIG5vcm1hbGl6ZWQsICdzdGF0ZScsIGdldFN0YXRlLCBzZXRTdGF0ZSApO1xuXHRzZXRSZWFkT25seUFjY2Vzc29yKCBub3JtYWxpemVkLCAnc3RhdGVMZW5ndGgnLCBnZXRTdGF0ZUxlbmd0aCApO1xuXHRzZXRSZWFkT25seUFjY2Vzc29yKCBub3JtYWxpemVkLCAnYnl0ZUxlbmd0aCcsIGdldFN0YXRlU2l6ZSApO1xuXHRzZXRSZWFkT25seSggbm9ybWFsaXplZCwgJ3RvSlNPTicsIHRvSlNPTiApO1xuXHRzZXRSZWFkT25seSggbm9ybWFsaXplZCwgJ01JTicsIChtaW5zdGQuTUlOLTEuMCkgLyBOT1JNQUxJWkFUSU9OX0NPTlNUQU5UICk7XG5cdHNldFJlYWRPbmx5KCBub3JtYWxpemVkLCAnTUFYJywgKG1pbnN0ZC5NQVgtMS4wKSAvIE5PUk1BTElaQVRJT05fQ09OU1RBTlQgKTtcblxuXHRyZXR1cm4gbWluc3RkO1xuXG5cdC8qKlxuXHQqIFJldHVybnMgdGhlIFBSTkcgc2VlZC5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCogQHJldHVybnMge1BSTkdTZWVkTUlOU1REfSBzZWVkXG5cdCovXG5cdGZ1bmN0aW9uIGdldFNlZWQoKSB7XG5cdFx0dmFyIGxlbiA9IFNUQVRFWyBTRUVEX1NFQ1RJT05fT0ZGU0VUIF07XG5cdFx0cmV0dXJuIGdjb3B5KCBsZW4sIHNlZWQsIDEsIG5ldyBJbnQzMkFycmF5KCBsZW4gKSwgMSApO1xuXHR9XG5cblx0LyoqXG5cdCogUmV0dXJucyB0aGUgUFJORyBzZWVkIGxlbmd0aC5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCogQHJldHVybnMge1Bvc2l0aXZlSW50ZWdlcn0gc2VlZCBsZW5ndGhcblx0Ki9cblx0ZnVuY3Rpb24gZ2V0U2VlZExlbmd0aCgpIHtcblx0XHRyZXR1cm4gU1RBVEVbIFNFRURfU0VDVElPTl9PRkZTRVQgXTtcblx0fVxuXG5cdC8qKlxuXHQqIFJldHVybnMgdGhlIFBSTkcgc3RhdGUgbGVuZ3RoLlxuXHQqXG5cdCogQHByaXZhdGVcblx0KiBAcmV0dXJucyB7UG9zaXRpdmVJbnRlZ2VyfSBzdGF0ZSBsZW5ndGhcblx0Ki9cblx0ZnVuY3Rpb24gZ2V0U3RhdGVMZW5ndGgoKSB7XG5cdFx0cmV0dXJuIFNUQVRFLmxlbmd0aDtcblx0fVxuXG5cdC8qKlxuXHQqIFJldHVybnMgdGhlIFBSTkcgc3RhdGUgc2l6ZSAoaW4gYnl0ZXMpLlxuXHQqXG5cdCogQHByaXZhdGVcblx0KiBAcmV0dXJucyB7UG9zaXRpdmVJbnRlZ2VyfSBzdGF0ZSBzaXplIChpbiBieXRlcylcblx0Ki9cblx0ZnVuY3Rpb24gZ2V0U3RhdGVTaXplKCkge1xuXHRcdHJldHVybiBTVEFURS5ieXRlTGVuZ3RoO1xuXHR9XG5cblx0LyoqXG5cdCogUmV0dXJucyB0aGUgY3VycmVudCBQUk5HIHN0YXRlLlxuXHQqXG5cdCogIyMgTm90ZXNcblx0KlxuXHQqIC0gICBUaGUgUFJORyBzdGF0ZSBhcnJheSBpcyBjb21wcmlzZWQgb2YgYSBwcmVhbWJsZSBmb2xsb3dlZCBieSBgMmAgc2VjdGlvbnM6XG5cdCpcblx0KiAgICAgMC4gIHByZWFtYmxlICh2ZXJzaW9uICsgbnVtYmVyIG9mIHNlY3Rpb25zKVxuXHQqICAgICAxLiAgaW50ZXJuYWwgUFJORyBzdGF0ZVxuXHQqICAgICAyLiAgUFJORyBzZWVkXG5cdCpcblx0KiAtICAgVGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIFBSTkcgc3RhdGUgYXJyYXkgcHJlYW1ibGUgaXMgdGhlIHN0YXRlIGFycmF5IHNjaGVtYSB2ZXJzaW9uLlxuXHQqXG5cdCogLSAgIFRoZSBzZWNvbmQgZWxlbWVudCBvZiB0aGUgUFJORyBzdGF0ZSBhcnJheSBwcmVhbWJsZSBpcyB0aGUgbnVtYmVyIG9mIHN0YXRlIGFycmF5IHNlY3Rpb25zIChpLmUuLCBgMmApLlxuXHQqXG5cdCogLSAgIFRoZSBmaXJzdCBlbGVtZW50IG9mIGVhY2ggc2VjdGlvbiBmb2xsb3dpbmcgdGhlIHByZWFtYmxlIHNwZWNpZmllcyB0aGUgc2VjdGlvbiBsZW5ndGguIFRoZSByZW1haW5pbmcgc2VjdGlvbiBlbGVtZW50cyBjb21wcmlzZSB0aGUgc2VjdGlvbiBjb250ZW50cy5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCogQHJldHVybnMge1BSTkdTdGF0ZU1JTlNURH0gY3VycmVudCBzdGF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBnZXRTdGF0ZSgpIHtcblx0XHR2YXIgbGVuID0gU1RBVEUubGVuZ3RoO1xuXHRcdHJldHVybiBnY29weSggbGVuLCBTVEFURSwgMSwgbmV3IEludDMyQXJyYXkoIGxlbiApLCAxICk7XG5cdH1cblxuXHQvKipcblx0KiBTZXRzIHRoZSBQUk5HIHN0YXRlLlxuXHQqXG5cdCogIyMgTm90ZXNcblx0KlxuXHQqIC0gICBJZiBQUk5HIHN0YXRlIGlzIFwic2hhcmVkXCIgKG1lYW5pbmcgYSBzdGF0ZSBhcnJheSB3YXMgcHJvdmlkZWQgZHVyaW5nIFBSTkcgY3JlYXRpb24gYW5kICoqbm90KiogY29waWVkKSBhbmQgb25lIHNldHMgdGhlIGdlbmVyYXRvciBzdGF0ZSB0byBhIHN0YXRlIGFycmF5IGhhdmluZyBhIGRpZmZlcmVudCBsZW5ndGgsIHRoZSBQUk5HIGRvZXMgKipub3QqKiB1cGRhdGUgdGhlIGV4aXN0aW5nIHNoYXJlZCBzdGF0ZSBhbmQsIGluc3RlYWQsIHBvaW50cyB0byB0aGUgbmV3bHkgcHJvdmlkZWQgc3RhdGUgYXJyYXkuIEluIG9yZGVyIHRvIHN5bmNocm9uaXplIFBSTkcgb3V0cHV0IGFjY29yZGluZyB0byB0aGUgbmV3IHNoYXJlZCBzdGF0ZSBhcnJheSwgdGhlIHN0YXRlIGFycmF5IGZvciAqKmVhY2gqKiByZWxldmFudCBQUk5HIG11c3QgYmUgKipleHBsaWNpdGx5Kiogc2V0LlxuXHQqIC0gICBJZiBQUk5HIHN0YXRlIGlzIFwic2hhcmVkXCIgYW5kIG9uZSBzZXRzIHRoZSBnZW5lcmF0b3Igc3RhdGUgdG8gYSBzdGF0ZSBhcnJheSBvZiB0aGUgc2FtZSBsZW5ndGgsIHRoZSBQUk5HIHN0YXRlIGlzIHVwZGF0ZWQgKGFsb25nIHdpdGggdGhlIHN0YXRlIG9mIGFsbCBvdGhlciBQUk5HcyBzaGFyaW5nIHRoZSBQUk5HJ3Mgc3RhdGUgYXJyYXkpLlxuXHQqXG5cdCogQHByaXZhdGVcblx0KiBAcGFyYW0ge1BSTkdTdGF0ZU1JTlNURH0gcyAtIGdlbmVyYXRvciBzdGF0ZVxuXHQqIEB0aHJvd3Mge1R5cGVFcnJvcn0gbXVzdCBwcm92aWRlIGFuIGBJbnQzMkFycmF5YFxuXHQqIEB0aHJvd3Mge0Vycm9yfSBtdXN0IHByb3ZpZGUgYSB2YWxpZCBzdGF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBzZXRTdGF0ZSggcyApIHtcblx0XHR2YXIgZXJyO1xuXHRcdGlmICggIWlzSW50MzJBcnJheSggcyApICkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ2ludmFsaWQgYXJndW1lbnQuIE11c3QgcHJvdmlkZSBhbiBJbnQzMkFycmF5LiBWYWx1ZTogYCcgKyBzICsgJ2AuJyApO1xuXHRcdH1cblx0XHRlcnIgPSB2ZXJpZnlTdGF0ZSggcywgZmFsc2UgKTtcblx0XHRpZiAoIGVyciApIHtcblx0XHRcdHRocm93IGVycjtcblx0XHR9XG5cdFx0aWYgKCBvcHRzLmNvcHkgPT09IGZhbHNlICkge1xuXHRcdFx0aWYgKCBvcHRzLnN0YXRlICYmIHMubGVuZ3RoID09PSBTVEFURS5sZW5ndGggKSB7XG5cdFx0XHRcdGdjb3B5KCBzLmxlbmd0aCwgcywgMSwgU1RBVEUsIDEgKTsgLy8gdXBkYXRlIGN1cnJlbnQgc2hhcmVkIHN0YXRlXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRTVEFURSA9IHM7IC8vIHBvaW50IHRvIG5ldyBzaGFyZWQgc3RhdGVcblx0XHRcdFx0b3B0cy5zdGF0ZSA9IHRydWU7IC8vIHNldHRpbmcgdGhpcyBmbGFnIGFsbG93cyB1cGRhdGluZyBhIHNoYXJlZCBzdGF0ZSBldmVuIGlmIGEgc3RhdGUgYXJyYXkgd2FzIG5vdCBwcm92aWRlZCBhdCBQUk5HIGNyZWF0aW9uXG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIENoZWNrIGlmIHdlIGNhbiByZXVzZSBhbGxvY2F0ZWQgbWVtb3J5Li4uXG5cdFx0XHRpZiAoIHMubGVuZ3RoICE9PSBTVEFURS5sZW5ndGggKSB7XG5cdFx0XHRcdFNUQVRFID0gbmV3IEludDMyQXJyYXkoIHMubGVuZ3RoICk7IC8vIHJlYWxsb2NhdGVcblx0XHRcdH1cblx0XHRcdGdjb3B5KCBzLmxlbmd0aCwgcywgMSwgU1RBVEUsIDEgKTtcblx0XHR9XG5cdFx0Ly8gQ3JlYXRlIGEgbmV3IHN0YXRlIFwidmlld1wiOlxuXHRcdHN0YXRlID0gbmV3IEludDMyQXJyYXkoIFNUQVRFLmJ1ZmZlciwgU1RBVEUuYnl0ZU9mZnNldCsoKFNUQVRFX1NFQ1RJT05fT0ZGU0VUKzEpKlNUQVRFLkJZVEVTX1BFUl9FTEVNRU5UKSwgMSApO1xuXG5cdFx0Ly8gQ3JlYXRlIGEgbmV3IHNlZWQgXCJ2aWV3XCI6XG5cdFx0c2VlZCA9IG5ldyBJbnQzMkFycmF5KCBTVEFURS5idWZmZXIsIFNUQVRFLmJ5dGVPZmZzZXQrKChTRUVEX1NFQ1RJT05fT0ZGU0VUKzEpKlNUQVRFLkJZVEVTX1BFUl9FTEVNRU5UKSwgU1RBVEVbIFNFRURfU0VDVElPTl9PRkZTRVQgXSApO1xuXHR9XG5cblx0LyoqXG5cdCogU2VyaWFsaXplcyB0aGUgcHNldWRvcmFuZG9tIG51bWJlciBnZW5lcmF0b3IgYXMgYSBKU09OIG9iamVjdC5cblx0KlxuXHQqICMjIE5vdGVzXG5cdCpcblx0KiAtICAgYEpTT04uc3RyaW5naWZ5KClgIGltcGxpY2l0bHkgY2FsbHMgdGhpcyBtZXRob2Qgd2hlbiBzdHJpbmdpZnlpbmcgYSBQUk5HLlxuXHQqXG5cdCogQHByaXZhdGVcblx0KiBAcmV0dXJucyB7T2JqZWN0fSBKU09OIHJlcHJlc2VudGF0aW9uXG5cdCovXG5cdGZ1bmN0aW9uIHRvSlNPTigpIHtcblx0XHR2YXIgb3V0ID0ge307XG5cdFx0b3V0LnR5cGUgPSAnUFJORyc7XG5cdFx0b3V0Lm5hbWUgPSBtaW5zdGQuTkFNRTtcblx0XHRvdXQuc3RhdGUgPSB0eXBlZGFycmF5Mmpzb24oIFNUQVRFICk7XG5cdFx0b3V0LnBhcmFtcyA9IFtdO1xuXHRcdHJldHVybiBvdXQ7XG5cdH1cblxuXHQvKipcblx0KiBHZW5lcmF0ZXMgYSBwc2V1ZG9yYW5kb20gaW50ZWdlciBvbiB0aGUgaW50ZXJ2YWwgXFxcXCggWzEsMl57MzF9LTEpIFxcXFwpLlxuXHQqXG5cdCogQHByaXZhdGVcblx0KiBAcmV0dXJucyB7aW50ZWdlcjMyfSBwc2V1ZG9yYW5kb20gaW50ZWdlclxuXHQqL1xuXHRmdW5jdGlvbiBtaW5zdGQoKSB7XG5cdFx0dmFyIHMgPSBzdGF0ZVsgMCBdfDA7IC8vIGFzbSB0eXBlIGFubm90YXRpb25cblx0XHRzID0gKCAoQSpzKSVJTlQzMl9NQVggKXwwOyAvLyBhc20gdHlwZSBhbm5vdGF0aW9uXG5cdFx0c3RhdGVbIDAgXSA9IHM7XG5cdFx0cmV0dXJuIHN8MDsgLy8gYXNtIHR5cGUgYW5ub3RhdGlvblxuXHR9XG5cblx0LyoqXG5cdCogR2VuZXJhdGVzIGEgcHNldWRvcmFuZG9tIG51bWJlciBvbiB0aGUgaW50ZXJ2YWwgXFxcXCggWzAsMSkgXFxcXCkuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqIEByZXR1cm5zIHtudW1iZXJ9IHBzZXVkb3JhbmRvbSBudW1iZXJcblx0Ki9cblx0ZnVuY3Rpb24gbm9ybWFsaXplZCgpIHtcblx0XHRyZXR1cm4gKG1pbnN0ZCgpLTEpIC8gTk9STUFMSVpBVElPTl9DT05TVEFOVDtcblx0fVxufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5O1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGZhY3RvcnkgPSByZXF1aXJlKCAnLi9mYWN0b3J5LmpzJyApO1xudmFyIHJhbmRpbnQzMiA9IHJlcXVpcmUoICcuL3JhbmRfaW50MzIuanMnICk7XG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogR2VuZXJhdGVzIGEgcHNldWRvcmFuZG9tIGludGVnZXIgb24gdGhlIGludGVydmFsIFxcXFwoIFsxLDJeezMxfS0xKSBcXFxcKS5cbipcbiogIyMgTWV0aG9kXG4qXG4qIExpbmVhciBjb25ncnVlbnRpYWwgZ2VuZXJhdG9ycyAoTENHcykgdXNlIHRoZSByZWN1cnJlbmNlIHJlbGF0aW9uXG4qXG4qIGBgYHRleFxuKiBYX3tuKzF9ID0gKCBhIFxcY2RvdCBYX24gKyBjICkgXFxvcGVyYXRvcm5hbWV7bW9kfShtKVxuKiBgYGBcbipcbiogd2hlcmUgdGhlIG1vZHVsdXMgXFxcXCggbSBcXFxcKSBpcyBhIHByaW1lIG51bWJlciBvciBwb3dlciBvZiBhIHByaW1lIG51bWJlciBhbmQgXFxcXCggYSBcXFxcKSBpcyBhIHByaW1pdGl2ZSByb290IG1vZHVsbyBcXFxcKCBtIFxcXFwpLlxuKlxuKiA8IS0tIDxub3RlPiAtLT5cbipcbiogRm9yIGFuIExDRyB0byBiZSBhIExlaG1lciBSTkcsIHRoZSBzZWVkIFxcXFwoIFhfMCBcXFxcKSBtdXN0IGJlIGNvcHJpbWUgdG8gXFxcXCggbSBcXFxcKS5cbipcbiogPCEtLSA8L25vdGU+IC0tPlxuKlxuKiBJbiB0aGlzIGltcGxlbWVudGF0aW9uLCB0aGUgY29uc3RhbnRzIFxcXFwoIGEgXFxcXCksIFxcXFwoIGMgXFxcXCksIGFuZCBcXFxcKCBtIFxcXFwpIGhhdmUgdGhlIHZhbHVlc1xuKlxuKiBgYGB0ZXhcbiogXFxiZWdpbnthbGlnbip9XG4qIGEgJj0gN141ID0gMTY4MDcgXFxcXFxuKiBjICY9IDAgXFxcXFxuKiBtICY9IDJeezMxfSAtIDEgPSAyMTQ3NDgzNjQ3XG4qIFxcZW5ke2FsaWduKn1cbiogYGBgXG4qXG4qIDwhLS0gPG5vdGU+IC0tPlxuKlxuKiBUaGUgY29uc3RhbnQgXFxcXCggbSBcXFxcKSBpcyBhIE1lcnNlbm5lIHByaW1lIChtb2R1bG8gXFxcXCgzMVxcXFwpKS5cbipcbiogPCEtLSA8L25vdGU+IC0tPlxuKlxuKiA8IS0tIDxub3RlPiAtLT5cbipcbiogVGhlIGNvbnN0YW50IFxcXFwoIGEgXFxcXCkgaXMgYSBwcmltaXRpdmUgcm9vdCAobW9kdWxvIFxcXFwoMzFcXFxcKSkuXG4qXG4qIDwhLS0gPC9ub3RlPiAtLT5cbipcbiogQWNjb3JkaW5nbHksIHRoZSBtYXhpbXVtIHBvc3NpYmxlIHByb2R1Y3QgaXNcbipcbiogYGBgdGV4XG4qIDE2ODA3IFxcY2RvdCAobSAtIDEpIFxcYXBwcm94IDJeezQ2fVxuKiBgYGBcbipcbiogVGhlIHZhbHVlcyBmb3IgXFxcXCggYSBcXFxcKSwgXFxcXCggYyBcXFxcKSwgYW5kIFxcXFwoIG0gXFxcXCkgYXJlIHRha2VuIGZyb20gUGFyayBhbmQgTWlsbGVyLCBcIlJhbmRvbSBOdW1iZXIgR2VuZXJhdG9yczogR29vZCBPbmVzIEFyZSBIYXJkIFRvIEZpbmRcIi4gUGFyaydzIGFuZCBNaWxsZXIncyBhcnRpY2xlIGlzIGFsc28gdGhlIGJhc2lzIGZvciBhIHJlY2lwZSBpbiB0aGUgc2Vjb25kIGVkaXRpb24gb2YgX051bWVyaWNhbCBSZWNpcGVzIGluIENfLlxuKlxuKlxuKiAjIyBOb3Rlc1xuKlxuKiAtICAgVGhlIGdlbmVyYXRvciBoYXMgYSBwZXJpb2Qgb2YgYXBwcm94aW1hdGVseSBcXFxcKDIuMVxcbWJveHtlfTlcXFxcKSAoc2VlIFtOdW1lcmljYWwgUmVjaXBlcyBpbiBDLCAybmQgRWRpdGlvbl0oI3JlZmVyZW5jZXMpLCBwLiAyNzkpLlxuKlxuKlxuKiAjIyBSZWZlcmVuY2VzXG4qXG4qIC0gICBQYXJrLCBTLiBLLiwgYW5kIEsuIFcuIE1pbGxlci4gMTk4OC4gXCJSYW5kb20gTnVtYmVyIEdlbmVyYXRvcnM6IEdvb2QgT25lcyBBcmUgSGFyZCB0byBGaW5kLlwiIF9Db21tdW5pY2F0aW9ucyBvZiB0aGUgQUNNXyAzMSAoMTApLiBOZXcgWW9yaywgTlksIFVTQTogQUNNOiAxMTkyXHUyMDEzMTIwMS4gZG9pOlsxMC4xMTQ1LzYzMDM5LjYzMDQyXShodHRwOi8vZHguZG9pLm9yZy8xMC4xMTQ1LzYzMDM5LjYzMDQyKS5cbiogLSAgIFByZXNzLCBXaWxsaWFtIEguLCBCcmlhbiBQLiBGbGFubmVyeSwgU2F1bCBBLiBUZXVrb2xza3ksIGFuZCBXaWxsaWFtIFQuIFZldHRlcmxpbmcuIDE5OTIuIF9OdW1lcmljYWwgUmVjaXBlcyBpbiBDOiBUaGUgQXJ0IG9mIFNjaWVudGlmaWMgQ29tcHV0aW5nLCBTZWNvbmQgRWRpdGlvbl8uIENhbWJyaWRnZSBVbml2ZXJzaXR5IFByZXNzLlxuKlxuKlxuKiBAZnVuY3Rpb24gbWluc3RkXG4qIEB0eXBlIHtQUk5HfVxuKiBAcmV0dXJucyB7UG9zaXRpdmVJbnRlZ2VyfSBwc2V1ZG9yYW5kb20gaW50ZWdlclxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgdiA9IG1pbnN0ZCgpO1xuKiAvLyByZXR1cm5zIDxudW1iZXI+XG4qL1xudmFyIG1pbnN0ZCA9IGZhY3Rvcnkoe1xuXHQnc2VlZCc6IHJhbmRpbnQzMigpXG59KTtcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gbWluc3RkO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBBIGxpbmVhciBjb25ncnVlbnRpYWwgcHNldWRvcmFuZG9tIG51bWJlciBnZW5lcmF0b3IgKExDRykgYmFzZWQgb24gUGFyayBhbmQgTWlsbGVyLlxuKlxuKiBAbW9kdWxlIEBzdGRsaWIvcmFuZG9tLWJhc2UtbWluc3RkXG4qXG4qIEBleGFtcGxlXG4qIHZhciBtaW5zdGQgPSByZXF1aXJlKCAnQHN0ZGxpYi9yYW5kb20tYmFzZS1taW5zdGQnICk7XG4qXG4qIHZhciB2ID0gbWluc3RkKCk7XG4qIC8vIHJldHVybnMgPG51bWJlcj5cbipcbiogQGV4YW1wbGVcbiogdmFyIGZhY3RvcnkgPSByZXF1aXJlKCAnQHN0ZGxpYi9yYW5kb20tYmFzZS1taW5zdGQnICkuZmFjdG9yeTtcbipcbiogdmFyIG1pbnN0ZCA9IGZhY3Rvcnkoe1xuKiAgICAgJ3NlZWQnOiAxMjM0XG4qIH0pO1xuKlxuKiB2YXIgdiA9IG1pbnN0ZCgpO1xuKiAvLyByZXR1cm5zIDIwNzM5ODM4XG4qL1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBzZXRSZWFkT25seSA9IHJlcXVpcmUoICdAc3RkbGliL3V0aWxzLWRlZmluZS1ub25lbnVtZXJhYmxlLXJlYWQtb25seS1wcm9wZXJ0eScgKTtcbnZhciBtaW5zdGQgPSByZXF1aXJlKCAnLi9tYWluLmpzJyApO1xudmFyIGZhY3RvcnkgPSByZXF1aXJlKCAnLi9mYWN0b3J5LmpzJyApO1xuXG5cbi8vIE1BSU4gLy9cblxuc2V0UmVhZE9ubHkoIG1pbnN0ZCwgJ2ZhY3RvcnknLCBmYWN0b3J5ICk7XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1pbnN0ZDtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBpc25hbiA9IHJlcXVpcmUoICdAc3RkbGliL21hdGgtYmFzZS1hc3NlcnQtaXMtbmFuJyApO1xuXG5cbi8vIFZBUklBQkxFUyAvL1xuXG52YXIgTlVNX1dBUk1VUFMgPSA4O1xuXG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIEluaXRpYWxpemVzIGEgc2h1ZmZsZSB0YWJsZS5cbipcbiogQHByaXZhdGVcbiogQHBhcmFtIHtQUk5HfSByYW5kIC0gcHNldWRvcmFuZG9tIG51bWJlciBnZW5lcmF0b3JcbiogQHBhcmFtIHtJbnQzMkFycmF5fSB0YWJsZSAtIHRhYmxlXG4qIEBwYXJhbSB7UG9zaXRpdmVJbnRlZ2VyfSBOIC0gdGFibGUgc2l6ZVxuKiBAdGhyb3dzIHtFcnJvcn0gUFJORyByZXR1cm5lZCBgTmFOYFxuKiBAcmV0dXJucyB7TnVtYmVyQXJyYXl9IHNodWZmbGUgdGFibGVcbiovXG5mdW5jdGlvbiBjcmVhdGVUYWJsZSggcmFuZCwgdGFibGUsIE4gKSB7XG5cdHZhciB2O1xuXHR2YXIgaTtcblxuXHQvLyBcIndhcm0tdXBcIiB0aGUgUFJORy4uLlxuXHRmb3IgKCBpID0gMDsgaSA8IE5VTV9XQVJNVVBTOyBpKysgKSB7XG5cdFx0diA9IHJhbmQoKTtcblxuXHRcdC8vIFByZXZlbnQgdGhlIGFib3ZlIGxvb3AgZnJvbSBiZWluZyBkaXNjYXJkZWQgYnkgdGhlIGNvbXBpbGVyLi4uXG5cdFx0aWYgKCBpc25hbiggdiApICkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAndW5leHBlY3RlZCBlcnJvci4gUFJORyByZXR1cm5lZCBgTmFOYC4nICk7XG5cdFx0fVxuXHR9XG5cdC8vIEluaXRpYWxpemUgdGhlIHNodWZmbGUgdGFibGUuLi5cblx0Zm9yICggaSA9IE4tMTsgaSA+PSAwOyBpLS0gKSB7XG5cdFx0dGFibGVbIGkgXSA9IHJhbmQoKTtcblx0fVxuXHRyZXR1cm4gdGFibGU7XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVRhYmxlO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIElOVDMyX01BWCA9IHJlcXVpcmUoICdAc3RkbGliL2NvbnN0YW50cy1pbnQzMi1tYXgnICk7XG52YXIgZmxvb3IgPSByZXF1aXJlKCAnQHN0ZGxpYi9tYXRoLWJhc2Utc3BlY2lhbC1mbG9vcicgKTtcblxuXG4vLyBWQVJJQUJMRVMgLy9cblxudmFyIE1BWCA9IElOVDMyX01BWCAtIDE7XG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogUmV0dXJucyBhIHBzZXVkb3JhbmRvbSBpbnRlZ2VyIG9uIHRoZSBpbnRlcnZhbCBcXFxcKFsxLCAyXnszMX0tMSlcXFxcKS5cbipcbiogQHByaXZhdGVcbiogQHJldHVybnMge1Bvc2l0aXZlSW50ZWdlcn0gcHNldWRvcmFuZG9tIGludGVnZXJcbipcbiogQGV4YW1wbGVcbiogdmFyIHYgPSByYW5kaW50MzIoKTtcbiogLy8gcmV0dXJucyA8bnVtYmVyPlxuKi9cbmZ1bmN0aW9uIHJhbmRpbnQzMigpIHtcblx0dmFyIHYgPSBmbG9vciggMS4wICsgKE1BWCpNYXRoLnJhbmRvbSgpKSApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHN0ZGxpYi9uby1idWlsdGluLW1hdGhcblx0cmV0dXJuIHZ8MDsgLy8gYXNtIHR5cGUgYW5ub3RhdGlvblxufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSByYW5kaW50MzI7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBzZXRSZWFkT25seSA9IHJlcXVpcmUoICdAc3RkbGliL3V0aWxzLWRlZmluZS1ub25lbnVtZXJhYmxlLXJlYWQtb25seS1wcm9wZXJ0eScgKTtcbnZhciBzZXRSZWFkT25seUFjY2Vzc29yID0gcmVxdWlyZSggJ0BzdGRsaWIvdXRpbHMtZGVmaW5lLW5vbmVudW1lcmFibGUtcmVhZC1vbmx5LWFjY2Vzc29yJyApO1xudmFyIHNldFJlYWRXcml0ZUFjY2Vzc29yID0gcmVxdWlyZSggJ0BzdGRsaWIvdXRpbHMtZGVmaW5lLW5vbmVudW1lcmFibGUtcmVhZC13cml0ZS1hY2Nlc3NvcicgKTtcbnZhciBoYXNPd25Qcm9wID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWhhcy1vd24tcHJvcGVydHknICk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaXMtcGxhaW4tb2JqZWN0JyApO1xudmFyIGlzQm9vbGVhbiA9IHJlcXVpcmUoICdAc3RkbGliL2Fzc2VydC1pcy1ib29sZWFuJyApLmlzUHJpbWl0aXZlO1xudmFyIGlzQ29sbGVjdGlvbiA9IHJlcXVpcmUoICdAc3RkbGliL2Fzc2VydC1pcy1jb2xsZWN0aW9uJyApO1xudmFyIGlzUG9zaXRpdmVJbnRlZ2VyID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLXBvc2l0aXZlLWludGVnZXInICkuaXNQcmltaXRpdmU7XG52YXIgaXNJbnQzMkFycmF5ID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLWludDMyYXJyYXknICk7XG52YXIgZ2NvcHkgPSByZXF1aXJlKCAnQHN0ZGxpYi9ibGFzLWJhc2UtZ2NvcHknICk7XG52YXIgZmxvb3IgPSByZXF1aXJlKCAnQHN0ZGxpYi9tYXRoLWJhc2Utc3BlY2lhbC1mbG9vcicgKTtcbnZhciBJbnQzMkFycmF5ID0gcmVxdWlyZSggJ0BzdGRsaWIvYXJyYXktaW50MzInICk7XG52YXIgSU5UMzJfTUFYID0gcmVxdWlyZSggJ0BzdGRsaWIvY29uc3RhbnRzLWludDMyLW1heCcgKTtcbnZhciB0eXBlZGFycmF5Mmpzb24gPSByZXF1aXJlKCAnQHN0ZGxpYi9hcnJheS10by1qc29uJyApO1xudmFyIGNyZWF0ZVRhYmxlID0gcmVxdWlyZSggJy4vY3JlYXRlX3RhYmxlLmpzJyApO1xudmFyIHJhbmRpbnQzMiA9IHJlcXVpcmUoICcuL3JhbmRfaW50MzIuanMnICk7XG5cblxuLy8gVkFSSUFCTEVTIC8vXG5cbnZhciBOT1JNQUxJWkFUSU9OX0NPTlNUQU5UID0gKElOVDMyX01BWCAtIDEpfDA7IC8vIGFzbSB0eXBlIGFubm90YXRpb25cbnZhciBNQVhfU0VFRCA9IChJTlQzMl9NQVggLSAxKXwwOyAvLyBhc20gdHlwZSBhbm5vdGF0aW9uXG52YXIgQSA9IDE2ODA3fDA7IC8vIGFzbSB0eXBlIGFubm90YXRpb25cblxuLy8gRGVmaW5lIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHNodWZmbGUgdGFibGU6XG52YXIgVEFCTEVfTEVOR1RIID0gMzI7XG5cbi8vIERlZmluZSB0aGUgc3RhdGUgYXJyYXkgc2NoZW1hIHZlcnNpb246XG52YXIgU1RBVEVfQVJSQVlfVkVSU0lPTiA9IDE7IC8vIE5PVEU6IGFueXRpbWUgdGhlIHN0YXRlIGFycmF5IHNjaGVtYSBjaGFuZ2VzLCB0aGlzIHZhbHVlIHNob3VsZCBiZSBpbmNyZW1lbnRlZCEhIVxuXG4vLyBEZWZpbmUgdGhlIG51bWJlciBvZiBzZWN0aW9ucyBpbiB0aGUgc3RhdGUgYXJyYXk6XG52YXIgTlVNX1NUQVRFX1NFQ1RJT05TID0gMzsgLy8gdGFibGUsIG90aGVyLCBzZWVkXG5cbi8vIERlZmluZSB0aGUgaW5kZXggb2Zmc2V0IG9mIHRoZSBcInRhYmxlXCIgc2VjdGlvbiBpbiB0aGUgc3RhdGUgYXJyYXk6XG52YXIgVEFCTEVfU0VDVElPTl9PRkZTRVQgPSAyOyAvLyB8IHZlcnNpb24gfCBudW1fc2VjdGlvbnMgfCB0YWJsZV9sZW5ndGggfCAuLi50YWJsZSB8IG90aGVyX2xlbmd0aCB8IHNodWZmbGVfc3RhdGUgfCBwcm5nX3N0YXRlIHwgc2VlZF9sZW5ndGggfCAuLi5zZWVkIHxcblxuLy8gRGVmaW5lIHRoZSBpbmRleCBvZmZzZXQgb2YgdGhlIFwic3RhdGVcIiBzZWN0aW9uIGluIHRoZSBzdGF0ZSBhcnJheTpcbnZhciBTVEFURV9TRUNUSU9OX09GRlNFVCA9IFRBQkxFX0xFTkdUSCArIDM7IC8vIHwgdmVyc2lvbiB8IG51bV9zZWN0aW9ucyB8IHRhYmxlX2xlbmd0aCB8IC4uLnRhYmxlIHwgc3RhdGVfbGVuZ3RoIHwgc2h1ZmZsZV9zdGF0ZSB8IHBybmdfc3RhdGUgfCBzZWVkX2xlbmd0aCB8IC4uLnNlZWQgfFxuXG4vLyBEZWZpbmUgdGhlIGluZGV4IG9mZnNldCBvZiB0aGUgc2VlZCBzZWN0aW9uIGluIHRoZSBzdGF0ZSBhcnJheTpcbnZhciBTRUVEX1NFQ1RJT05fT0ZGU0VUID0gVEFCTEVfTEVOR1RIICsgNjsgLy8gfCB2ZXJzaW9uIHwgbnVtX3NlY3Rpb25zIHwgdGFibGVfbGVuZ3RoIHwgLi4udGFibGUgfCBzdGF0ZV9sZW5ndGggfCBzaHVmZmxlX3N0YXRlIHwgcHJuZ19zdGF0ZSB8IHNlZWRfbGVuZ3RoIHwgLi4uc2VlZCB8XG5cbi8vIERlZmluZSB0aGUgbGVuZ3RoIG9mIHRoZSBcImZpeGVkXCIgbGVuZ3RoIHBvcnRpb24gb2YgdGhlIHN0YXRlIGFycmF5OlxudmFyIFNUQVRFX0ZJWEVEX0xFTkdUSCA9IFRBQkxFX0xFTkdUSCArIDc7IC8vIDEgKHZlcnNpb24pICsgMSAobnVtX3NlY3Rpb25zKSArIDEgKHRhYmxlX2xlbmd0aCkgKyBUQUJMRV9MRU5HVEggKHRhYmxlKSArIDEgKHN0YXRlX2xlbmd0aCkgKyAxIChzaHVmZmxlX3N0YXRlKSArIDEgKHBybmdfc3RhdGUpICsgMSAoc2VlZF9sZW5ndGgpXG5cbi8vIERlZmluZSB0aGUgaW5kaWNlcyBmb3IgdGhlIHNodWZmbGUgdGFibGUgYW5kIFBSTkcgc3RhdGVzOlxudmFyIFNIVUZGTEVfU1RBVEUgPSBTVEFURV9TRUNUSU9OX09GRlNFVCArIDE7XG52YXIgUFJOR19TVEFURSA9IFNUQVRFX1NFQ1RJT05fT0ZGU0VUICsgMjtcblxuXG4vLyBGVU5DVElPTlMgLy9cblxuLyoqXG4qIFZlcmlmaWVzIHN0YXRlIGFycmF5IGludGVncml0eS5cbipcbiogQHByaXZhdGVcbiogQHBhcmFtIHtJbnQzMkFycmF5fSBzdGF0ZSAtIHN0YXRlIGFycmF5XG4qIEBwYXJhbSB7Ym9vbGVhbn0gRkxHIC0gZmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHN0YXRlIGFycmF5IHdhcyBwcm92aWRlZCBhcyBhbiBvcHRpb24gKHRydWUpIG9yIGFuIGFyZ3VtZW50IChmYWxzZSlcbiogQHJldHVybnMgeyhFcnJvcnxudWxsKX0gYW4gZXJyb3Igb3IgYG51bGxgXG4qL1xuZnVuY3Rpb24gdmVyaWZ5U3RhdGUoIHN0YXRlLCBGTEcgKSB7XG5cdHZhciBzMTtcblx0aWYgKCBGTEcgKSB7XG5cdFx0czEgPSAnb3B0aW9uJztcblx0fSBlbHNlIHtcblx0XHRzMSA9ICdhcmd1bWVudCc7XG5cdH1cblx0Ly8gVGhlIHN0YXRlIGFycmF5IG11c3QgaGF2ZSBhIG1pbmltdW0gbGVuZ3RoLi4uXG5cdGlmICggc3RhdGUubGVuZ3RoIDwgU1RBVEVfRklYRURfTEVOR1RIKzEgKSB7XG5cdFx0cmV0dXJuIG5ldyBSYW5nZUVycm9yKCAnaW52YWxpZCAnK3MxKycuIGBzdGF0ZWAgYXJyYXkgaGFzIGluc3VmZmljaWVudCBsZW5ndGguJyApO1xuXHR9XG5cdC8vIFRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBzdGF0ZSBhcnJheSBtdXN0IGVxdWFsIHRoZSBzdXBwb3J0ZWQgc3RhdGUgYXJyYXkgc2NoZW1hIHZlcnNpb24uLi5cblx0aWYgKCBzdGF0ZVsgMCBdICE9PSBTVEFURV9BUlJBWV9WRVJTSU9OICkge1xuXHRcdHJldHVybiBuZXcgUmFuZ2VFcnJvciggJ2ludmFsaWQgJytzMSsnLiBgc3RhdGVgIGFycmF5IGhhcyBhbiBpbmNvbXBhdGlibGUgc2NoZW1hIHZlcnNpb24uIEV4cGVjdGVkOiAnK1NUQVRFX0FSUkFZX1ZFUlNJT04rJy4gQWN0dWFsOiAnK3N0YXRlWyAwIF0rJy4nICk7XG5cdH1cblx0Ly8gVGhlIHNlY29uZCBlbGVtZW50IG9mIHRoZSBzdGF0ZSBhcnJheSBtdXN0IGNvbnRhaW4gdGhlIG51bWJlciBvZiBzZWN0aW9ucy4uLlxuXHRpZiAoIHN0YXRlWyAxIF0gIT09IE5VTV9TVEFURV9TRUNUSU9OUyApIHtcblx0XHRyZXR1cm4gbmV3IFJhbmdlRXJyb3IoICdpbnZhbGlkICcrczErJy4gYHN0YXRlYCBhcnJheSBoYXMgYW4gaW5jb21wYXRpYmxlIG51bWJlciBvZiBzZWN0aW9ucy4gRXhwZWN0ZWQ6ICcrTlVNX1NUQVRFX1NFQ1RJT05TKycuIEFjdHVhbDogJytzdGF0ZVsgMSBdKycuJyApO1xuXHR9XG5cdC8vIFRoZSBsZW5ndGggb2YgdGhlIFwidGFibGVcIiBzZWN0aW9uIG11c3QgZXF1YWwgYFRBQkxFX0xFTkdUSGAuLi5cblx0aWYgKCBzdGF0ZVsgVEFCTEVfU0VDVElPTl9PRkZTRVQgXSAhPT0gVEFCTEVfTEVOR1RIICkge1xuXHRcdHJldHVybiBuZXcgUmFuZ2VFcnJvciggJ2ludmFsaWQgJytzMSsnLiBgc3RhdGVgIGFycmF5IGhhcyBhbiBpbmNvbXBhdGlibGUgdGFibGUgbGVuZ3RoLiBFeHBlY3RlZDogJytUQUJMRV9MRU5HVEgrJy4gQWN0dWFsOiAnK3N0YXRlWyBUQUJMRV9TRUNUSU9OX09GRlNFVCBdKycuJyApO1xuXHR9XG5cdC8vIFRoZSBsZW5ndGggb2YgdGhlIFwic3RhdGVcIiBzZWN0aW9uIG11c3QgZXF1YWwgYDJgLi4uXG5cdGlmICggc3RhdGVbIFNUQVRFX1NFQ1RJT05fT0ZGU0VUIF0gIT09IDIgKSB7XG5cdFx0cmV0dXJuIG5ldyBSYW5nZUVycm9yKCAnaW52YWxpZCAnK3MxKycuIGBzdGF0ZWAgYXJyYXkgaGFzIGFuIGluY29tcGF0aWJsZSBzdGF0ZSBsZW5ndGguIEV4cGVjdGVkOiAnKygyKS50b1N0cmluZygpKycuIEFjdHVhbDogJytzdGF0ZVsgU1RBVEVfU0VDVElPTl9PRkZTRVQgXSsnLicgKTtcblx0fVxuXHQvLyBUaGUgbGVuZ3RoIG9mIHRoZSBcInNlZWRcIiBzZWN0aW9uIG11Y2ggbWF0Y2ggdGhlIGVtcGlyaWNhbCBsZW5ndGguLi5cblx0aWYgKCBzdGF0ZVsgU0VFRF9TRUNUSU9OX09GRlNFVCBdICE9PSBzdGF0ZS5sZW5ndGgtU1RBVEVfRklYRURfTEVOR1RIICkge1xuXHRcdHJldHVybiBuZXcgUmFuZ2VFcnJvciggJ2ludmFsaWQgJytzMSsnLiBgc3RhdGVgIGFycmF5IGxlbmd0aCBpcyBpbmNvbXBhdGlibGUgd2l0aCBzZWVkIHNlY3Rpb24gbGVuZ3RoLiBFeHBlY3RlZDogJysoc3RhdGUubGVuZ3RoLVNUQVRFX0ZJWEVEX0xFTkdUSCkrJy4gQWN0dWFsOiAnK3N0YXRlWyBTRUVEX1NFQ1RJT05fT0ZGU0VUIF0rJy4nICk7XG5cdH1cblx0cmV0dXJuIG51bGw7XG59XG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogUmV0dXJucyBhIGxpbmVhciBjb25ncnVlbnRpYWwgcHNldWRvcmFuZG9tIG51bWJlciBnZW5lcmF0b3IgKExDRykgd2hvc2Ugb3V0cHV0IGlzIHNodWZmbGVkLlxuKlxuKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSAtIG9wdGlvbnNcbiogQHBhcmFtIHtQUk5HU2VlZE1JTlNURH0gW29wdGlvbnMuc2VlZF0gLSBwc2V1ZG9yYW5kb20gbnVtYmVyIGdlbmVyYXRvciBzZWVkXG4qIEBwYXJhbSB7UFJOR1N0YXRlTUlOU1REfSBbb3B0aW9ucy5zdGF0ZV0gLSBwc2V1ZG9yYW5kb20gbnVtYmVyIGdlbmVyYXRvciBzdGF0ZVxuKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNvcHk9dHJ1ZV0gLSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0byBjb3B5IGEgcHJvdmlkZWQgcHNldWRvcmFuZG9tIG51bWJlciBnZW5lcmF0b3Igc3RhdGVcbiogQHRocm93cyB7VHlwZUVycm9yfSBvcHRpb25zIGFyZ3VtZW50IG11c3QgYmUgYW4gb2JqZWN0XG4qIEB0aHJvd3Mge1R5cGVFcnJvcn0gYSBzZWVkIG11c3QgYmUgZWl0aGVyIGEgcG9zaXRpdmUgaW50ZWdlciBsZXNzIHRoYW4gdGhlIG1heGltdW0gc2lnbmVkIDMyLWJpdCBpbnRlZ2VyIG9yIGFuIGFycmF5LWxpa2Ugb2JqZWN0IGNvbnRhaW5pbmcgaW50ZWdlcnMgbGVzcyB0aGFuIHRoZSBtYXhpbXVtIHNpZ25lZCAzMi1iaXQgaW50ZWdlclxuKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBhIG51bWVyaWMgc2VlZCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBsZXNzIHRoYW4gdGhlIG1heGltdW0gc2lnbmVkIDMyLWJpdCBpbnRlZ2VyXG4qIEB0aHJvd3Mge1R5cGVFcnJvcn0gc3RhdGUgbXVzdCBiZSBhbiBgSW50MzJBcnJheWBcbiogQHRocm93cyB7RXJyb3J9IG11c3QgcHJvdmlkZSBhIHZhbGlkIHN0YXRlXG4qIEB0aHJvd3Mge1R5cGVFcnJvcn0gYGNvcHlgIG9wdGlvbiBtdXN0IGJlIGEgYm9vbGVhblxuKiBAcmV0dXJucyB7UFJOR30gc2h1ZmZsZWQgTENHIFBSTkdcbipcbiogQGV4YW1wbGVcbiogdmFyIG1pbnN0ZCA9IGZhY3RvcnkoKTtcbipcbiogdmFyIHYgPSBtaW5zdGQoKTtcbiogLy8gcmV0dXJucyA8bnVtYmVyPlxuKlxuKiBAZXhhbXBsZVxuKiAvLyBSZXR1cm4gYSBzZWVkZWQgTENHOlxuKiB2YXIgbWluc3RkID0gZmFjdG9yeSh7XG4qICAgICAnc2VlZCc6IDEyMzRcbiogfSk7XG4qXG4qIHZhciB2ID0gbWluc3RkKCk7XG4qIC8vIHJldHVybnMgMTQyMTYwMDY1NFxuKi9cbmZ1bmN0aW9uIGZhY3RvcnkoIG9wdGlvbnMgKSB7XG5cdHZhciBTVEFURTtcblx0dmFyIHN0YXRlO1xuXHR2YXIgb3B0cztcblx0dmFyIHNlZWQ7XG5cdHZhciBzbGVuO1xuXHR2YXIgZXJyO1xuXG5cdG9wdHMgPSB7fTtcblx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdGlmICggIWlzT2JqZWN0KCBvcHRpb25zICkgKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnaW52YWxpZCBhcmd1bWVudC4gT3B0aW9ucyBhcmd1bWVudCBtdXN0IGJlIGFuIG9iamVjdC4gVmFsdWU6IGAnICsgb3B0aW9ucyArICdgLicgKTtcblx0XHR9XG5cdFx0aWYgKCBoYXNPd25Qcm9wKCBvcHRpb25zLCAnY29weScgKSApIHtcblx0XHRcdG9wdHMuY29weSA9IG9wdGlvbnMuY29weTtcblx0XHRcdGlmICggIWlzQm9vbGVhbiggb3B0aW9ucy5jb3B5ICkgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdpbnZhbGlkIG9wdGlvbi4gYGNvcHlgIG9wdGlvbiBtdXN0IGJlIGEgYm9vbGVhbi4gT3B0aW9uOiBgJyArIG9wdGlvbnMuY29weSArICdgLicgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCBoYXNPd25Qcm9wKCBvcHRpb25zLCAnc3RhdGUnICkgKSB7XG5cdFx0XHRzdGF0ZSA9IG9wdGlvbnMuc3RhdGU7XG5cdFx0XHRvcHRzLnN0YXRlID0gdHJ1ZTtcblx0XHRcdGlmICggIWlzSW50MzJBcnJheSggc3RhdGUgKSApIHtcblx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ2ludmFsaWQgb3B0aW9uLiBgc3RhdGVgIG9wdGlvbiBtdXN0IGJlIGFuIEludDMyQXJyYXkuIE9wdGlvbjogYCcgKyBzdGF0ZSArICdgLicgKTtcblx0XHRcdH1cblx0XHRcdGVyciA9IHZlcmlmeVN0YXRlKCBzdGF0ZSwgdHJ1ZSApO1xuXHRcdFx0aWYgKCBlcnIgKSB7XG5cdFx0XHRcdHRocm93IGVycjtcblx0XHRcdH1cblx0XHRcdGlmICggb3B0cy5jb3B5ID09PSBmYWxzZSApIHtcblx0XHRcdFx0U1RBVEUgPSBzdGF0ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFNUQVRFID0gbmV3IEludDMyQXJyYXkoIHN0YXRlLmxlbmd0aCApO1xuXHRcdFx0XHRnY29weSggc3RhdGUubGVuZ3RoLCBzdGF0ZSwgMSwgU1RBVEUsIDEgKTtcblx0XHRcdH1cblx0XHRcdC8vIENyZWF0ZSBhIHN0YXRlICh0YWJsZSkgXCJ2aWV3XCI6XG5cdFx0XHRzdGF0ZSA9IG5ldyBJbnQzMkFycmF5KCBTVEFURS5idWZmZXIsIFNUQVRFLmJ5dGVPZmZzZXQrKChUQUJMRV9TRUNUSU9OX09GRlNFVCsxKSpTVEFURS5CWVRFU19QRVJfRUxFTUVOVCksIFRBQkxFX0xFTkdUSCApO1xuXG5cdFx0XHQvLyBDcmVhdGUgYSBzZWVkIFwidmlld1wiOlxuXHRcdFx0c2VlZCA9IG5ldyBJbnQzMkFycmF5KCBTVEFURS5idWZmZXIsIFNUQVRFLmJ5dGVPZmZzZXQrKChTRUVEX1NFQ1RJT05fT0ZGU0VUKzEpKlNUQVRFLkJZVEVTX1BFUl9FTEVNRU5UKSwgc3RhdGVbIFNFRURfU0VDVElPTl9PRkZTRVQgXSApO1xuXHRcdH1cblx0XHQvLyBJZiBwcm92aWRlZCBhIFBSTkcgc3RhdGUsIHdlIGlnbm9yZSB0aGUgYHNlZWRgIG9wdGlvbi4uLlxuXHRcdGlmICggc2VlZCA9PT0gdm9pZCAwICkge1xuXHRcdFx0aWYgKCBoYXNPd25Qcm9wKCBvcHRpb25zLCAnc2VlZCcgKSApIHtcblx0XHRcdFx0c2VlZCA9IG9wdGlvbnMuc2VlZDtcblx0XHRcdFx0b3B0cy5zZWVkID0gdHJ1ZTtcblx0XHRcdFx0aWYgKCBpc1Bvc2l0aXZlSW50ZWdlciggc2VlZCApICkge1xuXHRcdFx0XHRcdGlmICggc2VlZCA+IE1BWF9TRUVEICkge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoICdpbnZhbGlkIG9wdGlvbi4gYHNlZWRgIG9wdGlvbiBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBsZXNzIHRoYW4gdGhlIG1heGltdW0gc2lnbmVkIDMyLWJpdCBpbnRlZ2VyLiBPcHRpb246IGAnICsgc2VlZCArICdgLicgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c2VlZCB8PSAwOyAvLyBhc20gdHlwZSBhbm5vdGF0aW9uXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGlzQ29sbGVjdGlvbiggc2VlZCApICYmIHNlZWQubGVuZ3RoID4gMCApIHtcblx0XHRcdFx0XHRzbGVuID0gc2VlZC5sZW5ndGg7XG5cdFx0XHRcdFx0U1RBVEUgPSBuZXcgSW50MzJBcnJheSggU1RBVEVfRklYRURfTEVOR1RIK3NsZW4gKTtcblxuXHRcdFx0XHRcdC8vIEluaXRpYWxpemUgc2VjdGlvbnM6XG5cdFx0XHRcdFx0U1RBVEVbIDAgXSA9IFNUQVRFX0FSUkFZX1ZFUlNJT047XG5cdFx0XHRcdFx0U1RBVEVbIDEgXSA9IE5VTV9TVEFURV9TRUNUSU9OUztcblx0XHRcdFx0XHRTVEFURVsgVEFCTEVfU0VDVElPTl9PRkZTRVQgXSA9IFRBQkxFX0xFTkdUSDtcblx0XHRcdFx0XHRTVEFURVsgU1RBVEVfU0VDVElPTl9PRkZTRVQgXSA9IDI7XG5cdFx0XHRcdFx0U1RBVEVbIFBSTkdfU1RBVEUgXSA9IHNlZWRbIDAgXTtcblx0XHRcdFx0XHRTVEFURVsgU0VFRF9TRUNUSU9OX09GRlNFVCBdID0gc2xlbjtcblxuXHRcdFx0XHRcdC8vIENvcHkgdGhlIHByb3ZpZGVkIHNlZWQgYXJyYXkgdG8gcHJldmVudCBleHRlcm5hbCBtdXRhdGlvbiwgYXMgbXV0YXRpb24gd291bGQgbGVhZCB0byBhbiBpbmFiaWxpdHkgdG8gcmVwcm9kdWNlIFBSTkcgdmFsdWVzIGFjY29yZGluZyB0byB0aGUgUFJORydzIHN0YXRlZCBzZWVkOlxuXHRcdFx0XHRcdGdjb3B5Lm5kYXJyYXkoIHNsZW4sIHNlZWQsIDEsIDAsIFNUQVRFLCAxLCBTRUVEX1NFQ1RJT05fT0ZGU0VUKzEgKTtcblxuXHRcdFx0XHRcdC8vIENyZWF0ZSBhIHN0YXRlICh0YWJsZSkgXCJ2aWV3XCI6XG5cdFx0XHRcdFx0c3RhdGUgPSBuZXcgSW50MzJBcnJheSggU1RBVEUuYnVmZmVyLCBTVEFURS5ieXRlT2Zmc2V0KygoVEFCTEVfU0VDVElPTl9PRkZTRVQrMSkqU1RBVEUuQllURVNfUEVSX0VMRU1FTlQpLCBUQUJMRV9MRU5HVEggKTtcblxuXHRcdFx0XHRcdC8vIENyZWF0ZSBhIHNlZWQgXCJ2aWV3XCI6XG5cdFx0XHRcdFx0c2VlZCA9IG5ldyBJbnQzMkFycmF5KCBTVEFURS5idWZmZXIsIFNUQVRFLmJ5dGVPZmZzZXQrKChTRUVEX1NFQ1RJT05fT0ZGU0VUKzEpKlNUQVRFLkJZVEVTX1BFUl9FTEVNRU5UKSwgc2xlbiApO1xuXG5cdFx0XHRcdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgaW50ZXJuYWwgUFJORyBzdGF0ZTpcblx0XHRcdFx0XHRzdGF0ZSA9IGNyZWF0ZVRhYmxlKCBtaW5zdGQsIHN0YXRlLCBUQUJMRV9MRU5HVEggKTtcblx0XHRcdFx0XHRTVEFURVsgU0hVRkZMRV9TVEFURSBdID0gc3RhdGVbIDAgXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnaW52YWxpZCBvcHRpb24uIGBzZWVkYCBvcHRpb24gbXVzdCBiZSBlaXRoZXIgYSBwb3NpdGl2ZSBpbnRlZ2VyIGxlc3MgdGhhbiB0aGUgbWF4aW11bSBzaWduZWQgMzItYml0IGludGVnZXIgb3IgYW4gYXJyYXktbGlrZSBvYmplY3QgY29udGFpbmluZyBpbnRlZ2VyIHZhbHVlcyBsZXNzIHRoYW4gdGhlIG1heGltdW0gc2lnbmVkIDMyLWJpdCBpbnRlZ2VyLiBPcHRpb246IGAnICsgc2VlZCArICdgLicgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VlZCA9IHJhbmRpbnQzMigpfDA7IC8vIGFzbSB0eXBlIGFubm90YXRpb25cblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0c2VlZCA9IHJhbmRpbnQzMigpfDA7IC8vIGFzbSB0eXBlIGFubm90YXRpb25cblx0fVxuXHRpZiAoIHN0YXRlID09PSB2b2lkIDAgKSB7XG5cdFx0U1RBVEUgPSBuZXcgSW50MzJBcnJheSggU1RBVEVfRklYRURfTEVOR1RIKzEgKTtcblxuXHRcdC8vIEluaXRpYWxpemUgc2VjdGlvbnM6XG5cdFx0U1RBVEVbIDAgXSA9IFNUQVRFX0FSUkFZX1ZFUlNJT047XG5cdFx0U1RBVEVbIDEgXSA9IE5VTV9TVEFURV9TRUNUSU9OUztcblx0XHRTVEFURVsgVEFCTEVfU0VDVElPTl9PRkZTRVQgXSA9IFRBQkxFX0xFTkdUSDtcblx0XHRTVEFURVsgU1RBVEVfU0VDVElPTl9PRkZTRVQgXSA9IDI7XG5cdFx0U1RBVEVbIFBSTkdfU1RBVEUgXSA9IHNlZWQ7XG5cdFx0U1RBVEVbIFNFRURfU0VDVElPTl9PRkZTRVQgXSA9IDE7XG5cdFx0U1RBVEVbIFNFRURfU0VDVElPTl9PRkZTRVQrMSBdID0gc2VlZDtcblxuXHRcdC8vIENyZWF0ZSBhIHN0YXRlICh0YWJsZSkgXCJ2aWV3XCI6XG5cdFx0c3RhdGUgPSBuZXcgSW50MzJBcnJheSggU1RBVEUuYnVmZmVyLCBTVEFURS5ieXRlT2Zmc2V0KygoVEFCTEVfU0VDVElPTl9PRkZTRVQrMSkqU1RBVEUuQllURVNfUEVSX0VMRU1FTlQpLCBUQUJMRV9MRU5HVEggKTtcblxuXHRcdC8vIENyZWF0ZSBhIHNlZWQgXCJ2aWV3XCI6XG5cdFx0c2VlZCA9IG5ldyBJbnQzMkFycmF5KCBTVEFURS5idWZmZXIsIFNUQVRFLmJ5dGVPZmZzZXQrKChTRUVEX1NFQ1RJT05fT0ZGU0VUKzEpKlNUQVRFLkJZVEVTX1BFUl9FTEVNRU5UKSwgMSApO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgaW50ZXJuYWwgUFJORyBzdGF0ZTpcblx0XHRzdGF0ZSA9IGNyZWF0ZVRhYmxlKCBtaW5zdGQsIHN0YXRlLCBUQUJMRV9MRU5HVEggKTtcblx0XHRTVEFURVsgU0hVRkZMRV9TVEFURSBdID0gc3RhdGVbIDAgXTtcblx0fVxuXHRzZXRSZWFkT25seSggbWluc3RkU2h1ZmZsZSwgJ05BTUUnLCAnbWluc3RkLXNodWZmbGUnICk7XG5cdHNldFJlYWRPbmx5QWNjZXNzb3IoIG1pbnN0ZFNodWZmbGUsICdzZWVkJywgZ2V0U2VlZCApO1xuXHRzZXRSZWFkT25seUFjY2Vzc29yKCBtaW5zdGRTaHVmZmxlLCAnc2VlZExlbmd0aCcsIGdldFNlZWRMZW5ndGggKTtcblx0c2V0UmVhZFdyaXRlQWNjZXNzb3IoIG1pbnN0ZFNodWZmbGUsICdzdGF0ZScsIGdldFN0YXRlLCBzZXRTdGF0ZSApO1xuXHRzZXRSZWFkT25seUFjY2Vzc29yKCBtaW5zdGRTaHVmZmxlLCAnc3RhdGVMZW5ndGgnLCBnZXRTdGF0ZUxlbmd0aCApO1xuXHRzZXRSZWFkT25seUFjY2Vzc29yKCBtaW5zdGRTaHVmZmxlLCAnYnl0ZUxlbmd0aCcsIGdldFN0YXRlU2l6ZSApO1xuXHRzZXRSZWFkT25seSggbWluc3RkU2h1ZmZsZSwgJ3RvSlNPTicsIHRvSlNPTiApO1xuXHRzZXRSZWFkT25seSggbWluc3RkU2h1ZmZsZSwgJ01JTicsIDEgKTtcblx0c2V0UmVhZE9ubHkoIG1pbnN0ZFNodWZmbGUsICdNQVgnLCBJTlQzMl9NQVgtMSApO1xuXHRzZXRSZWFkT25seSggbWluc3RkU2h1ZmZsZSwgJ25vcm1hbGl6ZWQnLCBub3JtYWxpemVkICk7XG5cblx0c2V0UmVhZE9ubHkoIG5vcm1hbGl6ZWQsICdOQU1FJywgbWluc3RkU2h1ZmZsZS5OQU1FICk7XG5cdHNldFJlYWRPbmx5QWNjZXNzb3IoIG5vcm1hbGl6ZWQsICdzZWVkJywgZ2V0U2VlZCApO1xuXHRzZXRSZWFkT25seUFjY2Vzc29yKCBub3JtYWxpemVkLCAnc2VlZExlbmd0aCcsIGdldFNlZWRMZW5ndGggKTtcblx0c2V0UmVhZFdyaXRlQWNjZXNzb3IoIG5vcm1hbGl6ZWQsICdzdGF0ZScsIGdldFN0YXRlLCBzZXRTdGF0ZSApO1xuXHRzZXRSZWFkT25seUFjY2Vzc29yKCBub3JtYWxpemVkLCAnc3RhdGVMZW5ndGgnLCBnZXRTdGF0ZUxlbmd0aCApO1xuXHRzZXRSZWFkT25seUFjY2Vzc29yKCBub3JtYWxpemVkLCAnYnl0ZUxlbmd0aCcsIGdldFN0YXRlU2l6ZSApO1xuXHRzZXRSZWFkT25seSggbm9ybWFsaXplZCwgJ3RvSlNPTicsIHRvSlNPTiApO1xuXHRzZXRSZWFkT25seSggbm9ybWFsaXplZCwgJ01JTicsIChtaW5zdGRTaHVmZmxlLk1JTi0xLjApIC8gTk9STUFMSVpBVElPTl9DT05TVEFOVCApO1xuXHRzZXRSZWFkT25seSggbm9ybWFsaXplZCwgJ01BWCcsIChtaW5zdGRTaHVmZmxlLk1BWC0xLjApIC8gTk9STUFMSVpBVElPTl9DT05TVEFOVCApO1xuXG5cdHJldHVybiBtaW5zdGRTaHVmZmxlO1xuXG5cdC8qKlxuXHQqIFJldHVybnMgdGhlIFBSTkcgc2VlZC5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCogQHJldHVybnMge1BSTkdTZWVkTUlOU1REfSBzZWVkXG5cdCovXG5cdGZ1bmN0aW9uIGdldFNlZWQoKSB7XG5cdFx0dmFyIGxlbiA9IFNUQVRFWyBTRUVEX1NFQ1RJT05fT0ZGU0VUIF07XG5cdFx0cmV0dXJuIGdjb3B5KCBsZW4sIHNlZWQsIDEsIG5ldyBJbnQzMkFycmF5KCBsZW4gKSwgMSApO1xuXHR9XG5cblx0LyoqXG5cdCogUmV0dXJucyB0aGUgUFJORyBzZWVkIGxlbmd0aC5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCogQHJldHVybnMge1Bvc2l0aXZlSW50ZWdlcn0gc2VlZCBsZW5ndGhcblx0Ki9cblx0ZnVuY3Rpb24gZ2V0U2VlZExlbmd0aCgpIHtcblx0XHRyZXR1cm4gU1RBVEVbIFNFRURfU0VDVElPTl9PRkZTRVQgXTtcblx0fVxuXG5cdC8qKlxuXHQqIFJldHVybnMgdGhlIFBSTkcgc3RhdGUgbGVuZ3RoLlxuXHQqXG5cdCogQHByaXZhdGVcblx0KiBAcmV0dXJucyB7UG9zaXRpdmVJbnRlZ2VyfSBzdGF0ZSBsZW5ndGhcblx0Ki9cblx0ZnVuY3Rpb24gZ2V0U3RhdGVMZW5ndGgoKSB7XG5cdFx0cmV0dXJuIFNUQVRFLmxlbmd0aDtcblx0fVxuXG5cdC8qKlxuXHQqIFJldHVybnMgdGhlIFBSTkcgc3RhdGUgc2l6ZSAoaW4gYnl0ZXMpLlxuXHQqXG5cdCogQHByaXZhdGVcblx0KiBAcmV0dXJucyB7UG9zaXRpdmVJbnRlZ2VyfSBzdGF0ZSBzaXplIChpbiBieXRlcylcblx0Ki9cblx0ZnVuY3Rpb24gZ2V0U3RhdGVTaXplKCkge1xuXHRcdHJldHVybiBTVEFURS5ieXRlTGVuZ3RoO1xuXHR9XG5cblx0LyoqXG5cdCogUmV0dXJucyB0aGUgY3VycmVudCBQUk5HIHN0YXRlLlxuXHQqXG5cdCogIyMgTm90ZXNcblx0KlxuXHQqIC0gICBUaGUgUFJORyBzdGF0ZSBhcnJheSBpcyBjb21wcmlzZWQgb2YgYSBwcmVhbWJsZSBmb2xsb3dlZCBieSBgM2Agc2VjdGlvbnM6XG5cdCpcblx0KiAgICAgMC4gIHByZWFtYmxlICh2ZXJzaW9uICsgbnVtYmVyIG9mIHNlY3Rpb25zKVxuXHQqICAgICAxLiAgc2h1ZmZsZSB0YWJsZVxuXHQqICAgICAyLiAgaW50ZXJuYWwgUFJORyBzdGF0ZVxuXHQqICAgICAzLiAgUFJORyBzZWVkXG5cdCpcblx0KiAtICAgVGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIFBSTkcgc3RhdGUgYXJyYXkgcHJlYW1ibGUgaXMgdGhlIHN0YXRlIGFycmF5IHNjaGVtYSB2ZXJzaW9uLlxuXHQqXG5cdCogLSAgIFRoZSBzZWNvbmQgZWxlbWVudCBvZiB0aGUgUFJORyBzdGF0ZSBhcnJheSBwcmVhbWJsZSBpcyB0aGUgbnVtYmVyIG9mIHN0YXRlIGFycmF5IHNlY3Rpb25zIChpLmUuLCBgM2ApLlxuXHQqXG5cdCogLSAgIFRoZSBmaXJzdCBlbGVtZW50IG9mIGVhY2ggc2VjdGlvbiBmb2xsb3dpbmcgdGhlIHByZWFtYmxlIHNwZWNpZmllcyB0aGUgc2VjdGlvbiBsZW5ndGguIFRoZSByZW1haW5pbmcgc2VjdGlvbiBlbGVtZW50cyBjb21wcmlzZSB0aGUgc2VjdGlvbiBjb250ZW50cy5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCogQHJldHVybnMge1BSTkdTdGF0ZU1JTlNURH0gY3VycmVudCBzdGF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBnZXRTdGF0ZSgpIHtcblx0XHR2YXIgbGVuID0gU1RBVEUubGVuZ3RoO1xuXHRcdHJldHVybiBnY29weSggbGVuLCBTVEFURSwgMSwgbmV3IEludDMyQXJyYXkoIGxlbiApLCAxICk7XG5cdH1cblxuXHQvKipcblx0KiBTZXRzIHRoZSBQUk5HIHN0YXRlLlxuXHQqXG5cdCogIyMgTm90ZXNcblx0KlxuXHQqIC0gICBJZiBQUk5HIHN0YXRlIGlzIFwic2hhcmVkXCIgKG1lYW5pbmcgYSBzdGF0ZSBhcnJheSB3YXMgcHJvdmlkZWQgZHVyaW5nIFBSTkcgY3JlYXRpb24gYW5kICoqbm90KiogY29waWVkKSBhbmQgb25lIHNldHMgdGhlIGdlbmVyYXRvciBzdGF0ZSB0byBhIHN0YXRlIGFycmF5IGhhdmluZyBhIGRpZmZlcmVudCBsZW5ndGgsIHRoZSBQUk5HIGRvZXMgKipub3QqKiB1cGRhdGUgdGhlIGV4aXN0aW5nIHNoYXJlZCBzdGF0ZSBhbmQsIGluc3RlYWQsIHBvaW50cyB0byB0aGUgbmV3bHkgcHJvdmlkZWQgc3RhdGUgYXJyYXkuIEluIG9yZGVyIHRvIHN5bmNocm9uaXplIFBSTkcgb3V0cHV0IGFjY29yZGluZyB0byB0aGUgbmV3IHNoYXJlZCBzdGF0ZSBhcnJheSwgdGhlIHN0YXRlIGFycmF5IGZvciAqKmVhY2gqKiByZWxldmFudCBQUk5HIG11c3QgYmUgKipleHBsaWNpdGx5Kiogc2V0LlxuXHQqIC0gICBJZiBQUk5HIHN0YXRlIGlzIFwic2hhcmVkXCIgYW5kIG9uZSBzZXRzIHRoZSBnZW5lcmF0b3Igc3RhdGUgdG8gYSBzdGF0ZSBhcnJheSBvZiB0aGUgc2FtZSBsZW5ndGgsIHRoZSBQUk5HIHN0YXRlIGlzIHVwZGF0ZWQgKGFsb25nIHdpdGggdGhlIHN0YXRlIG9mIGFsbCBvdGhlciBQUk5HcyBzaGFyaW5nIHRoZSBQUk5HJ3Mgc3RhdGUgYXJyYXkpLlxuXHQqXG5cdCogQHByaXZhdGVcblx0KiBAcGFyYW0ge1BSTkdTdGF0ZU1JTlNURH0gcyAtIGdlbmVyYXRvciBzdGF0ZVxuXHQqIEB0aHJvd3Mge1R5cGVFcnJvcn0gbXVzdCBwcm92aWRlIGFuIGBJbnQzMkFycmF5YFxuXHQqIEB0aHJvd3Mge0Vycm9yfSBtdXN0IHByb3ZpZGUgYSB2YWxpZCBzdGF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBzZXRTdGF0ZSggcyApIHtcblx0XHR2YXIgZXJyO1xuXHRcdGlmICggIWlzSW50MzJBcnJheSggcyApICkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ2ludmFsaWQgYXJndW1lbnQuIE11c3QgcHJvdmlkZSBhbiBJbnQzMkFycmF5LiBWYWx1ZTogYCcgKyBzICsgJ2AuJyApO1xuXHRcdH1cblx0XHRlcnIgPSB2ZXJpZnlTdGF0ZSggcywgZmFsc2UgKTtcblx0XHRpZiAoIGVyciApIHtcblx0XHRcdHRocm93IGVycjtcblx0XHR9XG5cdFx0aWYgKCBvcHRzLmNvcHkgPT09IGZhbHNlICkge1xuXHRcdFx0aWYgKCBvcHRzLnN0YXRlICYmIHMubGVuZ3RoID09PSBTVEFURS5sZW5ndGggKSB7XG5cdFx0XHRcdGdjb3B5KCBzLmxlbmd0aCwgcywgMSwgU1RBVEUsIDEgKTsgLy8gdXBkYXRlIGN1cnJlbnQgc2hhcmVkIHN0YXRlXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRTVEFURSA9IHM7IC8vIHBvaW50IHRvIG5ldyBzaGFyZWQgc3RhdGVcblx0XHRcdFx0b3B0cy5zdGF0ZSA9IHRydWU7IC8vIHNldHRpbmcgdGhpcyBmbGFnIGFsbG93cyB1cGRhdGluZyBhIHNoYXJlZCBzdGF0ZSBldmVuIGlmIGEgc3RhdGUgYXJyYXkgd2FzIG5vdCBwcm92aWRlZCBhdCBQUk5HIGNyZWF0aW9uXG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIENoZWNrIGlmIHdlIGNhbiByZXVzZSBhbGxvY2F0ZWQgbWVtb3J5Li4uXG5cdFx0XHRpZiAoIHMubGVuZ3RoICE9PSBTVEFURS5sZW5ndGggKSB7XG5cdFx0XHRcdFNUQVRFID0gbmV3IEludDMyQXJyYXkoIHMubGVuZ3RoICk7IC8vIHJlYWxsb2NhdGVcblx0XHRcdH1cblx0XHRcdGdjb3B5KCBzLmxlbmd0aCwgcywgMSwgU1RBVEUsIDEgKTtcblx0XHR9XG5cdFx0Ly8gQ3JlYXRlIGEgbmV3IHN0YXRlICh0YWJsZSkgXCJ2aWV3XCI6XG5cdFx0c3RhdGUgPSBuZXcgSW50MzJBcnJheSggU1RBVEUuYnVmZmVyLCBTVEFURS5ieXRlT2Zmc2V0KygoVEFCTEVfU0VDVElPTl9PRkZTRVQrMSkqU1RBVEUuQllURVNfUEVSX0VMRU1FTlQpLCBUQUJMRV9MRU5HVEggKTtcblxuXHRcdC8vIENyZWF0ZSBhIG5ldyBzZWVkIFwidmlld1wiOlxuXHRcdHNlZWQgPSBuZXcgSW50MzJBcnJheSggU1RBVEUuYnVmZmVyLCBTVEFURS5ieXRlT2Zmc2V0KygoU0VFRF9TRUNUSU9OX09GRlNFVCsxKSpTVEFURS5CWVRFU19QRVJfRUxFTUVOVCksIFNUQVRFWyBTRUVEX1NFQ1RJT05fT0ZGU0VUIF0gKTtcblx0fVxuXG5cdC8qKlxuXHQqIFNlcmlhbGl6ZXMgdGhlIHBzZXVkb3JhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIGFzIGEgSlNPTiBvYmplY3QuXG5cdCpcblx0KiAjIyBOb3Rlc1xuXHQqXG5cdCogLSAgIGBKU09OLnN0cmluZ2lmeSgpYCBpbXBsaWNpdGx5IGNhbGxzIHRoaXMgbWV0aG9kIHdoZW4gc3RyaW5naWZ5aW5nIGEgUFJORy5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCogQHJldHVybnMge09iamVjdH0gSlNPTiByZXByZXNlbnRhdGlvblxuXHQqL1xuXHRmdW5jdGlvbiB0b0pTT04oKSB7XG5cdFx0dmFyIG91dCA9IHt9O1xuXHRcdG91dC50eXBlID0gJ1BSTkcnO1xuXHRcdG91dC5uYW1lID0gbWluc3RkU2h1ZmZsZS5OQU1FO1xuXHRcdG91dC5zdGF0ZSA9IHR5cGVkYXJyYXkyanNvbiggU1RBVEUgKTtcblx0XHRvdXQucGFyYW1zID0gW107XG5cdFx0cmV0dXJuIG91dDtcblx0fVxuXG5cdC8qKlxuXHQqIEdlbmVyYXRlcyBhIHBzZXVkb3JhbmRvbSBpbnRlZ2VyIG9uIHRoZSBpbnRlcnZhbCBcXFxcKCBbMSwyXnszMX0tMSkgXFxcXCkuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqIEByZXR1cm5zIHtpbnRlZ2VyMzJ9IHBzZXVkb3JhbmRvbSBpbnRlZ2VyXG5cdCovXG5cdGZ1bmN0aW9uIG1pbnN0ZCgpIHtcblx0XHR2YXIgcyA9IFNUQVRFWyBQUk5HX1NUQVRFIF18MDsgLy8gYXNtIHR5cGUgYW5ub3RhdGlvblxuXHRcdHMgPSAoIChBKnMpJUlOVDMyX01BWCApfDA7IC8vIGFzbSB0eXBlIGFubm90YXRpb25cblx0XHRTVEFURVsgUFJOR19TVEFURSBdID0gcztcblx0XHRyZXR1cm4gc3wwOyAvLyBhc20gdHlwZSBhbm5vdGF0aW9uXG5cdH1cblxuXHQvKipcblx0KiBHZW5lcmF0ZXMgYSBwc2V1ZG9yYW5kb20gaW50ZWdlciBvbiB0aGUgaW50ZXJ2YWwgXFxcXCggWzEsMl57MzF9LTEpIFxcXFwpLlxuXHQqXG5cdCogQHByaXZhdGVcblx0KiBAcmV0dXJucyB7aW50ZWdlcjMyfSBwc2V1ZG9yYW5kb20gaW50ZWdlclxuXHQqXG5cdCogQGV4YW1wbGVcblx0KiB2YXIgdiA9IG1pbnN0ZCgpO1xuXHQqIC8vIHJldHVybnMgPG51bWJlcj5cblx0Ki9cblx0ZnVuY3Rpb24gbWluc3RkU2h1ZmZsZSgpIHtcblx0XHR2YXIgcztcblx0XHR2YXIgaTtcblxuXHRcdHMgPSBTVEFURVsgU0hVRkZMRV9TVEFURSBdO1xuXHRcdGkgPSBmbG9vciggVEFCTEVfTEVOR1RIICogKHMvSU5UMzJfTUFYKSApO1xuXG5cdFx0Ly8gUHVsbCBhIHN0YXRlIGZyb20gdGhlIHRhYmxlOlxuXHRcdHMgPSBzdGF0ZVsgaSBdO1xuXG5cdFx0Ly8gVXBkYXRlIHRoZSBQUk5HIHN0YXRlOlxuXHRcdFNUQVRFWyBTSFVGRkxFX1NUQVRFIF0gPSBzO1xuXG5cdFx0Ly8gUmVwbGFjZSB0aGUgcHVsbGVkIHN0YXRlOlxuXHRcdHN0YXRlWyBpIF0gPSBtaW5zdGQoKTtcblxuXHRcdHJldHVybiBzO1xuXHR9XG5cblx0LyoqXG5cdCogR2VuZXJhdGVzIGEgcHNldWRvcmFuZG9tIG51bWJlciBvbiB0aGUgaW50ZXJ2YWwgXFxcXCggWzAsMSkgXFxcXCkuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqIEByZXR1cm5zIHtudW1iZXJ9IHBzZXVkb3JhbmRvbSBudW1iZXJcblx0KlxuXHQqIEBleGFtcGxlXG5cdCogdmFyIHYgPSBub3JtYWxpemVkKCk7XG5cdCogLy8gcmV0dXJucyA8bnVtYmVyPlxuXHQqL1xuXHRmdW5jdGlvbiBub3JtYWxpemVkKCkge1xuXHRcdHJldHVybiAobWluc3RkU2h1ZmZsZSgpLTEpIC8gTk9STUFMSVpBVElPTl9DT05TVEFOVDtcblx0fVxufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5O1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGZhY3RvcnkgPSByZXF1aXJlKCAnLi9mYWN0b3J5LmpzJyApO1xudmFyIHJhbmRpbnQzMiA9IHJlcXVpcmUoICcuL3JhbmRfaW50MzIuanMnICk7XG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogR2VuZXJhdGVzIGEgcHNldWRvcmFuZG9tIGludGVnZXIgb24gdGhlIGludGVydmFsIFxcXFwoIFsxLDJeezMxfS0xKSBcXFxcKS5cbipcbiogIyMgTWV0aG9kXG4qXG4qIExpbmVhciBjb25ncnVlbnRpYWwgZ2VuZXJhdG9ycyAoTENHcykgdXNlIHRoZSByZWN1cnJlbmNlIHJlbGF0aW9uXG4qXG4qIGBgYHRleFxuKiBYX3tuKzF9ID0gKCBhIFxcY2RvdCBYX24gKyBjICkgXFxvcGVyYXRvcm5hbWV7bW9kfShtKVxuKiBgYGBcbipcbiogd2hlcmUgdGhlIG1vZHVsdXMgXFxcXCggbSBcXFxcKSBpcyBhIHByaW1lIG51bWJlciBvciBwb3dlciBvZiBhIHByaW1lIG51bWJlciBhbmQgXFxcXCggYSBcXFxcKSBpcyBhIHByaW1pdGl2ZSByb290IG1vZHVsbyBcXFxcKCBtIFxcXFwpLlxuKlxuKiA8IS0tIDxub3RlPiAtLT5cbipcbiogRm9yIGFuIExDRyB0byBiZSBhIExlaG1lciBSTkcsIHRoZSBzZWVkIFxcXFwoIFhfMCBcXFxcKSBtdXN0IGJlIGNvcHJpbWUgdG8gXFxcXCggbSBcXFxcKS5cbipcbiogPCEtLSA8L25vdGU+IC0tPlxuKlxuKiBJbiB0aGlzIGltcGxlbWVudGF0aW9uLCB0aGUgY29uc3RhbnRzIFxcXFwoIGEgXFxcXCksIFxcXFwoIGMgXFxcXCksIGFuZCBcXFxcKCBtIFxcXFwpIGhhdmUgdGhlIHZhbHVlc1xuKlxuKiBgYGB0ZXhcbiogXFxiZWdpbnthbGlnbip9XG4qIGEgJj0gN141ID0gMTY4MDcgXFxcXFxuKiBjICY9IDAgXFxcXFxuKiBtICY9IDJeezMxfSAtIDEgPSAyMTQ3NDgzNjQ3XG4qIFxcZW5ke2FsaWduKn1cbiogYGBgXG4qXG4qIDwhLS0gPG5vdGU+IC0tPlxuKlxuKiBUaGUgY29uc3RhbnQgXFxcXCggbSBcXFxcKSBpcyBhIE1lcnNlbm5lIHByaW1lIChtb2R1bG8gXFxcXCgzMVxcXFwpKS5cbipcbiogPCEtLSA8L25vdGU+IC0tPlxuKlxuKiA8IS0tIDxub3RlPiAtLT5cbipcbiogVGhlIGNvbnN0YW50IFxcXFwoIGEgXFxcXCkgaXMgYSBwcmltaXRpdmUgcm9vdCAobW9kdWxvIFxcXFwoMzFcXFxcKSkuXG4qXG4qIDwhLS0gPC9ub3RlPiAtLT5cbipcbiogQWNjb3JkaW5nbHksIHRoZSBtYXhpbXVtIHBvc3NpYmxlIHByb2R1Y3QgaXNcbipcbiogYGBgdGV4XG4qIDE2ODA3IFxcY2RvdCAobSAtIDEpIFxcYXBwcm94IDJeezQ2fVxuKiBgYGBcbipcbiogVGhlIHZhbHVlcyBmb3IgXFxcXCggYSBcXFxcKSwgXFxcXCggYyBcXFxcKSwgYW5kIFxcXFwoIG0gXFxcXCkgYXJlIHRha2VuIGZyb20gUGFyayBhbmQgTWlsbGVyLCBcIlJhbmRvbSBOdW1iZXIgR2VuZXJhdG9yczogR29vZCBPbmVzIEFyZSBIYXJkIFRvIEZpbmRcIi4gUGFyaydzIGFuZCBNaWxsZXIncyBhcnRpY2xlIGlzIGFsc28gdGhlIGJhc2lzIGZvciBhIHJlY2lwZSBpbiB0aGUgc2Vjb25kIGVkaXRpb24gb2YgX051bWVyaWNhbCBSZWNpcGVzIGluIENfLlxuKlxuKiBUaGlzIGltcGxlbWVudGF0aW9uIHN1YnNlcXVlbnRseSBzaHVmZmxlcyB0aGUgb3V0cHV0IG9mIGEgbGluZWFyIGNvbmdydWVudGlhbCBwc2V1ZG9yYW5kb20gbnVtYmVyIGdlbmVyYXRvciAoTENHKSB1c2luZyBhIHNodWZmbGUgdGFibGUgaW4gYWNjb3JkYW5jZSB3aXRoIHRoZSBCYXlzLUR1cmhhbSBhbGdvcml0aG0uXG4qXG4qXG4qICMjIE5vdGVzXG4qXG4qIC0gICBUaGUgZ2VuZXJhdG9yIGhhcyBhIHBlcmlvZCBvZiBhcHByb3hpbWF0ZWx5IFxcXFwoMi4xXFxtYm94e2V9OVxcXFwpIChzZWUgW051bWVyaWNhbCBSZWNpcGVzIGluIEMsIDJuZCBFZGl0aW9uXSgjcmVmZXJlbmNlcyksIHAuIDI3OSkuXG4qXG4qXG4qICMjIFJlZmVyZW5jZXNcbipcbiogLSAgIEJheXMsIENhcnRlciwgYW5kIFMuIEQuIER1cmhhbS4gMTk3Ni4gXCJJbXByb3ZpbmcgYSBQb29yIFJhbmRvbSBOdW1iZXIgR2VuZXJhdG9yLlwiIF9BQ00gVHJhbnNhY3Rpb25zIG9uIE1hdGhlbWF0aWNhbCBTb2Z0d2FyZV8gMiAoMSkuIE5ldyBZb3JrLCBOWSwgVVNBOiBBQ006IDU5XHUyMDEzNjQuIGRvaTpbMTAuMTE0NS8zNTU2NjYuMzU1NjcwXShodHRwOi8vZHguZG9pLm9yZy8xMC4xMTQ1LzM1NTY2Ni4zNTU2NzApLlxuKiAtICAgSGVyem9nLCBULk4uLCBhbmQgRy4gTG9yZC4gMjAwMi4gX0FwcGxpY2F0aW9ucyBvZiBNb250ZSBDYXJsbyBNZXRob2RzIHRvIEZpbmFuY2UgYW5kIEluc3VyYW5jZV8uIEFDVEVYIFB1YmxpY2F0aW9ucy4gW2h0dHBzOi8vYm9va3MuZ29vZ2xlLmNvbS9ib29rcz9pZD12QzdJXFxcXFxcX2dkWC1BMENdKGh0dHBzOi8vYm9va3MuZ29vZ2xlLmNvbS9ib29rcz9pZD12QzdJXFxfZ2RYLUEwQykuXG4qIC0gICBQcmVzcywgV2lsbGlhbSBILiwgQnJpYW4gUC4gRmxhbm5lcnksIFNhdWwgQS4gVGV1a29sc2t5LCBhbmQgV2lsbGlhbSBULiBWZXR0ZXJsaW5nLiAxOTkyLiBfTnVtZXJpY2FsIFJlY2lwZXMgaW4gQzogVGhlIEFydCBvZiBTY2llbnRpZmljIENvbXB1dGluZywgU2Vjb25kIEVkaXRpb25fLiBDYW1icmlkZ2UgVW5pdmVyc2l0eSBQcmVzcy5cbipcbipcbiogQGZ1bmN0aW9uIG1pbnN0ZFxuKiBAdHlwZSB7UFJOR31cbiogQHJldHVybnMge1Bvc2l0aXZlSW50ZWdlcn0gcHNldWRvcmFuZG9tIGludGVnZXJcbipcbiogQGV4YW1wbGVcbiogdmFyIHYgPSBtaW5zdGQoKTtcbiogLy8gcmV0dXJucyA8bnVtYmVyPlxuKi9cbnZhciBtaW5zdGQgPSBmYWN0b3J5KHtcblx0J3NlZWQnOiByYW5kaW50MzIoKVxufSk7XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1pbnN0ZDtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogQSBsaW5lYXIgY29uZ3J1ZW50aWFsIHBzZXVkb3JhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIChMQ0cpIHdob3NlIG91dHB1dCBpcyBzaHVmZmxlZC5cbipcbiogQG1vZHVsZSBAc3RkbGliL3JhbmRvbS1iYXNlLW1pbnN0ZC1zaHVmZmxlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBtaW5zdGQgPSByZXF1aXJlKCAnQHN0ZGxpYi9yYW5kb20tYmFzZS1taW5zdGQtc2h1ZmZsZScgKTtcbipcbiogdmFyIHYgPSBtaW5zdGQoKTtcbiogLy8gcmV0dXJucyA8bnVtYmVyPlxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgZmFjdG9yeSA9IHJlcXVpcmUoICdAc3RkbGliL3JhbmRvbS1iYXNlLW1pbnN0ZC1zaHVmZmxlJyApLmZhY3Rvcnk7XG4qXG4qIHZhciBtaW5zdGQgPSBmYWN0b3J5KHtcbiogICAgICdzZWVkJzogMTIzNFxuKiB9KTtcbipcbiogdmFyIHYgPSBtaW5zdGQoKTtcbiogLy8gcmV0dXJucyAxNDIxNjAwNjU0XG4qL1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBzZXRSZWFkT25seSA9IHJlcXVpcmUoICdAc3RkbGliL3V0aWxzLWRlZmluZS1ub25lbnVtZXJhYmxlLXJlYWQtb25seS1wcm9wZXJ0eScgKTtcbnZhciBtaW5zdGQgPSByZXF1aXJlKCAnLi9tYWluLmpzJyApO1xudmFyIGZhY3RvcnkgPSByZXF1aXJlKCAnLi9mYWN0b3J5LmpzJyApO1xuXG5cbi8vIE1BSU4gLy9cblxuc2V0UmVhZE9ubHkoIG1pbnN0ZCwgJ2ZhY3RvcnknLCBmYWN0b3J5ICk7XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1pbnN0ZDtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBQSU5GID0gcmVxdWlyZSggJ0BzdGRsaWIvY29uc3RhbnRzLWZsb2F0NjQtcGluZicgKTtcblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBUZXN0cyBpZiBhIGRvdWJsZS1wcmVjaXNpb24gZmxvYXRpbmctcG9pbnQgbnVtZXJpYyB2YWx1ZSBpcyBwb3NpdGl2ZSB6ZXJvLlxuKlxuKiBAcGFyYW0ge251bWJlcn0geCAtIHZhbHVlIHRvIHRlc3RcbiogQHJldHVybnMge2Jvb2xlYW59IGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSB2YWx1ZSBpcyBwb3NpdGl2ZSB6ZXJvXG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaXNQb3NpdGl2ZVplcm8oIDAuMCApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBpc1Bvc2l0aXZlWmVybyggLTAuMCApO1xuKiAvLyByZXR1cm5zIGZhbHNlXG4qL1xuZnVuY3Rpb24gaXNQb3NpdGl2ZVplcm8oIHggKSB7XG5cdHJldHVybiAoeCA9PT0gMC4wICYmIDEuMC94ID09PSBQSU5GKTtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNQb3NpdGl2ZVplcm87XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIFRlc3QgaWYgYSBkb3VibGUtcHJlY2lzaW9uIGZsb2F0aW5nLXBvaW50IG51bWVyaWMgdmFsdWUgaXMgcG9zaXRpdmUgemVyby5cbipcbiogQG1vZHVsZSBAc3RkbGliL21hdGgtYmFzZS1hc3NlcnQtaXMtcG9zaXRpdmUtemVyb1xuKlxuKiBAZXhhbXBsZVxuKiB2YXIgaXNQb3NpdGl2ZVplcm8gPSByZXF1aXJlKCAnQHN0ZGxpYi9tYXRoLWJhc2UtYXNzZXJ0LWlzLXBvc2l0aXZlLXplcm8nICk7XG4qXG4qIHZhciBib29sID0gaXNQb3NpdGl2ZVplcm8oIDAuMCApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogYm9vbCA9IGlzUG9zaXRpdmVaZXJvKCAtMC4wICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbiovXG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGlzUG9zaXRpdmVaZXJvID0gcmVxdWlyZSggJy4vbWFpbi5qcycgKTtcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNQb3NpdGl2ZVplcm87XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgaXNQb3NpdGl2ZVplcm8gPSByZXF1aXJlKCAnQHN0ZGxpYi9tYXRoLWJhc2UtYXNzZXJ0LWlzLXBvc2l0aXZlLXplcm8nICk7XG52YXIgaXNuYW4gPSByZXF1aXJlKCAnQHN0ZGxpYi9tYXRoLWJhc2UtYXNzZXJ0LWlzLW5hbicgKTtcbnZhciBOSU5GID0gcmVxdWlyZSggJ0BzdGRsaWIvY29uc3RhbnRzLWZsb2F0NjQtbmluZicgKTtcbnZhciBQSU5GID0gcmVxdWlyZSggJ0BzdGRsaWIvY29uc3RhbnRzLWZsb2F0NjQtcGluZicgKTtcblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlLlxuKlxuKiBAcGFyYW0ge251bWJlcn0gW3hdIC0gZmlyc3QgbnVtYmVyXG4qIEBwYXJhbSB7bnVtYmVyfSBbeV0gLSBzZWNvbmQgbnVtYmVyXG4qIEBwYXJhbSB7Li4ubnVtYmVyfSBbYXJnc10gLSBudW1iZXJzXG4qIEByZXR1cm5zIHtudW1iZXJ9IG1heGltdW0gdmFsdWVcbipcbiogQGV4YW1wbGVcbiogdmFyIHYgPSBtYXgoIDMuMTQsIDQuMiApO1xuKiAvLyByZXR1cm5zIDQuMlxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgdiA9IG1heCggNS45LCAzLjE0LCA0LjIgKTtcbiogLy8gcmV0dXJucyA1LjlcbipcbiogQGV4YW1wbGVcbiogdmFyIHYgPSBtYXgoIDMuMTQsIE5hTiApO1xuKiAvLyByZXR1cm5zIE5hTlxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgdiA9IG1heCggKzAuMCwgLTAuMCApO1xuKiAvLyByZXR1cm5zICswLjBcbiovXG5mdW5jdGlvbiBtYXgoIHgsIHkgKSB7XG5cdHZhciBsZW47XG5cdHZhciBtO1xuXHR2YXIgdjtcblx0dmFyIGk7XG5cblx0bGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblx0aWYgKCBsZW4gPT09IDIgKSB7XG5cdFx0aWYgKCBpc25hbiggeCApIHx8IGlzbmFuKCB5ICkgKSB7XG5cdFx0XHRyZXR1cm4gTmFOO1xuXHRcdH1cblx0XHRpZiAoIHggPT09IFBJTkYgfHwgeSA9PT0gUElORiApIHtcblx0XHRcdHJldHVybiBQSU5GO1xuXHRcdH1cblx0XHRpZiAoIHggPT09IHkgJiYgeCA9PT0gMC4wICkge1xuXHRcdFx0aWYgKCBpc1Bvc2l0aXZlWmVybyggeCApICkge1xuXHRcdFx0XHRyZXR1cm4geDtcblx0XHRcdH1cblx0XHRcdHJldHVybiB5O1xuXHRcdH1cblx0XHRpZiAoIHggPiB5ICkge1xuXHRcdFx0cmV0dXJuIHg7XG5cdFx0fVxuXHRcdHJldHVybiB5O1xuXHR9XG5cdG0gPSBOSU5GO1xuXHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdHYgPSBhcmd1bWVudHNbIGkgXTtcblx0XHRpZiAoIGlzbmFuKCB2ICkgfHwgdiA9PT0gUElORiApIHtcblx0XHRcdHJldHVybiB2O1xuXHRcdH1cblx0XHRpZiAoIHYgPiBtICkge1xuXHRcdFx0bSA9IHY7XG5cdFx0fSBlbHNlIGlmIChcblx0XHRcdHYgPT09IG0gJiZcblx0XHRcdHYgPT09IDAuMCAmJlxuXHRcdFx0aXNQb3NpdGl2ZVplcm8oIHYgKVxuXHRcdCkge1xuXHRcdFx0bSA9IHY7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBtO1xufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBtYXg7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIFJldHVybiB0aGUgbWF4aW11bSB2YWx1ZS5cbipcbiogQG1vZHVsZSBAc3RkbGliL21hdGgtYmFzZS1zcGVjaWFsLW1heFxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgbWF4ID0gcmVxdWlyZSggJ0BzdGRsaWIvbWF0aC1iYXNlLXNwZWNpYWwtbWF4JyApO1xuKlxuKiB2YXIgdiA9IG1heCggMy4xNCwgNC4yICk7XG4qIC8vIHJldHVybnMgNC4yXG4qXG4qIHYgPSBtYXgoIDUuOSwgMy4xNCwgNC4yICk7XG4qIC8vIHJldHVybnMgNS45XG4qXG4qIHYgPSBtYXgoIDMuMTQsIE5hTiApO1xuKiAvLyByZXR1cm5zIE5hTlxuKlxuKiB2ID0gbWF4KCArMC4wLCAtMC4wICk7XG4qIC8vIHJldHVybnMgKzAuMFxuKi9cblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgbWF4ID0gcmVxdWlyZSggJy4vbWF4LmpzJyApO1xuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBtYXg7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gVkFSSUFCTEVTIC8vXG5cbi8vIERlZmluZSBhIG1hc2sgZm9yIHRoZSBsZWFzdCBzaWduaWZpY2FudCAxNiBiaXRzIChsb3cgd29yZCk6IDY1NTM1ID0+IDB4MDAwMGZmZmYgPT4gMDAwMDAwMDAwMDAwMDAwMDExMTExMTExMTExMTExMTFcbnZhciBMT1dfV09SRF9NQVNLID0gMHgwMDAwZmZmZj4+PjA7IC8vIGFzbSB0eXBlIGFubm90YXRpb25cblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBQZXJmb3JtcyBDLWxpa2UgbXVsdGlwbGljYXRpb24gb2YgdHdvIHVuc2lnbmVkIDMyLWJpdCBpbnRlZ2Vycy5cbipcbiogIyMgTWV0aG9kXG4qXG4qIC0gICBUbyBlbXVsYXRlIEMtbGlrZSBtdWx0aXBsaWNhdGlvbiB3aXRob3V0IHRoZSBhaWQgb2YgNjQtYml0IGludGVnZXJzLCB3ZSByZWNvZ25pemUgdGhhdCBhIDMyLWJpdCBpbnRlZ2VyIGNhbiBiZSBzcGxpdCBpbnRvIHR3byAxNi1iaXQgd29yZHNcbipcbiogICAgIGBgYHRleFxuKiAgICAgYSA9IHdfaCoyXnsxNn0gKyB3X2xcbiogICAgIGBgYFxuKlxuKiAgICAgd2hlcmUgXFxcXCggd19oIFxcXFwpIGlzIHRoZSBtb3N0IHNpZ25pZmljYW50IDE2IGJpdHMgYW5kIFxcXFwoIHdfbCBcXFxcKSBpcyB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgMTYgYml0cy4gRm9yIGV4YW1wbGUsIGNvbnNpZGVyIHRoZSBtYXhpbXVtIHVuc2lnbmVkIDMyLWJpdCBpbnRlZ2VyIFxcXFwoIDJeezMyfS0xIFxcXFwpXG4qXG4qICAgICBgYGBiaW5hcnlzdHJpbmdcbiogICAgIDExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExXG4qICAgICBgYGBcbipcbiogICAgIFRoZSAxNi1iaXQgaGlnaCB3b3JkIGlzIHRoZW5cbipcbiogICAgIGBgYGJpbmFyeXN0cmluZ1xuKiAgICAgMTExMTExMTExMTExMTExMVxuKiAgICAgYGBgXG4qXG4qICAgICBhbmQgdGhlIDE2LWJpdCBsb3cgd29yZFxuKlxuKiAgICAgYGBgYmluYXJ5c3RyaW5nXG4qICAgICAxMTExMTExMTExMTExMTExXG4qICAgICBgYGBcbipcbiogICAgIElmIHdlIGNhc3QgdGhlIGhpZ2ggd29yZCB0byAzMi1iaXQgcHJlY2lzaW9uIGFuZCBtdWx0aXBseSBieSBcXFxcKCAyXnsxNn0gXFxcXCkgKGVxdWl2YWxlbnQgdG8gYSAxNi1iaXQgbGVmdCBzaGlmdCksIHRoZW4gdGhlIGJpdCBzZXF1ZW5jZSBpc1xuKlxuKiAgICAgYGBgYmluYXJ5c3RyaW5nXG4qICAgICAxMTExMTExMTExMTExMTExMDAwMDAwMDAwMDAwMDAwMFxuKiAgICAgYGBgXG4qXG4qICAgICBTaW1pbGFybHksIHVwb24gY2FzdGluZyB0aGUgbG93IHdvcmQgdG8gMzItYml0IHByZWNpc2lvbiwgdGhlIGJpdCBzZXF1ZW5jZSBpc1xuKlxuKiAgICAgYGBgYmluYXJ5c3RyaW5nXG4qICAgICAwMDAwMDAwMDAwMDAwMDAwMTExMTExMTExMTExMTExMVxuKiAgICAgYGBgXG4qXG4qICAgICBGcm9tIHRoZSBydWxlcyBvZiBiaW5hcnkgYWRkaXRpb24sIHdlIHJlY29nbml6ZSB0aGF0IGFkZGluZyB0aGUgdHdvIDMyLWJpdCB2YWx1ZXMgZm9yIHRoZSBoaWdoIGFuZCBsb3cgd29yZHMgd2lsbCByZXR1cm4gb3VyIG9yaWdpbmFsIHZhbHVlIFxcXFwoIDJeezMyfS0xIFxcXFwpLlxuKlxuKiAtICAgQWNjb3JkaW5nbHksIHRoZSBtdWx0aXBsaWNhdGlvbiBvZiB0d28gMzItYml0IGludGVnZXJzIGNhbiBiZSBleHByZXNzZWRcbipcbiogICAgIGBgYHRleFxuKiAgICAgXFxiZWdpbnthbGlnbip9XG4qICAgICBhIFxcY2RvdCBiICY9ICggYV9oIFxcY2RvdCAyXnsxNn0gKyBhX2wpIFxcY2RvdCAoIGJfaCBcXGNkb3QgMl57MTZ9ICsgYl9sKSBcXFxcXG4qICAgICAgICAgICAmPSBhX2wgXFxjZG90IGJfbCArIGFfaCBcXGNkb3QgYl9sIFxcY2RvdCAyXnsxNn0gKyBhX2wgXFxjZG90IGJfaCBcXGNkb3QgMl57MTZ9ICsgKGFfaCBcXGNkb3QgYl9oKSBcXGNkb3QgMl57MzJ9IFxcXFxcbiogICAgICAgICAgICY9IGFfbCBcXGNkb3QgYl9sICsgKGFfaCBcXGNkb3QgYl9sICsgYV9sIFxcY2RvdCBiX2gpIFxcY2RvdCAyXnsxNn0gKyAoYV9oIFxcY2RvdCBiX2gpIFxcY2RvdCAyXnszMn1cbiogICAgIFxcZW5ke2FsaWduKn1cbiogICAgIGBgYFxuKlxuKiAtICAgV2Ugbm90ZSB0aGF0IG11bHRpcGx5aW5nIChkaXZpZGluZykgYW4gaW50ZWdlciBieSBcXFxcKCAyXm4gXFxcXCkgaXMgZXF1aXZhbGVudCB0byBwZXJmb3JtaW5nIGEgbGVmdCAocmlnaHQpIHNoaWZ0IG9mIFxcXFwoIG4gXFxcXCkgYml0cy5cbipcbiogLSAgIEZ1cnRoZXIsIGFzIHdlIHdhbnQgdG8gcmV0dXJuIGFuIGludGVnZXIgb2YgdGhlIHNhbWUgcHJlY2lzaW9uLCBmb3IgYSAzMi1iaXQgaW50ZWdlciwgdGhlIHJldHVybiB2YWx1ZSB3aWxsIGJlIG1vZHVsbyBcXFxcKCAyXnszMn0gXFxcXCkuIFN0YXRlZCBhbm90aGVyIHdheSwgd2Ugb25seSBjYXJlIGFib3V0IHRoZSBsb3cgd29yZCBvZiBhIDY0LWJpdCByZXN1bHQuXG4qXG4qIC0gICBBY2NvcmRpbmdseSwgdGhlIGxhc3QgdGVybSwgYmVpbmcgZXZlbmx5IGRpdmlzaWJsZSBieSBcXFxcKCAyXnszMn0gXFxcXCksIGRyb3BzIGZyb20gdGhlIGVxdWF0aW9uIGxlYXZpbmcgdGhlIHJlbWFpbmluZyB0d28gdGVybXMgYXMgdGhlIHJlbWFpbmRlci5cbipcbiogICAgIGBgYHRleFxuKiAgICAgYSBcXGNkb3QgYiA9IGFfbCBcXGNkb3QgYl9sICsgKGFfaCBcXGNkb3QgYl9sICsgYV9sIFxcY2RvdCBiX2gpIDw8IDE2XG4qICAgICBgYGBcbipcbiogLSAgIExhc3RseSwgdGhlIHNlY29uZCB0ZXJtIGluIHRoZSBhYm92ZSBlcXVhdGlvbiBjb250cmlidXRlcyB0byB0aGUgbWlkZGxlIGJpdHMgYW5kIG1heSBjYXVzZSB0aGUgcHJvZHVjdCB0byBcIm92ZXJmbG93XCIuIEhvd2V2ZXIsIHdlIGNhbiBkaXNyZWdhcmQgKGA+Pj4wYCkgb3ZlcmZsb3cgYml0cyBkdWUgbW9kdWxvIGFyaXRobWV0aWMsIGFzIGRpc2N1c3NlZCBlYXJsaWVyIHdpdGggcmVnYXJkIHRvIHRoZSB0ZXJtIGludm9sdmluZyB0aGUgcGFydGlhbCBwcm9kdWN0IG9mIGhpZ2ggd29yZHMuXG4qXG4qXG4qIEBwYXJhbSB7dWludGVnZXIzMn0gYSAtIGludGVnZXJcbiogQHBhcmFtIHt1aW50ZWdlcjMyfSBiIC0gaW50ZWdlclxuKiBAcmV0dXJucyB7dWludGVnZXIzMn0gcHJvZHVjdFxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgdiA9IHVpbXVsKCAxMD4+PjAsIDQ+Pj4wICk7XG4qIC8vIHJldHVybnMgNDBcbiovXG5mdW5jdGlvbiB1aW11bCggYSwgYiApIHtcblx0dmFyIGxiaXRzO1xuXHR2YXIgbWJpdHM7XG5cdHZhciBoYTtcblx0dmFyIGhiO1xuXHR2YXIgbGE7XG5cdHZhciBsYjtcblxuXHRhID4+Pj0gMDsgLy8gYXNtIHR5cGUgYW5ub3RhdGlvblxuXHRiID4+Pj0gMDsgLy8gYXNtIHR5cGUgYW5ub3RhdGlvblxuXG5cdC8vIElzb2xhdGUgdGhlIG1vc3Qgc2lnbmlmaWNhbnQgMTYtYml0czpcblx0aGEgPSAoIGE+Pj4xNiApPj4+MDsgLy8gYXNtIHR5cGUgYW5ub3RhdGlvblxuXHRoYiA9ICggYj4+PjE2ICk+Pj4wOyAvLyBhc20gdHlwZSBhbm5vdGF0aW9uXG5cblx0Ly8gSXNvbGF0ZSB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgMTYtYml0czpcblx0bGEgPSAoIGEmTE9XX1dPUkRfTUFTSyApPj4+MDsgLy8gYXNtIHR5cGUgYW5ub3RhdGlvblxuXHRsYiA9ICggYiZMT1dfV09SRF9NQVNLICk+Pj4wOyAvLyBhc20gdHlwZSBhbm5vdGF0aW9uXG5cblx0Ly8gQ29tcHV0ZSBwYXJ0aWFsIHN1bXM6XG5cdGxiaXRzID0gKCBsYSpsYiApPj4+MDsgLy8gYXNtIHR5cGUgYW5ub3RhdGlvbjsgbm8gaW50ZWdlciBvdmVyZmxvdyBwb3NzaWJsZVxuXHRtYml0cyA9ICggKChoYSpsYikgKyAobGEqaGIpKTw8MTYgKT4+PjA7IC8vIGFzbSB0eXBlIGFubm90YXRpb247IHBvc3NpYmxlIGludGVnZXIgb3ZlcmZsb3dcblxuXHQvLyBUaGUgZmluYWwgYD4+PjBgIGNvbnZlcnRzIHRoZSBpbnRlcm1lZGlhdGUgc3VtIHRvIGFuIHVuc2lnbmVkIGludGVnZXIgKHBvc3NpYmxlIGludGVnZXIgb3ZlcmZsb3cgZHVyaW5nIHN1bSk6XG5cdHJldHVybiAoIGxiaXRzICsgbWJpdHMgKT4+PjA7IC8vIGFzbSB0eXBlIGFubm90YXRpb25cbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gdWltdWw7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIFBlcmZvcm0gQy1saWtlIG11bHRpcGxpY2F0aW9uIG9mIHR3byB1bnNpZ25lZCAzMi1iaXQgaW50ZWdlcnMuXG4qXG4qIEBtb2R1bGUgQHN0ZGxpYi9tYXRoLWJhc2Utc3BlY2lhbC11aW11bFxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgdWltdWwgPSByZXF1aXJlKCAnQHN0ZGxpYi9tYXRoLWJhc2Utc3BlY2lhbC11aW11bCcgKTtcbipcbiogdmFyIHYgPSB1aW11bCggMTA+Pj4wLCA0Pj4+MCApO1xuKiAvLyByZXR1cm5zIDQwXG4qL1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciB1aW11bCA9IHJlcXVpcmUoICcuL21haW4uanMnICk7XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVpbXVsO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIFVJTlQzMl9NQVggPSByZXF1aXJlKCAnQHN0ZGxpYi9jb25zdGFudHMtdWludDMyLW1heCcgKTtcbnZhciBmbG9vciA9IHJlcXVpcmUoICdAc3RkbGliL21hdGgtYmFzZS1zcGVjaWFsLWZsb29yJyApO1xuXG5cbi8vIFZBUklBQkxFUyAvL1xuXG52YXIgTUFYID0gVUlOVDMyX01BWCAtIDE7XG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogUmV0dXJucyBhIHBzZXVkb3JhbmRvbSBpbnRlZ2VyIG9uIHRoZSBpbnRlcnZhbCBcXFxcKFsxLCAyXnszMn0tMSlcXFxcKS5cbipcbiogQHByaXZhdGVcbiogQHJldHVybnMge1Bvc2l0aXZlSW50ZWdlcn0gcHNldWRvcmFuZG9tIGludGVnZXJcbipcbiogQGV4YW1wbGVcbiogdmFyIHYgPSByYW5kdWludDMyKCk7XG4qIC8vIHJldHVybnMgPG51bWJlcj5cbiovXG5mdW5jdGlvbiByYW5kdWludDMyKCkge1xuXHR2YXIgdiA9IGZsb29yKCAxLjAgKyAoTUFYKk1hdGgucmFuZG9tKCkpICk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgc3RkbGliL25vLWJ1aWx0aW4tbWF0aFxuXHRyZXR1cm4gdiA+Pj4gMDsgLy8gYXNtIHR5cGUgYW5ub3RhdGlvblxufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSByYW5kdWludDMyO1xuIiwgIi8qIGVzbGludC1kaXNhYmxlIG1heC1saW5lcywgbWF4LWxlbiAqL1xuXG4vKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKlxuKlxuKiAjIyBOb3RpY2VcbipcbiogVGhlIG9yaWdpbmFsIEMgY29kZSBhbmQgY29weXJpZ2h0IG5vdGljZSBhcmUgZnJvbSB0aGUgW3NvdXJjZSBpbXBsZW1lbnRhdGlvbl17QGxpbmsgaHR0cDovL3d3dy5tYXRoLnNjaS5oaXJvc2hpbWEtdS5hYy5qcC9+bS1tYXQvTVQvTVQyMDAyL0NPREVTL210MTk5Mzdhci5jfS4gVGhlIGltcGxlbWVudGF0aW9uIGhhcyBiZWVuIG1vZGlmaWVkIGZvciBKYXZhU2NyaXB0LlxuKlxuKiBgYGB0ZXh0XG4qIENvcHlyaWdodCAoQykgMTk5NyAtIDIwMDIsIE1ha290byBNYXRzdW1vdG8gYW5kIFRha3VqaSBOaXNoaW11cmEsXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiogYXJlIG1ldDpcbipcbiogICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuKiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbipcbiogICAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuKiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiogICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuKlxuKiAgIDMuIFRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heSBub3QgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGVcbiogICAgICBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW5cbiogICAgICBwZXJtaXNzaW9uLlxuKlxuKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4qIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcbiogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4qIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBPV05FUiBPUlxuKiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCxcbiogRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuKiBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiogUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxuKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcbiogU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qIGBgYFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBzZXRSZWFkT25seSA9IHJlcXVpcmUoICdAc3RkbGliL3V0aWxzLWRlZmluZS1ub25lbnVtZXJhYmxlLXJlYWQtb25seS1wcm9wZXJ0eScgKTtcbnZhciBzZXRSZWFkT25seUFjY2Vzc29yID0gcmVxdWlyZSggJ0BzdGRsaWIvdXRpbHMtZGVmaW5lLW5vbmVudW1lcmFibGUtcmVhZC1vbmx5LWFjY2Vzc29yJyApO1xudmFyIHNldFJlYWRXcml0ZUFjY2Vzc29yID0gcmVxdWlyZSggJ0BzdGRsaWIvdXRpbHMtZGVmaW5lLW5vbmVudW1lcmFibGUtcmVhZC13cml0ZS1hY2Nlc3NvcicgKTtcbnZhciBoYXNPd25Qcm9wID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWhhcy1vd24tcHJvcGVydHknICk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaXMtcGxhaW4tb2JqZWN0JyApO1xudmFyIGlzQ29sbGVjdGlvbiA9IHJlcXVpcmUoICdAc3RkbGliL2Fzc2VydC1pcy1jb2xsZWN0aW9uJyApO1xudmFyIGlzVWludDMyQXJyYXkgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaXMtdWludDMyYXJyYXknICk7XG52YXIgaXNCb29sZWFuID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLWJvb2xlYW4nICkuaXNQcmltaXRpdmU7XG52YXIgaXNQb3NpdGl2ZUludGVnZXIgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaXMtcG9zaXRpdmUtaW50ZWdlcicgKS5pc1ByaW1pdGl2ZTtcbnZhciBGTE9BVDY0X01BWF9TQUZFX0lOVEVHRVIgPSByZXF1aXJlKCAnQHN0ZGxpYi9jb25zdGFudHMtZmxvYXQ2NC1tYXgtc2FmZS1pbnRlZ2VyJyApO1xudmFyIFVJTlQzMl9NQVggPSByZXF1aXJlKCAnQHN0ZGxpYi9jb25zdGFudHMtdWludDMyLW1heCcgKTtcbnZhciBVaW50MzJBcnJheSA9IHJlcXVpcmUoICdAc3RkbGliL2FycmF5LXVpbnQzMicgKTtcbnZhciBtYXggPSByZXF1aXJlKCAnQHN0ZGxpYi9tYXRoLWJhc2Utc3BlY2lhbC1tYXgnICk7XG52YXIgdWltdWwgPSByZXF1aXJlKCAnQHN0ZGxpYi9tYXRoLWJhc2Utc3BlY2lhbC11aW11bCcgKTtcbnZhciBnY29weSA9IHJlcXVpcmUoICdAc3RkbGliL2JsYXMtYmFzZS1nY29weScgKTtcbnZhciB0eXBlZGFycmF5Mmpzb24gPSByZXF1aXJlKCAnQHN0ZGxpYi9hcnJheS10by1qc29uJyApO1xudmFyIHJhbmR1aW50MzIgPSByZXF1aXJlKCAnLi9yYW5kX3VpbnQzMi5qcycgKTtcblxuXG4vLyBWQVJJQUJMRVMgLy9cblxuLy8gRGVmaW5lIHRoZSBzaXplIG9mIHRoZSBzdGF0ZSBhcnJheSAoc2VlIHJlZnMpOlxudmFyIE4gPSA2MjQ7XG5cbi8vIERlZmluZSBhIChtYWdpYykgY29uc3RhbnQgdXNlZCBmb3IgaW5kZXhpbmcgaW50byB0aGUgc3RhdGUgYXJyYXk6XG52YXIgTSA9IDM5NztcblxuLy8gRGVmaW5lIHRoZSBtYXhpbXVtIHNlZWQ6IDExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExXG52YXIgTUFYX1NFRUQgPSBVSU5UMzJfTUFYID4+PiAwOyAvLyBhc20gdHlwZSBhbm5vdGF0aW9uXG5cbi8vIEZvciBzZWVkIGFycmF5cywgZGVmaW5lIGFuIGluaXRpYWwgc3RhdGUgKG1hZ2ljKSBjb25zdGFudDogMTk2NTAyMTggPT4gMDAwMDAwMDEwMDEwMTAxMTExMDEwMTEwMTAxMDEwMTBcbnZhciBTRUVEX0FSUkFZX0lOSVRfU1RBVEUgPSAxOTY1MDIxOCA+Pj4gMDsgLy8gYXNtIHR5cGUgYW5ub3RhdGlvblxuXG4vLyBEZWZpbmUgYSBtYXNrIGZvciB0aGUgbW9zdCBzaWduaWZpY2FudCBgdy1yYCBiaXRzLCB3aGVyZSBgd2AgaXMgdGhlIHdvcmQgc2l6ZSAoMzIgYml0cykgYW5kIGByYCBpcyB0aGUgc2VwYXJhdGlvbiBwb2ludCBvZiBvbmUgd29yZCAoc2VlIHJlZnMpOiAyMTQ3NDgzNjQ4ID0+IDB4ODAwMDAwMDAgPT4gMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcbnZhciBVUFBFUl9NQVNLID0gMHg4MDAwMDAwMCA+Pj4gMDsgLy8gYXNtIHR5cGUgYW5ub3RhdGlvblxuXG4vLyBEZWZpbmUgYSBtYXNrIGZvciB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYHJgIGJpdHMgKHNlZSByZWZzKTogMjE0NzQ4MzY0NyA9PiAweDdmZmZmZmZmID0+IDAxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExXG52YXIgTE9XRVJfTUFTSyA9IDB4N2ZmZmZmZmYgPj4+IDA7IC8vIGFzbSB0eXBlIGFubm90YXRpb25cblxuLy8gRGVmaW5lIGEgbXVsdGlwbGllciAoc2VlIEtudXRoIFRBT0NQIFZvbDIuIDNyZCBFZC4gUC4xMDYpOiAxODEyNDMzMjUzID0+IDAxMTAxMTAwMDAwMDAxMTExMDAwMTAwMTAxMTAwMTAxXG52YXIgS05VVEhfTVVMVElQTElFUiA9IDE4MTI0MzMyNTMgPj4+IDA7IC8vIGFzbSB0eXBlIGFubm90YXRpb25cblxuLy8gRGVmaW5lIGEgKG1hZ2ljKSBtdWx0aXBsaWVyOiAxNjY0NTI1ID0+IDAwMDAwMDAwMDAwMTEwMDEwMTEwMDExMDAwMDAxMTAxXG52YXIgTUFHSUNfTVVMVElQTElFUl8xID0gMTY2NDUyNSA+Pj4gMDsgLy8gYXNtIHR5cGUgYW5ub3RhdGlvblxuXG4vLyBEZWZpbmUgYSAobWFnaWMpIG11bHRpcGxpZXI6IDE1NjYwODM5NDEgPT4gMDEwMTExMDEwMTAxMTAwMDEwMDAxMDExMDExMDAxMDFcbnZhciBNQUdJQ19NVUxUSVBMSUVSXzIgPSAxNTY2MDgzOTQxID4+PiAwOyAvLyBhc20gdHlwZSBhbm5vdGF0aW9uXG5cbi8vIERlZmluZSBhIHRlbXBlcmluZyBjb2VmZmljaWVudDogMjYzNjkyODY0MCA9PiAweDlkMmM1NjgwID0+IDEwMDExMTAxMDAxMDExMDAwMTAxMDExMDEwMDAwMDAwXG52YXIgVEVNUEVSSU5HX0NPRUZGSUNJRU5UXzEgPSAweDlkMmM1NjgwID4+PiAwOyAvLyBhc20gdHlwZSBhbm5vdGF0aW9uXG5cbi8vIERlZmluZSBhIHRlbXBlcmluZyBjb2VmZmljaWVudDogNDAyMjczMDc1MiA9PiAweGVmYzYwMDAwID0+IDExMTAxMTExMTEwMDAxMTAwMDAwMDAwMDAwMDAwMDAwXG52YXIgVEVNUEVSSU5HX0NPRUZGSUNJRU5UXzIgPSAweGVmYzYwMDAwID4+PiAwOyAvLyBhc20gdHlwZSBhbm5vdGF0aW9uXG5cbi8vIERlZmluZSBhIGNvbnN0YW50IHZlY3RvciBgYWAgKHNlZSByZWZzKTogMjU2NzQ4MzYxNSA9PiAweDk5MDhiMGRmID0+IDEwMDExMDAxMDAwMDEwMDAxMDExMDAwMDExMDExMTExXG52YXIgTUFUUklYX0EgPSAweDk5MDhiMGRmID4+PiAwOyAvLyBhc20gdHlwZSBhbm5vdGF0aW9uXG5cbi8vIE1BRzAxW3hdID0geCAqIE1BVFJJWF9BOyBmb3IgeCA9IHswLDF9XG52YXIgTUFHMDEgPSBbIDB4MCA+Pj4gMCwgTUFUUklYX0EgPj4+IDAgXTsgLy8gYXNtIHR5cGUgYW5ub3RhdGlvblxuXG4vLyBEZWZpbmUgYSBub3JtYWxpemF0aW9uIGNvbnN0YW50IHdoZW4gZ2VuZXJhdGluZyBkb3VibGUtcHJlY2lzaW9uIGZsb2F0aW5nLXBvaW50IG51bWJlcnM6IDJeNTMgPT4gOTAwNzE5OTI1NDc0MDk5MlxudmFyIEZMT0FUNjRfTk9STUFMSVpBVElPTl9DT05TVEFOVCA9IDEuMCAvICggRkxPQVQ2NF9NQVhfU0FGRV9JTlRFR0VSKzEuMCApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGlkLWxlbmd0aFxuXG4vLyAyXjI2OiA2NzEwODg2NFxudmFyIFRXT18yNiA9IDY3MTA4ODY0ID4+PiAwOyAvLyBhc20gdHlwZSBhbm5vdGF0aW9uXG5cbi8vIDJeMzI6IDIxNDc0ODM2NDggPT4gMHg4MDAwMDAwMCA9PiAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFxudmFyIFRXT18zMiA9IDB4ODAwMDAwMDAgPj4+IDA7IC8vIGFzbSB0eXBlIGFubm90YXRpb25cblxuLy8gMSAoYXMgYSAzMi1iaXQgdW5zaWduZWQgaW50ZWdlcik6IDEgPT4gMHgxID0+IDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxXG52YXIgT05FID0gMHgxID4+PiAwOyAvLyBhc20gdHlwZSBhbm5vdGF0aW9uXG5cbi8vIERlZmluZSB0aGUgbWF4aW11bSBub3JtYWxpemVkIHBzZXVkb3JhbmRvbSBkb3VibGUtcHJlY2lzaW9uIGZsb2F0aW5nLXBvaW50IG51bWJlcjogKCAoKCgyXjMyLTEpPj4+NSkqMl4yNikrKCAoMl4zMi0xKT4+PjYpICkgLyAyXjUzXG52YXIgTUFYX05PUk1BTElaRUQgPSBGTE9BVDY0X01BWF9TQUZFX0lOVEVHRVIgKiBGTE9BVDY0X05PUk1BTElaQVRJT05fQ09OU1RBTlQ7XG5cbi8vIERlZmluZSB0aGUgc3RhdGUgYXJyYXkgc2NoZW1hIHZlcnNpb246XG52YXIgU1RBVEVfQVJSQVlfVkVSU0lPTiA9IDE7IC8vIE5PVEU6IGFueXRpbWUgdGhlIHN0YXRlIGFycmF5IHNjaGVtYSBjaGFuZ2VzLCB0aGlzIHZhbHVlIHNob3VsZCBiZSBpbmNyZW1lbnRlZCEhIVxuXG4vLyBEZWZpbmUgdGhlIG51bWJlciBvZiBzZWN0aW9ucyBpbiB0aGUgc3RhdGUgYXJyYXk6XG52YXIgTlVNX1NUQVRFX1NFQ1RJT05TID0gMzsgLy8gc3RhdGUsIG90aGVyLCBzZWVkXG5cbi8vIERlZmluZSB0aGUgaW5kZXggb2Zmc2V0IG9mIHRoZSBcInN0YXRlXCIgc2VjdGlvbiBpbiB0aGUgc3RhdGUgYXJyYXk6XG52YXIgU1RBVEVfU0VDVElPTl9PRkZTRVQgPSAyOyAvLyB8IHZlcnNpb24gfCBudW1fc2VjdGlvbnMgfCBzdGF0ZV9sZW5ndGggfCAuLi5zdGF0ZSB8IG90aGVyX2xlbmd0aCB8IHN0YXRlX2luZGV4IHwgc2VlZF9sZW5ndGggfCAuLi5zZWVkIHxcblxuLy8gRGVmaW5lIHRoZSBpbmRleCBvZmZzZXQgb2YgdGhlIFwib3RoZXJcIiBzZWN0aW9uIGluIHRoZSBzdGF0ZSBhcnJheTpcbnZhciBPVEhFUl9TRUNUSU9OX09GRlNFVCA9IE4gKyAzOyAvLyB8IHZlcnNpb24gfCBudW1fc2VjdGlvbnMgfCBzdGF0ZV9sZW5ndGggfCAuLi5zdGF0ZSB8IG90aGVyX2xlbmd0aCB8IHN0YXRlX2luZGV4IHwgc2VlZF9sZW5ndGggfCAuLi5zZWVkIHxcblxuLy8gRGVmaW5lIHRoZSBpbmRleCBvZmZzZXQgb2YgdGhlIHNlZWQgc2VjdGlvbiBpbiB0aGUgc3RhdGUgYXJyYXk6XG52YXIgU0VFRF9TRUNUSU9OX09GRlNFVCA9IE4gKyA1OyAvLyB8IHZlcnNpb24gfCBudW1fc2VjdGlvbnMgfCBzdGF0ZV9sZW5ndGggfCAuLi5zdGF0ZSB8IG90aGVyX2xlbmd0aCB8IHN0YXRlX2luZGV4IHwgc2VlZF9sZW5ndGggfCAuLi5zZWVkIHxcblxuLy8gRGVmaW5lIHRoZSBsZW5ndGggb2YgdGhlIFwiZml4ZWRcIiBsZW5ndGggcG9ydGlvbiBvZiB0aGUgc3RhdGUgYXJyYXk6XG52YXIgU1RBVEVfRklYRURfTEVOR1RIID0gTiArIDY7IC8vIDEgKHZlcnNpb24pICsgMSAobnVtX3NlY3Rpb25zKSArIDEgKHN0YXRlX2xlbmd0aCkgKyBOIChzdGF0ZSkgKyAxIChvdGhlcl9sZW5ndGgpICsgMSAoc3RhdGVfaW5kZXgpICsgMSAoc2VlZF9sZW5ndGgpXG5cblxuLy8gRlVOQ1RJT05TIC8vXG5cbi8qKlxuKiBWZXJpZmllcyBzdGF0ZSBhcnJheSBpbnRlZ3JpdHkuXG4qXG4qIEBwcml2YXRlXG4qIEBwYXJhbSB7VWludDMyQXJyYXl9IHN0YXRlIC0gc3RhdGUgYXJyYXlcbiogQHBhcmFtIHtib29sZWFufSBGTEcgLSBmbGFnIGluZGljYXRpbmcgd2hldGhlciB0aGUgc3RhdGUgYXJyYXkgd2FzIHByb3ZpZGVkIGFzIGFuIG9wdGlvbiAodHJ1ZSkgb3IgYW4gYXJndW1lbnQgKGZhbHNlKVxuKiBAcmV0dXJucyB7KEVycm9yfG51bGwpfSBhbiBlcnJvciBvciBgbnVsbGBcbiovXG5mdW5jdGlvbiB2ZXJpZnlTdGF0ZSggc3RhdGUsIEZMRyApIHtcblx0dmFyIHMxO1xuXHRpZiAoIEZMRyApIHtcblx0XHRzMSA9ICdvcHRpb24nO1xuXHR9IGVsc2Uge1xuXHRcdHMxID0gJ2FyZ3VtZW50Jztcblx0fVxuXHQvLyBUaGUgc3RhdGUgYXJyYXkgbXVzdCBoYXZlIGEgbWluaW11bSBsZW5ndGguLi5cblx0aWYgKCBzdGF0ZS5sZW5ndGggPCBTVEFURV9GSVhFRF9MRU5HVEgrMSApIHtcblx0XHRyZXR1cm4gbmV3IFJhbmdlRXJyb3IoICdpbnZhbGlkICcrczErJy4gYHN0YXRlYCBhcnJheSBoYXMgaW5zdWZmaWNpZW50IGxlbmd0aC4nICk7XG5cdH1cblx0Ly8gVGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIHN0YXRlIGFycmF5IG11c3QgZXF1YWwgdGhlIHN1cHBvcnRlZCBzdGF0ZSBhcnJheSBzY2hlbWEgdmVyc2lvbi4uLlxuXHRpZiAoIHN0YXRlWyAwIF0gIT09IFNUQVRFX0FSUkFZX1ZFUlNJT04gKSB7XG5cdFx0cmV0dXJuIG5ldyBSYW5nZUVycm9yKCAnaW52YWxpZCAnK3MxKycuIGBzdGF0ZWAgYXJyYXkgaGFzIGFuIGluY29tcGF0aWJsZSBzY2hlbWEgdmVyc2lvbi4gRXhwZWN0ZWQ6ICcrU1RBVEVfQVJSQVlfVkVSU0lPTisnLiBBY3R1YWw6ICcrc3RhdGVbIDAgXSsnLicgKTtcblx0fVxuXHQvLyBUaGUgc2Vjb25kIGVsZW1lbnQgb2YgdGhlIHN0YXRlIGFycmF5IG11c3QgY29udGFpbiB0aGUgbnVtYmVyIG9mIHNlY3Rpb25zLi4uXG5cdGlmICggc3RhdGVbIDEgXSAhPT0gTlVNX1NUQVRFX1NFQ1RJT05TICkge1xuXHRcdHJldHVybiBuZXcgUmFuZ2VFcnJvciggJ2ludmFsaWQgJytzMSsnLiBgc3RhdGVgIGFycmF5IGhhcyBhbiBpbmNvbXBhdGlibGUgbnVtYmVyIG9mIHNlY3Rpb25zLiBFeHBlY3RlZDogJytOVU1fU1RBVEVfU0VDVElPTlMrJy4gQWN0dWFsOiAnK3N0YXRlWyAxIF0rJy4nICk7XG5cdH1cblx0Ly8gVGhlIGxlbmd0aCBvZiB0aGUgXCJzdGF0ZVwiIHNlY3Rpb24gbXVzdCBlcXVhbCBgTmAuLi5cblx0aWYgKCBzdGF0ZVsgU1RBVEVfU0VDVElPTl9PRkZTRVQgXSAhPT0gTiApIHtcblx0XHRyZXR1cm4gbmV3IFJhbmdlRXJyb3IoICdpbnZhbGlkICcrczErJy4gYHN0YXRlYCBhcnJheSBoYXMgYW4gaW5jb21wYXRpYmxlIHN0YXRlIGxlbmd0aC4gRXhwZWN0ZWQ6ICcrTisnLiBBY3R1YWw6ICcrc3RhdGVbIFNUQVRFX1NFQ1RJT05fT0ZGU0VUIF0rJy4nICk7XG5cdH1cblx0Ly8gVGhlIGxlbmd0aCBvZiB0aGUgXCJvdGhlclwiIHNlY3Rpb24gbXVzdCBlcXVhbCBgMWAuLi5cblx0aWYgKCBzdGF0ZVsgT1RIRVJfU0VDVElPTl9PRkZTRVQgXSAhPT0gMSApIHtcblx0XHRyZXR1cm4gbmV3IFJhbmdlRXJyb3IoICdpbnZhbGlkICcrczErJy4gYHN0YXRlYCBhcnJheSBoYXMgYW4gaW5jb21wYXRpYmxlIHNlY3Rpb24gbGVuZ3RoLiBFeHBlY3RlZDogJysoMSkudG9TdHJpbmcoKSsnLiBBY3R1YWw6ICcrc3RhdGVbIE9USEVSX1NFQ1RJT05fT0ZGU0VUIF0rJy4nICk7XG5cdH1cblx0Ly8gVGhlIGxlbmd0aCBvZiB0aGUgXCJzZWVkXCIgc2VjdGlvbiBtdWNoIG1hdGNoIHRoZSBlbXBpcmljYWwgbGVuZ3RoLi4uXG5cdGlmICggc3RhdGVbIFNFRURfU0VDVElPTl9PRkZTRVQgXSAhPT0gc3RhdGUubGVuZ3RoLVNUQVRFX0ZJWEVEX0xFTkdUSCApIHtcblx0XHRyZXR1cm4gbmV3IFJhbmdlRXJyb3IoICdpbnZhbGlkICcrczErJy4gYHN0YXRlYCBhcnJheSBsZW5ndGggaXMgaW5jb21wYXRpYmxlIHdpdGggc2VlZCBzZWN0aW9uIGxlbmd0aC4gRXhwZWN0ZWQ6ICcrKHN0YXRlLmxlbmd0aC1TVEFURV9GSVhFRF9MRU5HVEgpKycuIEFjdHVhbDogJytzdGF0ZVsgU0VFRF9TRUNUSU9OX09GRlNFVCBdKycuJyApO1xuXHR9XG5cdHJldHVybiBudWxsO1xufVxuXG4vKipcbiogUmV0dXJucyBhbiBpbml0aWFsIFBSTkcgc3RhdGUuXG4qXG4qIEBwcml2YXRlXG4qIEBwYXJhbSB7VWludDMyQXJyYXl9IHN0YXRlIC0gc3RhdGUgYXJyYXlcbiogQHBhcmFtIHtQb3NpdGl2ZUludGVnZXJ9IE4gLSBzdGF0ZSBzaXplXG4qIEBwYXJhbSB7dWludGVnZXIzMn0gcyAtIHNlZWRcbiogQHJldHVybnMge1VpbnQzMkFycmF5fSBzdGF0ZSBhcnJheVxuKi9cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRlKCBzdGF0ZSwgTiwgcyApIHtcblx0dmFyIGk7XG5cblx0Ly8gU2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBzdGF0ZSBhcnJheSB0byB0aGUgcHJvdmlkZWQgc2VlZDpcblx0c3RhdGVbIDAgXSA9IHMgPj4+IDA7IC8vIGVxdWl2YWxlbnQgdG8gYHMgJiAweGZmZmZmZmZmVUxgIGluIG9yaWdpbmFsIEMgaW1wbGVtZW50YXRpb25cblxuXHQvLyBJbml0aWFsaXplIHRoZSByZW1haW5pbmcgc3RhdGUgYXJyYXkgZWxlbWVudHM6XG5cdGZvciAoIGkgPSAxOyBpIDwgTjsgaSsrICkge1xuXHRcdC8qXG5cdFx0KiBJbiB0aGUgb3JpZ2luYWwgQyBpbXBsZW1lbnRhdGlvbiAoc2VlIGBpbml0X2dlbnJhbmQoKWApLFxuXHRcdCpcblx0XHQqIGBgYGNcblx0XHQqIG10W2ldID0gKEtOVVRIX01VTFRJUExJRVIgKiAobXRbaS0xXSBeIChtdFtpLTFdID4+IDMwKSkgKyBpKVxuXHRcdCogYGBgXG5cdFx0KlxuXHRcdCogSW4gb3JkZXIgdG8gcmVwbGljYXRlIHRoaXMgaW4gSmF2YVNjcmlwdCwgd2UgbXVzdCBlbXVsYXRlIEMtbGlrZSBtdWx0aXBsaWNhdGlvbiBvZiB1bnNpZ25lZCAzMi1iaXQgaW50ZWdlcnMuXG5cdFx0Ki9cblx0XHRzID0gc3RhdGVbIGktMSBdPj4+MDsgLy8gYXNtIHR5cGUgYW5ub3RhdGlvblxuXHRcdHMgPSAoIHNeKHM+Pj4zMCkgKT4+PjA7IC8vIGFzbSB0eXBlIGFubm90YXRpb25cblx0XHRzdGF0ZVsgaSBdID0gKCB1aW11bCggcywgS05VVEhfTVVMVElQTElFUiApICsgaSApPj4+MDsgLy8gYXNtIHR5cGUgYW5ub3RhdGlvblxuXHR9XG5cdHJldHVybiBzdGF0ZTtcbn1cblxuLyoqXG4qIEluaXRpYWxpemVzIGEgUFJORyBzdGF0ZSBhcnJheSBhY2NvcmRpbmcgdG8gYSBzZWVkIGFycmF5LlxuKlxuKiBAcHJpdmF0ZVxuKiBAcGFyYW0ge1VpbnQzMkFycmF5fSBzdGF0ZSAtIHN0YXRlIGFycmF5XG4qIEBwYXJhbSB7Tm9uTmVnYXRpdmVJbnRlZ2VyfSBOIC0gc3RhdGUgYXJyYXkgbGVuZ3RoXG4qIEBwYXJhbSB7Q29sbGVjdGlvbn0gc2VlZCAtIHNlZWQgYXJyYXlcbiogQHBhcmFtIHtOb25OZWdhdGl2ZUludGVnZXJ9IE0gLSBzZWVkIGFycmF5IGxlbmd0aFxuKiBAcmV0dXJucyB7VWludDMyQXJyYXl9IHN0YXRlIGFycmF5XG4qL1xuZnVuY3Rpb24gaW5pdFN0YXRlKCBzdGF0ZSwgTiwgc2VlZCwgTSApIHtcblx0dmFyIHM7XG5cdHZhciBpO1xuXHR2YXIgajtcblx0dmFyIGs7XG5cblx0aSA9IDE7XG5cdGogPSAwO1xuXHRmb3IgKCBrID0gbWF4KCBOLCBNICk7IGsgPiAwOyBrLS0gKSB7XG5cdFx0Lypcblx0XHQqIEluIHRoZSBvcmlnaW5hbCBDIGltcGxlbWVudGF0aW9uIChzZWUgYGluaXRfYnlfYXJyYXkoKWApLFxuXHRcdCpcblx0XHQqIGBgYGNcblx0XHQqIG10W2ldID0gKG10W2ldXigobXRbaS0xXV4obXRbaS0xXT4+MzApKSoxNjY0NTI1VUwpKSArIHNlZWRbal0gKyBqO1xuXHRcdCogYGBgXG5cdFx0KlxuXHRcdCogSW4gb3JkZXIgdG8gcmVwbGljYXRlIHRoaXMgaW4gSmF2YVNjcmlwdCwgd2UgbXVzdCBlbXVsYXRlIEMtbGlrZSBtdWx0aXBsaWNhdGlvbiBvZiB1bnNpZ25lZCAzMi1iaXQgaW50ZWdlcnMuXG5cdFx0Ki9cblx0XHRzID0gc3RhdGVbIGktMSBdPj4+MDsgLy8gYXNtIHR5cGUgYW5ub3RhdGlvblxuXHRcdHMgPSAoIHNeKHM+Pj4zMCkgKT4+PjA7IC8vIGFzbSB0eXBlIGFubm90YXRpb25cblx0XHRzID0gKCB1aW11bCggcywgTUFHSUNfTVVMVElQTElFUl8xICkgKT4+PjA7IC8vIGFzbSB0eXBlIGFubm90YXRpb25cblx0XHRzdGF0ZVsgaSBdID0gKCAoKHN0YXRlW2ldPj4+MClecykgKyBzZWVkW2pdICsgaiApPj4+MDsgLyogbm9uLWxpbmVhciAqLyAvLyBhc20gdHlwZSBhbm5vdGF0aW9uXG5cblx0XHRpICs9IDE7XG5cdFx0aiArPSAxO1xuXHRcdGlmICggaSA+PSBOICkge1xuXHRcdFx0c3RhdGVbIDAgXSA9IHN0YXRlWyBOLTEgXTtcblx0XHRcdGkgPSAxO1xuXHRcdH1cblx0XHRpZiAoIGogPj0gTSApIHtcblx0XHRcdGogPSAwO1xuXHRcdH1cblx0fVxuXHRmb3IgKCBrID0gTi0xOyBrID4gMDsgay0tICkge1xuXHRcdC8qXG5cdFx0KiBJbiB0aGUgb3JpZ2luYWwgQyBpbXBsZW1lbnRhdGlvbiAoc2VlIGBpbml0X2J5X2FycmF5KClgKSxcblx0XHQqXG5cdFx0KiBgYGBjXG5cdFx0KiBtdFtpXSA9IChtdFtpXV4oKG10W2ktMV1eKG10W2ktMV0+PjMwKSkqMTU2NjA4Mzk0MVVMKSkgLSBpO1xuXHRcdCogYGBgXG5cdFx0KlxuXHRcdCogSW4gb3JkZXIgdG8gcmVwbGljYXRlIHRoaXMgaW4gSmF2YVNjcmlwdCwgd2UgbXVzdCBlbXVsYXRlIEMtbGlrZSBtdWx0aXBsaWNhdGlvbiBvZiB1bnNpZ25lZCAzMi1iaXQgaW50ZWdlcnMuXG5cdFx0Ki9cblx0XHRzID0gc3RhdGVbIGktMSBdPj4+MDsgLy8gYXNtIHR5cGUgYW5ub3RhdGlvblxuXHRcdHMgPSAoIHNeKHM+Pj4zMCkgKT4+PjA7IC8vIGFzbSB0eXBlIGFubm90YXRpb25cblx0XHRzID0gKCB1aW11bCggcywgTUFHSUNfTVVMVElQTElFUl8yICkgKT4+PjA7IC8vIGFzbSB0eXBlIGFubm90YXRpb25cblx0XHRzdGF0ZVsgaSBdID0gKCAoKHN0YXRlW2ldPj4+MClecykgLSBpICk+Pj4wOyAvKiBub24tbGluZWFyICovIC8vIGFzbSB0eXBlIGFubm90YXRpb25cblxuXHRcdGkgKz0gMTtcblx0XHRpZiAoIGkgPj0gTiApIHtcblx0XHRcdHN0YXRlWyAwIF0gPSBzdGF0ZVsgTi0xIF07XG5cdFx0XHRpID0gMTtcblx0XHR9XG5cdH1cblx0Ly8gRW5zdXJlIGEgbm9uLXplcm8gaW5pdGlhbCBzdGF0ZSBhcnJheTpcblx0c3RhdGVbIDAgXSA9IFRXT18zMjsgLy8gTVNCIChtb3N0IHNpZ25pZmljYW50IGJpdCkgaXMgMVxuXG5cdHJldHVybiBzdGF0ZTtcbn1cblxuLyoqXG4qIFVwZGF0ZXMgYSBQUk5HJ3MgaW50ZXJuYWwgc3RhdGUgYnkgZ2VuZXJhdGluZyB0aGUgbmV4dCBgTmAgd29yZHMuXG4qXG4qIEBwcml2YXRlXG4qIEBwYXJhbSB7VWludDMyQXJyYXl9IHN0YXRlIC0gc3RhdGUgYXJyYXlcbiogQHJldHVybnMge1VpbnQzMkFycmF5fSBzdGF0ZSBhcnJheVxuKi9cbmZ1bmN0aW9uIHR3aXN0KCBzdGF0ZSApIHtcblx0dmFyIHc7XG5cdHZhciBpO1xuXHR2YXIgajtcblx0dmFyIGs7XG5cblx0ayA9IE4gLSBNO1xuXHRmb3IgKCBpID0gMDsgaSA8IGs7IGkrKyApIHtcblx0XHR3ID0gKCBzdGF0ZVtpXSZVUFBFUl9NQVNLICkgfCAoIHN0YXRlW2krMV0mTE9XRVJfTUFTSyApO1xuXHRcdHN0YXRlWyBpIF0gPSBzdGF0ZVsgaStNIF0gXiAoIHc+Pj4xICkgXiBNQUcwMVsgdyZPTkUgXTtcblx0fVxuXHRqID0gTiAtIDE7XG5cdGZvciAoIDsgaSA8IGo7IGkrKyApIHtcblx0XHR3ID0gKCBzdGF0ZVtpXSZVUFBFUl9NQVNLICkgfCAoIHN0YXRlW2krMV0mTE9XRVJfTUFTSyApO1xuXHRcdHN0YXRlWyBpIF0gPSBzdGF0ZVsgaS1rIF0gXiAoIHc+Pj4xICkgXiBNQUcwMVsgdyZPTkUgXTtcblx0fVxuXHR3ID0gKCBzdGF0ZVtqXSZVUFBFUl9NQVNLICkgfCAoIHN0YXRlWzBdJkxPV0VSX01BU0sgKTtcblx0c3RhdGVbIGogXSA9IHN0YXRlWyBNLTEgXSBeICggdz4+PjEgKSBeIE1BRzAxWyB3Jk9ORSBdO1xuXHRyZXR1cm4gc3RhdGU7XG59XG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogUmV0dXJucyBhIDMyLWJpdCBNZXJzZW5uZSBUd2lzdGVyIHBzZXVkb3JhbmRvbSBudW1iZXIgZ2VuZXJhdG9yLlxuKlxuKiAjIyBOb3Rlc1xuKlxuKiAtICAgSW4gY29udHJhc3QgdG8gdGhlIG9yaWdpbmFsIEMgaW1wbGVtZW50YXRpb24sIGFycmF5IHNlZWRzIG9mIGxlbmd0aCBgMWAgYXJlIGNvbnNpZGVyZWQgaW50ZWdlciBzZWVkcy4gVGhpcyBlbnN1cmVzIHRoYXQgdGhlIHNlZWQgYFsgMTIzNCBdYCBnZW5lcmF0ZXMgdGhlIHNhbWUgb3V0cHV0IGFzIHRoZSBzZWVkIGAxMjM0YC4gSW4gdGhlIG9yaWdpbmFsIEMgaW1wbGVtZW50YXRpb24sIHRoZSB0d28gc2VlZHMgd291bGQgeWllbGQgZGlmZmVyZW50IG91dHB1dCwgd2hpY2ggaXMgKipub3QqKiBvYnZpb3VzIGZyb20gYSB1c2VyIHBlcnNwZWN0aXZlLlxuKlxuKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSAtIG9wdGlvbnNcbiogQHBhcmFtIHtQUk5HU2VlZE1UMTk5Mzd9IFtvcHRpb25zLnNlZWRdIC0gcHNldWRvcmFuZG9tIG51bWJlciBnZW5lcmF0b3Igc2VlZFxuKiBAcGFyYW0ge1BSTkdTdGF0ZU1UMTk5Mzd9IFtvcHRpb25zLnN0YXRlXSAtIHBzZXVkb3JhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIHN0YXRlXG4qIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY29weT10cnVlXSAtIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRvIGNvcHkgYSBwcm92aWRlZCBwc2V1ZG9yYW5kb20gbnVtYmVyIGdlbmVyYXRvciBzdGF0ZVxuKiBAdGhyb3dzIHtUeXBlRXJyb3J9IG9wdGlvbnMgYXJndW1lbnQgbXVzdCBiZSBhbiBvYmplY3RcbiogQHRocm93cyB7VHlwZUVycm9yfSBhIHNlZWQgbXVzdCBiZSBlaXRoZXIgYSBwb3NpdGl2ZSBpbnRlZ2VyIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgbWF4aW11bSB1bnNpZ25lZCAzMi1iaXQgaW50ZWdlciBvciBhbiBhcnJheS1saWtlIG9iamVjdCBjb250YWluaW5nIGludGVnZXJzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgbWF4aW11bSB1bnNpZ25lZCAzMi1iaXQgaW50ZWdlclxuKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBhIG51bWVyaWMgc2VlZCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIG1heGltdW0gdW5zaWduZWQgMzItYml0IGludGVnZXJcbiogQHRocm93cyB7VHlwZUVycm9yfSBzdGF0ZSBtdXN0IGJlIGEgYFVpbnQzMkFycmF5YFxuKiBAdGhyb3dzIHtFcnJvcn0gbXVzdCBwcm92aWRlIGEgdmFsaWQgc3RhdGVcbiogQHRocm93cyB7VHlwZUVycm9yfSBgY29weWAgb3B0aW9uIG11c3QgYmUgYSBib29sZWFuXG4qIEByZXR1cm5zIHtQUk5HfSBNZXJzZW5uZSBUd2lzdGVyIFBSTkdcbipcbiogQGV4YW1wbGVcbiogdmFyIG10MTk5MzcgPSBmYWN0b3J5KCk7XG4qXG4qIHZhciB2ID0gbXQxOTkzNygpO1xuKiAvLyByZXR1cm5zIDxudW1iZXI+XG4qXG4qIEBleGFtcGxlXG4qIC8vIFJldHVybiBhIHNlZWRlZCBNZXJzZW5uZSBUd2lzdGVyIFBSTkc6XG4qIHZhciBtdDE5OTM3ID0gZmFjdG9yeSh7XG4qICAgICAnc2VlZCc6IDEyMzRcbiogfSk7XG4qXG4qIHZhciB2ID0gbXQxOTkzNygpO1xuKiAvLyByZXR1cm5zIDgyMjU2OTc3NVxuKi9cbmZ1bmN0aW9uIGZhY3RvcnkoIG9wdGlvbnMgKSB7XG5cdHZhciBTVEFURTtcblx0dmFyIHN0YXRlO1xuXHR2YXIgb3B0cztcblx0dmFyIHNlZWQ7XG5cdHZhciBzbGVuO1xuXHR2YXIgZXJyO1xuXG5cdG9wdHMgPSB7fTtcblx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdGlmICggIWlzT2JqZWN0KCBvcHRpb25zICkgKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnaW52YWxpZCBhcmd1bWVudC4gT3B0aW9ucyBhcmd1bWVudCBtdXN0IGJlIGFuIG9iamVjdC4gVmFsdWU6IGAnICsgb3B0aW9ucyArICdgLicgKTtcblx0XHR9XG5cdFx0aWYgKCBoYXNPd25Qcm9wKCBvcHRpb25zLCAnY29weScgKSApIHtcblx0XHRcdG9wdHMuY29weSA9IG9wdGlvbnMuY29weTtcblx0XHRcdGlmICggIWlzQm9vbGVhbiggb3B0aW9ucy5jb3B5ICkgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdpbnZhbGlkIG9wdGlvbi4gYGNvcHlgIG9wdGlvbiBtdXN0IGJlIGEgYm9vbGVhbi4gT3B0aW9uOiBgJyArIG9wdGlvbnMuY29weSArICdgLicgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCBoYXNPd25Qcm9wKCBvcHRpb25zLCAnc3RhdGUnICkgKSB7XG5cdFx0XHRzdGF0ZSA9IG9wdGlvbnMuc3RhdGU7XG5cdFx0XHRvcHRzLnN0YXRlID0gdHJ1ZTtcblx0XHRcdGlmICggIWlzVWludDMyQXJyYXkoIHN0YXRlICkgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdpbnZhbGlkIG9wdGlvbi4gYHN0YXRlYCBvcHRpb24gbXVzdCBiZSBhIFVpbnQzMkFycmF5LiBPcHRpb246IGAnICsgc3RhdGUgKyAnYC4nICk7XG5cdFx0XHR9XG5cdFx0XHRlcnIgPSB2ZXJpZnlTdGF0ZSggc3RhdGUsIHRydWUgKTtcblx0XHRcdGlmICggZXJyICkge1xuXHRcdFx0XHR0aHJvdyBlcnI7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG9wdHMuY29weSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFNUQVRFID0gc3RhdGU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRTVEFURSA9IG5ldyBVaW50MzJBcnJheSggc3RhdGUubGVuZ3RoICk7XG5cdFx0XHRcdGdjb3B5KCBzdGF0ZS5sZW5ndGgsIHN0YXRlLCAxLCBTVEFURSwgMSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gQ3JlYXRlIGEgc3RhdGUgXCJ2aWV3XCI6XG5cdFx0XHRzdGF0ZSA9IG5ldyBVaW50MzJBcnJheSggU1RBVEUuYnVmZmVyLCBTVEFURS5ieXRlT2Zmc2V0KygoU1RBVEVfU0VDVElPTl9PRkZTRVQrMSkqU1RBVEUuQllURVNfUEVSX0VMRU1FTlQpLCBOICk7XG5cblx0XHRcdC8vIENyZWF0ZSBhIHNlZWQgXCJ2aWV3XCI6XG5cdFx0XHRzZWVkID0gbmV3IFVpbnQzMkFycmF5KCBTVEFURS5idWZmZXIsIFNUQVRFLmJ5dGVPZmZzZXQrKChTRUVEX1NFQ1RJT05fT0ZGU0VUKzEpKlNUQVRFLkJZVEVTX1BFUl9FTEVNRU5UKSwgc3RhdGVbIFNFRURfU0VDVElPTl9PRkZTRVQgXSApO1xuXHRcdH1cblx0XHQvLyBJZiBwcm92aWRlZCBhIFBSTkcgc3RhdGUsIHdlIGlnbm9yZSB0aGUgYHNlZWRgIG9wdGlvbi4uLlxuXHRcdGlmICggc2VlZCA9PT0gdm9pZCAwICkge1xuXHRcdFx0aWYgKCBoYXNPd25Qcm9wKCBvcHRpb25zLCAnc2VlZCcgKSApIHtcblx0XHRcdFx0c2VlZCA9IG9wdGlvbnMuc2VlZDtcblx0XHRcdFx0b3B0cy5zZWVkID0gdHJ1ZTtcblx0XHRcdFx0aWYgKCBpc1Bvc2l0aXZlSW50ZWdlciggc2VlZCApICkge1xuXHRcdFx0XHRcdGlmICggc2VlZCA+IE1BWF9TRUVEICkge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoICdpbnZhbGlkIG9wdGlvbi4gYHNlZWRgIG9wdGlvbiBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIG1heGltdW0gdW5zaWduZWQgMzItYml0IGludGVnZXIuIE9wdGlvbjogYCcgKyBzZWVkICsgJ2AuJyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzZWVkID4+Pj0gMDsgLy8gYXNtIHR5cGUgYW5ub3RhdGlvblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBpc0NvbGxlY3Rpb24oIHNlZWQgKSA9PT0gZmFsc2UgfHwgc2VlZC5sZW5ndGggPCAxICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdpbnZhbGlkIG9wdGlvbi4gYHNlZWRgIG9wdGlvbiBtdXN0IGJlIGVpdGhlciBhIHBvc2l0aXZlIGludGVnZXIgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBtYXhpbXVtIHVuc2lnbmVkIDMyLWJpdCBpbnRlZ2VyIG9yIGFuIGFycmF5LWxpa2Ugb2JqZWN0IGNvbnRhaW5pbmcgaW50ZWdlciB2YWx1ZXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBtYXhpbXVtIHVuc2lnbmVkIDMyLWJpdCBpbnRlZ2VyLiBPcHRpb246IGAnICsgc2VlZCArICdgLicgKTtcblx0XHRcdFx0fSBlbHNlIGlmICggc2VlZC5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRcdFx0c2VlZCA9IHNlZWRbIDAgXTtcblx0XHRcdFx0XHRpZiAoICFpc1Bvc2l0aXZlSW50ZWdlciggc2VlZCApICkge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ2ludmFsaWQgb3B0aW9uLiBgc2VlZGAgb3B0aW9uIG11c3QgYmUgZWl0aGVyIGEgcG9zaXRpdmUgaW50ZWdlciBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIG1heGltdW0gdW5zaWduZWQgMzItYml0IGludGVnZXIgb3IgYW4gYXJyYXktbGlrZSBvYmplY3QgY29udGFpbmluZyBpbnRlZ2VyIHZhbHVlcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIG1heGltdW0gdW5zaWduZWQgMzItYml0IGludGVnZXIuIE9wdGlvbjogYCcgKyBzZWVkICsgJ2AuJyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHNlZWQgPiBNQVhfU0VFRCApIHtcblx0XHRcdFx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKCAnaW52YWxpZCBvcHRpb24uIGBzZWVkYCBvcHRpb24gbXVzdCBiZSBlaXRoZXIgYSBwb3NpdGl2ZSBpbnRlZ2VyIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgbWF4aW11bSB1bnNpZ25lZCAzMi1iaXQgaW50ZWdlciBvciBhbiBhcnJheS1saWtlIG9iamVjdCBjb250YWluaW5nIGludGVnZXIgdmFsdWVzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgbWF4aW11bSB1bnNpZ25lZCAzMi1iaXQgaW50ZWdlci4gT3B0aW9uOiBgJyArIHNlZWQgKyAnYC4nICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNlZWQgPj4+PSAwOyAvLyBhc20gdHlwZSBhbm5vdGF0aW9uXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c2xlbiA9IHNlZWQubGVuZ3RoO1xuXHRcdFx0XHRcdFNUQVRFID0gbmV3IFVpbnQzMkFycmF5KCBTVEFURV9GSVhFRF9MRU5HVEgrc2xlbiApO1xuXG5cdFx0XHRcdFx0Ly8gSW5pdGlhbGl6ZSBzZWN0aW9uczpcblx0XHRcdFx0XHRTVEFURVsgMCBdID0gU1RBVEVfQVJSQVlfVkVSU0lPTjtcblx0XHRcdFx0XHRTVEFURVsgMSBdID0gTlVNX1NUQVRFX1NFQ1RJT05TO1xuXHRcdFx0XHRcdFNUQVRFWyBTVEFURV9TRUNUSU9OX09GRlNFVCBdID0gTjtcblx0XHRcdFx0XHRTVEFURVsgT1RIRVJfU0VDVElPTl9PRkZTRVQgXSA9IDE7XG5cdFx0XHRcdFx0U1RBVEVbIE9USEVSX1NFQ1RJT05fT0ZGU0VUKzEgXSA9IE47IC8vIHN0YXRlIGluZGV4XG5cdFx0XHRcdFx0U1RBVEVbIFNFRURfU0VDVElPTl9PRkZTRVQgXSA9IHNsZW47XG5cblx0XHRcdFx0XHQvLyBDb3B5IHRoZSBwcm92aWRlZCBzZWVkIGFycmF5IHRvIHByZXZlbnQgZXh0ZXJuYWwgbXV0YXRpb24sIGFzIG11dGF0aW9uIHdvdWxkIGxlYWQgdG8gYW4gaW5hYmlsaXR5IHRvIHJlcHJvZHVjZSBQUk5HIHZhbHVlcyBhY2NvcmRpbmcgdG8gdGhlIFBSTkcncyBzdGF0ZWQgc2VlZDpcblx0XHRcdFx0XHRnY29weS5uZGFycmF5KCBzbGVuLCBzZWVkLCAxLCAwLCBTVEFURSwgMSwgU0VFRF9TRUNUSU9OX09GRlNFVCsxICk7XG5cblx0XHRcdFx0XHQvLyBDcmVhdGUgYSBzdGF0ZSBcInZpZXdcIjpcblx0XHRcdFx0XHRzdGF0ZSA9IG5ldyBVaW50MzJBcnJheSggU1RBVEUuYnVmZmVyLCBTVEFURS5ieXRlT2Zmc2V0KygoU1RBVEVfU0VDVElPTl9PRkZTRVQrMSkqU1RBVEUuQllURVNfUEVSX0VMRU1FTlQpLCBOICk7XG5cblx0XHRcdFx0XHQvLyBDcmVhdGUgYSBzZWVkIFwidmlld1wiOlxuXHRcdFx0XHRcdHNlZWQgPSBuZXcgVWludDMyQXJyYXkoIFNUQVRFLmJ1ZmZlciwgU1RBVEUuYnl0ZU9mZnNldCsoKFNFRURfU0VDVElPTl9PRkZTRVQrMSkqU1RBVEUuQllURVNfUEVSX0VMRU1FTlQpLCBzbGVuICk7XG5cblx0XHRcdFx0XHQvLyBJbml0aWFsaXplIHRoZSBpbnRlcm5hbCBQUk5HIHN0YXRlOlxuXHRcdFx0XHRcdHN0YXRlID0gY3JlYXRlU3RhdGUoIHN0YXRlLCBOLCBTRUVEX0FSUkFZX0lOSVRfU1RBVEUgKTtcblx0XHRcdFx0XHRzdGF0ZSA9IGluaXRTdGF0ZSggc3RhdGUsIE4sIHNlZWQsIHNsZW4gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VlZCA9IHJhbmR1aW50MzIoKSA+Pj4gMDsgLy8gYXNtIHR5cGUgYW5ub3RhdGlvblxuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRzZWVkID0gcmFuZHVpbnQzMigpID4+PiAwOyAvLyBhc20gdHlwZSBhbm5vdGF0aW9uXG5cdH1cblx0aWYgKCBzdGF0ZSA9PT0gdm9pZCAwICkge1xuXHRcdFNUQVRFID0gbmV3IFVpbnQzMkFycmF5KCBTVEFURV9GSVhFRF9MRU5HVEgrMSApO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSBzZWN0aW9uczpcblx0XHRTVEFURVsgMCBdID0gU1RBVEVfQVJSQVlfVkVSU0lPTjtcblx0XHRTVEFURVsgMSBdID0gTlVNX1NUQVRFX1NFQ1RJT05TO1xuXHRcdFNUQVRFWyBTVEFURV9TRUNUSU9OX09GRlNFVCBdID0gTjtcblx0XHRTVEFURVsgT1RIRVJfU0VDVElPTl9PRkZTRVQgXSA9IDE7XG5cdFx0U1RBVEVbIE9USEVSX1NFQ1RJT05fT0ZGU0VUKzEgXSA9IE47IC8vIHN0YXRlIGluZGV4XG5cdFx0U1RBVEVbIFNFRURfU0VDVElPTl9PRkZTRVQgXSA9IDE7XG5cdFx0U1RBVEVbIFNFRURfU0VDVElPTl9PRkZTRVQrMSBdID0gc2VlZDtcblxuXHRcdC8vIENyZWF0ZSBhIHN0YXRlIFwidmlld1wiOlxuXHRcdHN0YXRlID0gbmV3IFVpbnQzMkFycmF5KCBTVEFURS5idWZmZXIsIFNUQVRFLmJ5dGVPZmZzZXQrKChTVEFURV9TRUNUSU9OX09GRlNFVCsxKSpTVEFURS5CWVRFU19QRVJfRUxFTUVOVCksIE4gKTtcblxuXHRcdC8vIENyZWF0ZSBhIHNlZWQgXCJ2aWV3XCI6XG5cdFx0c2VlZCA9IG5ldyBVaW50MzJBcnJheSggU1RBVEUuYnVmZmVyLCBTVEFURS5ieXRlT2Zmc2V0KygoU0VFRF9TRUNUSU9OX09GRlNFVCsxKSpTVEFURS5CWVRFU19QRVJfRUxFTUVOVCksIDEgKTtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIGludGVybmFsIFBSTkcgc3RhdGU6XG5cdFx0c3RhdGUgPSBjcmVhdGVTdGF0ZSggc3RhdGUsIE4sIHNlZWQgKTtcblx0fVxuXHQvLyBOb3RlOiBwcm9wZXJ0eSBvcmRlciBtYXR0ZXJzIGluIG9yZGVyIHRvIG1haW50YWluIGNvbnNpc3RlbmN5IG9mIFBSTkcgXCJzaGFwZVwiIChoaWRkZW4gY2xhc3NlcykuXG5cdHNldFJlYWRPbmx5KCBtdDE5OTM3LCAnTkFNRScsICdtdDE5OTM3JyApO1xuXHRzZXRSZWFkT25seUFjY2Vzc29yKCBtdDE5OTM3LCAnc2VlZCcsIGdldFNlZWQgKTtcblx0c2V0UmVhZE9ubHlBY2Nlc3NvciggbXQxOTkzNywgJ3NlZWRMZW5ndGgnLCBnZXRTZWVkTGVuZ3RoICk7XG5cdHNldFJlYWRXcml0ZUFjY2Vzc29yKCBtdDE5OTM3LCAnc3RhdGUnLCBnZXRTdGF0ZSwgc2V0U3RhdGUgKTtcblx0c2V0UmVhZE9ubHlBY2Nlc3NvciggbXQxOTkzNywgJ3N0YXRlTGVuZ3RoJywgZ2V0U3RhdGVMZW5ndGggKTtcblx0c2V0UmVhZE9ubHlBY2Nlc3NvciggbXQxOTkzNywgJ2J5dGVMZW5ndGgnLCBnZXRTdGF0ZVNpemUgKTtcblx0c2V0UmVhZE9ubHkoIG10MTk5MzcsICd0b0pTT04nLCB0b0pTT04gKTtcblx0c2V0UmVhZE9ubHkoIG10MTk5MzcsICdNSU4nLCAxICk7XG5cdHNldFJlYWRPbmx5KCBtdDE5OTM3LCAnTUFYJywgVUlOVDMyX01BWCApO1xuXHRzZXRSZWFkT25seSggbXQxOTkzNywgJ25vcm1hbGl6ZWQnLCBub3JtYWxpemVkICk7XG5cblx0c2V0UmVhZE9ubHkoIG5vcm1hbGl6ZWQsICdOQU1FJywgbXQxOTkzNy5OQU1FICk7XG5cdHNldFJlYWRPbmx5QWNjZXNzb3IoIG5vcm1hbGl6ZWQsICdzZWVkJywgZ2V0U2VlZCApO1xuXHRzZXRSZWFkT25seUFjY2Vzc29yKCBub3JtYWxpemVkLCAnc2VlZExlbmd0aCcsIGdldFNlZWRMZW5ndGggKTtcblx0c2V0UmVhZFdyaXRlQWNjZXNzb3IoIG5vcm1hbGl6ZWQsICdzdGF0ZScsIGdldFN0YXRlLCBzZXRTdGF0ZSApO1xuXHRzZXRSZWFkT25seUFjY2Vzc29yKCBub3JtYWxpemVkLCAnc3RhdGVMZW5ndGgnLCBnZXRTdGF0ZUxlbmd0aCApO1xuXHRzZXRSZWFkT25seUFjY2Vzc29yKCBub3JtYWxpemVkLCAnYnl0ZUxlbmd0aCcsIGdldFN0YXRlU2l6ZSApO1xuXHRzZXRSZWFkT25seSggbm9ybWFsaXplZCwgJ3RvSlNPTicsIHRvSlNPTiApO1xuXHRzZXRSZWFkT25seSggbm9ybWFsaXplZCwgJ01JTicsIDAuMCApO1xuXHRzZXRSZWFkT25seSggbm9ybWFsaXplZCwgJ01BWCcsIE1BWF9OT1JNQUxJWkVEICk7XG5cblx0cmV0dXJuIG10MTk5Mzc7XG5cblx0LyoqXG5cdCogUmV0dXJucyB0aGUgUFJORyBzZWVkLlxuXHQqXG5cdCogQHByaXZhdGVcblx0KiBAcmV0dXJucyB7UFJOR1NlZWRNVDE5OTM3fSBzZWVkXG5cdCovXG5cdGZ1bmN0aW9uIGdldFNlZWQoKSB7XG5cdFx0dmFyIGxlbiA9IFNUQVRFWyBTRUVEX1NFQ1RJT05fT0ZGU0VUIF07XG5cdFx0cmV0dXJuIGdjb3B5KCBsZW4sIHNlZWQsIDEsIG5ldyBVaW50MzJBcnJheSggbGVuICksIDEgKTtcblx0fVxuXG5cdC8qKlxuXHQqIFJldHVybnMgdGhlIFBSTkcgc2VlZCBsZW5ndGguXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqIEByZXR1cm5zIHtQb3NpdGl2ZUludGVnZXJ9IHNlZWQgbGVuZ3RoXG5cdCovXG5cdGZ1bmN0aW9uIGdldFNlZWRMZW5ndGgoKSB7XG5cdFx0cmV0dXJuIFNUQVRFWyBTRUVEX1NFQ1RJT05fT0ZGU0VUIF07XG5cdH1cblxuXHQvKipcblx0KiBSZXR1cm5zIHRoZSBQUk5HIHN0YXRlIGxlbmd0aC5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCogQHJldHVybnMge1Bvc2l0aXZlSW50ZWdlcn0gc3RhdGUgbGVuZ3RoXG5cdCovXG5cdGZ1bmN0aW9uIGdldFN0YXRlTGVuZ3RoKCkge1xuXHRcdHJldHVybiBTVEFURS5sZW5ndGg7XG5cdH1cblxuXHQvKipcblx0KiBSZXR1cm5zIHRoZSBQUk5HIHN0YXRlIHNpemUgKGluIGJ5dGVzKS5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCogQHJldHVybnMge1Bvc2l0aXZlSW50ZWdlcn0gc3RhdGUgc2l6ZSAoaW4gYnl0ZXMpXG5cdCovXG5cdGZ1bmN0aW9uIGdldFN0YXRlU2l6ZSgpIHtcblx0XHRyZXR1cm4gU1RBVEUuYnl0ZUxlbmd0aDtcblx0fVxuXG5cdC8qKlxuXHQqIFJldHVybnMgdGhlIGN1cnJlbnQgUFJORyBzdGF0ZS5cblx0KlxuXHQqICMjIE5vdGVzXG5cdCpcblx0KiAtICAgVGhlIFBSTkcgc3RhdGUgYXJyYXkgaXMgY29tcHJpc2VkIG9mIGEgcHJlYW1ibGUgZm9sbG93ZWQgYnkgYDNgIHNlY3Rpb25zOlxuXHQqXG5cdCogICAgIDAuICBwcmVhbWJsZSAodmVyc2lvbiArIG51bWJlciBvZiBzZWN0aW9ucylcblx0KiAgICAgMS4gIGludGVybmFsIFBSTkcgc3RhdGVcblx0KiAgICAgMi4gIGF1eGlsaWFyeSBzdGF0ZSBpbmZvcm1hdGlvblxuXHQqICAgICAzLiAgUFJORyBzZWVkXG5cdCpcblx0KiAtICAgVGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIFBSTkcgc3RhdGUgYXJyYXkgcHJlYW1ibGUgaXMgdGhlIHN0YXRlIGFycmF5IHNjaGVtYSB2ZXJzaW9uLlxuXHQqXG5cdCogLSAgIFRoZSBzZWNvbmQgZWxlbWVudCBvZiB0aGUgUFJORyBzdGF0ZSBhcnJheSBwcmVhbWJsZSBpcyB0aGUgbnVtYmVyIG9mIHN0YXRlIGFycmF5IHNlY3Rpb25zIChpLmUuLCBgM2ApLlxuXHQqXG5cdCogLSAgIFRoZSBmaXJzdCBlbGVtZW50IG9mIGVhY2ggc2VjdGlvbiBmb2xsb3dpbmcgdGhlIHByZWFtYmxlIHNwZWNpZmllcyB0aGUgc2VjdGlvbiBsZW5ndGguIFRoZSByZW1haW5pbmcgc2VjdGlvbiBlbGVtZW50cyBjb21wcmlzZSB0aGUgc2VjdGlvbiBjb250ZW50cy5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCogQHJldHVybnMge1BSTkdTdGF0ZU1UMTk5Mzd9IGN1cnJlbnQgc3RhdGVcblx0Ki9cblx0ZnVuY3Rpb24gZ2V0U3RhdGUoKSB7XG5cdFx0dmFyIGxlbiA9IFNUQVRFLmxlbmd0aDtcblx0XHRyZXR1cm4gZ2NvcHkoIGxlbiwgU1RBVEUsIDEsIG5ldyBVaW50MzJBcnJheSggbGVuICksIDEgKTtcblx0fVxuXG5cdC8qKlxuXHQqIFNldHMgdGhlIFBSTkcgc3RhdGUuXG5cdCpcblx0KiAjIyBOb3Rlc1xuXHQqXG5cdCogLSAgIElmIFBSTkcgc3RhdGUgaXMgXCJzaGFyZWRcIiAobWVhbmluZyBhIHN0YXRlIGFycmF5IHdhcyBwcm92aWRlZCBkdXJpbmcgUFJORyBjcmVhdGlvbiBhbmQgKipub3QqKiBjb3BpZWQpIGFuZCBvbmUgc2V0cyB0aGUgZ2VuZXJhdG9yIHN0YXRlIHRvIGEgc3RhdGUgYXJyYXkgaGF2aW5nIGEgZGlmZmVyZW50IGxlbmd0aCwgdGhlIFBSTkcgZG9lcyAqKm5vdCoqIHVwZGF0ZSB0aGUgZXhpc3Rpbmcgc2hhcmVkIHN0YXRlIGFuZCwgaW5zdGVhZCwgcG9pbnRzIHRvIHRoZSBuZXdseSBwcm92aWRlZCBzdGF0ZSBhcnJheS4gSW4gb3JkZXIgdG8gc3luY2hyb25pemUgUFJORyBvdXRwdXQgYWNjb3JkaW5nIHRvIHRoZSBuZXcgc2hhcmVkIHN0YXRlIGFycmF5LCB0aGUgc3RhdGUgYXJyYXkgZm9yICoqZWFjaCoqIHJlbGV2YW50IFBSTkcgbXVzdCBiZSAqKmV4cGxpY2l0bHkqKiBzZXQuXG5cdCogLSAgIElmIFBSTkcgc3RhdGUgaXMgXCJzaGFyZWRcIiBhbmQgb25lIHNldHMgdGhlIGdlbmVyYXRvciBzdGF0ZSB0byBhIHN0YXRlIGFycmF5IG9mIHRoZSBzYW1lIGxlbmd0aCwgdGhlIFBSTkcgc3RhdGUgaXMgdXBkYXRlZCAoYWxvbmcgd2l0aCB0aGUgc3RhdGUgb2YgYWxsIG90aGVyIFBSTkdzIHNoYXJpbmcgdGhlIFBSTkcncyBzdGF0ZSBhcnJheSkuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqIEBwYXJhbSB7UFJOR1N0YXRlTVQxOTkzN30gcyAtIGdlbmVyYXRvciBzdGF0ZVxuXHQqIEB0aHJvd3Mge1R5cGVFcnJvcn0gbXVzdCBwcm92aWRlIGEgYFVpbnQzMkFycmF5YFxuXHQqIEB0aHJvd3Mge0Vycm9yfSBtdXN0IHByb3ZpZGUgYSB2YWxpZCBzdGF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBzZXRTdGF0ZSggcyApIHtcblx0XHR2YXIgZXJyO1xuXHRcdGlmICggIWlzVWludDMyQXJyYXkoIHMgKSApIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdpbnZhbGlkIGFyZ3VtZW50LiBNdXN0IHByb3ZpZGUgYSBVaW50MzJBcnJheS4gVmFsdWU6IGAnICsgcyArICdgLicgKTtcblx0XHR9XG5cdFx0ZXJyID0gdmVyaWZ5U3RhdGUoIHMsIGZhbHNlICk7XG5cdFx0aWYgKCBlcnIgKSB7XG5cdFx0XHR0aHJvdyBlcnI7XG5cdFx0fVxuXHRcdGlmICggb3B0cy5jb3B5ID09PSBmYWxzZSApIHtcblx0XHRcdGlmICggb3B0cy5zdGF0ZSAmJiBzLmxlbmd0aCA9PT0gU1RBVEUubGVuZ3RoICkge1xuXHRcdFx0XHRnY29weSggcy5sZW5ndGgsIHMsIDEsIFNUQVRFLCAxICk7IC8vIHVwZGF0ZSBjdXJyZW50IHNoYXJlZCBzdGF0ZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0U1RBVEUgPSBzOyAvLyBwb2ludCB0byBuZXcgc2hhcmVkIHN0YXRlXG5cdFx0XHRcdG9wdHMuc3RhdGUgPSB0cnVlOyAvLyBzZXR0aW5nIHRoaXMgZmxhZyBhbGxvd3MgdXBkYXRpbmcgYSBzaGFyZWQgc3RhdGUgZXZlbiBpZiBhIHN0YXRlIGFycmF5IHdhcyBub3QgcHJvdmlkZWQgYXQgUFJORyBjcmVhdGlvblxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBDaGVjayBpZiB3ZSBjYW4gcmV1c2UgYWxsb2NhdGVkIG1lbW9yeS4uLlxuXHRcdFx0aWYgKCBzLmxlbmd0aCAhPT0gU1RBVEUubGVuZ3RoICkge1xuXHRcdFx0XHRTVEFURSA9IG5ldyBVaW50MzJBcnJheSggcy5sZW5ndGggKTsgLy8gcmVhbGxvY2F0ZVxuXHRcdFx0fVxuXHRcdFx0Z2NvcHkoIHMubGVuZ3RoLCBzLCAxLCBTVEFURSwgMSApO1xuXHRcdH1cblx0XHQvLyBDcmVhdGUgYSBuZXcgc3RhdGUgXCJ2aWV3XCI6XG5cdFx0c3RhdGUgPSBuZXcgVWludDMyQXJyYXkoIFNUQVRFLmJ1ZmZlciwgU1RBVEUuYnl0ZU9mZnNldCsoKFNUQVRFX1NFQ1RJT05fT0ZGU0VUKzEpKlNUQVRFLkJZVEVTX1BFUl9FTEVNRU5UKSwgTiApO1xuXG5cdFx0Ly8gQ3JlYXRlIGEgbmV3IHNlZWQgXCJ2aWV3XCI6XG5cdFx0c2VlZCA9IG5ldyBVaW50MzJBcnJheSggU1RBVEUuYnVmZmVyLCBTVEFURS5ieXRlT2Zmc2V0KygoU0VFRF9TRUNUSU9OX09GRlNFVCsxKSpTVEFURS5CWVRFU19QRVJfRUxFTUVOVCksIFNUQVRFWyBTRUVEX1NFQ1RJT05fT0ZGU0VUIF0gKTtcblx0fVxuXG5cdC8qKlxuXHQqIFNlcmlhbGl6ZXMgdGhlIHBzZXVkb3JhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIGFzIGEgSlNPTiBvYmplY3QuXG5cdCpcblx0KiAjIyBOb3Rlc1xuXHQqXG5cdCogLSAgIGBKU09OLnN0cmluZ2lmeSgpYCBpbXBsaWNpdGx5IGNhbGxzIHRoaXMgbWV0aG9kIHdoZW4gc3RyaW5naWZ5aW5nIGEgUFJORy5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCogQHJldHVybnMge09iamVjdH0gSlNPTiByZXByZXNlbnRhdGlvblxuXHQqL1xuXHRmdW5jdGlvbiB0b0pTT04oKSB7XG5cdFx0dmFyIG91dCA9IHt9O1xuXHRcdG91dC50eXBlID0gJ1BSTkcnO1xuXHRcdG91dC5uYW1lID0gbXQxOTkzNy5OQU1FO1xuXHRcdG91dC5zdGF0ZSA9IHR5cGVkYXJyYXkyanNvbiggU1RBVEUgKTtcblx0XHRvdXQucGFyYW1zID0gW107XG5cdFx0cmV0dXJuIG91dDtcblx0fVxuXG5cdC8qKlxuXHQqIEdlbmVyYXRlcyBhIHBzZXVkb3JhbmRvbSBpbnRlZ2VyIG9uIHRoZSBpbnRlcnZhbCBcXFxcKCBbMSwyXnszMn0tMSkgXFxcXCkuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqIEByZXR1cm5zIHt1aW50ZWdlcjMyfSBwc2V1ZG9yYW5kb20gaW50ZWdlclxuXHQqXG5cdCogQGV4YW1wbGVcblx0KiB2YXIgciA9IG10MTk5MzcoKTtcblx0KiAvLyByZXR1cm5zIDxudW1iZXI+XG5cdCovXG5cdGZ1bmN0aW9uIG10MTk5MzcoKSB7XG5cdFx0dmFyIHI7XG5cdFx0dmFyIGk7XG5cblx0XHQvLyBSZXRyaWV2ZSB0aGUgY3VycmVudCBzdGF0ZSBpbmRleDpcblx0XHRpID0gU1RBVEVbIE9USEVSX1NFQ1RJT05fT0ZGU0VUKzEgXTtcblxuXHRcdC8vIERldGVybWluZSB3aGV0aGVyIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBQUk5HIHN0YXRlOlxuXHRcdGlmICggaSA+PSBOICkge1xuXHRcdFx0c3RhdGUgPSB0d2lzdCggc3RhdGUgKTtcblx0XHRcdGkgPSAwO1xuXHRcdH1cblx0XHQvLyBHZXQgdGhlIG5leHQgd29yZCBvZiBcInJhd1wiL3VudGVtcGVyZWQgc3RhdGU6XG5cdFx0ciA9IHN0YXRlWyBpIF07XG5cblx0XHQvLyBVcGRhdGUgdGhlIHN0YXRlIGluZGV4OlxuXHRcdFNUQVRFWyBPVEhFUl9TRUNUSU9OX09GRlNFVCsxIF0gPSBpICsgMTtcblxuXHRcdC8vIFRlbXBlcmluZyB0cmFuc2Zvcm0gdG8gY29tcGVuc2F0ZSBmb3IgdGhlIHJlZHVjZWQgZGltZW5zaW9uYWxpdHkgb2YgZXF1aWRpc3RyaWJ1dGlvbjpcblx0XHRyIF49IHIgPj4+IDExO1xuXHRcdHIgXj0gKCByIDw8IDcgKSAmIFRFTVBFUklOR19DT0VGRklDSUVOVF8xO1xuXHRcdHIgXj0gKCByIDw8IDE1ICkgJiBURU1QRVJJTkdfQ09FRkZJQ0lFTlRfMjtcblx0XHRyIF49IHIgPj4+IDE4O1xuXG5cdFx0cmV0dXJuIHIgPj4+IDA7XG5cdH1cblxuXHQvKipcblx0KiBHZW5lcmF0ZXMgYSBwc2V1ZG9yYW5kb20gbnVtYmVyIG9uIHRoZSBpbnRlcnZhbCBcXFxcKCBbMCwxKSBcXFxcKS5cblx0KlxuXHQqICMjIE5vdGVzXG5cdCpcblx0KiAtICAgVGhlIG9yaWdpbmFsIEMgaW1wbGVtZW50YXRpb24gY3JlZGl0cyBJc2FrdSBXYWRhIGZvciB0aGlzIGFsZ29yaXRobSAoMjAwMi8wMS8wOSkuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqIEByZXR1cm5zIHtudW1iZXJ9IHBzZXVkb3JhbmRvbSBudW1iZXJcblx0KlxuXHQqIEBleGFtcGxlXG5cdCogdmFyIHIgPSBub3JtYWxpemVkKCk7XG5cdCogLy8gcmV0dXJucyA8bnVtYmVyPlxuXHQqL1xuXHRmdW5jdGlvbiBub3JtYWxpemVkKCkge1xuXHRcdHZhciB4ID0gbXQxOTkzNygpID4+PiA1O1xuXHRcdHZhciB5ID0gbXQxOTkzNygpID4+PiA2O1xuXHRcdHJldHVybiAoICh4KlRXT18yNikreSApICogRkxPQVQ2NF9OT1JNQUxJWkFUSU9OX0NPTlNUQU5UO1xuXHR9XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZhY3Rvcnk7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgZmFjdG9yeSA9IHJlcXVpcmUoICcuL2ZhY3RvcnkuanMnICk7XG52YXIgcmFuZHVpbnQzMiA9IHJlcXVpcmUoICcuL3JhbmRfdWludDMyLmpzJyApO1xuXG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIEdlbmVyYXRlcyBhIHBzZXVkb3JhbmRvbSBpbnRlZ2VyIG9uIHRoZSBpbnRlcnZhbCBcXFxcKCBbMSwyXnszMn0tMSkgXFxcXCkuXG4qXG4qICMjIE1ldGhvZFxuKlxuKiAtICAgV2hlbiBnZW5lcmF0aW5nIG5vcm1hbGl6ZWQgZG91YmxlLXByZWNpc2lvbiBmbG9hdGluZy1wb2ludCBudW1iZXJzLCB3ZSBmaXJzdCBnZW5lcmF0ZSB0d28gcHNldWRvcmFuZG9tIGludGVnZXJzIFxcXFwoIHggXFxcXCkgYW5kIFxcXFwoIHkgXFxcXCkgb24gdGhlIGludGVydmFsIFxcXFwoIFsxLDJeezMyfS0xKSBcXFxcKSBmb3IgYSBjb21iaW5lZCBcXFxcKCA2NCBcXFxcKSByYW5kb20gYml0cy5cbipcbiogLSAgIFdlIHdvdWxkIGxpa2UgXFxcXCggNTMgXFxcXCkgcmFuZG9tIGJpdHMgdG8gZ2VuZXJhdGUgYSA1My1iaXQgcHJlY2lzaW9uIGludGVnZXIgYW5kLCB0aHVzLCB3YW50IHRvIGRpc2NhcmQgXFxcXCggMTEgXFxcXCkgb2YgdGhlIGdlbmVyYXRlZCBiaXRzLlxuKlxuKiAtICAgV2UgZG8gc28gYnkgZGlzY2FyZGluZyBcXFxcKCA1IFxcXFwpIGJpdHMgZnJvbSBcXFxcKCB4IFxcXFwpIGFuZCBcXFxcKCA2IFxcXFwpIGJpdHMgZnJvbSBcXFxcKCB5IFxcXFwpLlxuKlxuKiAtICAgQWNjb3JkaW5nbHksIFxcXFwoIHggXFxcXCkgY29udGFpbnMgXFxcXCggMjcgXFxcXCkgcmFuZG9tIGJpdHMsIHdoaWNoIGFyZSBzdWJzZXF1ZW50bHkgc2hpZnRlZCBsZWZ0IFxcXFwoIDI2IFxcXFwpIGJpdHMgKG11bHRpcGxpZWQgYnkgXFxcXCggMl57MjZ9IFxcXFwpLCBhbmQgXFxcXCggeSBcXFxcKSBjb250YWlucyBcXFxcKCAyNiBcXFxcKSByYW5kb20gYml0cyB0byBmaWxsIGluIHRoZSBsb3dlciBcXFxcKCAyNiBcXFxcKSBiaXRzLiBXaGVuIHN1bW1lZCwgdGhleSBjb21iaW5lIHRvIGNvbXByaXNlIFxcXFwoIDUzIFxcXFwpIHJhbmRvbSBiaXRzIG9mIGEgZG91YmxlLXByZWNpc2lvbiBmbG9hdGluZy1wb2ludCBpbnRlZ2VyLlxuKlxuKiAtICAgQXMgYW4gZXhhbXBsZSwgc3VwcG9zZSwgZm9yIHRoZSBzYWtlIG9mIGFyZ3VtZW50LCB0aGUgMzItYml0IFBSTkcgZ2VuZXJhdGVzIHRoZSBtYXhpbXVtIHVuc2lnbmVkIDMyLWJpdCBpbnRlZ2VyIFxcXFwoIDJeezMyfS0xIFxcXFwpIHR3aWNlIGluIGEgcm93LiBUaGVuLFxuKlxuKiAgICAgYGBgamF2YXNjcmlwdFxuKiAgICAgeCA9IDQyOTQ5NjcyOTUgPj4+IDU7IC8vIDAwMDAwMTExMTExMTExMTExMTExMTExMTExMTExMTExXG4qICAgICB5ID0gNDI5NDk2NzI5NSA+Pj4gNjsgLy8gMDAwMDAwMTExMTExMTExMTExMTExMTExMTExMTExMTFcbiogICAgIGBgYFxuKlxuKiAgICAgTXVsdGlwbHlpbmcgXFxcXCggeCBcXFxcKSBieSBcXFxcKCAyXnsyNn0gXFxcXCkgcmV0dXJucyBcXFxcKCA5MDA3MTk5MTg3NjMyMTI4IFxcXFwpLCB3aGljaCwgaW4gYmluYXJ5LCBpc1xuKlxuKiAgICAgYGBgYmluYXJ5c3RyaW5nXG4qICAgICAwIDEwMDAwMTEwMDExIDExMTExMTExMTExMTExMTExMTExIDExMTExMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXG4qICAgICBgYGBcbipcbiogICAgIEFkZGluZyBcXFxcKCB5IFxcXFwpIHlpZWxkcyBcXFxcKCA5MDA3MTk5MjU0NzQwOTkxIFxcXFwpICh0aGUgbWF4aW11bSBcInNhZmVcIiBkb3VibGUtcHJlY2lzaW9uIGZsb2F0aW5nLXBvaW50IGludGVnZXIgdmFsdWUpLCB3aGljaCwgaW4gYmluYXJ5LCBpc1xuKlxuKiAgICAgYGBgYmluYXJ5c3RyaW5nXG4qICAgICAwIDEwMDAwMTEwMDExIDExMTExMTExMTExMTExMTExMTExIDExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExXG4qICAgICBgYGBcbipcbiogLSAgIFNpbWlsYXJseSwgc3VwcG9zZSB0aGUgMzItYml0IFBSTkcgZ2VuZXJhdGVzIHRoZSBmb2xsb3dpbmcgdmFsdWVzXG4qXG4qICAgICBgYGBqYXZhc2NyaXB0XG4qICAgICB4ID0gMSA+Pj4gNTsgIC8vIDAgPT4gMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcbiogICAgIHkgPSA2NCA+Pj4gNjsgLy8gMSA9PiAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMVxuKiAgICAgYGBgXG4qXG4qICAgICBNdWx0aXBseWluZyBcXFxcKCB4IFxcXFwpIGJ5IFxcXFwoIDJeezI2fSBcXFxcKSByZXR1cm5zIFxcXFwoIDAgXFxcXCksIHdoaWNoLCBpbiBiaW5hcnksIGlzXG4qXG4qICAgICBgYGBiaW5hcnlzdHJpbmdcbiogICAgIDAgMDAwMDAwMDAwMDAgMDAwMDAwMDAwMDAwMDAwMDAwMDAgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcbiogICAgIGBgYFxuKlxuKiAgICAgQWRkaW5nIFxcXFwoIHkgXFxcXCkgeWllbGRzIFxcXFwoIDEgXFxcXCksIHdoaWNoLCBpbiBiaW5hcnksIGlzXG4qXG4qICAgICBgYGBiaW5hcnlzdHJpbmdcbiogICAgIDAgMDExMTExMTExMTEgMDAwMDAwMDAwMDAwMDAwMDAwMDAgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcbiogICAgIGBgYFxuKlxuKiAtICAgQXMgZGlmZmVyZW50IGNvbWJpbmF0aW9ucyBvZiBcXFxcKCB4IFxcXFwpIGFuZCBcXFxcKCB5IFxcXFwpIGFyZSBnZW5lcmF0ZWQsIGRpZmZlcmVudCBjb21iaW5hdGlvbnMgb2YgZG91YmxlLXByZWNpc2lvbiBmbG9hdGluZy1wb2ludCBleHBvbmVudCBhbmQgc2lnbmlmaWNhbmQgYml0cyB3aWxsIGJlIHRvZ2dsZWQsIHRodXMgZ2VuZXJhdGluZyBwc2V1ZG9yYW5kb20gZG91YmxlLXByZWNpc2lvbiBmbG9hdGluZy1wb2ludCBudW1iZXJzLlxuKlxuKlxuKiAjIyBSZWZlcmVuY2VzXG4qXG4qIC0gICBNYXRzdW1vdG8sIE1ha290bywgYW5kIFRha3VqaSBOaXNoaW11cmEuIDE5OTguIFwiTWVyc2VubmUgVHdpc3RlcjogQSA2MjMtZGltZW5zaW9uYWxseSBFcXVpZGlzdHJpYnV0ZWQgVW5pZm9ybSBQc2V1ZG8tcmFuZG9tIE51bWJlciBHZW5lcmF0b3IuXCIgX0FDTSBUcmFuc2FjdGlvbnMgb24gTW9kZWxpbmcgYW5kIENvbXB1dGVyIFNpbXVsYXRpb25fIDggKDEpLiBOZXcgWW9yaywgTlksIFVTQTogQUNNOiAzXHUyMDEzMzAuIGRvaTpbMTAuMTE0NS8yNzI5OTEuMjcyOTk1XVtAbWF0c3Vtb3RvOjE5OThhXS5cbiogLSAgIEhhcmFzZSwgU2hpbi4gMjAxNy4gXCJDb252ZXJzaW9uIG9mIE1lcnNlbm5lIFR3aXN0ZXIgdG8gZG91YmxlLXByZWNpc2lvbiBmbG9hdGluZy1wb2ludCBudW1iZXJzLlwiIF9Bclhpdl8gYWJzLzE3MDguMDYwMTggKFNlcHRlbWJlcikuIDxodHRwczovL2FyeGl2Lm9yZy9hYnMvMTcwOC4wNjAxOD4uXG4qXG4qIFtAbWF0c3Vtb3RvOjE5OThhXTogaHR0cHM6Ly9kb2kub3JnLzEwLjExNDUvMjcyOTkxLjI3Mjk5NVxuKlxuKlxuKiBAZnVuY3Rpb24gbXQxOTkzN1xuKiBAdHlwZSB7UFJOR31cbiogQHJldHVybnMge1Bvc2l0aXZlSW50ZWdlcn0gcHNldWRvcmFuZG9tIGludGVnZXJcbipcbiogQGV4YW1wbGVcbiogdmFyIHYgPSBtdDE5OTM3KCk7XG4qIC8vIHJldHVybnMgPG51bWJlcj5cbiovXG52YXIgbXQxOTkzNyA9IGZhY3Rvcnkoe1xuXHQnc2VlZCc6IHJhbmR1aW50MzIoKVxufSk7XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IG10MTk5Mzc7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIEEgMzItYml0IE1lcnNlbm5lIFR3aXN0ZXIgcHNldWRvcmFuZG9tIG51bWJlciBnZW5lcmF0b3IuXG4qXG4qIEBtb2R1bGUgQHN0ZGxpYi9yYW5kb20tYmFzZS1tdDE5OTM3XG4qXG4qIEBleGFtcGxlXG4qIHZhciBtdDE5OTM3ID0gcmVxdWlyZSggJ0BzdGRsaWIvcmFuZG9tLWJhc2UtbXQxOTkzNycgKTtcbipcbiogdmFyIHYgPSBtdDE5OTM3KCk7XG4qIC8vIHJldHVybnMgPG51bWJlcj5cbipcbiogQGV4YW1wbGVcbiogdmFyIGZhY3RvcnkgPSByZXF1aXJlKCAnQHN0ZGxpYi9yYW5kb20tYmFzZS1tdDE5OTM3JyApLmZhY3Rvcnk7XG4qXG4qIHZhciBtdDE5OTM3ID0gZmFjdG9yeSh7XG4qICAgICAnc2VlZCc6IDEyMzRcbiogfSk7XG4qXG4qIHZhciB2ID0gbXQxOTkzNygpO1xuKiAvLyByZXR1cm5zIDgyMjU2OTc3NVxuKi9cblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgc2V0UmVhZE9ubHkgPSByZXF1aXJlKCAnQHN0ZGxpYi91dGlscy1kZWZpbmUtbm9uZW51bWVyYWJsZS1yZWFkLW9ubHktcHJvcGVydHknICk7XG52YXIgbXQxOTkzNyA9IHJlcXVpcmUoICcuL21haW4uanMnICk7XG52YXIgZmFjdG9yeSA9IHJlcXVpcmUoICcuL2ZhY3RvcnkuanMnICk7XG5cblxuLy8gTUFJTiAvL1xuXG5zZXRSZWFkT25seSggbXQxOTkzNywgJ2ZhY3RvcnknLCBmYWN0b3J5ICk7XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IG10MTk5Mzc7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTUFJTiAvL1xuXG52YXIgcHJuZ3MgPSB7fTtcblxucHJuZ3NbICdtaW5zdGQnIF0gPSByZXF1aXJlKCAnQHN0ZGxpYi9yYW5kb20tYmFzZS1taW5zdGQnICk7XG5wcm5nc1sgJ21pbnN0ZC1zaHVmZmxlJyBdID0gcmVxdWlyZSggJ0BzdGRsaWIvcmFuZG9tLWJhc2UtbWluc3RkLXNodWZmbGUnICk7XG5wcm5nc1sgJ210MTk5MzcnIF0gPSByZXF1aXJlKCAnQHN0ZGxpYi9yYW5kb20tYmFzZS1tdDE5OTM3JyApO1xuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBwcm5ncztcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBzZXRSZWFkT25seSA9IHJlcXVpcmUoICdAc3RkbGliL3V0aWxzLWRlZmluZS1ub25lbnVtZXJhYmxlLXJlYWQtb25seS1wcm9wZXJ0eScgKTtcbnZhciBzZXRSZWFkT25seUFjY2Vzc29yID0gcmVxdWlyZSggJ0BzdGRsaWIvdXRpbHMtZGVmaW5lLW5vbmVudW1lcmFibGUtcmVhZC1vbmx5LWFjY2Vzc29yJyApO1xudmFyIHNldFJlYWRXcml0ZUFjY2Vzc29yID0gcmVxdWlyZSggJ0BzdGRsaWIvdXRpbHMtZGVmaW5lLW5vbmVudW1lcmFibGUtcmVhZC13cml0ZS1hY2Nlc3NvcicgKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoICdAc3RkbGliL2Fzc2VydC1pcy1wbGFpbi1vYmplY3QnICk7XG52YXIgaXNCb29sZWFuID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLWJvb2xlYW4nICkuaXNQcmltaXRpdmU7XG52YXIgaGFzT3duUHJvcCA9IHJlcXVpcmUoICdAc3RkbGliL2Fzc2VydC1oYXMtb3duLXByb3BlcnR5JyApO1xudmFyIHR5cGVkYXJyYXkyanNvbiA9IHJlcXVpcmUoICdAc3RkbGliL2FycmF5LXRvLWpzb24nICk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCAnLi9kZWZhdWx0cy5qc29uJyApO1xudmFyIFBSTkdTID0gcmVxdWlyZSggJy4vcHJuZ3MuanMnICk7XG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogUmV0dXJucyBhIHBzZXVkb3JhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIGZvciBnZW5lcmF0aW5nIHVuaWZvcm1seSBkaXN0cmlidXRlZCByYW5kb20gbnVtYmVycyBvbiB0aGUgaW50ZXJ2YWwgXFxcXCggWzAsMSkgXFxcXCkuXG4qXG4qIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIC0gZnVuY3Rpb24gb3B0aW9uc1xuKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubmFtZT0nbXQxOTkzNyddIC0gbmFtZSBvZiBwc2V1ZG9yYW5kb20gbnVtYmVyIGdlbmVyYXRvclxuKiBAcGFyYW0geyp9IFtvcHRpb25zLnNlZWRdIC0gcHNldWRvcmFuZG9tIG51bWJlciBnZW5lcmF0b3Igc2VlZFxuKiBAcGFyYW0geyp9IFtvcHRpb25zLnN0YXRlXSAtIHBzZXVkb3JhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIHN0YXRlXG4qIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY29weT10cnVlXSAtIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRvIGNvcHkgYSBwcm92aWRlZCBwc2V1ZG9yYW5kb20gbnVtYmVyIGdlbmVyYXRvciBzdGF0ZVxuKiBAdGhyb3dzIHtUeXBlRXJyb3J9IG11c3QgcHJvdmlkZSBhbiBvYmplY3RcbiogQHRocm93cyB7VHlwZUVycm9yfSBtdXN0IHByb3ZpZGUgdmFsaWQgb3B0aW9uc1xuKiBAdGhyb3dzIHtFcnJvcn0gbXVzdCBwcm92aWRlIHRoZSBuYW1lIG9mIGEgc3VwcG9ydGVkIHBzZXVkb3JhbmRvbSBudW1iZXIgZ2VuZXJhdG9yXG4qIEByZXR1cm5zIHtQUk5HfSBwc2V1ZG9yYW5kb20gbnVtYmVyIGdlbmVyYXRvclxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgdW5pZm9ybSA9IGZhY3RvcnkoKTtcbiogdmFyIHYgPSB1bmlmb3JtKCk7XG4qIC8vIHJldHVybnMgPG51bWJlcj5cbipcbiogQGV4YW1wbGVcbiogdmFyIHVuaWZvcm0gPSBmYWN0b3J5KHtcbiogICAgICduYW1lJzogJ21pbnN0ZCdcbiogfSk7XG4qIHZhciB2ID0gdW5pZm9ybSgpO1xuKiAvLyByZXR1cm5zIDxudW1iZXI+XG4qXG4qIEBleGFtcGxlXG4qIHZhciB1bmlmb3JtID0gZmFjdG9yeSh7XG4qICAgICAnc2VlZCc6IDEyMzQ1XG4qIH0pO1xuKiB2YXIgdiA9IHVuaWZvcm0oKTtcbiogLy8gcmV0dXJucyA8bnVtYmVyPlxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgdW5pZm9ybSA9IGZhY3Rvcnkoe1xuKiAgICAgJ25hbWUnOiAnbWluc3RkJyxcbiogICAgICdzZWVkJzogMTIzNDVcbiogfSk7XG4qIHZhciB2ID0gdW5pZm9ybSgpO1xuKiAvLyByZXR1cm5zIDxudW1iZXI+XG4qL1xuZnVuY3Rpb24gZmFjdG9yeSggb3B0aW9ucyApIHtcblx0dmFyIG9wdHM7XG5cdHZhciByYW5kO1xuXHR2YXIgcHJuZztcblxuXHRvcHRzID0ge1xuXHRcdCduYW1lJzogZGVmYXVsdHMubmFtZSxcblx0XHQnY29weSc6IGRlZmF1bHRzLmNvcHlcblx0fTtcblx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdGlmICggIWlzT2JqZWN0KCBvcHRpb25zICkgKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnaW52YWxpZCBhcmd1bWVudC4gTXVzdCBwcm92aWRlIGFuIG9iamVjdC4gVmFsdWU6IGAnICsgb3B0aW9ucyArICdgLicgKTtcblx0XHR9XG5cdFx0aWYgKCBoYXNPd25Qcm9wKCBvcHRpb25zLCAnbmFtZScgKSApIHtcblx0XHRcdG9wdHMubmFtZSA9IG9wdGlvbnMubmFtZTtcblx0XHR9XG5cdFx0aWYgKCBoYXNPd25Qcm9wKCBvcHRpb25zLCAnc3RhdGUnICkgKSB7XG5cdFx0XHRvcHRzLnN0YXRlID0gb3B0aW9ucy5zdGF0ZTtcblx0XHRcdGlmICggb3B0cy5zdGF0ZSA9PT0gdm9pZCAwICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnaW52YWxpZCBvcHRpb24uIGBzdGF0ZWAgb3B0aW9uIGNhbm5vdCBiZSB1bmRlZmluZWQuIE9wdGlvbjogYCcgKyBvcHRzLnN0YXRlICsgJ2AuJyApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoIGhhc093blByb3AoIG9wdGlvbnMsICdzZWVkJyApICkge1xuXHRcdFx0b3B0cy5zZWVkID0gb3B0aW9ucy5zZWVkO1xuXHRcdFx0aWYgKCBvcHRzLnNlZWQgPT09IHZvaWQgMCApIHtcblx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ2ludmFsaWQgb3B0aW9uLiBgc2VlZGAgb3B0aW9uIGNhbm5vdCBiZSB1bmRlZmluZWQuIE9wdGlvbjogYCcgKyBvcHRzLnNlZWQgKyAnYC4nICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICggaGFzT3duUHJvcCggb3B0aW9ucywgJ2NvcHknICkgKSB7XG5cdFx0XHRvcHRzLmNvcHkgPSBvcHRpb25zLmNvcHk7XG5cdFx0XHRpZiAoICFpc0Jvb2xlYW4oIG9wdHMuY29weSApICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnaW52YWxpZCBvcHRpb24uIGBjb3B5YCBvcHRpb24gbXVzdCBiZSBhIGJvb2xlYW4uIE9wdGlvbjogYCcgKyBvcHRzLmNvcHkgKyAnYC4nICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHBybmcgPSBQUk5HU1sgb3B0cy5uYW1lIF07XG5cdGlmICggcHJuZyA9PT0gdm9pZCAwICkge1xuXHRcdHRocm93IG5ldyBFcnJvciggJ2ludmFsaWQgb3B0aW9uLiBVbnJlY29nbml6ZWQvdW5zdXBwb3J0ZWQgUFJORy4gT3B0aW9uOiBgJyArIG9wdHMubmFtZSArICdgLicgKTtcblx0fVxuXHRpZiAoIG9wdHMuc3RhdGUgPT09IHZvaWQgMCApIHtcblx0XHRpZiAoIG9wdHMuc2VlZCA9PT0gdm9pZCAwICkge1xuXHRcdFx0cmFuZCA9IHBybmcuZmFjdG9yeSgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyYW5kID0gcHJuZy5mYWN0b3J5KHtcblx0XHRcdFx0J3NlZWQnOiBvcHRzLnNlZWRcblx0XHRcdH0pO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRyYW5kID0gcHJuZy5mYWN0b3J5KHtcblx0XHRcdCdzdGF0ZSc6IG9wdHMuc3RhdGUsXG5cdFx0XHQnY29weSc6IG9wdHMuY29weVxuXHRcdH0pO1xuXHR9XG5cdHNldFJlYWRPbmx5KCB1bmlmb3JtLCAnTkFNRScsICdyYW5kdScgKTtcblx0c2V0UmVhZE9ubHlBY2Nlc3NvciggdW5pZm9ybSwgJ3NlZWQnLCBnZXRTZWVkICk7XG5cdHNldFJlYWRPbmx5QWNjZXNzb3IoIHVuaWZvcm0sICdzZWVkTGVuZ3RoJywgZ2V0U2VlZExlbmd0aCApO1xuXHRzZXRSZWFkV3JpdGVBY2Nlc3NvciggdW5pZm9ybSwgJ3N0YXRlJywgZ2V0U3RhdGUsIHNldFN0YXRlICk7XG5cdHNldFJlYWRPbmx5QWNjZXNzb3IoIHVuaWZvcm0sICdzdGF0ZUxlbmd0aCcsIGdldFN0YXRlTGVuZ3RoICk7XG5cdHNldFJlYWRPbmx5QWNjZXNzb3IoIHVuaWZvcm0sICdieXRlTGVuZ3RoJywgZ2V0U3RhdGVTaXplICk7XG5cdHNldFJlYWRPbmx5KCB1bmlmb3JtLCAndG9KU09OJywgdG9KU09OICk7XG5cdHNldFJlYWRPbmx5KCB1bmlmb3JtLCAnUFJORycsIHJhbmQgKTtcblx0c2V0UmVhZE9ubHkoIHVuaWZvcm0sICdNSU4nLCByYW5kLm5vcm1hbGl6ZWQuTUlOICk7XG5cdHNldFJlYWRPbmx5KCB1bmlmb3JtLCAnTUFYJywgcmFuZC5ub3JtYWxpemVkLk1BWCApO1xuXG5cdHJldHVybiB1bmlmb3JtO1xuXG5cdC8qKlxuXHQqIFJldHVybnMgdGhlIFBSTkcgc2VlZC5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCogQHJldHVybnMgeyp9IHNlZWRcblx0Ki9cblx0ZnVuY3Rpb24gZ2V0U2VlZCgpIHtcblx0XHRyZXR1cm4gcmFuZC5zZWVkO1xuXHR9XG5cblx0LyoqXG5cdCogUmV0dXJucyB0aGUgUFJORyBzZWVkIGxlbmd0aC5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCogQHJldHVybnMge1Bvc2l0aXZlSW50ZWdlcn0gc2VlZCBsZW5ndGhcblx0Ki9cblx0ZnVuY3Rpb24gZ2V0U2VlZExlbmd0aCgpIHtcblx0XHRyZXR1cm4gcmFuZC5zZWVkTGVuZ3RoO1xuXHR9XG5cblx0LyoqXG5cdCogUmV0dXJucyB0aGUgUFJORyBzdGF0ZSBsZW5ndGguXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqIEByZXR1cm5zIHtQb3NpdGl2ZUludGVnZXJ9IHN0YXRlIGxlbmd0aFxuXHQqL1xuXHRmdW5jdGlvbiBnZXRTdGF0ZUxlbmd0aCgpIHtcblx0XHRyZXR1cm4gcmFuZC5zdGF0ZUxlbmd0aDtcblx0fVxuXG5cdC8qKlxuXHQqIFJldHVybnMgdGhlIFBSTkcgc3RhdGUgc2l6ZSAoaW4gYnl0ZXMpLlxuXHQqXG5cdCogQHByaXZhdGVcblx0KiBAcmV0dXJucyB7UG9zaXRpdmVJbnRlZ2VyfSBzdGF0ZSBzaXplIChpbiBieXRlcylcblx0Ki9cblx0ZnVuY3Rpb24gZ2V0U3RhdGVTaXplKCkge1xuXHRcdHJldHVybiByYW5kLmJ5dGVMZW5ndGg7XG5cdH1cblxuXHQvKipcblx0KiBSZXR1cm5zIHRoZSBjdXJyZW50IHBzZXVkb3JhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIHN0YXRlLlxuXHQqXG5cdCogQHByaXZhdGVcblx0KiBAcmV0dXJucyB7Kn0gY3VycmVudCBzdGF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBnZXRTdGF0ZSgpIHtcblx0XHRyZXR1cm4gcmFuZC5zdGF0ZTtcblx0fVxuXG5cdC8qKlxuXHQqIFNldHMgdGhlIHBzZXVkb3JhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIHN0YXRlLlxuXHQqXG5cdCogQHByaXZhdGVcblx0KiBAcGFyYW0geyp9IHMgLSBnZW5lcmF0b3Igc3RhdGVcblx0KiBAdGhyb3dzIHtFcnJvcn0gbXVzdCBwcm92aWRlIGEgdmFsaWQgc3RhdGVcblx0Ki9cblx0ZnVuY3Rpb24gc2V0U3RhdGUoIHMgKSB7XG5cdFx0cmFuZC5zdGF0ZSA9IHM7XG5cdH1cblxuXHQvKipcblx0KiBTZXJpYWxpemVzIHRoZSBwc2V1ZG9yYW5kb20gbnVtYmVyIGdlbmVyYXRvciBhcyBhIEpTT04gb2JqZWN0LlxuXHQqXG5cdCogIyMgTm90ZXNcblx0KlxuXHQqIC0gICBgSlNPTi5zdHJpbmdpZnkoKWAgaW1wbGljaXRseSBjYWxscyB0aGlzIG1ldGhvZCB3aGVuIHN0cmluZ2lmeWluZyBhIFBSTkcuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqIEByZXR1cm5zIHtPYmplY3R9IEpTT04gcmVwcmVzZW50YXRpb25cblx0Ki9cblx0ZnVuY3Rpb24gdG9KU09OKCkge1xuXHRcdHZhciBvdXQgPSB7fTtcblx0XHRvdXQudHlwZSA9ICdQUk5HJztcblx0XHRvdXQubmFtZSA9IHVuaWZvcm0uTkFNRSArICctJyArIHJhbmQuTkFNRTtcblx0XHRvdXQuc3RhdGUgPSB0eXBlZGFycmF5Mmpzb24oIHJhbmQuc3RhdGUgKTtcblx0XHRvdXQucGFyYW1zID0gW107XG5cdFx0cmV0dXJuIG91dDtcblx0fVxuXG5cdC8qKlxuXHQqIFJldHVybnMgYSB1bmlmb3JtbHkgZGlzdHJpYnV0ZWQgcHNldWRvcmFuZG9tIG51bWJlciBvbiB0aGUgaW50ZXJ2YWwgXFxcXCggWzAsMSkgXFxcXCkuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqIEByZXR1cm5zIHtudW1iZXJ9IHBzZXVkb3JhbmRvbSBudW1iZXJcblx0KlxuXHQqIEBleGFtcGxlXG5cdCogdmFyIHYgPSB1bmlmb3JtKCk7XG5cdCogLy8gcmV0dXJucyA8bnVtYmVyPlxuXHQqL1xuXHRmdW5jdGlvbiB1bmlmb3JtKCkge1xuXHRcdHJldHVybiByYW5kLm5vcm1hbGl6ZWQoKTtcblx0fVxufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5O1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGZhY3RvcnkgPSByZXF1aXJlKCAnLi9mYWN0b3J5LmpzJyApO1xuXG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIFJldHVybnMgYSB1bmlmb3JtbHkgZGlzdHJpYnV0ZWQgcmFuZG9tIG51bWJlciBvbiB0aGUgaW50ZXJ2YWwgXFxcXCggWzAsMSkgXFxcXCkuXG4qXG4qIEBuYW1lIHJhbmR1XG4qIEB0eXBlIHtQUk5HfVxuKiBAcmV0dXJucyB7bnVtYmVyfSBwc2V1ZG9yYW5kb20gbnVtYmVyXG4qXG4qIEBleGFtcGxlXG4qIHZhciB2ID0gcmFuZHUoKTtcbiogLy8gcmV0dXJucyA8bnVtYmVyPlxuKi9cbnZhciByYW5kdSA9IGZhY3RvcnkoKTtcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gcmFuZHU7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIFVuaWZvcm1seSBkaXN0cmlidXRlZCBwc2V1ZG9yYW5kb20gbnVtYmVycyBvbiB0aGUgaW50ZXJ2YWwgXFxcXCggWzAsMSkgXFxcXCkuXG4qXG4qIEBtb2R1bGUgQHN0ZGxpYi9yYW5kb20tYmFzZS1yYW5kdVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgcmFuZHUgPSByZXF1aXJlKCAnQHN0ZGxpYi9yYW5kb20tYmFzZS1yYW5kdScgKTtcbipcbiogdmFyIHYgPSByYW5kdSgpO1xuKiAvLyByZXR1cm5zIDxudW1iZXI+XG4qXG4qIEBleGFtcGxlXG4qIHZhciBmYWN0b3J5ID0gcmVxdWlyZSggJ0BzdGRsaWIvcmFuZG9tLWJhc2UtcmFuZHUnICkuZmFjdG9yeTtcbipcbiogdmFyIHJhbmR1ID0gZmFjdG9yeSh7XG4qICAgICAnbmFtZSc6ICdtaW5zdGQnLFxuKiAgICAgJ3NlZWQnOiAxMjM0NVxuKiB9KTtcbipcbiogdmFyIHYgPSByYW5kdSgpO1xuKiAvLyByZXR1cm5zIDxudW1iZXI+XG4qL1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBzZXRSZWFkT25seSA9IHJlcXVpcmUoICdAc3RkbGliL3V0aWxzLWRlZmluZS1ub25lbnVtZXJhYmxlLXJlYWQtb25seS1wcm9wZXJ0eScgKTtcbnZhciByYW5kdSA9IHJlcXVpcmUoICcuL21haW4uanMnICk7XG52YXIgZmFjdG9yeSA9IHJlcXVpcmUoICcuL2ZhY3RvcnkuanMnICk7XG5cblxuLy8gTUFJTiAvL1xuXG5zZXRSZWFkT25seSggcmFuZHUsICdmYWN0b3J5JywgZmFjdG9yeSApO1xuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSByYW5kdTtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciByYW5kdSA9IHJlcXVpcmUoICdAc3RkbGliL3JhbmRvbS1iYXNlLXJhbmR1JyApO1xudmFyIGZsb29yID0gcmVxdWlyZSggJ0BzdGRsaWIvbWF0aC1iYXNlLXNwZWNpYWwtZmxvb3InICk7XG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogUmFuZG9tbHkgYXNzaWduIHRvcGljcyB0byB3b3JkcyBhbmQga2VlcCB0cmFjayBvZiB0aGUgY291bnRzLlxuKlxuKiBAcHJpdmF0ZVxuKi9cbmZ1bmN0aW9uIGluaXQoKSB7XG5cdC8qIGVzbGludC1kaXNhYmxlIG5vLWludmFsaWQtdGhpcyAqL1xuXHR2YXIgdG9waWM7XG5cdHZhciBuZXd6O1xuXHR2YXIgbGVuO1xuXHR2YXIgd3Q7XG5cdHZhciBkO1xuXHR2YXIgaTtcblxuXHR0aGlzLnogPSBbXTtcblx0Zm9yICggZCA9IDA7IGQgPCB0aGlzLkQ7IGQrKyApIHtcblx0XHR0aGlzLnoucHVzaCggW10gKTtcblx0XHRsZW4gPSB0aGlzLndbIGQgXS5sZW5ndGg7XG5cblx0XHQvLyBJbml0aWFsaXplIHJhbmRvbSB0b3BpY3MuLi5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0bmV3eiA9IGZsb29yKCByYW5kdSgpICogdGhpcy5LICk7XG5cdFx0XHR0aGlzLnpbIGQgXS5wdXNoKCBuZXd6ICk7XG5cdFx0fVxuXHRcdHRoaXMubmRTdW1bIGQgXSA9IGxlbjtcblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0d3QgPSB0aGlzLndbIGQgXVsgaSBdO1xuXHRcdFx0dG9waWMgPSB0aGlzLnpbIGQgXVsgaSBdO1xuXG5cdFx0XHQvLyBOdW1iZXIgb2YgaW5zdGFuY2VzIG9mIHdvcmQgaSBhc3NpZ25lZCB0byB0b3BpYyBqOlxuXHRcdFx0dGhpcy5udy5zZXQoIHd0LCB0b3BpYywgdGhpcy5udy5nZXQoIHd0LCB0b3BpYyApICsgMSApO1xuXG5cdFx0XHQvLyBOdW1iZXIgb2Ygd29yZHMgaW4gZG9jdW1lbnQgaSBhc3NpZ25lZCB0byB0b3BpYyBqOlxuXHRcdFx0dGhpcy5uZC5zZXQoIGQsIHRvcGljLCB0aGlzLm5kLmdldCggZCwgdG9waWMgKSArIDEgKTtcblxuXHRcdFx0Ly8gVG90YWwgbnVtYmVyIG9mIHdvcmRzIGFzc2lnbmVkIHRvIHRvcGljIGo6XG5cdFx0XHR0aGlzLm53U3VtWyB0b3BpYyBdID0gdGhpcy5ud1N1bVsgdG9waWMgXSArIDE7XG5cdFx0fVxuXHR9XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXQ7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgbWF0cml4ID0gcmVxdWlyZSggJy4vbWF0cml4LmpzJyApO1xuXG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIENhbGN1bGF0ZSB3ZWlnaHRlZCBhdmVyYWdlIG9mIHR3byBtYXRyaWNlcy5cbipcbiogQHByaXZhdGVcbiogQHBhcmFtIHtNYXRyaXh9IEEgLSBmaXJzdCBtYXRyaXhcbiogQHBhcmFtIHtNYXRyaXh9IEIgLSBzZWNvbmQgbWF0cml4XG4qIEBwYXJhbSB7UG9zaXRpdmVJbnRlZ2VyfSB3ZWlnaHQgLSByZWxhdGl2ZSB3ZWlnaHQgb2YgbWF0cml4IEFcbiogQHJldHVybnMge01hdHJpeH0gYXZlcmFnZWQgbWF0cml4XG4qL1xuZnVuY3Rpb24gYXZnTWF0cml4KCBBLCBCLCB3ZWlnaHQgKSB7XG5cdHZhciBwcm9wQTtcblx0dmFyIHByb3BCO1xuXHR2YXIgbnJvdztcblx0dmFyIG5jb2w7XG5cdHZhciB2YWw7XG5cdHZhciBDO1xuXHR2YXIgaTtcblx0dmFyIGo7XG5cblx0bnJvdyA9IEEuc2hhcGVbIDAgXTtcblx0bmNvbCA9IEEuc2hhcGVbIDEgXTtcblx0QyA9IG1hdHJpeCggWyBucm93LCBuY29sIF0gKTtcblx0cHJvcEEgPSAoIHdlaWdodCAtIDEuMCApIC8gd2VpZ2h0O1xuXHRwcm9wQiA9IDEuMCAvIHdlaWdodDtcblxuXHRmb3IgKCBpID0gMDsgaSA8IG5yb3c7IGkrKyApIHtcblx0XHRmb3IgKCBqID0gMDsgaiA8IG5jb2w7IGorKyApIHtcblx0XHRcdHZhbCA9IChwcm9wQSAqIEEuZ2V0KGksIGopKSArIChwcm9wQiAqIEIuZ2V0KGksIGopKTtcblx0XHRcdEMuc2V0KCBpLCBqLCB2YWwgKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIEM7XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGF2Z01hdHJpeDtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBpc1Bvc2l0aXZlSW50ZWdlciA9IHJlcXVpcmUoICdAc3RkbGliL2Fzc2VydC1pcy1wb3NpdGl2ZS1pbnRlZ2VyJyApO1xudmFyIHJhbmR1ID0gcmVxdWlyZSggJ0BzdGRsaWIvcmFuZG9tLWJhc2UtcmFuZHUnICk7XG52YXIgYXZnTWF0cml4ID0gcmVxdWlyZSggJy4vYXZnX21hdHJpeC5qcycgKTtcblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBGaXQgbW9kZWwgdXNpbmcgY29sbGFwc2VkIEdpYmJzIHNhbXBsaW5nLlxuKlxuKiBAcHJpdmF0ZVxuKiBAcGFyYW0ge1Bvc2l0aXZlSW50ZWdlcn0gaXRlciAtIG51bWJlciBvZiBzYW1wbGluZyBpdGVyYXRpb25zXG4qIEBwYXJhbSB7UG9zaXRpdmVJbnRlZ2VyfSBidXJuaW4gLSBudW1iZXIgb2YgZXN0aW1hdGVzIHRvIGJlIHRocm93biBhd2F5IGF0IGJlZ2lubmluZ1xuKiBAcGFyYW0ge1Bvc2l0aXZlSW50ZWdlcn0gdGhpbiAtIG51bWJlciBvZiBkaXNjYXJkZWQgaW4tYmV0d2VlbiBpdGVyYXRpb25zXG4qIEB0aHJvd3Mge1R5cGVFcnJvcn0gZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXJcbiogQHRocm93cyB7VHlwZUVycm9yfSBzZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXJcbiogQHRocm93cyB7VHlwZUVycm9yfSB0aGlyZCBhcmd1bWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlclxuKi9cbmZ1bmN0aW9uIGZpdCggaXRlciwgYnVybmluLCB0aGluICkge1xuXHQvKiBlc2xpbnQtZGlzYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cblx0dmFyIGthbHBoYTtcblx0dmFyIHdiZXRhO1xuXHR2YXIgdG9waWM7XG5cdHZhciB0aGV0YTtcblx0dmFyIHByb2I7XG5cdHZhciB3b3JkO1xuXHR2YXIgcGhpO1xuXHR2YXIgbGVuO1xuXHR2YXIgbnQ7XG5cdHZhciBkO1xuXHR2YXIgaTtcblx0dmFyIGo7XG5cdHZhciB1O1xuXHR2YXIgdztcblxuXHRpZiAoICFpc1Bvc2l0aXZlSW50ZWdlciggaXRlciApICkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdpbnZhbGlkIGFyZ3VtZW50LiBGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlci4gVmFsdWU6IGAnICsgaXRlciArICdgLicgKTtcblx0fVxuXHRpZiAoICFpc1Bvc2l0aXZlSW50ZWdlciggYnVybmluICkgKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ2ludmFsaWQgYXJndW1lbnQuIFNlY29uZCBhcmd1bWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlci4gVmFsdWU6IGAnICsgYnVybmluICsgJ2AuJyApO1xuXHR9XG5cdGlmICggIWlzUG9zaXRpdmVJbnRlZ2VyKCB0aGluICkgKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ2ludmFsaWQgYXJndW1lbnQuIFRoaXJkIGFyZ3VtZW50IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLiBWYWx1ZTogYCcgKyB0aGluICsgJ2AuJyApO1xuXHR9XG5cblx0d2JldGEgPSB0aGlzLlcgKiB0aGlzLmJldGE7XG5cdGthbHBoYSA9IHRoaXMuSyAqIHRoaXMuYWxwaGE7XG5cblx0Zm9yICggaSA9IDA7IGkgPCBpdGVyOyBpKysgKSB7XG5cdFx0Zm9yICggZCA9IDA7IGQgPCB0aGlzLkQ7IGQrKyApIHtcblx0XHRcdGZvciAoIHcgPSAwOyB3IDwgdGhpcy5uZFN1bVsgZCBdOyB3KysgKSB7XG5cdFx0XHRcdHdvcmQgPSB0aGlzLndbIGQgXVsgdyBdO1xuXHRcdFx0XHR0b3BpYyA9IHRoaXMuelsgZCBdWyB3IF07XG5cblx0XHRcdFx0dGhpcy5udy5zZXQoIHdvcmQsIHRvcGljLCB0aGlzLm53LmdldCggd29yZCwgdG9waWMgKSAtIDEgKTtcblx0XHRcdFx0dGhpcy5uZC5zZXQoIGQsIHRvcGljLCB0aGlzLm5kLmdldCggZCwgdG9waWMgKSAtIDEgKTtcblx0XHRcdFx0dGhpcy5uZFN1bVsgZCBdIC09IDE7XG5cdFx0XHRcdHRoaXMubndTdW1bIHRvcGljIF0gLT0gMTtcblxuXHRcdFx0XHRwcm9iID0gW107XG5cdFx0XHRcdGZvciAoIGogPSAwOyBqIDwgdGhpcy5LOyBqKysgKSB7XG5cdFx0XHRcdFx0cHJvYi5wdXNoKCAoIHRoaXMubncuZ2V0KCB3b3JkLCBqICkgKyB0aGlzLmJldGEgKSAvXG5cdFx0XHRcdFx0XHQoIHRoaXMubndTdW1bIGogXSArIHdiZXRhICkgKlxuXHRcdFx0XHRcdFx0KCB0aGlzLm5kLmdldCggZCwgaiApICsgdGhpcy5hbHBoYSApIC9cblx0XHRcdFx0XHRcdCggdGhpcy5uZFN1bVsgZCBdICsga2FscGhhICkgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKCBqID0gMTsgaiA8IHRoaXMuSzsgaisrICkge1xuXHRcdFx0XHRcdHByb2JbIGogXSArPSBwcm9iWyBqIC0gMSBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHUgPSBwcm9iWyB0aGlzLksgLSAxIF0gKiByYW5kdSgpO1xuXHRcdFx0XHR0b3BpYyA9IDA7XG5cdFx0XHRcdGZvciAoIG50ID0gMDsgbnQgPCB0aGlzLks7IG50KysgKSB7XG5cdFx0XHRcdFx0aWYgKCBwcm9iWyBudCBdID4gdSApIHtcblx0XHRcdFx0XHRcdHRvcGljID0gbnQ7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gQXNzaWduIG5ldyB6X2kgdG8gY291bnRzLi4uXG5cdFx0XHRcdHRoaXMubncuc2V0KCB3b3JkLCB0b3BpYywgdGhpcy5udy5nZXQoIHdvcmQsIHRvcGljICkgKyAxICk7XG5cdFx0XHRcdHRoaXMubmQuc2V0KCBkLCB0b3BpYywgdGhpcy5uZC5nZXQoIGQsIHRvcGljICkgKyAxICk7XG5cdFx0XHRcdHRoaXMubndTdW1bIHRvcGljIF0gKz0gMTtcblx0XHRcdFx0dGhpcy5uZFN1bVsgZCBdICs9IDE7XG5cblx0XHRcdFx0dGhpcy56WyBkIF1bIHcgXSA9IHRvcGljO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggaSAlIHRoaW4gPT09IDAgJiYgaSA+IGJ1cm5pbiApIHtcblx0XHRcdHBoaSA9IHRoaXMuZ2V0UGhpcygpO1xuXHRcdFx0dGhldGEgPSB0aGlzLmdldFRoZXRhcygpO1xuXG5cdFx0XHR0aGlzLnBoaUxpc3QucHVzaCggcGhpICk7XG5cdFx0XHR0aGlzLnRoZXRhTGlzdC5wdXNoKCB0aGV0YSApO1xuXG5cdFx0XHRsZW4gPSB0aGlzLnBoaUxpc3QubGVuZ3RoO1xuXHRcdFx0aWYgKCBsZW4gPT09IDEgKSB7XG5cdFx0XHRcdHRoaXMuYXZnUGhpID0gcGhpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5hdmdQaGkgPSBhdmdNYXRyaXgoIHRoaXMuYXZnUGhpLCBwaGksIGxlbiApO1xuXHRcdFx0fVxuXHRcdFx0bGVuID0gdGhpcy50aGV0YUxpc3QubGVuZ3RoO1xuXHRcdFx0aWYgKCBsZW4gPT09IDEgKSB7XG5cdFx0XHRcdHRoaXMuYXZnVGhldGEgPSB0aGV0YTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuYXZnVGhldGEgPSBhdmdNYXRyaXgoIHRoaXMuYXZnVGhldGEsIHRoZXRhLCBsZW4gKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gZml0O1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGlzTm9uTmVnYXRpdmVJbnRlZ2VyID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLW5vbm5lZ2F0aXZlLWludGVnZXInICk7XG52YXIgaXNQb3NpdGl2ZUludGVnZXIgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaXMtcG9zaXRpdmUtaW50ZWdlcicgKTtcbnZhciBpc1N0cmluZ0FycmF5ID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLXN0cmluZy1hcnJheScgKTtcbnZhciBzZXRSZWFkT25seSA9IHJlcXVpcmUoICdAc3RkbGliL3V0aWxzLWRlZmluZS1yZWFkLW9ubHktcHJvcGVydHknICk7XG52YXIgY29udGFpbnMgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtY29udGFpbnMnICk7XG52YXIgdG9rZW5pemUgPSByZXF1aXJlKCAnQHN0ZGxpYi9ubHAtdG9rZW5pemUnICk7XG52YXIgSW50MzJBcnJheSA9IHJlcXVpcmUoICdAc3RkbGliL2FycmF5LWludDMyJyApO1xudmFyIG1hdHJpeCA9IHJlcXVpcmUoICcuL21hdHJpeC5qcycgKTtcbnZhciBnZXRUaGV0YXMgPSByZXF1aXJlKCAnLi9nZXRfdGhldGFzLmpzJyApO1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSggJy4vdmFsaWRhdGUuanMnICk7XG52YXIgZ2V0UGhpcyA9IHJlcXVpcmUoICcuL2dldF9waGlzLmpzJyApO1xudmFyIGluaXQgPSByZXF1aXJlKCAnLi9pbml0LmpzJyApO1xudmFyIGZpdCA9IHJlcXVpcmUoICcuL2ZpdC5qcycgKTtcblxuXG4vLyBGVU5DVElPTlMgLy9cblxuLyoqXG4qIEZpbmQgaW5kZXggb2YgdGhlIHZhbHVlIGluIHZvY2FidWxhcnkgZXF1YWwgdG8gdGhlIHN1cHBsaWVkIHNlYXJjaCB2YWx1ZS5cbipcbiogQHByaXZhdGVcbiogQHBhcmFtIHtBcnJheX0gdm9jYWIgLSB2b2NhYnVsYXJ5XG4qIEBwYXJhbSB7c3RyaW5nfSBzZWFyY2hWYWwgLSBzZWFyY2ggdmFsdWVcbiogQHJldHVybnMge2ludGVnZXJ9IGluZGV4IGluIHZvY2FiIGlmIHNlYXJjaCB2YWx1ZSBpcyBmb3VuZCwgLTEgb3RoZXJ3aXNlXG4qL1xuZnVuY3Rpb24gZmluZEluZGV4KCB2b2NhYiwgc2VhcmNoVmFsICkge1xuXHR2YXIgaTtcblx0Zm9yICggaSA9IDA7IGkgPCB2b2NhYi5sZW5ndGg7IGkrKyApIHtcblx0XHRpZiAoIHZvY2FiWyBpIF0gPT09IHNlYXJjaFZhbCApIHtcblx0XHRcdHJldHVybiBpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gLTE7XG59XG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogTGF0ZW50IERpcmljaGxldCBBbGxvY2F0aW9uIHZpYSBjb2xsYXBzZWQgR2liYnMgc2FtcGxpbmcuXG4qXG4qIEBwYXJhbSB7U3RyaW5nQXJyYXl9IGRvY3VtZW50cyAtIGRvY3VtZW50IGNvcnB1c1xuKiBAcGFyYW0ge1Bvc2l0aXZlSW50ZWdlcn0gSyAtIG51bWJlciBvZiB0b3BpY3NcbiogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gLSBvcHRpb25zIG9iamVjdFxuKiBAcGFyYW0ge1Bvc2l0aXZlTnVtYmVyfSBbb3B0aW9ucy5hbHBoYT01MC9LXSAtIERpcmljaGxldCBoeXBlci1wYXJhbWV0ZXIgb2YgdG9waWMgdmVjdG9yIHRoZXRhOlxuKiBAcGFyYW0ge1Bvc2l0aXZlTnVtYmVyfSBbb3B0aW9ucy5iZXRhPTAuMV0gLSBEaXJpY2hsZXQgaHlwZXItcGFyYW1ldGVyIGZvciB3b3JkIHZlY3RvciBwaGlcbiogQHRocm93cyB7VHlwZUVycm9yfSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGFuIGFycmF5IG9mIHN0cmluZ3NcbiogQHRocm93cyB7VHlwZUVycm9yfSBzZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXJcbiogQHRocm93cyB7VHlwZUVycm9yfSBtdXN0IHByb3ZpZGUgdmFsaWQgb3B0aW9uc1xuKiBAcmV0dXJucyB7T2JqZWN0fSBtb2RlbCBvYmplY3RcbiovXG5mdW5jdGlvbiBsZGEoIGRvY3VtZW50cywgSywgb3B0aW9ucyApIHtcblx0dmFyIHRhcmdldDtcblx0dmFyIHZvY2FiO1xuXHR2YXIgbW9kZWw7XG5cdHZhciBhbHBoYTtcblx0dmFyIGJldGE7XG5cdHZhciBvcHRzO1xuXHR2YXIgZXJyO1xuXHR2YXIgcG9zO1xuXHR2YXIgbmQ7XG5cdHZhciBpdDtcblx0dmFyIHdkO1xuXHR2YXIgRDtcblx0dmFyIGQ7XG5cdHZhciBpO1xuXHR2YXIgajtcblx0dmFyIFc7XG5cdHZhciB3O1xuXG5cdGlmICggIWlzU3RyaW5nQXJyYXkoIGRvY3VtZW50cyApICkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdpbnZhbGlkIGFyZ3VtZW50LiBGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nIGFycmF5LiBWYWx1ZTogYCcgKyBkb2N1bWVudHMgKyAnYC4nICk7XG5cdH1cblx0aWYgKCAhaXNQb3NpdGl2ZUludGVnZXIoIEsgKSApIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnaW52YWxpZCBhcmd1bWVudC4gTnVtYmVyIG9mIHRvcGljcyBgS2AgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIuIFZhbHVlOiBgJyArIEsgKyAnYC4nICk7XG5cdH1cblx0b3B0cyA9IHt9O1xuXHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAyICkge1xuXHRcdGVyciA9IHZhbGlkYXRlKCBvcHRzLCBvcHRpb25zICk7XG5cdFx0aWYgKCBlcnIgKSB7XG5cdFx0XHR0aHJvdyBlcnI7XG5cdFx0fVxuXHR9XG5cblx0Ly8gTnVtYmVyIG9mIGRvY3VtZW50czpcblx0RCA9IGRvY3VtZW50cy5sZW5ndGg7XG5cblx0Ly8gSHlwZXItcGFyYW1ldGVyIGZvciBEaXJpY2hsZXQgZGlzdHJpYnV0aW9uIG9mIHRvcGljIHZlY3RvciB0aGV0YTpcblx0YWxwaGEgPSBvcHRzLmFscGhhIHx8IDUwIC8gSztcblxuXHQvLyBIeXBlci1wYXJhbWV0ZXIgb2YgRGlyaWNobGV0IGRpc3RyaWJ1dGlvbiBvZiBwaGk6XG5cdGJldGEgPSBvcHRzLmJldGEgfHwgMC4xO1xuXG5cdC8vIEV4dHJhY3Qgd29yZHMgJiBjb25zdHJ1Y3Qgdm9jYWJ1bGFyeTpzXG5cdHZvY2FiID0gW107XG5cdHcgPSBbXTtcblx0cG9zID0gMDtcblx0Zm9yICggZCA9IDA7IGQgPCBEOyBkKysgKSB7XG5cdFx0dy5wdXNoKCBbXSApO1xuXHRcdHdkID0gdG9rZW5pemUoIGRvY3VtZW50c1sgZCBdICk7XG5cdFx0bmQgPSB3ZC5sZW5ndGg7XG5cdFx0Zm9yICggaSA9IDA7IGkgPCBuZDsgaSsrICkge1xuXHRcdFx0dGFyZ2V0ID0gd2RbIGkgXTtcblx0XHRcdGl0ID0gZmluZEluZGV4KCB2b2NhYiwgdGFyZ2V0ICk7XG5cdFx0XHRpZiAoIGl0ID09PSAtMSApIHtcblx0XHRcdFx0dm9jYWIucHVzaCggdGFyZ2V0ICk7XG5cdFx0XHRcdHdbIGQgXS5wdXNoKCBwb3MgKTtcblx0XHRcdFx0cG9zICs9IDE7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3WyBkIF0ucHVzaCggaXQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Ly8gU2l6ZSBvZiB2b2NhYnVsYXJ5OlxuXHRXID0gdm9jYWIubGVuZ3RoO1xuXG5cdG1vZGVsID0ge307XG5cblx0Ly8gQXR0YWNoIHJlYWQtb25seSBwcm9wZXJ0aWVzOlxuXHRzZXRSZWFkT25seSggbW9kZWwsICdLJywgSyApO1xuXHRzZXRSZWFkT25seSggbW9kZWwsICdEJywgRCApO1xuXHRzZXRSZWFkT25seSggbW9kZWwsICdXJywgVyApO1xuXHRzZXRSZWFkT25seSggbW9kZWwsICdhbHBoYScsIGFscGhhICk7XG5cdHNldFJlYWRPbmx5KCBtb2RlbCwgJ2JldGEnLCBiZXRhICk7XG5cblx0Ly8gQXR0YWNoIG1ldGhvZHM6XG5cdHNldFJlYWRPbmx5KCBtb2RlbCwgJ2luaXQnLCBpbml0ICk7XG5cdHNldFJlYWRPbmx5KCBtb2RlbCwgJ2ZpdCcsIGZpdCApO1xuXHRzZXRSZWFkT25seSggbW9kZWwsICdnZXRQaGlzJywgZ2V0UGhpcyApO1xuXHRzZXRSZWFkT25seSggbW9kZWwsICdnZXRUaGV0YXMnLCBnZXRUaGV0YXMgKTtcblx0c2V0UmVhZE9ubHkoIG1vZGVsLCAnZ2V0VGVybXMnLCBnZXRUZXJtcyApO1xuXG5cdG1vZGVsLm53U3VtID0gbmV3IEludDMyQXJyYXkoIEsgKTtcblx0bW9kZWwubmRTdW0gPSBuZXcgSW50MzJBcnJheSggRCApO1xuXHRtb2RlbC5udyA9IG1hdHJpeCggWyBXLCBLIF0sICdpbnQzMicgKTtcblx0bW9kZWwubmQgPSBtYXRyaXgoIFsgRCwgSyBdLCAnaW50MzInICk7XG5cblx0bW9kZWwucGhpTGlzdCA9IFtdO1xuXHRtb2RlbC50aGV0YUxpc3QgPSBbXTtcblxuXHRtb2RlbC53ID0gdztcblx0bW9kZWwuaW5pdCgpO1xuXG5cdHJldHVybiBtb2RlbDtcblxuXHQvKipcblx0KiBHZXQgdG9wIHRlcm1zIGZvciB0aGUgc3BlY2lmaWVkIHRvcGljLlxuXHQqXG5cdCogQHByaXZhdGVcblx0KiBAcGFyYW0ge05vbk5lZ2F0aXZlSW50ZWdlcn0gayAtIHRvcGljXG5cdCogQHBhcmFtIHtQb3NpdGl2ZUludGVnZXJ9IFtubz0xMF0gLSBudW1iZXIgb2YgdGVybXNcblx0KiBAdGhyb3dzIHtUeXBlRXJyb3J9IGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBub25uZWdhdGl2ZSBpbnRlZ2VyIHNtYWxsZXIgdGhhbiB0aGUgdG90YWwgbnVtYmVyIG9mIHRvcGljc1xuXHQqIEB0aHJvd3Mge1R5cGVFcnJvcn0gc2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyXG5cdCogQHJldHVybnMge0FycmF5fSB3b3JkIHByb2JhYmlsaXR5IGFycmF5XG5cdCovXG5cdGZ1bmN0aW9uIGdldFRlcm1zKCBrLCBubyApIHtcblx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cblx0XHR2YXIgc2tpcDtcblx0XHR2YXIgcGhpO1xuXHRcdHZhciByZXQ7XG5cdFx0dmFyIG1heDtcblx0XHR2YXIgbWlkO1xuXHRcdHZhciBpO1xuXG5cdFx0aWYgKCAhaXNOb25OZWdhdGl2ZUludGVnZXIoIGsgKSB8fCBrID49IEsgKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnaW52YWxpZCBhcmd1bWVudC4gRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIG5vbm5lZ2F0aXZlIGludGVnZXIgc21hbGxlciB0aGFuIHRoZSB0b3RhbCBudW1iZXIgb2YgdG9waWNzLiBWYWx1ZTogYCcgKyBrICsgJ2AuJyApO1xuXHRcdH1cblx0XHRpZiAoIG5vICkge1xuXHRcdFx0aWYgKCAhaXNQb3NpdGl2ZUludGVnZXIoIG5vICkgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdpbnZhbGlkIGFyZ3VtZW50LiBTZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIuIFZhbHVlOiBgJyArIG5vICsgJ2AuJyApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRubyA9IDEwO1xuXHRcdH1cblxuXHRcdHJldCA9IFtdO1xuXHRcdHNraXAgPSBbXTtcblx0XHRmb3IgKCBpID0gMDsgaSA8IG5vOyBpKysgKSB7XG5cdFx0XHRtYXggPSAwO1xuXHRcdFx0Zm9yICggaiA9IDA7IGogPCB0aGlzLlc7IGorKyApIHtcblx0XHRcdFx0cGhpID0gdGhpcy5hdmdQaGkuZ2V0KCBrLCBqICk7XG5cdFx0XHRcdGlmICggcGhpID4gbWF4ICYmICFjb250YWlucyggc2tpcCwgaiApICkge1xuXHRcdFx0XHRcdG1heCA9IHBoaTtcblx0XHRcdFx0XHRtaWQgPSBqO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRza2lwLnB1c2goIG1pZCApO1xuXHRcdFx0cmV0LnB1c2goe1xuXHRcdFx0XHQnd29yZCc6IHZvY2FiWyBtaWQgXSxcblx0XHRcdFx0J3Byb2InOiBtYXhcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0O1xuXHR9XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGxkYTtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogTGF0ZW50IERpcmljaGxldCBBbGxvY2F0aW9uIHZpYSBjb2xsYXBzZWQgR2liYnMgc2FtcGxpbmcuXG4qXG4qIEBtb2R1bGUgQHN0ZGxpYi9ubHAtbGRhXG4qXG4qIEBleGFtcGxlXG4qIHZhciBsZGEgPSByZXF1aXJlKCAnQHN0ZGxpYi9ubHAtbGRhJyApO1xuKlxuKiB2YXIgd29yZHM7XG4qIHZhciBtb2RlbDtcbiogdmFyIGRvY3M7XG4qXG4qIGRvY3MgPSBbXG4qICAgICAnSSBsb3ZlZCB5b3UgZmlyc3QnLFxuKiAgICAgJ0ZvciBvbmUgaXMgYm90aCBhbmQgYm90aCBhcmUgb25lIGluIGxvdmUnLFxuKiAgICAgJ1lvdSBuZXZlciBzZWUgbXkgcGFpbicsXG4qICAgICAnTXkgbG92ZSBpcyBzdWNoIHRoYXQgcml2ZXJzIGNhbm5vdCBxdWVuY2gnLFxuKiAgICAgJ1NlZSBhIGxvdCBvZiBwYWluLCBhIGxvdCBvZiB0ZWFycydcbiogXTtcbipcbiogbW9kZWwgPSBsZGEoIGRvY3MsIDIgKTtcbiogLy8gcmV0dXJucyB7fVxuKlxuKiBtb2RlbC5maXQoIDEwMDAsIDEwMCwgMTAgKTtcbipcbiogd29yZHMgPSBnZXRUZXJtcyggMCwgMyApO1xuKiAvLyBlLmcuLCByZXR1cm5zIFsgeyB3b3JkOiAnYm90aCcsIHByb2I6IH4wLjA2MzIgfSwgeyB3b3JkOiAncGFpbicsIHByb2I6IH4wLjA1NTIgfSwgLi4uIF1cbiovXG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGxkYSA9IHJlcXVpcmUoICcuL2xkYS5qcycgKTtcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gbGRhO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGlzSW50ZWdlciA9IHJlcXVpcmUoICdAc3RkbGliL2Fzc2VydC1pcy1pbnRlZ2VyJyApLmlzUHJpbWl0aXZlO1xudmFyIGlzU3RyaW5nID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLXN0cmluZycgKS5pc1ByaW1pdGl2ZTtcblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBUZXN0IGlmIGEgc3RyaW5nIGVuZHMgd2l0aCB0aGUgY2hhcmFjdGVycyBvZiBhbm90aGVyIHN0cmluZy5cbipcbiogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIGlucHV0IHN0cmluZ1xuKiBAcGFyYW0ge3N0cmluZ30gc2VhcmNoIC0gc2VhcmNoIHN0cmluZ1xuKiBAcGFyYW0ge2ludGVnZXJ9IFtsZW49c3RyLmxlbmd0aF0gLSBzdWJzdHJpbmcgbGVuZ3RoXG4qIEB0aHJvd3Mge1R5cGVFcnJvcn0gZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZyBwcmltaXRpdmVcbiogQHRocm93cyB7VHlwZUVycm9yfSBzZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZyBwcmltaXRpdmVcbiogQHRocm93cyB7VHlwZUVycm9yfSB0aGlyZCBhcmd1bWVudCBtdXN0IGJlIGFuIGludGVnZXJcbiogQHJldHVybnMge2Jvb2xlYW59IGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgaW5wdXQgc3RyaW5nIGVuZHMgd2l0aCB0aGUgc2VhcmNoIHN0cmluZ1xuKlxuKiBAZXhhbXBsZVxuKiB2YXIgYm9vbCA9IGVuZHNXaXRoKCAnUmVtZW1iZXIgdGhlIHN0b3J5IEkgdXNlZCB0byB0ZWxsIHlvdSB3aGVuIHlvdSB3ZXJlIGEgYm95PycsICdib3k/JyApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBlbmRzV2l0aCggJ1JlbWVtYmVyIHRoZSBzdG9yeSBJIHVzZWQgdG8gdGVsbCB5b3Ugd2hlbiB5b3Ugd2VyZSBhIGJveT8nLCAnQm95PycgKTtcbiogLy8gcmV0dXJucyBmYWxzZVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgYm9vbCA9IGVuZHNXaXRoKCAnVG8gYmUsIG9yIG5vdCB0byBiZSwgdGhhdCBpcyB0aGUgcXVlc3Rpb24uJywgJ3RvIGJlJyApO1xuKiAvLyByZXR1cm5zIGZhbHNlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gZW5kc1dpdGgoICdUbyBiZSwgb3Igbm90IHRvIGJlLCB0aGF0IGlzIHRoZSBxdWVzdGlvbi4nLCAndG8gYmUnLCAxOSApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogQGV4YW1wbGVcbiogdmFyIGJvb2wgPSBlbmRzV2l0aCggJ1RvIGJlLCBvciBub3QgdG8gYmUsIHRoYXQgaXMgdGhlIHF1ZXN0aW9uLicsICd0byBiZScsIC0yMyApO1xuKiAvLyByZXR1cm5zIHRydWVcbiovXG5mdW5jdGlvbiBlbmRzV2l0aCggc3RyLCBzZWFyY2gsIGxlbiApIHtcblx0dmFyIGlkeDtcblx0dmFyIGk7XG5cdGlmICggIWlzU3RyaW5nKCBzdHIgKSApIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnaW52YWxpZCBhcmd1bWVudC4gRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZyBwcmltaXRpdmUuIFZhbHVlOiBgJyArIHN0ciArICdgLicgKTtcblx0fVxuXHRpZiAoICFpc1N0cmluZyggc2VhcmNoICkgKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ2ludmFsaWQgYXJndW1lbnQuIFNlY29uZCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nIHByaW1pdGl2ZS4gVmFsdWU6IGAnICsgc2VhcmNoICsgJ2AuJyApO1xuXHR9XG5cdGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDIgKSB7XG5cdFx0aWYgKCAhaXNJbnRlZ2VyKCBsZW4gKSApIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdpbnZhbGlkIGFyZ3VtZW50LiBUaGlyZCBhcmd1bWVudCBtdXN0IGJlIGFuIGludGVnZXIuIFZhbHVlOiBgJyArIGxlbiArICdgLicgKTtcblx0XHR9XG5cdFx0aWYgKCBsZW4gPT09IDAgKSB7XG5cdFx0XHRyZXR1cm4gKCBzZWFyY2gubGVuZ3RoID09PSAwICk7XG5cdFx0fVxuXHRcdGlmICggbGVuIDwgMCApIHtcblx0XHRcdGlkeCA9IHN0ci5sZW5ndGggKyBsZW47XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlkeCA9IGxlbjtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0aWR4ID0gc3RyLmxlbmd0aDtcblx0fVxuXHRpZiAoIHNlYXJjaC5sZW5ndGggPT09IDAgKSB7XG5cdFx0Ly8gQmFzZWQgb24gdGhlIHByZW1pc2UgdGhhdCBldmVyeSBzdHJpbmcgY2FuIGJlIFwic3Vycm91bmRlZFwiIGJ5IGVtcHR5IHN0cmluZ3MgKGUuZy4sIFwiXCIgKyBcImFcIiArIFwiXCIgKyBcImJcIiArIFwiXCIgPT09IFwiYWJcIik6XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0aWR4IC09IHNlYXJjaC5sZW5ndGg7XG5cdGlmICggaWR4IDwgMCApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0Zm9yICggaSA9IDA7IGkgPCBzZWFyY2gubGVuZ3RoOyBpKyspIHtcblx0XHRpZiAoIHN0ci5jaGFyQ29kZUF0KCBpZHggKyBpICkgIT09IHNlYXJjaC5jaGFyQ29kZUF0KCBpICkgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cdHJldHVybiB0cnVlO1xufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBlbmRzV2l0aDtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogVGVzdCBpZiBhIHN0cmluZyBlbmRzIHdpdGggdGhlIGNoYXJhY3RlcnMgb2YgYW5vdGhlciBzdHJpbmcuXG4qXG4qIEBtb2R1bGUgQHN0ZGxpYi9zdHJpbmctZW5kcy13aXRoXG4qXG4qIEBleGFtcGxlXG4qIHZhciBlbmRzV2l0aCA9IHJlcXVpcmUoICdAc3RkbGliL3N0cmluZy1lbmRzLXdpdGgnICk7XG4qXG4qIHZhciBzdHIgPSAnRmFpciBpcyBmb3VsLCBhbmQgZm91bCBpcyBmYWlyLCBob3ZlciB0aHJvdWdoIGZvZyBhbmQgZmlsdGh5IGFpcic7XG4qXG4qIHZhciBib29sID0gZW5kc1dpdGgoIHN0ciwgJ2FpcicgKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qXG4qIGJvb2wgPSBlbmRzV2l0aCggc3RyLCAnZmFpcicgKTtcbiogLy8gcmV0dXJucyBmYWxzZVxuKlxuKiBib29sID0gZW5kc1dpdGgoIHN0ciwgJ2ZhaXInLCAzMCApO1xuKiAvLyByZXR1cm5zIHRydWVcbipcbiogYm9vbCA9IGVuZHNXaXRoKCBzdHIsICdmYWlyJywgLTM0ICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKi9cblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgZW5kc1dpdGggPSByZXF1aXJlKCAnLi9lbmRzX3dpdGguanMnICk7XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVuZHNXaXRoO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGlzU3RyaW5nID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLXN0cmluZycgKS5pc1ByaW1pdGl2ZTtcblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBDb252ZXJ0cyBhIHN0cmluZyB0byBsb3dlcmNhc2UuXG4qXG4qIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBzdHJpbmcgdG8gY29udmVydFxuKiBAdGhyb3dzIHtUeXBlRXJyb3J9IG11c3QgcHJvdmlkZSBhIHByaW1pdGl2ZSBzdHJpbmdcbiogQHJldHVybnMge3N0cmluZ30gbG93ZXJjYXNlIHN0cmluZ1xuKlxuKiBAZXhhbXBsZVxuKiB2YXIgc3RyID0gbG93ZXJjYXNlKCAnYkVFcCcgKTtcbiogLy8gcmV0dXJucyAnYmVlcCdcbiovXG5mdW5jdGlvbiBsb3dlcmNhc2UoIHN0ciApIHtcblx0aWYgKCAhaXNTdHJpbmcoIHN0ciApICkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdpbnZhbGlkIGFyZ3VtZW50LiBNdXN0IHByb3ZpZGUgYSBwcmltaXRpdmUgc3RyaW5nLiBWYWx1ZTogYCcrc3RyKydgLicgKTtcblx0fVxuXHRyZXR1cm4gc3RyLnRvTG93ZXJDYXNlKCk7XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGxvd2VyY2FzZTtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogQ29udmVydCBhIHN0cmluZyB0byBsb3dlcmNhc2UuXG4qXG4qIEBtb2R1bGUgQHN0ZGxpYi9zdHJpbmctbG93ZXJjYXNlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBsb3dlcmNhc2UgPSByZXF1aXJlKCAnQHN0ZGxpYi9zdHJpbmctbG93ZXJjYXNlJyApO1xuKlxuKiB2YXIgc3RyID0gbG93ZXJjYXNlKCAnYkVFcCcgKTtcbiogLy8gcmV0dXJucyAnYmVlcCdcbiovXG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGxvd2VyY2FzZSA9IHJlcXVpcmUoICcuL2xvd2VyY2FzZS5qcycgKTtcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gbG93ZXJjYXNlO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGlzU3RyaW5nID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLXN0cmluZycgKS5pc1ByaW1pdGl2ZTtcblxuXG4vLyBWQVJJQUJMRVMgLy9cblxudmFyIFJFX0NIQVJTID0gL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuXG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIEVzY2FwZXMgYSByZWd1bGFyIGV4cHJlc3Npb24gc3RyaW5nLlxuKlxuKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gcmVndWxhciBleHByZXNzaW9uIHN0cmluZ1xuKiBAdGhyb3dzIHtUeXBlRXJyb3J9IGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcgcHJpbWl0aXZlXG4qIEByZXR1cm5zIHtzdHJpbmd9IGVzY2FwZWQgc3RyaW5nXG4qXG4qIEBleGFtcGxlXG4qIHZhciBzdHIgPSByZXNjYXBlKCAnW0EtWl0qJyApO1xuKiAvLyByZXR1cm5zICdcXFxcW0FcXFxcLVpcXFxcXVxcXFwqJ1xuKi9cbmZ1bmN0aW9uIHJlc2NhcGUoIHN0ciApIHtcblx0dmFyIGxlbjtcblx0dmFyIHM7XG5cdHZhciBpO1xuXG5cdGlmICggIWlzU3RyaW5nKCBzdHIgKSApIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnaW52YWxpZCBhcmd1bWVudC4gTXVzdCBwcm92aWRlIGEgcmVndWxhciBleHByZXNzaW9uIHN0cmluZy4gVmFsdWU6IGAnICsgc3RyICsgJ2AuJyApO1xuXHR9XG5cdC8vIENoZWNrIGlmIHRoZSBzdHJpbmcgc3RhcnRzIHdpdGggYSBmb3J3YXJkIHNsYXNoLi4uXG5cdGlmICggc3RyWyAwIF0gPT09ICcvJyApIHtcblx0XHQvLyBGaW5kIHRoZSBsYXN0IGZvcndhcmQgc2xhc2guLi5cblx0XHRsZW4gPSBzdHIubGVuZ3RoO1xuXHRcdGZvciAoIGkgPSBsZW4tMTsgaSA+PSAwOyBpLS0gKSB7XG5cdFx0XHRpZiAoIHN0clsgaSBdID09PSAnLycgKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHQvLyBJZiB3ZSBzZWFyY2hlZCB0aGUgc3RyaW5nIHRvIG5vIGF2YWlsIG9yIGlmIHRoZSBmaXJzdCBsZXR0ZXIgaXMgbm90IGAvYCwgYXNzdW1lIHRoYXQgdGhlIHN0cmluZyBpcyBub3Qgb2YgdGhlIGZvcm0gYC9bLi4uXS9bZ3VpbXldYDpcblx0aWYgKCBpID09PSB2b2lkIDAgfHwgaSA8PSAwICkge1xuXHRcdHJldHVybiBzdHIucmVwbGFjZSggUkVfQ0hBUlMsICdcXFxcJCYnICk7XG5cdH1cblx0Ly8gV2UgbmVlZCB0byBkZS1jb25zdHJ1Y3QgdGhlIHN0cmluZy4uLlxuXHRzID0gc3RyLnN1YnN0cmluZyggMSwgaSApO1xuXG5cdC8vIE9ubHkgZXNjYXBlIHRoZSBjaGFyYWN0ZXJzIGJldHdlZW4gdGhlIGAvYDpcblx0cyA9IHMucmVwbGFjZSggUkVfQ0hBUlMsICdcXFxcJCYnICk7XG5cblx0Ly8gUmVhc3NlbWJsZTpcblx0c3RyID0gc3RyWyAwIF0gKyBzICsgc3RyLnN1YnN0cmluZyggaSApO1xuXG5cdHJldHVybiBzdHI7XG59XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlc2NhcGU7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIEVzY2FwZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBzdHJpbmcgb3IgcGF0dGVybi5cbipcbiogQG1vZHVsZSBAc3RkbGliL3V0aWxzLWVzY2FwZS1yZWdleHAtc3RyaW5nXG4qXG4qIEBleGFtcGxlXG4qIHZhciByZXNjYXBlID0gcmVxdWlyZSggJ0BzdGRsaWIvdXRpbHMtZXNjYXBlLXJlZ2V4cC1zdHJpbmcnICk7XG4qXG4qIHZhciBzdHIgPSByZXNjYXBlKCAnW0EtWl0qJyApO1xuKiAvLyByZXR1cm5zICdcXFxcW0FcXFxcLVpcXFxcXVxcXFwqJ1xuKi9cblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgcmVzY2FwZSA9IHJlcXVpcmUoICcuL21haW4uanMnICk7XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlc2NhcGU7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGV4ZWMgPSBSZWdFeHAucHJvdG90eXBlLmV4ZWM7IC8vIG5vbi1nZW5lcmljXG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4ZWM7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgZXhlYyA9IHJlcXVpcmUoICcuL2V4ZWMuanMnICk7XG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogQXR0ZW1wdHMgdG8gY2FsbCBhIGBSZWdFeHBgIG1ldGhvZC5cbipcbiogQHByaXZhdGVcbiogQHBhcmFtIHsqfSB2YWx1ZSAtIHZhbHVlIHRvIHRlc3RcbiogQHJldHVybnMge2Jvb2xlYW59IGJvb2xlYW4gaW5kaWNhdGluZyBpZiBhYmxlIHRvIGNhbGwgYSBgUmVnRXhwYCBtZXRob2RcbiovXG5mdW5jdGlvbiB0ZXN0KCB2YWx1ZSApIHtcblx0dHJ5IHtcblx0XHRleGVjLmNhbGwoIHZhbHVlICk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKCBlcnIgKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gdGVzdDtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBoYXNUb1N0cmluZ1RhZyA9IHJlcXVpcmUoICdAc3RkbGliL2Fzc2VydC1oYXMtdG9zdHJpbmd0YWctc3VwcG9ydCcgKTtcbnZhciBuYXRpdmVDbGFzcyA9IHJlcXVpcmUoICdAc3RkbGliL3V0aWxzLW5hdGl2ZS1jbGFzcycgKTtcbnZhciB0ZXN0ID0gcmVxdWlyZSggJy4vdHJ5MmV4ZWMuanMnICk7XG5cblxuLy8gVkFSSUFCTEVTIC8vXG5cbnZhciBGTEcgPSBoYXNUb1N0cmluZ1RhZygpO1xuXG5cbi8vIE1BSU4gLy9cblxuLyoqXG4qIFRlc3RzIGlmIGEgdmFsdWUgaXMgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4qXG4qIEBwYXJhbSB7Kn0gdmFsdWUgLSB2YWx1ZSB0byB0ZXN0XG4qIEByZXR1cm5zIHtib29sZWFufSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB2YWx1ZSBpcyBhIHJlZ3VsYXIgZXhwcmVzc2lvblxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgYm9vbCA9IGlzUmVnRXhwKCAvXFwuKy8gKTtcbiogLy8gcmV0dXJucyB0cnVlXG4qXG4qIEBleGFtcGxlXG4qIHZhciBib29sID0gaXNSZWdFeHAoIHt9ICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbiovXG5mdW5jdGlvbiBpc1JlZ0V4cCggdmFsdWUgKSB7XG5cdGlmICggdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyApIHtcblx0XHRpZiAoIHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdGlmICggRkxHICkge1xuXHRcdFx0cmV0dXJuIHRlc3QoIHZhbHVlICk7XG5cdFx0fVxuXHRcdHJldHVybiAoIG5hdGl2ZUNsYXNzKCB2YWx1ZSApID09PSAnW29iamVjdCBSZWdFeHBdJyApO1xuXHR9XG5cdHJldHVybiBmYWxzZTtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNSZWdFeHA7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIFRlc3QgaWYgYSB2YWx1ZSBpcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbipcbiogQG1vZHVsZSBAc3RkbGliL2Fzc2VydC1pcy1yZWdleHBcbipcbiogQGV4YW1wbGVcbiogdmFyIGlzUmVnRXhwID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLXJlZ2V4cCcgKTtcbipcbiogdmFyIGJvb2wgPSBpc1JlZ0V4cCggL1xcLisvICk7XG4qIC8vIHJldHVybnMgdHJ1ZVxuKlxuKiBib29sID0gaXNSZWdFeHAoIHt9ICk7XG4qIC8vIHJldHVybnMgZmFsc2VcbiovXG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGlzUmVnRXhwID0gcmVxdWlyZSggJy4vbWFpbi5qcycgKTtcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNSZWdFeHA7XG4iLCAiLyoqXG4qIEBsaWNlbnNlIEFwYWNoZS0yLjBcbipcbiogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBTdGRsaWIgQXV0aG9ycy5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgcmVzY2FwZSA9IHJlcXVpcmUoICdAc3RkbGliL3V0aWxzLWVzY2FwZS1yZWdleHAtc3RyaW5nJyApO1xudmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaXMtZnVuY3Rpb24nICk7XG52YXIgaXNTdHJpbmcgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaXMtc3RyaW5nJyApLmlzUHJpbWl0aXZlO1xudmFyIGlzUmVnRXhwID0gcmVxdWlyZSggJ0BzdGRsaWIvYXNzZXJ0LWlzLXJlZ2V4cCcgKTtcblxuXG4vLyBNQUlOIC8vXG5cbi8qKlxuKiBSZXBsYWNlIHNlYXJjaCBvY2N1cnJlbmNlcyB3aXRoIGEgcmVwbGFjZW1lbnQgc3RyaW5nLlxuKlxuKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gaW5wdXQgc3RyaW5nXG4qIEBwYXJhbSB7KHN0cmluZ3xSZWdFeHApfSBzZWFyY2ggLSBzZWFyY2ggZXhwcmVzc2lvblxuKiBAcGFyYW0geyhzdHJpbmd8RnVuY3Rpb24pfSBuZXd2YWwgLSByZXBsYWNlbWVudCB2YWx1ZSBvciBmdW5jdGlvblxuKiBAdGhyb3dzIHtUeXBlRXJyb3J9IGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcgcHJpbWl0aXZlXG4qIEB0aHJvd3Mge1R5cGVFcnJvcn0gc2Vjb25kIGFyZ3VtZW50IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcgcHJpbWl0aXZlIG9yIHJlZ3VsYXIgZXhwcmVzc2lvblxuKiBAdGhyb3dzIHtUeXBlRXJyb3J9IHRoaXJkIGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcgcHJpbWl0aXZlIG9yIGZ1bmN0aW9uXG4qIEByZXR1cm5zIHtzdHJpbmd9IG5ldyBzdHJpbmcgY29udGFpbmluZyByZXBsYWNlbWVudChzKVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgc3RyID0gJ2JlZXAnO1xuKiB2YXIgb3V0ID0gcmVwbGFjZSggc3RyLCAnZScsICdvJyApO1xuKiAvLyByZXR1cm5zICdib29wJ1xuKlxuKiBAZXhhbXBsZVxuKiB2YXIgc3RyID0gJ0hlbGxvIFdvcmxkJztcbiogdmFyIG91dCA9IHJlcGxhY2UoIHN0ciwgL3dvcmxkL2ksICdNci4gUHJlc2lkZW50JyApO1xuKiAvLyByZXR1cm5zICdIZWxsbyBNci4gUHJlc2lkZW50J1xuKlxuKiBAZXhhbXBsZVxuKiB2YXIgY2FwaXRhbGl6ZSA9IHJlcXVpcmUoICdAc3RkbGliL3N0cmluZy1jYXBpdGFsaXplJyApO1xuKlxuKiB2YXIgc3RyID0gJ09yYW5nZXMgYW5kIGxlbW9ucyBzYXkgdGhlIGJlbGxzIG9mIFN0LiBDbGVtZW50XFwncyc7XG4qXG4qIGZ1bmN0aW9uIHJlcGxhY2VyKCBtYXRjaCwgcDEgKSB7XG4qICAgICByZXR1cm4gY2FwaXRhbGl6ZSggcDEgKTtcbiogfVxuKlxuKiB2YXIgb3V0ID0gcmVwbGFjZSggc3RyLCAvKFteXFxzXSopL2dpLCByZXBsYWNlcik7XG4qIC8vIHJldHVybnMgJ09yYW5nZXMgQW5kIExlbW9ucyBTYXkgVGhlIEJlbGxzIE9mIFN0LiBDbGVtZW50XFwncydcbiovXG5mdW5jdGlvbiByZXBsYWNlKCBzdHIsIHNlYXJjaCwgbmV3dmFsICkge1xuXHRpZiAoICFpc1N0cmluZyggc3RyICkgKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ2ludmFsaWQgYXJndW1lbnQuIEZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcgcHJpbWl0aXZlLiBWYWx1ZTogYCcgKyBzdHIgKyAnYC4nICk7XG5cdH1cblx0aWYgKCBpc1N0cmluZyggc2VhcmNoICkgKSB7XG5cdFx0c2VhcmNoID0gcmVzY2FwZSggc2VhcmNoICk7XG5cdFx0c2VhcmNoID0gbmV3IFJlZ0V4cCggc2VhcmNoLCAnZycgKTtcblx0fVxuXHRlbHNlIGlmICggIWlzUmVnRXhwKCBzZWFyY2ggKSApIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnaW52YWxpZCBhcmd1bWVudC4gU2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcgcHJpbWl0aXZlIG9yIHJlZ3VsYXIgZXhwcmVzc2lvbi4gVmFsdWU6IGAnICsgc2VhcmNoICsgJ2AuJyApO1xuXHR9XG5cdGlmICggIWlzU3RyaW5nKCBuZXd2YWwgKSAmJiAhaXNGdW5jdGlvbiggbmV3dmFsICkgKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ2ludmFsaWQgYXJndW1lbnQuIFRoaXJkIGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcgcHJpbWl0aXZlIG9yIHJlcGxhY2VtZW50IGZ1bmN0aW9uLiBWYWx1ZTogYCcgKyBuZXd2YWwgKyAnYC4nICk7XG5cdH1cblx0cmV0dXJuIHN0ci5yZXBsYWNlKCBzZWFyY2gsIG5ld3ZhbCApO1xufVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSByZXBsYWNlO1xuIiwgIi8qKlxuKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4qXG4qIENvcHlyaWdodCAoYykgMjAxOCBUaGUgU3RkbGliIEF1dGhvcnMuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBSZXBsYWNlIHNlYXJjaCBvY2N1cnJlbmNlcyB3aXRoIGEgcmVwbGFjZW1lbnQgc3RyaW5nLlxuKlxuKiBAbW9kdWxlIEBzdGRsaWIvc3RyaW5nLXJlcGxhY2VcbipcbiogQGV4YW1wbGVcbiogdmFyIHJlcGxhY2UgPSByZXF1aXJlKCAnQHN0ZGxpYi9zdHJpbmctcmVwbGFjZScgKTtcbipcbiogdmFyIHN0ciA9ICdiZWVwJztcbiogdmFyIG91dCA9IHJlcGxhY2UoIHN0ciwgJ2UnLCAnbycgKTtcbiogLy8gcmV0dXJucyAnYm9vcCdcbipcbiogc3RyID0gJ0hlbGxvIFdvcmxkJztcbiogb3V0ID0gcmVwbGFjZSggc3RyLCAvd29ybGQvaSwgJ01yLiBQcmVzaWRlbnQnICk7XG4qIC8vIHJldHVybnMgJ0hlbGxvIE1yLiBQcmVzaWRlbnQnXG4qL1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciByZXBsYWNlID0gcmVxdWlyZSggJy4vcmVwbGFjZS5qcycgKTtcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gcmVwbGFjZTtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTkgVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKlxuKlxuKiAjIyBOb3RpY2VcbipcbiogVGhpcyBjb2RlIGlzIGEgbW9kaWZpY2F0aW9uIG9mIGFuIGV4aXN0aW5nIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlciBbUG9ydGVyIHN0ZW1taW5nIGFsZ29yaXRobV17QGxpbmsgaHR0cHM6Ly90YXJ0YXJ1cy5vcmcvbWFydGluL1BvcnRlclN0ZW1tZXIvfS5cbipcbiogYGBgdGV4dFxuKiBSZWxlYXNlIDEgYmUgJ2FuZGFyZ29yJywgSnVsIDIwMDRcbiogUmVsZWFzZSAyIChzdWJzdGFudGlhbGx5IHJldmlzZWQpIGJ5IENocmlzdG9waGVyIE1jS2VuemllLCBBdWcgMjAwOVxuKiBgYGBcbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgaXNTdHJpbmcgPSByZXF1aXJlKCAnQHN0ZGxpYi9hc3NlcnQtaXMtc3RyaW5nJyApLmlzUHJpbWl0aXZlO1xudmFyIGVuZHNXaXRoID0gcmVxdWlyZSggJ0BzdGRsaWIvc3RyaW5nLWVuZHMtd2l0aCcgKTtcbnZhciBsb3dlcmNhc2UgPSByZXF1aXJlKCAnQHN0ZGxpYi9zdHJpbmctbG93ZXJjYXNlJyApO1xudmFyIHJlcGxhY2UgPSByZXF1aXJlKCAnQHN0ZGxpYi9zdHJpbmctcmVwbGFjZScgKTtcblxuXG4vLyBWQVJJQUJMRVMgLy9cblxudmFyIHN0ZXAybGlzdCA9IHtcblx0J2F0aW9uYWwnOiAnYXRlJyxcblx0J3Rpb25hbCc6ICd0aW9uJyxcblx0J2VuY2knOiAnZW5jZScsXG5cdCdhbmNpJzogJ2FuY2UnLFxuXHQnaXplcic6ICdpemUnLFxuXHQnYmxpJzogJ2JsZScsXG5cdCdhbGxpJzogJ2FsJyxcblx0J2VudGxpJzogJ2VudCcsXG5cdCdlbGknOiAnZScsXG5cdCdvdXNsaSc6ICdvdXMnLFxuXHQnaXphdGlvbic6ICdpemUnLFxuXHQnYXRpb24nOiAnYXRlJyxcblx0J2F0b3InOiAnYXRlJyxcblx0J2FsaXNtJzogJ2FsJyxcblx0J2l2ZW5lc3MnOiAnaXZlJyxcblx0J2Z1bG5lc3MnOiAnZnVsJyxcblx0J291c25lc3MnOiAnb3VzJyxcblx0J2FsaXRpJzogJ2FsJyxcblx0J2l2aXRpJzogJ2l2ZScsXG5cdCdiaWxpdGknOiAnYmxlJyxcblx0J2xvZ2knOiAnbG9nJ1xufTtcbnZhciBzdGVwM2xpc3QgPSB7XG5cdCdpY2F0ZSc6ICdpYycsXG5cdCdhdGl2ZSc6ICcnLFxuXHQnYWxpemUnOiAnYWwnLFxuXHQnaWNpdGknOiAnaWMnLFxuXHQnaWNhbCc6ICdpYycsXG5cdCdmdWwnOiAnJyxcblx0J25lc3MnOiAnJ1xufTtcbnZhciBjID0gJ1teYWVpb3VdJzsgLy8gY29uc29uYW50XG52YXIgdiA9ICdbYWVpb3V5XSc7IC8vIHZvd2VsXG52YXIgQyA9IGMgKyAnW15hZWlvdXldKic7IC8vIGNvbnNvbmFudCBzZXF1ZW5jZVxudmFyIFYgPSB2ICsgJ1thZWlvdV0qJzsgLy8gdm93ZWwgc2VxdWVuY2VcbnZhciBSRV9DViA9IG5ldyBSZWdFeHAoICdeJyArIEMgKyB2ICsgJ1teYWVpb3V3eHldJCcgKTtcbnZhciBtZ3IwID0gJ14oJyArIEMgKyAnKT8nICsgViArIEM7IC8vIFtDXVZDLi4uIGlzIG0+MFxudmFyIFJFX01HUjAgPSBuZXcgUmVnRXhwKCBtZ3IwICk7XG52YXIgbWVxMSA9ICdeKCcgKyBDICsgJyk/JyArIFYgKyBDICsgJygnICsgViArICcpPyQnOyAvLyBbQ11WQ1tWXSBpcyBtPTFcbnZhciBSRV9NRVExID0gbmV3IFJlZ0V4cCggbWVxMSApO1xudmFyIG1ncjEgPSAnXignICsgQyArICcpPycgKyBWICsgQyArIFYgKyBDOyAvLyBbQ11WQ1ZDLi4uIGlzIG0+MVxudmFyIFJFX01HUjEgPSBuZXcgUmVnRXhwKCBtZ3IxICk7XG52YXIgc1YgPSAnXignICsgQyArICcpPycgKyB2OyAvLyB2b3dlbCBpbiBzdGVtXG52YXIgUkVfU1YgPSBuZXcgUmVnRXhwKCBzViApO1xudmFyIFJFX1NURVAxQSA9IC9eKC4rPykoc3N8aSllcyQvO1xudmFyIFJFMl9TVEVQMUEgPSAvXiguKz8pKFtec10pcyQvO1xudmFyIFJFX1NURVAxQiA9IC9eKC4rPyllZWQkLztcbnZhciBSRTJfU1RFUDFCID0gL14oLis/KShlZHxpbmcpJC87XG52YXIgUkVfU1RFUDFDID0gL14oLis/KXkkLztcbnZhciBSRV9TVEVQMiA9IC9eKC4rPykoYXRpb25hbHx0aW9uYWx8ZW5jaXxhbmNpfGl6ZXJ8YmxpfGFsbGl8ZW50bGl8ZWxpfG91c2xpfGl6YXRpb258YXRpb258YXRvcnxhbGlzbXxpdmVuZXNzfGZ1bG5lc3N8b3VzbmVzc3xhbGl0aXxpdml0aXxiaWxpdGl8bG9naSkkLztcbnZhciBSRV9TVEVQMyA9IC9eKC4rPykoaWNhdGV8YXRpdmV8YWxpemV8aWNpdGl8aWNhbHxmdWx8bmVzcykkLztcbnZhciBSRV9TVEVQNCA9IC9eKC4rPykoYWx8YW5jZXxlbmNlfGVyfGljfGFibGV8aWJsZXxhbnR8ZW1lbnR8bWVudHxlbnR8b3V8aXNtfGF0ZXxpdGl8b3VzfGl2ZXxpemUpJC87XG52YXIgUkUyX1NURVA0ID0gL14oLis/KShzfHQpKGlvbikkLztcbnZhciBSRV9TVEVQNSA9IC9eKC4rPyllJC87XG52YXIgUkVfTEFTVCA9IC8uJC87XG52YXIgUkVfQVRCTElaID0gLyhhdHxibHxpeikkLztcbnZhciBSRV9ET1VCTEUgPSBuZXcgUmVnRXhwKCAnKFteYWVpb3V5bHN6XSlcXFxcMSQnICk7XG5cblxuLy8gTUFJTiAvL1xuXG4vKipcbiogRXh0cmFjdHMgdGhlIHN0ZW0gb2YgYSBnaXZlbiB3b3JkIHVzaW5nIHRoZSBQb3J0ZXIgc3RlbW1pbmcgYWxnb3JpdGhtLlxuKlxuKiAjIyBSZWZlcmVuY2VzXG4qXG4qIC0gICBQb3J0ZXIsIE1pY2hhZWwgRi4gMTk4MC4gXCJBbiBhbGdvcml0aG0gZm9yIHN1ZmZpeCBzdHJpcHBpbmcuXCIgX1Byb2dyYW1fIDEzICgzKTogMTMwXHUyMDEzMzcuIGRvaTpbMTAuMTEwOC9lYjA0NjgxNF1bQHBvcnRlcjoxOTgwXS5cbipcbiogW0Bwb3J0ZXI6MTk4MF06IGh0dHBzOi8vZG9pLm9yZy8xMC4xMTA4L2ViMDQ2ODE0XG4qXG4qIEBwYXJhbSB7c3RyaW5nfSB3b3JkIC0gaW5wdXQgd29yZFxuKiBAdGhyb3dzIHtUeXBlRXJyb3J9IGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcgcHJpbWl0aXZlXG4qIEByZXR1cm5zIHtzdHJpbmd9IHdvcmQgc3RlbVxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgb3V0ID0gcG9ydGVyU3RlbW1lciggJ3dhbGtpbmcnICk7XG4qIC8vIHJldHVybnMgJ3dhbGsnXG4qXG4qIEBleGFtcGxlXG4qIHZhciBvdXQgPSBwb3J0ZXJTdGVtbWVyKCAnd2Fsa2VkJyApO1xuKiAvLyByZXR1cm5zICd3YWxrJ1xuKlxuKiBAZXhhbXBsZVxuKiB2YXIgb3V0ID0gcG9ydGVyU3RlbW1lciggJ3dhbGtzJyApO1xuKiAvLyByZXR1cm5zICd3YWxrJ1xuKlxuKiBAZXhhbXBsZVxuKiB2YXIgb3V0ID0gcG9ydGVyU3RlbW1lciggJ3dvcmxkd2lkZScgKTtcbiogLy8gcmV0dXJucyAnd29ybGR3aWQnXG4qXG4qIEBleGFtcGxlXG4qIHZhciBvdXQgPSBwb3J0ZXJTdGVtbWVyKCAnJyApO1xuKiAvLyByZXR1cm5zICcnXG4qL1xuZnVuY3Rpb24gcG9ydGVyU3RlbW1lciggd29yZCApIHtcblx0dmFyIGZpcnN0Y2g7XG5cdHZhciBzdWZmaXg7XG5cdHZhciBzdGVtO1xuXHR2YXIgZnA7XG5cblx0aWYgKCAhaXNTdHJpbmcoIHdvcmQgKSApIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnaW52YWxpZCBhcmd1bWVudC4gRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZyBwcmltaXRpdmUuIFZhbHVlOiBgJyArIHdvcmQgKyAnYC4nICk7XG5cdH1cblx0aWYgKCB3b3JkLmxlbmd0aCA8IDMgKSB7XG5cdFx0cmV0dXJuIHdvcmQ7XG5cdH1cblx0d29yZCA9IGxvd2VyY2FzZSggd29yZCApO1xuXHRmaXJzdGNoID0gd29yZFsgMCBdO1xuXHRpZiAoIGZpcnN0Y2ggPT09ICd5JyApIHtcblx0XHR3b3JkID0gZmlyc3RjaC50b1VwcGVyQ2FzZSgpICsgd29yZC5zdWJzdHIoIDEgKTtcblx0fVxuXG5cdC8vIFN0ZXAgMWE6XG5cdGlmICggUkVfU1RFUDFBLnRlc3QoIHdvcmQgKSApIHtcblx0XHR3b3JkID0gcmVwbGFjZSggd29yZCwgUkVfU1RFUDFBLCAnJDEkMicgKTtcblx0fSBlbHNlIGlmICggUkUyX1NURVAxQS50ZXN0KCB3b3JkICkgKSB7XG5cdFx0d29yZCA9IHJlcGxhY2UoIHdvcmQsIFJFMl9TVEVQMUEsICckMSQyJyApO1xuXHR9XG5cblx0Ly8gU3RlcCAxYjpcblx0aWYgKCBSRV9TVEVQMUIudGVzdCggd29yZCApICkge1xuXHRcdGZwID0gUkVfU1RFUDFCLmV4ZWMoIHdvcmQgKTtcblx0XHRpZiAoIFJFX01HUjAudGVzdCggZnBbIDEgXSApICkge1xuXHRcdFx0d29yZCA9IHJlcGxhY2UoIHdvcmQsIFJFX0xBU1QsICcnICk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBSRTJfU1RFUDFCLnRlc3QoIHdvcmQgKSApIHtcblx0XHRmcCA9IFJFMl9TVEVQMUIuZXhlYyggd29yZCApO1xuXHRcdHN0ZW0gPSBmcFsgMSBdO1xuXHRcdGlmICggUkVfU1YudGVzdCggc3RlbSApICkge1xuXHRcdFx0d29yZCA9IHN0ZW07XG5cdFx0XHRpZiAoIFJFX0FUQkxJWi50ZXN0KCB3b3JkICkgKSB7XG5cdFx0XHRcdHdvcmQgKz0gJ2UnO1xuXHRcdFx0fSBlbHNlIGlmICggUkVfRE9VQkxFLnRlc3QoIHdvcmQgKSApIHtcblx0XHRcdFx0d29yZCA9IHJlcGxhY2UoIHdvcmQsIFJFX0xBU1QsICcnICk7XG5cdFx0XHR9IGVsc2UgaWYgKCBSRV9DVi50ZXN0KCB3b3JkICkgKSB7XG5cdFx0XHRcdHdvcmQgKz0gJ2UnO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFN0ZXAgMWM6XG5cdGlmICggUkVfU1RFUDFDLnRlc3QoIHdvcmQgKSApIHtcblx0XHRmcCA9IFJFX1NURVAxQy5leGVjKCB3b3JkICk7XG5cdFx0c3RlbSA9IGZwWyAxIF07XG5cdFx0aWYgKCBSRV9TVi50ZXN0KCBzdGVtICkgKSB7XG5cdFx0XHR3b3JkID0gc3RlbSArICdpJztcblx0XHR9XG5cdH1cblxuXHQvLyBTdGVwIDI6XG5cdGlmICggUkVfU1RFUDIudGVzdCggd29yZCApICkge1xuXHRcdGZwID0gUkVfU1RFUDIuZXhlYyggd29yZCApO1xuXHRcdHN0ZW0gPSBmcFsgMSBdO1xuXHRcdHN1ZmZpeCA9IGZwWyAyIF07XG5cdFx0aWYgKCBSRV9NR1IwLnRlc3QoIHN0ZW0gKSApIHtcblx0XHRcdHdvcmQgPSBzdGVtICsgc3RlcDJsaXN0WyBzdWZmaXggXTtcblx0XHR9XG5cdH1cblxuXHQvLyBTdGVwIDM6XG5cdGlmICggUkVfU1RFUDMudGVzdCggd29yZCApICkge1xuXHRcdGZwID0gUkVfU1RFUDMuZXhlYyggd29yZCApO1xuXHRcdHN0ZW0gPSBmcFsgMSBdO1xuXHRcdHN1ZmZpeCA9IGZwWyAyIF07XG5cdFx0aWYgKCBSRV9NR1IwLnRlc3QoIHN0ZW0gKSApIHtcblx0XHRcdHdvcmQgPSBzdGVtICsgc3RlcDNsaXN0WyBzdWZmaXggXTtcblx0XHR9XG5cdH1cblxuXHQvLyBTdGVwIDQ6XG5cdGlmICggUkVfU1RFUDQudGVzdCggd29yZCApICkge1xuXHRcdGZwID0gUkVfU1RFUDQuZXhlYyggd29yZCApO1xuXHRcdHN0ZW0gPSBmcFsgMSBdO1xuXHRcdGlmICggUkVfTUdSMS50ZXN0KCBzdGVtICkgKSB7XG5cdFx0XHR3b3JkID0gc3RlbTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoIFJFMl9TVEVQNC50ZXN0KCB3b3JkICkgKSB7XG5cdFx0ZnAgPSBSRTJfU1RFUDQuZXhlYyggd29yZCApO1xuXHRcdHN0ZW0gPSBmcFsgMSBdICsgZnBbIDIgXTtcblx0XHRpZiAoIFJFX01HUjEudGVzdCggc3RlbSApICkge1xuXHRcdFx0d29yZCA9IHN0ZW07XG5cdFx0fVxuXHR9XG5cblx0Ly8gU3RlcCA1OlxuXHRpZiAoIFJFX1NURVA1LnRlc3QoIHdvcmQgKSApIHtcblx0XHRmcCA9IFJFX1NURVA1LmV4ZWMoIHdvcmQgKTtcblx0XHRzdGVtID0gZnBbIDEgXTtcblx0XHRpZiAoXG5cdFx0XHRSRV9NR1IxLnRlc3QoIHN0ZW0gKSB8fFxuXHRcdFx0KCBSRV9NRVExLnRlc3QoIHN0ZW0gKSAmJiAhKCBSRV9DVi50ZXN0KCBzdGVtICkgKSApXG5cdFx0KSB7XG5cdFx0XHR3b3JkID0gc3RlbTtcblx0XHR9XG5cdH1cblx0aWYgKCBlbmRzV2l0aCggd29yZCwgJ2xsJyApICYmIFJFX01HUjEudGVzdCggd29yZCApICkge1xuXHRcdHdvcmQgPSByZXBsYWNlKCB3b3JkLCBSRV9MQVNULCAnJyApO1xuXHR9XG5cblx0Ly8gVHVybiBpbml0aWFsIFkgYmFjayB0byB5OlxuXHRpZiAoIGZpcnN0Y2ggPT09ICd5JyApIHtcblx0XHR3b3JkID0gZmlyc3RjaC50b0xvd2VyQ2FzZSgpICsgd29yZC5zdWJzdHIoIDEgKTtcblx0fVxuXHRyZXR1cm4gd29yZDtcbn1cblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gcG9ydGVyU3RlbW1lcjtcbiIsICIvKipcbiogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTkgVGhlIFN0ZGxpYiBBdXRob3JzLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogRXh0cmFjdCB0aGUgc3RlbSBvZiBhIGdpdmVuIHdvcmQuXG4qXG4qIEBtb2R1bGUgQHN0ZGxpYi9ubHAtcG9ydGVyLXN0ZW1tZXJcbipcbiogQGV4YW1wbGVcbiogdmFyIHBvcnRlclN0ZW1tZXIgPSByZXF1aXJlKCAnQHN0ZGxpYi9ubHAtcG9ydGVyLXN0ZW1tZXInICk7XG4qXG4qIHZhciBvdXQgPSBwb3J0ZXJTdGVtbWVyKCAnd2Fsa2luZycgKTtcbiogLy8gcmV0dXJucyAnd2Fsaydcbipcbiogb3V0ID0gcG9ydGVyU3RlbW1lciggJ3dhbGtlZCcgKTtcbiogLy8gcmV0dXJucyAnd2Fsaydcbipcbiogb3V0ID0gcG9ydGVyU3RlbW1lciggJ3dhbGtzJyApO1xuKiAvLyByZXR1cm5zICd3YWxrJ1xuKi9cblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgcG9ydGVyU3RlbW1lciA9IHJlcXVpcmUoICcuL21haW4uanMnICk7XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBvcnRlclN0ZW1tZXI7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmlzSW50ZWdlciA9IG51bSA9PiB7XG4gIGlmICh0eXBlb2YgbnVtID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKG51bSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBudW0gPT09ICdzdHJpbmcnICYmIG51bS50cmltKCkgIT09ICcnKSB7XG4gICAgcmV0dXJuIE51bWJlci5pc0ludGVnZXIoTnVtYmVyKG51bSkpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogRmluZCBhIG5vZGUgb2YgdGhlIGdpdmVuIHR5cGVcbiAqL1xuXG5leHBvcnRzLmZpbmQgPSAobm9kZSwgdHlwZSkgPT4gbm9kZS5ub2Rlcy5maW5kKG5vZGUgPT4gbm9kZS50eXBlID09PSB0eXBlKTtcblxuLyoqXG4gKiBGaW5kIGEgbm9kZSBvZiB0aGUgZ2l2ZW4gdHlwZVxuICovXG5cbmV4cG9ydHMuZXhjZWVkc0xpbWl0ID0gKG1pbiwgbWF4LCBzdGVwID0gMSwgbGltaXQpID0+IHtcbiAgaWYgKGxpbWl0ID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoIWV4cG9ydHMuaXNJbnRlZ2VyKG1pbikgfHwgIWV4cG9ydHMuaXNJbnRlZ2VyKG1heCkpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuICgoTnVtYmVyKG1heCkgLSBOdW1iZXIobWluKSkgLyBOdW1iZXIoc3RlcCkpID49IGxpbWl0O1xufTtcblxuLyoqXG4gKiBFc2NhcGUgdGhlIGdpdmVuIG5vZGUgd2l0aCAnXFxcXCcgYmVmb3JlIG5vZGUudmFsdWVcbiAqL1xuXG5leHBvcnRzLmVzY2FwZU5vZGUgPSAoYmxvY2ssIG4gPSAwLCB0eXBlKSA9PiB7XG4gIGxldCBub2RlID0gYmxvY2subm9kZXNbbl07XG4gIGlmICghbm9kZSkgcmV0dXJuO1xuXG4gIGlmICgodHlwZSAmJiBub2RlLnR5cGUgPT09IHR5cGUpIHx8IG5vZGUudHlwZSA9PT0gJ29wZW4nIHx8IG5vZGUudHlwZSA9PT0gJ2Nsb3NlJykge1xuICAgIGlmIChub2RlLmVzY2FwZWQgIT09IHRydWUpIHtcbiAgICAgIG5vZGUudmFsdWUgPSAnXFxcXCcgKyBub2RlLnZhbHVlO1xuICAgICAgbm9kZS5lc2NhcGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBicmFjZSBub2RlIHNob3VsZCBiZSBlbmNsb3NlZCBpbiBsaXRlcmFsIGJyYWNlc1xuICovXG5cbmV4cG9ydHMuZW5jbG9zZUJyYWNlID0gbm9kZSA9PiB7XG4gIGlmIChub2RlLnR5cGUgIT09ICdicmFjZScpIHJldHVybiBmYWxzZTtcbiAgaWYgKChub2RlLmNvbW1hcyA+PiAwICsgbm9kZS5yYW5nZXMgPj4gMCkgPT09IDApIHtcbiAgICBub2RlLmludmFsaWQgPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGEgYnJhY2Ugbm9kZSBpcyBpbnZhbGlkLlxuICovXG5cbmV4cG9ydHMuaXNJbnZhbGlkQnJhY2UgPSBibG9jayA9PiB7XG4gIGlmIChibG9jay50eXBlICE9PSAnYnJhY2UnKSByZXR1cm4gZmFsc2U7XG4gIGlmIChibG9jay5pbnZhbGlkID09PSB0cnVlIHx8IGJsb2NrLmRvbGxhcikgcmV0dXJuIHRydWU7XG4gIGlmICgoYmxvY2suY29tbWFzID4+IDAgKyBibG9jay5yYW5nZXMgPj4gMCkgPT09IDApIHtcbiAgICBibG9jay5pbnZhbGlkID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoYmxvY2sub3BlbiAhPT0gdHJ1ZSB8fCBibG9jay5jbG9zZSAhPT0gdHJ1ZSkge1xuICAgIGJsb2NrLmludmFsaWQgPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGEgbm9kZSBpcyBhbiBvcGVuIG9yIGNsb3NlIG5vZGVcbiAqL1xuXG5leHBvcnRzLmlzT3Blbk9yQ2xvc2UgPSBub2RlID0+IHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gJ29wZW4nIHx8IG5vZGUudHlwZSA9PT0gJ2Nsb3NlJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBub2RlLm9wZW4gPT09IHRydWUgfHwgbm9kZS5jbG9zZSA9PT0gdHJ1ZTtcbn07XG5cbi8qKlxuICogUmVkdWNlIGFuIGFycmF5IG9mIHRleHQgbm9kZXMuXG4gKi9cblxuZXhwb3J0cy5yZWR1Y2UgPSBub2RlcyA9PiBub2Rlcy5yZWR1Y2UoKGFjYywgbm9kZSkgPT4ge1xuICBpZiAobm9kZS50eXBlID09PSAndGV4dCcpIGFjYy5wdXNoKG5vZGUudmFsdWUpO1xuICBpZiAobm9kZS50eXBlID09PSAncmFuZ2UnKSBub2RlLnR5cGUgPSAndGV4dCc7XG4gIHJldHVybiBhY2M7XG59LCBbXSk7XG5cbi8qKlxuICogRmxhdHRlbiBhbiBhcnJheVxuICovXG5cbmV4cG9ydHMuZmxhdHRlbiA9ICguLi5hcmdzKSA9PiB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBmbGF0ID0gYXJyID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGVsZSA9IGFycltpXTtcbiAgICAgIEFycmF5LmlzQXJyYXkoZWxlKSA/IGZsYXQoZWxlLCByZXN1bHQpIDogZWxlICE9PSB2b2lkIDAgJiYgcmVzdWx0LnB1c2goZWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgZmxhdChhcmdzKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoYXN0LCBvcHRpb25zID0ge30pID0+IHtcbiAgbGV0IHN0cmluZ2lmeSA9IChub2RlLCBwYXJlbnQgPSB7fSkgPT4ge1xuICAgIGxldCBpbnZhbGlkQmxvY2sgPSBvcHRpb25zLmVzY2FwZUludmFsaWQgJiYgdXRpbHMuaXNJbnZhbGlkQnJhY2UocGFyZW50KTtcbiAgICBsZXQgaW52YWxpZE5vZGUgPSBub2RlLmludmFsaWQgPT09IHRydWUgJiYgb3B0aW9ucy5lc2NhcGVJbnZhbGlkID09PSB0cnVlO1xuICAgIGxldCBvdXRwdXQgPSAnJztcblxuICAgIGlmIChub2RlLnZhbHVlKSB7XG4gICAgICBpZiAoKGludmFsaWRCbG9jayB8fCBpbnZhbGlkTm9kZSkgJiYgdXRpbHMuaXNPcGVuT3JDbG9zZShub2RlKSkge1xuICAgICAgICByZXR1cm4gJ1xcXFwnICsgbm9kZS52YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlLnZhbHVlO1xuICAgIH1cblxuICAgIGlmIChub2RlLnZhbHVlKSB7XG4gICAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS5ub2Rlcykge1xuICAgICAgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5ub2Rlcykge1xuICAgICAgICBvdXRwdXQgKz0gc3RyaW5naWZ5KGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcblxuICByZXR1cm4gc3RyaW5naWZ5KGFzdCk7XG59O1xuXG4iLCAiLyohXG4gKiBpcy1udW1iZXIgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2lzLW51bWJlcj5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG51bSkge1xuICBpZiAodHlwZW9mIG51bSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gbnVtIC0gbnVtID09PSAwO1xuICB9XG4gIGlmICh0eXBlb2YgbnVtID09PSAnc3RyaW5nJyAmJiBudW0udHJpbSgpICE9PSAnJykge1xuICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUgPyBOdW1iZXIuaXNGaW5pdGUoK251bSkgOiBpc0Zpbml0ZSgrbnVtKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuIiwgIi8qIVxuICogdG8tcmVnZXgtcmFuZ2UgPGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb21hdGNoL3RvLXJlZ2V4LXJhbmdlPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50LCBKb24gU2NobGlua2VydC5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IGlzTnVtYmVyID0gcmVxdWlyZSgnaXMtbnVtYmVyJyk7XG5cbmNvbnN0IHRvUmVnZXhSYW5nZSA9IChtaW4sIG1heCwgb3B0aW9ucykgPT4ge1xuICBpZiAoaXNOdW1iZXIobWluKSA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0b1JlZ2V4UmFuZ2U6IGV4cGVjdGVkIHRoZSBmaXJzdCBhcmd1bWVudCB0byBiZSBhIG51bWJlcicpO1xuICB9XG5cbiAgaWYgKG1heCA9PT0gdm9pZCAwIHx8IG1pbiA9PT0gbWF4KSB7XG4gICAgcmV0dXJuIFN0cmluZyhtaW4pO1xuICB9XG5cbiAgaWYgKGlzTnVtYmVyKG1heCkgPT09IGZhbHNlKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndG9SZWdleFJhbmdlOiBleHBlY3RlZCB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIGEgbnVtYmVyLicpO1xuICB9XG5cbiAgbGV0IG9wdHMgPSB7IHJlbGF4WmVyb3M6IHRydWUsIC4uLm9wdGlvbnMgfTtcbiAgaWYgKHR5cGVvZiBvcHRzLnN0cmljdFplcm9zID09PSAnYm9vbGVhbicpIHtcbiAgICBvcHRzLnJlbGF4WmVyb3MgPSBvcHRzLnN0cmljdFplcm9zID09PSBmYWxzZTtcbiAgfVxuXG4gIGxldCByZWxheCA9IFN0cmluZyhvcHRzLnJlbGF4WmVyb3MpO1xuICBsZXQgc2hvcnRoYW5kID0gU3RyaW5nKG9wdHMuc2hvcnRoYW5kKTtcbiAgbGV0IGNhcHR1cmUgPSBTdHJpbmcob3B0cy5jYXB0dXJlKTtcbiAgbGV0IHdyYXAgPSBTdHJpbmcob3B0cy53cmFwKTtcbiAgbGV0IGNhY2hlS2V5ID0gbWluICsgJzonICsgbWF4ICsgJz0nICsgcmVsYXggKyBzaG9ydGhhbmQgKyBjYXB0dXJlICsgd3JhcDtcblxuICBpZiAodG9SZWdleFJhbmdlLmNhY2hlLmhhc093blByb3BlcnR5KGNhY2hlS2V5KSkge1xuICAgIHJldHVybiB0b1JlZ2V4UmFuZ2UuY2FjaGVbY2FjaGVLZXldLnJlc3VsdDtcbiAgfVxuXG4gIGxldCBhID0gTWF0aC5taW4obWluLCBtYXgpO1xuICBsZXQgYiA9IE1hdGgubWF4KG1pbiwgbWF4KTtcblxuICBpZiAoTWF0aC5hYnMoYSAtIGIpID09PSAxKSB7XG4gICAgbGV0IHJlc3VsdCA9IG1pbiArICd8JyArIG1heDtcbiAgICBpZiAob3B0cy5jYXB0dXJlKSB7XG4gICAgICByZXR1cm4gYCgke3Jlc3VsdH0pYDtcbiAgICB9XG4gICAgaWYgKG9wdHMud3JhcCA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBgKD86JHtyZXN1bHR9KWA7XG4gIH1cblxuICBsZXQgaXNQYWRkZWQgPSBoYXNQYWRkaW5nKG1pbikgfHwgaGFzUGFkZGluZyhtYXgpO1xuICBsZXQgc3RhdGUgPSB7IG1pbiwgbWF4LCBhLCBiIH07XG4gIGxldCBwb3NpdGl2ZXMgPSBbXTtcbiAgbGV0IG5lZ2F0aXZlcyA9IFtdO1xuXG4gIGlmIChpc1BhZGRlZCkge1xuICAgIHN0YXRlLmlzUGFkZGVkID0gaXNQYWRkZWQ7XG4gICAgc3RhdGUubWF4TGVuID0gU3RyaW5nKHN0YXRlLm1heCkubGVuZ3RoO1xuICB9XG5cbiAgaWYgKGEgPCAwKSB7XG4gICAgbGV0IG5ld01pbiA9IGIgPCAwID8gTWF0aC5hYnMoYikgOiAxO1xuICAgIG5lZ2F0aXZlcyA9IHNwbGl0VG9QYXR0ZXJucyhuZXdNaW4sIE1hdGguYWJzKGEpLCBzdGF0ZSwgb3B0cyk7XG4gICAgYSA9IHN0YXRlLmEgPSAwO1xuICB9XG5cbiAgaWYgKGIgPj0gMCkge1xuICAgIHBvc2l0aXZlcyA9IHNwbGl0VG9QYXR0ZXJucyhhLCBiLCBzdGF0ZSwgb3B0cyk7XG4gIH1cblxuICBzdGF0ZS5uZWdhdGl2ZXMgPSBuZWdhdGl2ZXM7XG4gIHN0YXRlLnBvc2l0aXZlcyA9IHBvc2l0aXZlcztcbiAgc3RhdGUucmVzdWx0ID0gY29sbGF0ZVBhdHRlcm5zKG5lZ2F0aXZlcywgcG9zaXRpdmVzLCBvcHRzKTtcblxuICBpZiAob3B0cy5jYXB0dXJlID09PSB0cnVlKSB7XG4gICAgc3RhdGUucmVzdWx0ID0gYCgke3N0YXRlLnJlc3VsdH0pYDtcbiAgfSBlbHNlIGlmIChvcHRzLndyYXAgIT09IGZhbHNlICYmIChwb3NpdGl2ZXMubGVuZ3RoICsgbmVnYXRpdmVzLmxlbmd0aCkgPiAxKSB7XG4gICAgc3RhdGUucmVzdWx0ID0gYCg/OiR7c3RhdGUucmVzdWx0fSlgO1xuICB9XG5cbiAgdG9SZWdleFJhbmdlLmNhY2hlW2NhY2hlS2V5XSA9IHN0YXRlO1xuICByZXR1cm4gc3RhdGUucmVzdWx0O1xufTtcblxuZnVuY3Rpb24gY29sbGF0ZVBhdHRlcm5zKG5lZywgcG9zLCBvcHRpb25zKSB7XG4gIGxldCBvbmx5TmVnYXRpdmUgPSBmaWx0ZXJQYXR0ZXJucyhuZWcsIHBvcywgJy0nLCBmYWxzZSwgb3B0aW9ucykgfHwgW107XG4gIGxldCBvbmx5UG9zaXRpdmUgPSBmaWx0ZXJQYXR0ZXJucyhwb3MsIG5lZywgJycsIGZhbHNlLCBvcHRpb25zKSB8fCBbXTtcbiAgbGV0IGludGVyc2VjdGVkID0gZmlsdGVyUGF0dGVybnMobmVnLCBwb3MsICctPycsIHRydWUsIG9wdGlvbnMpIHx8IFtdO1xuICBsZXQgc3VicGF0dGVybnMgPSBvbmx5TmVnYXRpdmUuY29uY2F0KGludGVyc2VjdGVkKS5jb25jYXQob25seVBvc2l0aXZlKTtcbiAgcmV0dXJuIHN1YnBhdHRlcm5zLmpvaW4oJ3wnKTtcbn1cblxuZnVuY3Rpb24gc3BsaXRUb1JhbmdlcyhtaW4sIG1heCkge1xuICBsZXQgbmluZXMgPSAxO1xuICBsZXQgemVyb3MgPSAxO1xuXG4gIGxldCBzdG9wID0gY291bnROaW5lcyhtaW4sIG5pbmVzKTtcbiAgbGV0IHN0b3BzID0gbmV3IFNldChbbWF4XSk7XG5cbiAgd2hpbGUgKG1pbiA8PSBzdG9wICYmIHN0b3AgPD0gbWF4KSB7XG4gICAgc3RvcHMuYWRkKHN0b3ApO1xuICAgIG5pbmVzICs9IDE7XG4gICAgc3RvcCA9IGNvdW50TmluZXMobWluLCBuaW5lcyk7XG4gIH1cblxuICBzdG9wID0gY291bnRaZXJvcyhtYXggKyAxLCB6ZXJvcykgLSAxO1xuXG4gIHdoaWxlIChtaW4gPCBzdG9wICYmIHN0b3AgPD0gbWF4KSB7XG4gICAgc3RvcHMuYWRkKHN0b3ApO1xuICAgIHplcm9zICs9IDE7XG4gICAgc3RvcCA9IGNvdW50WmVyb3MobWF4ICsgMSwgemVyb3MpIC0gMTtcbiAgfVxuXG4gIHN0b3BzID0gWy4uLnN0b3BzXTtcbiAgc3RvcHMuc29ydChjb21wYXJlKTtcbiAgcmV0dXJuIHN0b3BzO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYSByYW5nZSB0byBhIHJlZ2V4IHBhdHRlcm5cbiAqIEBwYXJhbSB7TnVtYmVyfSBgc3RhcnRgXG4gKiBAcGFyYW0ge051bWJlcn0gYHN0b3BgXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gcmFuZ2VUb1BhdHRlcm4oc3RhcnQsIHN0b3AsIG9wdGlvbnMpIHtcbiAgaWYgKHN0YXJ0ID09PSBzdG9wKSB7XG4gICAgcmV0dXJuIHsgcGF0dGVybjogc3RhcnQsIGNvdW50OiBbXSwgZGlnaXRzOiAwIH07XG4gIH1cblxuICBsZXQgemlwcGVkID0gemlwKHN0YXJ0LCBzdG9wKTtcbiAgbGV0IGRpZ2l0cyA9IHppcHBlZC5sZW5ndGg7XG4gIGxldCBwYXR0ZXJuID0gJyc7XG4gIGxldCBjb3VudCA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaWdpdHM7IGkrKykge1xuICAgIGxldCBbc3RhcnREaWdpdCwgc3RvcERpZ2l0XSA9IHppcHBlZFtpXTtcblxuICAgIGlmIChzdGFydERpZ2l0ID09PSBzdG9wRGlnaXQpIHtcbiAgICAgIHBhdHRlcm4gKz0gc3RhcnREaWdpdDtcblxuICAgIH0gZWxzZSBpZiAoc3RhcnREaWdpdCAhPT0gJzAnIHx8IHN0b3BEaWdpdCAhPT0gJzknKSB7XG4gICAgICBwYXR0ZXJuICs9IHRvQ2hhcmFjdGVyQ2xhc3Moc3RhcnREaWdpdCwgc3RvcERpZ2l0LCBvcHRpb25zKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCsrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjb3VudCkge1xuICAgIHBhdHRlcm4gKz0gb3B0aW9ucy5zaG9ydGhhbmQgPT09IHRydWUgPyAnXFxcXGQnIDogJ1swLTldJztcbiAgfVxuXG4gIHJldHVybiB7IHBhdHRlcm4sIGNvdW50OiBbY291bnRdLCBkaWdpdHMgfTtcbn1cblxuZnVuY3Rpb24gc3BsaXRUb1BhdHRlcm5zKG1pbiwgbWF4LCB0b2ssIG9wdGlvbnMpIHtcbiAgbGV0IHJhbmdlcyA9IHNwbGl0VG9SYW5nZXMobWluLCBtYXgpO1xuICBsZXQgdG9rZW5zID0gW107XG4gIGxldCBzdGFydCA9IG1pbjtcbiAgbGV0IHByZXY7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgbWF4ID0gcmFuZ2VzW2ldO1xuICAgIGxldCBvYmogPSByYW5nZVRvUGF0dGVybihTdHJpbmcoc3RhcnQpLCBTdHJpbmcobWF4KSwgb3B0aW9ucyk7XG4gICAgbGV0IHplcm9zID0gJyc7XG5cbiAgICBpZiAoIXRvay5pc1BhZGRlZCAmJiBwcmV2ICYmIHByZXYucGF0dGVybiA9PT0gb2JqLnBhdHRlcm4pIHtcbiAgICAgIGlmIChwcmV2LmNvdW50Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcHJldi5jb3VudC5wb3AoKTtcbiAgICAgIH1cblxuICAgICAgcHJldi5jb3VudC5wdXNoKG9iai5jb3VudFswXSk7XG4gICAgICBwcmV2LnN0cmluZyA9IHByZXYucGF0dGVybiArIHRvUXVhbnRpZmllcihwcmV2LmNvdW50KTtcbiAgICAgIHN0YXJ0ID0gbWF4ICsgMTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICh0b2suaXNQYWRkZWQpIHtcbiAgICAgIHplcm9zID0gcGFkWmVyb3MobWF4LCB0b2ssIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIG9iai5zdHJpbmcgPSB6ZXJvcyArIG9iai5wYXR0ZXJuICsgdG9RdWFudGlmaWVyKG9iai5jb3VudCk7XG4gICAgdG9rZW5zLnB1c2gob2JqKTtcbiAgICBzdGFydCA9IG1heCArIDE7XG4gICAgcHJldiA9IG9iajtcbiAgfVxuXG4gIHJldHVybiB0b2tlbnM7XG59XG5cbmZ1bmN0aW9uIGZpbHRlclBhdHRlcm5zKGFyciwgY29tcGFyaXNvbiwgcHJlZml4LCBpbnRlcnNlY3Rpb24sIG9wdGlvbnMpIHtcbiAgbGV0IHJlc3VsdCA9IFtdO1xuXG4gIGZvciAobGV0IGVsZSBvZiBhcnIpIHtcbiAgICBsZXQgeyBzdHJpbmcgfSA9IGVsZTtcblxuICAgIC8vIG9ubHkgcHVzaCBpZiBfYm90aF8gYXJlIG5lZ2F0aXZlLi4uXG4gICAgaWYgKCFpbnRlcnNlY3Rpb24gJiYgIWNvbnRhaW5zKGNvbXBhcmlzb24sICdzdHJpbmcnLCBzdHJpbmcpKSB7XG4gICAgICByZXN1bHQucHVzaChwcmVmaXggKyBzdHJpbmcpO1xuICAgIH1cblxuICAgIC8vIG9yIF9ib3RoXyBhcmUgcG9zaXRpdmVcbiAgICBpZiAoaW50ZXJzZWN0aW9uICYmIGNvbnRhaW5zKGNvbXBhcmlzb24sICdzdHJpbmcnLCBzdHJpbmcpKSB7XG4gICAgICByZXN1bHQucHVzaChwcmVmaXggKyBzdHJpbmcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFppcCBzdHJpbmdzXG4gKi9cblxuZnVuY3Rpb24gemlwKGEsIGIpIHtcbiAgbGV0IGFyciA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIGFyci5wdXNoKFthW2ldLCBiW2ldXSk7XG4gIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICByZXR1cm4gYSA+IGIgPyAxIDogYiA+IGEgPyAtMSA6IDA7XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zKGFyciwga2V5LCB2YWwpIHtcbiAgcmV0dXJuIGFyci5zb21lKGVsZSA9PiBlbGVba2V5XSA9PT0gdmFsKTtcbn1cblxuZnVuY3Rpb24gY291bnROaW5lcyhtaW4sIGxlbikge1xuICByZXR1cm4gTnVtYmVyKFN0cmluZyhtaW4pLnNsaWNlKDAsIC1sZW4pICsgJzknLnJlcGVhdChsZW4pKTtcbn1cblxuZnVuY3Rpb24gY291bnRaZXJvcyhpbnRlZ2VyLCB6ZXJvcykge1xuICByZXR1cm4gaW50ZWdlciAtIChpbnRlZ2VyICUgTWF0aC5wb3coMTAsIHplcm9zKSk7XG59XG5cbmZ1bmN0aW9uIHRvUXVhbnRpZmllcihkaWdpdHMpIHtcbiAgbGV0IFtzdGFydCA9IDAsIHN0b3AgPSAnJ10gPSBkaWdpdHM7XG4gIGlmIChzdG9wIHx8IHN0YXJ0ID4gMSkge1xuICAgIHJldHVybiBgeyR7c3RhcnQgKyAoc3RvcCA/ICcsJyArIHN0b3AgOiAnJyl9fWA7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiB0b0NoYXJhY3RlckNsYXNzKGEsIGIsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGBbJHthfSR7KGIgLSBhID09PSAxKSA/ICcnIDogJy0nfSR7Yn1dYDtcbn1cblxuZnVuY3Rpb24gaGFzUGFkZGluZyhzdHIpIHtcbiAgcmV0dXJuIC9eLT8oMCspXFxkLy50ZXN0KHN0cik7XG59XG5cbmZ1bmN0aW9uIHBhZFplcm9zKHZhbHVlLCB0b2ssIG9wdGlvbnMpIHtcbiAgaWYgKCF0b2suaXNQYWRkZWQpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBsZXQgZGlmZiA9IE1hdGguYWJzKHRvay5tYXhMZW4gLSBTdHJpbmcodmFsdWUpLmxlbmd0aCk7XG4gIGxldCByZWxheCA9IG9wdGlvbnMucmVsYXhaZXJvcyAhPT0gZmFsc2U7XG5cbiAgc3dpdGNoIChkaWZmKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuICcnO1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiByZWxheCA/ICcwPycgOiAnMCc7XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIHJlbGF4ID8gJzB7MCwyfScgOiAnMDAnO1xuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHJldHVybiByZWxheCA/IGAwezAsJHtkaWZmfX1gIDogYDB7JHtkaWZmfX1gO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENhY2hlXG4gKi9cblxudG9SZWdleFJhbmdlLmNhY2hlID0ge307XG50b1JlZ2V4UmFuZ2UuY2xlYXJDYWNoZSA9ICgpID0+ICh0b1JlZ2V4UmFuZ2UuY2FjaGUgPSB7fSk7XG5cbi8qKlxuICogRXhwb3NlIGB0b1JlZ2V4UmFuZ2VgXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB0b1JlZ2V4UmFuZ2U7XG4iLCAiLyohXG4gKiBmaWxsLXJhbmdlIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9maWxsLXJhbmdlPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBKb24gU2NobGlua2VydC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCB0b1JlZ2V4UmFuZ2UgPSByZXF1aXJlKCd0by1yZWdleC1yYW5nZScpO1xuXG5jb25zdCBpc09iamVjdCA9IHZhbCA9PiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodmFsKTtcblxuY29uc3QgdHJhbnNmb3JtID0gdG9OdW1iZXIgPT4ge1xuICByZXR1cm4gdmFsdWUgPT4gdG9OdW1iZXIgPT09IHRydWUgPyBOdW1iZXIodmFsdWUpIDogU3RyaW5nKHZhbHVlKTtcbn07XG5cbmNvbnN0IGlzVmFsaWRWYWx1ZSA9IHZhbHVlID0+IHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUgIT09ICcnKTtcbn07XG5cbmNvbnN0IGlzTnVtYmVyID0gbnVtID0+IE51bWJlci5pc0ludGVnZXIoK251bSk7XG5cbmNvbnN0IHplcm9zID0gaW5wdXQgPT4ge1xuICBsZXQgdmFsdWUgPSBgJHtpbnB1dH1gO1xuICBsZXQgaW5kZXggPSAtMTtcbiAgaWYgKHZhbHVlWzBdID09PSAnLScpIHZhbHVlID0gdmFsdWUuc2xpY2UoMSk7XG4gIGlmICh2YWx1ZSA9PT0gJzAnKSByZXR1cm4gZmFsc2U7XG4gIHdoaWxlICh2YWx1ZVsrK2luZGV4XSA9PT0gJzAnKTtcbiAgcmV0dXJuIGluZGV4ID4gMDtcbn07XG5cbmNvbnN0IHN0cmluZ2lmeSA9IChzdGFydCwgZW5kLCBvcHRpb25zKSA9PiB7XG4gIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnMuc3RyaW5naWZ5ID09PSB0cnVlO1xufTtcblxuY29uc3QgcGFkID0gKGlucHV0LCBtYXhMZW5ndGgsIHRvTnVtYmVyKSA9PiB7XG4gIGlmIChtYXhMZW5ndGggPiAwKSB7XG4gICAgbGV0IGRhc2ggPSBpbnB1dFswXSA9PT0gJy0nID8gJy0nIDogJyc7XG4gICAgaWYgKGRhc2gpIGlucHV0ID0gaW5wdXQuc2xpY2UoMSk7XG4gICAgaW5wdXQgPSAoZGFzaCArIGlucHV0LnBhZFN0YXJ0KGRhc2ggPyBtYXhMZW5ndGggLSAxIDogbWF4TGVuZ3RoLCAnMCcpKTtcbiAgfVxuICBpZiAodG9OdW1iZXIgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIFN0cmluZyhpbnB1dCk7XG4gIH1cbiAgcmV0dXJuIGlucHV0O1xufTtcblxuY29uc3QgdG9NYXhMZW4gPSAoaW5wdXQsIG1heExlbmd0aCkgPT4ge1xuICBsZXQgbmVnYXRpdmUgPSBpbnB1dFswXSA9PT0gJy0nID8gJy0nIDogJyc7XG4gIGlmIChuZWdhdGl2ZSkge1xuICAgIGlucHV0ID0gaW5wdXQuc2xpY2UoMSk7XG4gICAgbWF4TGVuZ3RoLS07XG4gIH1cbiAgd2hpbGUgKGlucHV0Lmxlbmd0aCA8IG1heExlbmd0aCkgaW5wdXQgPSAnMCcgKyBpbnB1dDtcbiAgcmV0dXJuIG5lZ2F0aXZlID8gKCctJyArIGlucHV0KSA6IGlucHV0O1xufTtcblxuY29uc3QgdG9TZXF1ZW5jZSA9IChwYXJ0cywgb3B0aW9ucykgPT4ge1xuICBwYXJ0cy5uZWdhdGl2ZXMuc29ydCgoYSwgYikgPT4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IDApO1xuICBwYXJ0cy5wb3NpdGl2ZXMuc29ydCgoYSwgYikgPT4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IDApO1xuXG4gIGxldCBwcmVmaXggPSBvcHRpb25zLmNhcHR1cmUgPyAnJyA6ICc/Oic7XG4gIGxldCBwb3NpdGl2ZXMgPSAnJztcbiAgbGV0IG5lZ2F0aXZlcyA9ICcnO1xuICBsZXQgcmVzdWx0O1xuXG4gIGlmIChwYXJ0cy5wb3NpdGl2ZXMubGVuZ3RoKSB7XG4gICAgcG9zaXRpdmVzID0gcGFydHMucG9zaXRpdmVzLmpvaW4oJ3wnKTtcbiAgfVxuXG4gIGlmIChwYXJ0cy5uZWdhdGl2ZXMubGVuZ3RoKSB7XG4gICAgbmVnYXRpdmVzID0gYC0oJHtwcmVmaXh9JHtwYXJ0cy5uZWdhdGl2ZXMuam9pbignfCcpfSlgO1xuICB9XG5cbiAgaWYgKHBvc2l0aXZlcyAmJiBuZWdhdGl2ZXMpIHtcbiAgICByZXN1bHQgPSBgJHtwb3NpdGl2ZXN9fCR7bmVnYXRpdmVzfWA7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gcG9zaXRpdmVzIHx8IG5lZ2F0aXZlcztcbiAgfVxuXG4gIGlmIChvcHRpb25zLndyYXApIHtcbiAgICByZXR1cm4gYCgke3ByZWZpeH0ke3Jlc3VsdH0pYDtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5jb25zdCB0b1JhbmdlID0gKGEsIGIsIGlzTnVtYmVycywgb3B0aW9ucykgPT4ge1xuICBpZiAoaXNOdW1iZXJzKSB7XG4gICAgcmV0dXJuIHRvUmVnZXhSYW5nZShhLCBiLCB7IHdyYXA6IGZhbHNlLCAuLi5vcHRpb25zIH0pO1xuICB9XG5cbiAgbGV0IHN0YXJ0ID0gU3RyaW5nLmZyb21DaGFyQ29kZShhKTtcbiAgaWYgKGEgPT09IGIpIHJldHVybiBzdGFydDtcblxuICBsZXQgc3RvcCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoYik7XG4gIHJldHVybiBgWyR7c3RhcnR9LSR7c3RvcH1dYDtcbn07XG5cbmNvbnN0IHRvUmVnZXggPSAoc3RhcnQsIGVuZCwgb3B0aW9ucykgPT4ge1xuICBpZiAoQXJyYXkuaXNBcnJheShzdGFydCkpIHtcbiAgICBsZXQgd3JhcCA9IG9wdGlvbnMud3JhcCA9PT0gdHJ1ZTtcbiAgICBsZXQgcHJlZml4ID0gb3B0aW9ucy5jYXB0dXJlID8gJycgOiAnPzonO1xuICAgIHJldHVybiB3cmFwID8gYCgke3ByZWZpeH0ke3N0YXJ0LmpvaW4oJ3wnKX0pYCA6IHN0YXJ0LmpvaW4oJ3wnKTtcbiAgfVxuICByZXR1cm4gdG9SZWdleFJhbmdlKHN0YXJ0LCBlbmQsIG9wdGlvbnMpO1xufTtcblxuY29uc3QgcmFuZ2VFcnJvciA9ICguLi5hcmdzKSA9PiB7XG4gIHJldHVybiBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCByYW5nZSBhcmd1bWVudHM6ICcgKyB1dGlsLmluc3BlY3QoLi4uYXJncykpO1xufTtcblxuY29uc3QgaW52YWxpZFJhbmdlID0gKHN0YXJ0LCBlbmQsIG9wdGlvbnMpID0+IHtcbiAgaWYgKG9wdGlvbnMuc3RyaWN0UmFuZ2VzID09PSB0cnVlKSB0aHJvdyByYW5nZUVycm9yKFtzdGFydCwgZW5kXSk7XG4gIHJldHVybiBbXTtcbn07XG5cbmNvbnN0IGludmFsaWRTdGVwID0gKHN0ZXAsIG9wdGlvbnMpID0+IHtcbiAgaWYgKG9wdGlvbnMuc3RyaWN0UmFuZ2VzID09PSB0cnVlKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgc3RlcCBcIiR7c3RlcH1cIiB0byBiZSBhIG51bWJlcmApO1xuICB9XG4gIHJldHVybiBbXTtcbn07XG5cbmNvbnN0IGZpbGxOdW1iZXJzID0gKHN0YXJ0LCBlbmQsIHN0ZXAgPSAxLCBvcHRpb25zID0ge30pID0+IHtcbiAgbGV0IGEgPSBOdW1iZXIoc3RhcnQpO1xuICBsZXQgYiA9IE51bWJlcihlbmQpO1xuXG4gIGlmICghTnVtYmVyLmlzSW50ZWdlcihhKSB8fCAhTnVtYmVyLmlzSW50ZWdlcihiKSkge1xuICAgIGlmIChvcHRpb25zLnN0cmljdFJhbmdlcyA9PT0gdHJ1ZSkgdGhyb3cgcmFuZ2VFcnJvcihbc3RhcnQsIGVuZF0pO1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIC8vIGZpeCBuZWdhdGl2ZSB6ZXJvXG4gIGlmIChhID09PSAwKSBhID0gMDtcbiAgaWYgKGIgPT09IDApIGIgPSAwO1xuXG4gIGxldCBkZXNjZW5kaW5nID0gYSA+IGI7XG4gIGxldCBzdGFydFN0cmluZyA9IFN0cmluZyhzdGFydCk7XG4gIGxldCBlbmRTdHJpbmcgPSBTdHJpbmcoZW5kKTtcbiAgbGV0IHN0ZXBTdHJpbmcgPSBTdHJpbmcoc3RlcCk7XG4gIHN0ZXAgPSBNYXRoLm1heChNYXRoLmFicyhzdGVwKSwgMSk7XG5cbiAgbGV0IHBhZGRlZCA9IHplcm9zKHN0YXJ0U3RyaW5nKSB8fCB6ZXJvcyhlbmRTdHJpbmcpIHx8IHplcm9zKHN0ZXBTdHJpbmcpO1xuICBsZXQgbWF4TGVuID0gcGFkZGVkID8gTWF0aC5tYXgoc3RhcnRTdHJpbmcubGVuZ3RoLCBlbmRTdHJpbmcubGVuZ3RoLCBzdGVwU3RyaW5nLmxlbmd0aCkgOiAwO1xuICBsZXQgdG9OdW1iZXIgPSBwYWRkZWQgPT09IGZhbHNlICYmIHN0cmluZ2lmeShzdGFydCwgZW5kLCBvcHRpb25zKSA9PT0gZmFsc2U7XG4gIGxldCBmb3JtYXQgPSBvcHRpb25zLnRyYW5zZm9ybSB8fCB0cmFuc2Zvcm0odG9OdW1iZXIpO1xuXG4gIGlmIChvcHRpb25zLnRvUmVnZXggJiYgc3RlcCA9PT0gMSkge1xuICAgIHJldHVybiB0b1JhbmdlKHRvTWF4TGVuKHN0YXJ0LCBtYXhMZW4pLCB0b01heExlbihlbmQsIG1heExlbiksIHRydWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgbGV0IHBhcnRzID0geyBuZWdhdGl2ZXM6IFtdLCBwb3NpdGl2ZXM6IFtdIH07XG4gIGxldCBwdXNoID0gbnVtID0+IHBhcnRzW251bSA8IDAgPyAnbmVnYXRpdmVzJyA6ICdwb3NpdGl2ZXMnXS5wdXNoKE1hdGguYWJzKG51bSkpO1xuICBsZXQgcmFuZ2UgPSBbXTtcbiAgbGV0IGluZGV4ID0gMDtcblxuICB3aGlsZSAoZGVzY2VuZGluZyA/IGEgPj0gYiA6IGEgPD0gYikge1xuICAgIGlmIChvcHRpb25zLnRvUmVnZXggPT09IHRydWUgJiYgc3RlcCA+IDEpIHtcbiAgICAgIHB1c2goYSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlLnB1c2gocGFkKGZvcm1hdChhLCBpbmRleCksIG1heExlbiwgdG9OdW1iZXIpKTtcbiAgICB9XG4gICAgYSA9IGRlc2NlbmRpbmcgPyBhIC0gc3RlcCA6IGEgKyBzdGVwO1xuICAgIGluZGV4Kys7XG4gIH1cblxuICBpZiAob3B0aW9ucy50b1JlZ2V4ID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHN0ZXAgPiAxXG4gICAgICA/IHRvU2VxdWVuY2UocGFydHMsIG9wdGlvbnMpXG4gICAgICA6IHRvUmVnZXgocmFuZ2UsIG51bGwsIHsgd3JhcDogZmFsc2UsIC4uLm9wdGlvbnMgfSk7XG4gIH1cblxuICByZXR1cm4gcmFuZ2U7XG59O1xuXG5jb25zdCBmaWxsTGV0dGVycyA9IChzdGFydCwgZW5kLCBzdGVwID0gMSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGlmICgoIWlzTnVtYmVyKHN0YXJ0KSAmJiBzdGFydC5sZW5ndGggPiAxKSB8fCAoIWlzTnVtYmVyKGVuZCkgJiYgZW5kLmxlbmd0aCA+IDEpKSB7XG4gICAgcmV0dXJuIGludmFsaWRSYW5nZShzdGFydCwgZW5kLCBvcHRpb25zKTtcbiAgfVxuXG5cbiAgbGV0IGZvcm1hdCA9IG9wdGlvbnMudHJhbnNmb3JtIHx8ICh2YWwgPT4gU3RyaW5nLmZyb21DaGFyQ29kZSh2YWwpKTtcbiAgbGV0IGEgPSBgJHtzdGFydH1gLmNoYXJDb2RlQXQoMCk7XG4gIGxldCBiID0gYCR7ZW5kfWAuY2hhckNvZGVBdCgwKTtcblxuICBsZXQgZGVzY2VuZGluZyA9IGEgPiBiO1xuICBsZXQgbWluID0gTWF0aC5taW4oYSwgYik7XG4gIGxldCBtYXggPSBNYXRoLm1heChhLCBiKTtcblxuICBpZiAob3B0aW9ucy50b1JlZ2V4ICYmIHN0ZXAgPT09IDEpIHtcbiAgICByZXR1cm4gdG9SYW5nZShtaW4sIG1heCwgZmFsc2UsIG9wdGlvbnMpO1xuICB9XG5cbiAgbGV0IHJhbmdlID0gW107XG4gIGxldCBpbmRleCA9IDA7XG5cbiAgd2hpbGUgKGRlc2NlbmRpbmcgPyBhID49IGIgOiBhIDw9IGIpIHtcbiAgICByYW5nZS5wdXNoKGZvcm1hdChhLCBpbmRleCkpO1xuICAgIGEgPSBkZXNjZW5kaW5nID8gYSAtIHN0ZXAgOiBhICsgc3RlcDtcbiAgICBpbmRleCsrO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMudG9SZWdleCA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiB0b1JlZ2V4KHJhbmdlLCBudWxsLCB7IHdyYXA6IGZhbHNlLCBvcHRpb25zIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJhbmdlO1xufTtcblxuY29uc3QgZmlsbCA9IChzdGFydCwgZW5kLCBzdGVwLCBvcHRpb25zID0ge30pID0+IHtcbiAgaWYgKGVuZCA9PSBudWxsICYmIGlzVmFsaWRWYWx1ZShzdGFydCkpIHtcbiAgICByZXR1cm4gW3N0YXJ0XTtcbiAgfVxuXG4gIGlmICghaXNWYWxpZFZhbHVlKHN0YXJ0KSB8fCAhaXNWYWxpZFZhbHVlKGVuZCkpIHtcbiAgICByZXR1cm4gaW52YWxpZFJhbmdlKHN0YXJ0LCBlbmQsIG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBzdGVwID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZpbGwoc3RhcnQsIGVuZCwgMSwgeyB0cmFuc2Zvcm06IHN0ZXAgfSk7XG4gIH1cblxuICBpZiAoaXNPYmplY3Qoc3RlcCkpIHtcbiAgICByZXR1cm4gZmlsbChzdGFydCwgZW5kLCAwLCBzdGVwKTtcbiAgfVxuXG4gIGxldCBvcHRzID0geyAuLi5vcHRpb25zIH07XG4gIGlmIChvcHRzLmNhcHR1cmUgPT09IHRydWUpIG9wdHMud3JhcCA9IHRydWU7XG4gIHN0ZXAgPSBzdGVwIHx8IG9wdHMuc3RlcCB8fCAxO1xuXG4gIGlmICghaXNOdW1iZXIoc3RlcCkpIHtcbiAgICBpZiAoc3RlcCAhPSBudWxsICYmICFpc09iamVjdChzdGVwKSkgcmV0dXJuIGludmFsaWRTdGVwKHN0ZXAsIG9wdHMpO1xuICAgIHJldHVybiBmaWxsKHN0YXJ0LCBlbmQsIDEsIHN0ZXApO1xuICB9XG5cbiAgaWYgKGlzTnVtYmVyKHN0YXJ0KSAmJiBpc051bWJlcihlbmQpKSB7XG4gICAgcmV0dXJuIGZpbGxOdW1iZXJzKHN0YXJ0LCBlbmQsIHN0ZXAsIG9wdHMpO1xuICB9XG5cbiAgcmV0dXJuIGZpbGxMZXR0ZXJzKHN0YXJ0LCBlbmQsIE1hdGgubWF4KE1hdGguYWJzKHN0ZXApLCAxKSwgb3B0cyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbGw7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBmaWxsID0gcmVxdWlyZSgnZmlsbC1yYW5nZScpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbmNvbnN0IGNvbXBpbGUgPSAoYXN0LCBvcHRpb25zID0ge30pID0+IHtcbiAgbGV0IHdhbGsgPSAobm9kZSwgcGFyZW50ID0ge30pID0+IHtcbiAgICBsZXQgaW52YWxpZEJsb2NrID0gdXRpbHMuaXNJbnZhbGlkQnJhY2UocGFyZW50KTtcbiAgICBsZXQgaW52YWxpZE5vZGUgPSBub2RlLmludmFsaWQgPT09IHRydWUgJiYgb3B0aW9ucy5lc2NhcGVJbnZhbGlkID09PSB0cnVlO1xuICAgIGxldCBpbnZhbGlkID0gaW52YWxpZEJsb2NrID09PSB0cnVlIHx8IGludmFsaWROb2RlID09PSB0cnVlO1xuICAgIGxldCBwcmVmaXggPSBvcHRpb25zLmVzY2FwZUludmFsaWQgPT09IHRydWUgPyAnXFxcXCcgOiAnJztcbiAgICBsZXQgb3V0cHV0ID0gJyc7XG5cbiAgICBpZiAobm9kZS5pc09wZW4gPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBwcmVmaXggKyBub2RlLnZhbHVlO1xuICAgIH1cbiAgICBpZiAobm9kZS5pc0Nsb3NlID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gcHJlZml4ICsgbm9kZS52YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS50eXBlID09PSAnb3BlbicpIHtcbiAgICAgIHJldHVybiBpbnZhbGlkID8gKHByZWZpeCArIG5vZGUudmFsdWUpIDogJygnO1xuICAgIH1cblxuICAgIGlmIChub2RlLnR5cGUgPT09ICdjbG9zZScpIHtcbiAgICAgIHJldHVybiBpbnZhbGlkID8gKHByZWZpeCArIG5vZGUudmFsdWUpIDogJyknO1xuICAgIH1cblxuICAgIGlmIChub2RlLnR5cGUgPT09ICdjb21tYScpIHtcbiAgICAgIHJldHVybiBub2RlLnByZXYudHlwZSA9PT0gJ2NvbW1hJyA/ICcnIDogKGludmFsaWQgPyBub2RlLnZhbHVlIDogJ3wnKTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS52YWx1ZSkge1xuICAgICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUubm9kZXMgJiYgbm9kZS5yYW5nZXMgPiAwKSB7XG4gICAgICBsZXQgYXJncyA9IHV0aWxzLnJlZHVjZShub2RlLm5vZGVzKTtcbiAgICAgIGxldCByYW5nZSA9IGZpbGwoLi4uYXJncywgeyAuLi5vcHRpb25zLCB3cmFwOiBmYWxzZSwgdG9SZWdleDogdHJ1ZSB9KTtcblxuICAgICAgaWYgKHJhbmdlLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICByZXR1cm4gYXJncy5sZW5ndGggPiAxICYmIHJhbmdlLmxlbmd0aCA+IDEgPyBgKCR7cmFuZ2V9KWAgOiByYW5nZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobm9kZS5ub2Rlcykge1xuICAgICAgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5ub2Rlcykge1xuICAgICAgICBvdXRwdXQgKz0gd2FsayhjaGlsZCwgbm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG5cbiAgcmV0dXJuIHdhbGsoYXN0KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY29tcGlsZTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGZpbGwgPSByZXF1aXJlKCdmaWxsLXJhbmdlJyk7XG5jb25zdCBzdHJpbmdpZnkgPSByZXF1aXJlKCcuL3N0cmluZ2lmeScpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbmNvbnN0IGFwcGVuZCA9IChxdWV1ZSA9ICcnLCBzdGFzaCA9ICcnLCBlbmNsb3NlID0gZmFsc2UpID0+IHtcbiAgbGV0IHJlc3VsdCA9IFtdO1xuXG4gIHF1ZXVlID0gW10uY29uY2F0KHF1ZXVlKTtcbiAgc3Rhc2ggPSBbXS5jb25jYXQoc3Rhc2gpO1xuXG4gIGlmICghc3Rhc2gubGVuZ3RoKSByZXR1cm4gcXVldWU7XG4gIGlmICghcXVldWUubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGVuY2xvc2UgPyB1dGlscy5mbGF0dGVuKHN0YXNoKS5tYXAoZWxlID0+IGB7JHtlbGV9fWApIDogc3Rhc2g7XG4gIH1cblxuICBmb3IgKGxldCBpdGVtIG9mIHF1ZXVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgIGZvciAobGV0IHZhbHVlIG9mIGl0ZW0pIHtcbiAgICAgICAgcmVzdWx0LnB1c2goYXBwZW5kKHZhbHVlLCBzdGFzaCwgZW5jbG9zZSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBlbGUgb2Ygc3Rhc2gpIHtcbiAgICAgICAgaWYgKGVuY2xvc2UgPT09IHRydWUgJiYgdHlwZW9mIGVsZSA9PT0gJ3N0cmluZycpIGVsZSA9IGB7JHtlbGV9fWA7XG4gICAgICAgIHJlc3VsdC5wdXNoKEFycmF5LmlzQXJyYXkoZWxlKSA/IGFwcGVuZChpdGVtLCBlbGUsIGVuY2xvc2UpIDogKGl0ZW0gKyBlbGUpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHV0aWxzLmZsYXR0ZW4ocmVzdWx0KTtcbn07XG5cbmNvbnN0IGV4cGFuZCA9IChhc3QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBsZXQgcmFuZ2VMaW1pdCA9IG9wdGlvbnMucmFuZ2VMaW1pdCA9PT0gdm9pZCAwID8gMTAwMCA6IG9wdGlvbnMucmFuZ2VMaW1pdDtcblxuICBsZXQgd2FsayA9IChub2RlLCBwYXJlbnQgPSB7fSkgPT4ge1xuICAgIG5vZGUucXVldWUgPSBbXTtcblxuICAgIGxldCBwID0gcGFyZW50O1xuICAgIGxldCBxID0gcGFyZW50LnF1ZXVlO1xuXG4gICAgd2hpbGUgKHAudHlwZSAhPT0gJ2JyYWNlJyAmJiBwLnR5cGUgIT09ICdyb290JyAmJiBwLnBhcmVudCkge1xuICAgICAgcCA9IHAucGFyZW50O1xuICAgICAgcSA9IHAucXVldWU7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuaW52YWxpZCB8fCBub2RlLmRvbGxhcikge1xuICAgICAgcS5wdXNoKGFwcGVuZChxLnBvcCgpLCBzdHJpbmdpZnkobm9kZSwgb3B0aW9ucykpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobm9kZS50eXBlID09PSAnYnJhY2UnICYmIG5vZGUuaW52YWxpZCAhPT0gdHJ1ZSAmJiBub2RlLm5vZGVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgcS5wdXNoKGFwcGVuZChxLnBvcCgpLCBbJ3t9J10pKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobm9kZS5ub2RlcyAmJiBub2RlLnJhbmdlcyA+IDApIHtcbiAgICAgIGxldCBhcmdzID0gdXRpbHMucmVkdWNlKG5vZGUubm9kZXMpO1xuXG4gICAgICBpZiAodXRpbHMuZXhjZWVkc0xpbWl0KC4uLmFyZ3MsIG9wdGlvbnMuc3RlcCwgcmFuZ2VMaW1pdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2V4cGFuZGVkIGFycmF5IGxlbmd0aCBleGNlZWRzIHJhbmdlIGxpbWl0LiBVc2Ugb3B0aW9ucy5yYW5nZUxpbWl0IHRvIGluY3JlYXNlIG9yIGRpc2FibGUgdGhlIGxpbWl0LicpO1xuICAgICAgfVxuXG4gICAgICBsZXQgcmFuZ2UgPSBmaWxsKC4uLmFyZ3MsIG9wdGlvbnMpO1xuICAgICAgaWYgKHJhbmdlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByYW5nZSA9IHN0cmluZ2lmeShub2RlLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgcS5wdXNoKGFwcGVuZChxLnBvcCgpLCByYW5nZSkpO1xuICAgICAgbm9kZS5ub2RlcyA9IFtdO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBlbmNsb3NlID0gdXRpbHMuZW5jbG9zZUJyYWNlKG5vZGUpO1xuICAgIGxldCBxdWV1ZSA9IG5vZGUucXVldWU7XG4gICAgbGV0IGJsb2NrID0gbm9kZTtcblxuICAgIHdoaWxlIChibG9jay50eXBlICE9PSAnYnJhY2UnICYmIGJsb2NrLnR5cGUgIT09ICdyb290JyAmJiBibG9jay5wYXJlbnQpIHtcbiAgICAgIGJsb2NrID0gYmxvY2sucGFyZW50O1xuICAgICAgcXVldWUgPSBibG9jay5xdWV1ZTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUubm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBjaGlsZCA9IG5vZGUubm9kZXNbaV07XG5cbiAgICAgIGlmIChjaGlsZC50eXBlID09PSAnY29tbWEnICYmIG5vZGUudHlwZSA9PT0gJ2JyYWNlJykge1xuICAgICAgICBpZiAoaSA9PT0gMSkgcXVldWUucHVzaCgnJyk7XG4gICAgICAgIHF1ZXVlLnB1c2goJycpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoaWxkLnR5cGUgPT09ICdjbG9zZScpIHtcbiAgICAgICAgcS5wdXNoKGFwcGVuZChxLnBvcCgpLCBxdWV1ZSwgZW5jbG9zZSkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoaWxkLnZhbHVlICYmIGNoaWxkLnR5cGUgIT09ICdvcGVuJykge1xuICAgICAgICBxdWV1ZS5wdXNoKGFwcGVuZChxdWV1ZS5wb3AoKSwgY2hpbGQudmFsdWUpKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGlsZC5ub2Rlcykge1xuICAgICAgICB3YWxrKGNoaWxkLCBub2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcXVldWU7XG4gIH07XG5cbiAgcmV0dXJuIHV0aWxzLmZsYXR0ZW4od2Fsayhhc3QpKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwYW5kO1xuIiwgIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIE1BWF9MRU5HVEg6IDEwMjQgKiA2NCxcblxuICAvLyBEaWdpdHNcbiAgQ0hBUl8wOiAnMCcsIC8qIDAgKi9cbiAgQ0hBUl85OiAnOScsIC8qIDkgKi9cblxuICAvLyBBbHBoYWJldCBjaGFycy5cbiAgQ0hBUl9VUFBFUkNBU0VfQTogJ0EnLCAvKiBBICovXG4gIENIQVJfTE9XRVJDQVNFX0E6ICdhJywgLyogYSAqL1xuICBDSEFSX1VQUEVSQ0FTRV9aOiAnWicsIC8qIFogKi9cbiAgQ0hBUl9MT1dFUkNBU0VfWjogJ3onLCAvKiB6ICovXG5cbiAgQ0hBUl9MRUZUX1BBUkVOVEhFU0VTOiAnKCcsIC8qICggKi9cbiAgQ0hBUl9SSUdIVF9QQVJFTlRIRVNFUzogJyknLCAvKiApICovXG5cbiAgQ0hBUl9BU1RFUklTSzogJyonLCAvKiAqICovXG5cbiAgLy8gTm9uLWFscGhhYmV0aWMgY2hhcnMuXG4gIENIQVJfQU1QRVJTQU5EOiAnJicsIC8qICYgKi9cbiAgQ0hBUl9BVDogJ0AnLCAvKiBAICovXG4gIENIQVJfQkFDS1NMQVNIOiAnXFxcXCcsIC8qIFxcICovXG4gIENIQVJfQkFDS1RJQ0s6ICdgJywgLyogYCAqL1xuICBDSEFSX0NBUlJJQUdFX1JFVFVSTjogJ1xccicsIC8qIFxcciAqL1xuICBDSEFSX0NJUkNVTUZMRVhfQUNDRU5UOiAnXicsIC8qIF4gKi9cbiAgQ0hBUl9DT0xPTjogJzonLCAvKiA6ICovXG4gIENIQVJfQ09NTUE6ICcsJywgLyogLCAqL1xuICBDSEFSX0RPTExBUjogJyQnLCAvKiAuICovXG4gIENIQVJfRE9UOiAnLicsIC8qIC4gKi9cbiAgQ0hBUl9ET1VCTEVfUVVPVEU6ICdcIicsIC8qIFwiICovXG4gIENIQVJfRVFVQUw6ICc9JywgLyogPSAqL1xuICBDSEFSX0VYQ0xBTUFUSU9OX01BUks6ICchJywgLyogISAqL1xuICBDSEFSX0ZPUk1fRkVFRDogJ1xcZicsIC8qIFxcZiAqL1xuICBDSEFSX0ZPUldBUkRfU0xBU0g6ICcvJywgLyogLyAqL1xuICBDSEFSX0hBU0g6ICcjJywgLyogIyAqL1xuICBDSEFSX0hZUEhFTl9NSU5VUzogJy0nLCAvKiAtICovXG4gIENIQVJfTEVGVF9BTkdMRV9CUkFDS0VUOiAnPCcsIC8qIDwgKi9cbiAgQ0hBUl9MRUZUX0NVUkxZX0JSQUNFOiAneycsIC8qIHsgKi9cbiAgQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUOiAnWycsIC8qIFsgKi9cbiAgQ0hBUl9MSU5FX0ZFRUQ6ICdcXG4nLCAvKiBcXG4gKi9cbiAgQ0hBUl9OT19CUkVBS19TUEFDRTogJ1xcdTAwQTAnLCAvKiBcXHUwMEEwICovXG4gIENIQVJfUEVSQ0VOVDogJyUnLCAvKiAlICovXG4gIENIQVJfUExVUzogJysnLCAvKiArICovXG4gIENIQVJfUVVFU1RJT05fTUFSSzogJz8nLCAvKiA/ICovXG4gIENIQVJfUklHSFRfQU5HTEVfQlJBQ0tFVDogJz4nLCAvKiA+ICovXG4gIENIQVJfUklHSFRfQ1VSTFlfQlJBQ0U6ICd9JywgLyogfSAqL1xuICBDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUOiAnXScsIC8qIF0gKi9cbiAgQ0hBUl9TRU1JQ09MT046ICc7JywgLyogOyAqL1xuICBDSEFSX1NJTkdMRV9RVU9URTogJ1xcJycsIC8qICcgKi9cbiAgQ0hBUl9TUEFDRTogJyAnLCAvKiAgICovXG4gIENIQVJfVEFCOiAnXFx0JywgLyogXFx0ICovXG4gIENIQVJfVU5ERVJTQ09SRTogJ18nLCAvKiBfICovXG4gIENIQVJfVkVSVElDQUxfTElORTogJ3wnLCAvKiB8ICovXG4gIENIQVJfWkVST19XSURUSF9OT0JSRUFLX1NQQUNFOiAnXFx1RkVGRicgLyogXFx1RkVGRiAqL1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vc3RyaW5naWZ5Jyk7XG5cbi8qKlxuICogQ29uc3RhbnRzXG4gKi9cblxuY29uc3Qge1xuICBNQVhfTEVOR1RILFxuICBDSEFSX0JBQ0tTTEFTSCwgLyogXFwgKi9cbiAgQ0hBUl9CQUNLVElDSywgLyogYCAqL1xuICBDSEFSX0NPTU1BLCAvKiAsICovXG4gIENIQVJfRE9ULCAvKiAuICovXG4gIENIQVJfTEVGVF9QQVJFTlRIRVNFUywgLyogKCAqL1xuICBDSEFSX1JJR0hUX1BBUkVOVEhFU0VTLCAvKiApICovXG4gIENIQVJfTEVGVF9DVVJMWV9CUkFDRSwgLyogeyAqL1xuICBDSEFSX1JJR0hUX0NVUkxZX0JSQUNFLCAvKiB9ICovXG4gIENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVCwgLyogWyAqL1xuICBDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VULCAvKiBdICovXG4gIENIQVJfRE9VQkxFX1FVT1RFLCAvKiBcIiAqL1xuICBDSEFSX1NJTkdMRV9RVU9URSwgLyogJyAqL1xuICBDSEFSX05PX0JSRUFLX1NQQUNFLFxuICBDSEFSX1pFUk9fV0lEVEhfTk9CUkVBS19TUEFDRVxufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbi8qKlxuICogcGFyc2VcbiAqL1xuXG5jb25zdCBwYXJzZSA9IChpbnB1dCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBzdHJpbmcnKTtcbiAgfVxuXG4gIGxldCBvcHRzID0gb3B0aW9ucyB8fCB7fTtcbiAgbGV0IG1heCA9IHR5cGVvZiBvcHRzLm1heExlbmd0aCA9PT0gJ251bWJlcicgPyBNYXRoLm1pbihNQVhfTEVOR1RILCBvcHRzLm1heExlbmd0aCkgOiBNQVhfTEVOR1RIO1xuICBpZiAoaW5wdXQubGVuZ3RoID4gbWF4KSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnB1dCBsZW5ndGggKCR7aW5wdXQubGVuZ3RofSksIGV4Y2VlZHMgbWF4IGNoYXJhY3RlcnMgKCR7bWF4fSlgKTtcbiAgfVxuXG4gIGxldCBhc3QgPSB7IHR5cGU6ICdyb290JywgaW5wdXQsIG5vZGVzOiBbXSB9O1xuICBsZXQgc3RhY2sgPSBbYXN0XTtcbiAgbGV0IGJsb2NrID0gYXN0O1xuICBsZXQgcHJldiA9IGFzdDtcbiAgbGV0IGJyYWNrZXRzID0gMDtcbiAgbGV0IGxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgbGV0IGluZGV4ID0gMDtcbiAgbGV0IGRlcHRoID0gMDtcbiAgbGV0IHZhbHVlO1xuICBsZXQgbWVtbyA9IHt9O1xuXG4gIC8qKlxuICAgKiBIZWxwZXJzXG4gICAqL1xuXG4gIGNvbnN0IGFkdmFuY2UgPSAoKSA9PiBpbnB1dFtpbmRleCsrXTtcbiAgY29uc3QgcHVzaCA9IG5vZGUgPT4ge1xuICAgIGlmIChub2RlLnR5cGUgPT09ICd0ZXh0JyAmJiBwcmV2LnR5cGUgPT09ICdkb3QnKSB7XG4gICAgICBwcmV2LnR5cGUgPSAndGV4dCc7XG4gICAgfVxuXG4gICAgaWYgKHByZXYgJiYgcHJldi50eXBlID09PSAndGV4dCcgJiYgbm9kZS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgIHByZXYudmFsdWUgKz0gbm9kZS52YWx1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBibG9jay5ub2Rlcy5wdXNoKG5vZGUpO1xuICAgIG5vZGUucGFyZW50ID0gYmxvY2s7XG4gICAgbm9kZS5wcmV2ID0gcHJldjtcbiAgICBwcmV2ID0gbm9kZTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcblxuICBwdXNoKHsgdHlwZTogJ2JvcycgfSk7XG5cbiAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgYmxvY2sgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICB2YWx1ZSA9IGFkdmFuY2UoKTtcblxuICAgIC8qKlxuICAgICAqIEludmFsaWQgY2hhcnNcbiAgICAgKi9cblxuICAgIGlmICh2YWx1ZSA9PT0gQ0hBUl9aRVJPX1dJRFRIX05PQlJFQUtfU1BBQ0UgfHwgdmFsdWUgPT09IENIQVJfTk9fQlJFQUtfU1BBQ0UpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVzY2FwZWQgY2hhcnNcbiAgICAgKi9cblxuICAgIGlmICh2YWx1ZSA9PT0gQ0hBUl9CQUNLU0xBU0gpIHtcbiAgICAgIHB1c2goeyB0eXBlOiAndGV4dCcsIHZhbHVlOiAob3B0aW9ucy5rZWVwRXNjYXBpbmcgPyB2YWx1ZSA6ICcnKSArIGFkdmFuY2UoKSB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJpZ2h0IHNxdWFyZSBicmFja2V0IChsaXRlcmFsKTogJ10nXG4gICAgICovXG5cbiAgICBpZiAodmFsdWUgPT09IENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVQpIHtcbiAgICAgIHB1c2goeyB0eXBlOiAndGV4dCcsIHZhbHVlOiAnXFxcXCcgKyB2YWx1ZSB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExlZnQgc3F1YXJlIGJyYWNrZXQ6ICdbJ1xuICAgICAqL1xuXG4gICAgaWYgKHZhbHVlID09PSBDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVQpIHtcbiAgICAgIGJyYWNrZXRzKys7XG5cbiAgICAgIGxldCBjbG9zZWQgPSB0cnVlO1xuICAgICAgbGV0IG5leHQ7XG5cbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCAmJiAobmV4dCA9IGFkdmFuY2UoKSkpIHtcbiAgICAgICAgdmFsdWUgKz0gbmV4dDtcblxuICAgICAgICBpZiAobmV4dCA9PT0gQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUKSB7XG4gICAgICAgICAgYnJhY2tldHMrKztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXh0ID09PSBDSEFSX0JBQ0tTTEFTSCkge1xuICAgICAgICAgIHZhbHVlICs9IGFkdmFuY2UoKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXh0ID09PSBDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUKSB7XG4gICAgICAgICAgYnJhY2tldHMtLTtcblxuICAgICAgICAgIGlmIChicmFja2V0cyA9PT0gMCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHB1c2goeyB0eXBlOiAndGV4dCcsIHZhbHVlIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyZW50aGVzZXNcbiAgICAgKi9cblxuICAgIGlmICh2YWx1ZSA9PT0gQ0hBUl9MRUZUX1BBUkVOVEhFU0VTKSB7XG4gICAgICBibG9jayA9IHB1c2goeyB0eXBlOiAncGFyZW4nLCBub2RlczogW10gfSk7XG4gICAgICBzdGFjay5wdXNoKGJsb2NrKTtcbiAgICAgIHB1c2goeyB0eXBlOiAndGV4dCcsIHZhbHVlIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID09PSBDSEFSX1JJR0hUX1BBUkVOVEhFU0VTKSB7XG4gICAgICBpZiAoYmxvY2sudHlwZSAhPT0gJ3BhcmVuJykge1xuICAgICAgICBwdXNoKHsgdHlwZTogJ3RleHQnLCB2YWx1ZSB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBibG9jayA9IHN0YWNrLnBvcCgpO1xuICAgICAgcHVzaCh7IHR5cGU6ICd0ZXh0JywgdmFsdWUgfSk7XG4gICAgICBibG9jayA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUXVvdGVzOiAnfFwifGBcbiAgICAgKi9cblxuICAgIGlmICh2YWx1ZSA9PT0gQ0hBUl9ET1VCTEVfUVVPVEUgfHwgdmFsdWUgPT09IENIQVJfU0lOR0xFX1FVT1RFIHx8IHZhbHVlID09PSBDSEFSX0JBQ0tUSUNLKSB7XG4gICAgICBsZXQgb3BlbiA9IHZhbHVlO1xuICAgICAgbGV0IG5leHQ7XG5cbiAgICAgIGlmIChvcHRpb25zLmtlZXBRdW90ZXMgIT09IHRydWUpIHtcbiAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoICYmIChuZXh0ID0gYWR2YW5jZSgpKSkge1xuICAgICAgICBpZiAobmV4dCA9PT0gQ0hBUl9CQUNLU0xBU0gpIHtcbiAgICAgICAgICB2YWx1ZSArPSBuZXh0ICsgYWR2YW5jZSgpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHQgPT09IG9wZW4pIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5rZWVwUXVvdGVzID09PSB0cnVlKSB2YWx1ZSArPSBuZXh0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgKz0gbmV4dDtcbiAgICAgIH1cblxuICAgICAgcHVzaCh7IHR5cGU6ICd0ZXh0JywgdmFsdWUgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMZWZ0IGN1cmx5IGJyYWNlOiAneydcbiAgICAgKi9cblxuICAgIGlmICh2YWx1ZSA9PT0gQ0hBUl9MRUZUX0NVUkxZX0JSQUNFKSB7XG4gICAgICBkZXB0aCsrO1xuXG4gICAgICBsZXQgZG9sbGFyID0gcHJldi52YWx1ZSAmJiBwcmV2LnZhbHVlLnNsaWNlKC0xKSA9PT0gJyQnIHx8IGJsb2NrLmRvbGxhciA9PT0gdHJ1ZTtcbiAgICAgIGxldCBicmFjZSA9IHtcbiAgICAgICAgdHlwZTogJ2JyYWNlJyxcbiAgICAgICAgb3BlbjogdHJ1ZSxcbiAgICAgICAgY2xvc2U6IGZhbHNlLFxuICAgICAgICBkb2xsYXIsXG4gICAgICAgIGRlcHRoLFxuICAgICAgICBjb21tYXM6IDAsXG4gICAgICAgIHJhbmdlczogMCxcbiAgICAgICAgbm9kZXM6IFtdXG4gICAgICB9O1xuXG4gICAgICBibG9jayA9IHB1c2goYnJhY2UpO1xuICAgICAgc3RhY2sucHVzaChibG9jayk7XG4gICAgICBwdXNoKHsgdHlwZTogJ29wZW4nLCB2YWx1ZSB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJpZ2h0IGN1cmx5IGJyYWNlOiAnfSdcbiAgICAgKi9cblxuICAgIGlmICh2YWx1ZSA9PT0gQ0hBUl9SSUdIVF9DVVJMWV9CUkFDRSkge1xuICAgICAgaWYgKGJsb2NrLnR5cGUgIT09ICdicmFjZScpIHtcbiAgICAgICAgcHVzaCh7IHR5cGU6ICd0ZXh0JywgdmFsdWUgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBsZXQgdHlwZSA9ICdjbG9zZSc7XG4gICAgICBibG9jayA9IHN0YWNrLnBvcCgpO1xuICAgICAgYmxvY2suY2xvc2UgPSB0cnVlO1xuXG4gICAgICBwdXNoKHsgdHlwZSwgdmFsdWUgfSk7XG4gICAgICBkZXB0aC0tO1xuXG4gICAgICBibG9jayA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tbWE6ICcsJ1xuICAgICAqL1xuXG4gICAgaWYgKHZhbHVlID09PSBDSEFSX0NPTU1BICYmIGRlcHRoID4gMCkge1xuICAgICAgaWYgKGJsb2NrLnJhbmdlcyA+IDApIHtcbiAgICAgICAgYmxvY2sucmFuZ2VzID0gMDtcbiAgICAgICAgbGV0IG9wZW4gPSBibG9jay5ub2Rlcy5zaGlmdCgpO1xuICAgICAgICBibG9jay5ub2RlcyA9IFtvcGVuLCB7IHR5cGU6ICd0ZXh0JywgdmFsdWU6IHN0cmluZ2lmeShibG9jaykgfV07XG4gICAgICB9XG5cbiAgICAgIHB1c2goeyB0eXBlOiAnY29tbWEnLCB2YWx1ZSB9KTtcbiAgICAgIGJsb2NrLmNvbW1hcysrO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRG90OiAnLidcbiAgICAgKi9cblxuICAgIGlmICh2YWx1ZSA9PT0gQ0hBUl9ET1QgJiYgZGVwdGggPiAwICYmIGJsb2NrLmNvbW1hcyA9PT0gMCkge1xuICAgICAgbGV0IHNpYmxpbmdzID0gYmxvY2subm9kZXM7XG5cbiAgICAgIGlmIChkZXB0aCA9PT0gMCB8fCBzaWJsaW5ncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcHVzaCh7IHR5cGU6ICd0ZXh0JywgdmFsdWUgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJldi50eXBlID09PSAnZG90Jykge1xuICAgICAgICBibG9jay5yYW5nZSA9IFtdO1xuICAgICAgICBwcmV2LnZhbHVlICs9IHZhbHVlO1xuICAgICAgICBwcmV2LnR5cGUgPSAncmFuZ2UnO1xuXG4gICAgICAgIGlmIChibG9jay5ub2Rlcy5sZW5ndGggIT09IDMgJiYgYmxvY2subm9kZXMubGVuZ3RoICE9PSA1KSB7XG4gICAgICAgICAgYmxvY2suaW52YWxpZCA9IHRydWU7XG4gICAgICAgICAgYmxvY2sucmFuZ2VzID0gMDtcbiAgICAgICAgICBwcmV2LnR5cGUgPSAndGV4dCc7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBibG9jay5yYW5nZXMrKztcbiAgICAgICAgYmxvY2suYXJncyA9IFtdO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByZXYudHlwZSA9PT0gJ3JhbmdlJykge1xuICAgICAgICBzaWJsaW5ncy5wb3AoKTtcblxuICAgICAgICBsZXQgYmVmb3JlID0gc2libGluZ3Nbc2libGluZ3MubGVuZ3RoIC0gMV07XG4gICAgICAgIGJlZm9yZS52YWx1ZSArPSBwcmV2LnZhbHVlICsgdmFsdWU7XG4gICAgICAgIHByZXYgPSBiZWZvcmU7XG4gICAgICAgIGJsb2NrLnJhbmdlcy0tO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcHVzaCh7IHR5cGU6ICdkb3QnLCB2YWx1ZSB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRleHRcbiAgICAgKi9cblxuICAgIHB1c2goeyB0eXBlOiAndGV4dCcsIHZhbHVlIH0pO1xuICB9XG5cbiAgLy8gTWFyayBpbWJhbGFuY2VkIGJyYWNlcyBhbmQgYnJhY2tldHMgYXMgaW52YWxpZFxuICBkbyB7XG4gICAgYmxvY2sgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChibG9jay50eXBlICE9PSAncm9vdCcpIHtcbiAgICAgIGJsb2NrLm5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgIGlmICghbm9kZS5ub2Rlcykge1xuICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdvcGVuJykgbm9kZS5pc09wZW4gPSB0cnVlO1xuICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdjbG9zZScpIG5vZGUuaXNDbG9zZSA9IHRydWU7XG4gICAgICAgICAgaWYgKCFub2RlLm5vZGVzKSBub2RlLnR5cGUgPSAndGV4dCc7XG4gICAgICAgICAgbm9kZS5pbnZhbGlkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIGdldCB0aGUgbG9jYXRpb24gb2YgdGhlIGJsb2NrIG9uIHBhcmVudC5ub2RlcyAoYmxvY2sncyBzaWJsaW5ncylcbiAgICAgIGxldCBwYXJlbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIGxldCBpbmRleCA9IHBhcmVudC5ub2Rlcy5pbmRleE9mKGJsb2NrKTtcbiAgICAgIC8vIHJlcGxhY2UgdGhlIChpbnZhbGlkKSBibG9jayB3aXRoIGl0J3Mgbm9kZXNcbiAgICAgIHBhcmVudC5ub2Rlcy5zcGxpY2UoaW5kZXgsIDEsIC4uLmJsb2NrLm5vZGVzKTtcbiAgICB9XG4gIH0gd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApO1xuXG4gIHB1c2goeyB0eXBlOiAnZW9zJyB9KTtcbiAgcmV0dXJuIGFzdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2U7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBzdHJpbmdpZnkgPSByZXF1aXJlKCcuL2xpYi9zdHJpbmdpZnknKTtcbmNvbnN0IGNvbXBpbGUgPSByZXF1aXJlKCcuL2xpYi9jb21waWxlJyk7XG5jb25zdCBleHBhbmQgPSByZXF1aXJlKCcuL2xpYi9leHBhbmQnKTtcbmNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9saWIvcGFyc2UnKTtcblxuLyoqXG4gKiBFeHBhbmQgdGhlIGdpdmVuIHBhdHRlcm4gb3IgY3JlYXRlIGEgcmVnZXgtY29tcGF0aWJsZSBzdHJpbmcuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IGJyYWNlcyA9IHJlcXVpcmUoJ2JyYWNlcycpO1xuICogY29uc29sZS5sb2coYnJhY2VzKCd7YSxiLGN9JywgeyBjb21waWxlOiB0cnVlIH0pKTsgLy89PiBbJyhhfGJ8YyknXVxuICogY29uc29sZS5sb2coYnJhY2VzKCd7YSxiLGN9JykpOyAvLz0+IFsnYScsICdiJywgJ2MnXVxuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHN0cmBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuY29uc3QgYnJhY2VzID0gKGlucHV0LCBvcHRpb25zID0ge30pID0+IHtcbiAgbGV0IG91dHB1dCA9IFtdO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgIGZvciAobGV0IHBhdHRlcm4gb2YgaW5wdXQpIHtcbiAgICAgIGxldCByZXN1bHQgPSBicmFjZXMuY3JlYXRlKHBhdHRlcm4sIG9wdGlvbnMpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgICAgICBvdXRwdXQucHVzaCguLi5yZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0LnB1c2gocmVzdWx0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0gW10uY29uY2F0KGJyYWNlcy5jcmVhdGUoaW5wdXQsIG9wdGlvbnMpKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZXhwYW5kID09PSB0cnVlICYmIG9wdGlvbnMubm9kdXBlcyA9PT0gdHJ1ZSkge1xuICAgIG91dHB1dCA9IFsuLi5uZXcgU2V0KG91dHB1dCldO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCB3aXRoIHRoZSBnaXZlbiBgb3B0aW9uc2AuXG4gKlxuICogYGBganNcbiAqIC8vIGJyYWNlcy5wYXJzZShwYXR0ZXJuLCBbLCBvcHRpb25zXSk7XG4gKiBjb25zdCBhc3QgPSBicmFjZXMucGFyc2UoJ2Eve2IsY30vZCcpO1xuICogY29uc29sZS5sb2coYXN0KTtcbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IHBhdHRlcm4gQnJhY2UgcGF0dGVybiB0byBwYXJzZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBhbiBBU1RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuYnJhY2VzLnBhcnNlID0gKGlucHV0LCBvcHRpb25zID0ge30pID0+IHBhcnNlKGlucHV0LCBvcHRpb25zKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgYnJhY2VzIHN0cmluZyBmcm9tIGFuIEFTVCwgb3IgYW4gQVNUIG5vZGUuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IGJyYWNlcyA9IHJlcXVpcmUoJ2JyYWNlcycpO1xuICogbGV0IGFzdCA9IGJyYWNlcy5wYXJzZSgnZm9vL3thLGJ9L2JhcicpO1xuICogY29uc29sZS5sb2coc3RyaW5naWZ5KGFzdC5ub2Rlc1syXSkpOyAvLz0+ICd7YSxifSdcbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBpbnB1dGAgQnJhY2UgcGF0dGVybiBvciBBU1QuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBleHBhbmRlZCB2YWx1ZXMuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmJyYWNlcy5zdHJpbmdpZnkgPSAoaW5wdXQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBzdHJpbmdpZnkoYnJhY2VzLnBhcnNlKGlucHV0LCBvcHRpb25zKSwgb3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIHN0cmluZ2lmeShpbnB1dCwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIENvbXBpbGVzIGEgYnJhY2UgcGF0dGVybiBpbnRvIGEgcmVnZXgtY29tcGF0aWJsZSwgb3B0aW1pemVkIHN0cmluZy5cbiAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSB0aGUgbWFpbiBbYnJhY2VzXSgjYnJhY2VzKSBmdW5jdGlvbiBieSBkZWZhdWx0LlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBicmFjZXMgPSByZXF1aXJlKCdicmFjZXMnKTtcbiAqIGNvbnNvbGUubG9nKGJyYWNlcy5jb21waWxlKCdhL3tiLGN9L2QnKSk7XG4gKiAvLz0+IFsnYS8oYnxjKS9kJ11cbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBpbnB1dGAgQnJhY2UgcGF0dGVybiBvciBBU1QuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBleHBhbmRlZCB2YWx1ZXMuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmJyYWNlcy5jb21waWxlID0gKGlucHV0LCBvcHRpb25zID0ge30pID0+IHtcbiAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICBpbnB1dCA9IGJyYWNlcy5wYXJzZShpbnB1dCwgb3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIGNvbXBpbGUoaW5wdXQsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBFeHBhbmRzIGEgYnJhY2UgcGF0dGVybiBpbnRvIGFuIGFycmF5LiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgdGhlXG4gKiBtYWluIFticmFjZXNdKCNicmFjZXMpIGZ1bmN0aW9uIHdoZW4gYG9wdGlvbnMuZXhwYW5kYCBpcyB0cnVlLiBCZWZvcmVcbiAqIHVzaW5nIHRoaXMgbWV0aG9kIGl0J3MgcmVjb21tZW5kZWQgdGhhdCB5b3UgcmVhZCB0aGUgW3BlcmZvcm1hbmNlIG5vdGVzXSgjcGVyZm9ybWFuY2UpKVxuICogYW5kIGFkdmFudGFnZXMgb2YgdXNpbmcgWy5jb21waWxlXSgjY29tcGlsZSkgaW5zdGVhZC5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgYnJhY2VzID0gcmVxdWlyZSgnYnJhY2VzJyk7XG4gKiBjb25zb2xlLmxvZyhicmFjZXMuZXhwYW5kKCdhL3tiLGN9L2QnKSk7XG4gKiAvLz0+IFsnYS9iL2QnLCAnYS9jL2QnXTtcbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBwYXR0ZXJuYCBCcmFjZSBwYXR0ZXJuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBleHBhbmRlZCB2YWx1ZXMuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmJyYWNlcy5leHBhbmQgPSAoaW5wdXQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgIGlucHV0ID0gYnJhY2VzLnBhcnNlKGlucHV0LCBvcHRpb25zKTtcbiAgfVxuXG4gIGxldCByZXN1bHQgPSBleHBhbmQoaW5wdXQsIG9wdGlvbnMpO1xuXG4gIC8vIGZpbHRlciBvdXQgZW1wdHkgc3RyaW5ncyBpZiBzcGVjaWZpZWRcbiAgaWYgKG9wdGlvbnMubm9lbXB0eSA9PT0gdHJ1ZSkge1xuICAgIHJlc3VsdCA9IHJlc3VsdC5maWx0ZXIoQm9vbGVhbik7XG4gIH1cblxuICAvLyBmaWx0ZXIgb3V0IGR1cGxpY2F0ZXMgaWYgc3BlY2lmaWVkXG4gIGlmIChvcHRpb25zLm5vZHVwZXMgPT09IHRydWUpIHtcbiAgICByZXN1bHQgPSBbLi4ubmV3IFNldChyZXN1bHQpXTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFByb2Nlc3NlcyBhIGJyYWNlIHBhdHRlcm4gYW5kIHJldHVybnMgZWl0aGVyIGFuIGV4cGFuZGVkIGFycmF5XG4gKiAoaWYgYG9wdGlvbnMuZXhwYW5kYCBpcyB0cnVlKSwgYSBoaWdobHkgb3B0aW1pemVkIHJlZ2V4LWNvbXBhdGlibGUgc3RyaW5nLlxuICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IHRoZSBtYWluIFticmFjZXNdKCNicmFjZXMpIGZ1bmN0aW9uLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBicmFjZXMgPSByZXF1aXJlKCdicmFjZXMnKTtcbiAqIGNvbnNvbGUubG9nKGJyYWNlcy5jcmVhdGUoJ3VzZXItezIwMC4uMzAwfS9wcm9qZWN0LXthLGIsY30tezEuLjEwfScpKVxuICogLy89PiAndXNlci0oMjBbMC05XXwyWzEtOV1bMC05XXwzMDApL3Byb2plY3QtKGF8YnxjKS0oWzEtOV18MTApJ1xuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHBhdHRlcm5gIEJyYWNlIHBhdHRlcm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIGV4cGFuZGVkIHZhbHVlcy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuYnJhY2VzLmNyZWF0ZSA9IChpbnB1dCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGlmIChpbnB1dCA9PT0gJycgfHwgaW5wdXQubGVuZ3RoIDwgMykge1xuICAgIHJldHVybiBbaW5wdXRdO1xuICB9XG5cbiByZXR1cm4gb3B0aW9ucy5leHBhbmQgIT09IHRydWVcbiAgICA/IGJyYWNlcy5jb21waWxlKGlucHV0LCBvcHRpb25zKVxuICAgIDogYnJhY2VzLmV4cGFuZChpbnB1dCwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIEV4cG9zZSBcImJyYWNlc1wiXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBicmFjZXM7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgV0lOX1NMQVNIID0gJ1xcXFxcXFxcLyc7XG5jb25zdCBXSU5fTk9fU0xBU0ggPSBgW14ke1dJTl9TTEFTSH1dYDtcblxuLyoqXG4gKiBQb3NpeCBnbG9iIHJlZ2V4XG4gKi9cblxuY29uc3QgRE9UX0xJVEVSQUwgPSAnXFxcXC4nO1xuY29uc3QgUExVU19MSVRFUkFMID0gJ1xcXFwrJztcbmNvbnN0IFFNQVJLX0xJVEVSQUwgPSAnXFxcXD8nO1xuY29uc3QgU0xBU0hfTElURVJBTCA9ICdcXFxcLyc7XG5jb25zdCBPTkVfQ0hBUiA9ICcoPz0uKSc7XG5jb25zdCBRTUFSSyA9ICdbXi9dJztcbmNvbnN0IEVORF9BTkNIT1IgPSBgKD86JHtTTEFTSF9MSVRFUkFMfXwkKWA7XG5jb25zdCBTVEFSVF9BTkNIT1IgPSBgKD86Xnwke1NMQVNIX0xJVEVSQUx9KWA7XG5jb25zdCBET1RTX1NMQVNIID0gYCR7RE9UX0xJVEVSQUx9ezEsMn0ke0VORF9BTkNIT1J9YDtcbmNvbnN0IE5PX0RPVCA9IGAoPyEke0RPVF9MSVRFUkFMfSlgO1xuY29uc3QgTk9fRE9UUyA9IGAoPyEke1NUQVJUX0FOQ0hPUn0ke0RPVFNfU0xBU0h9KWA7XG5jb25zdCBOT19ET1RfU0xBU0ggPSBgKD8hJHtET1RfTElURVJBTH17MCwxfSR7RU5EX0FOQ0hPUn0pYDtcbmNvbnN0IE5PX0RPVFNfU0xBU0ggPSBgKD8hJHtET1RTX1NMQVNIfSlgO1xuY29uc3QgUU1BUktfTk9fRE9UID0gYFteLiR7U0xBU0hfTElURVJBTH1dYDtcbmNvbnN0IFNUQVIgPSBgJHtRTUFSS30qP2A7XG5cbmNvbnN0IFBPU0lYX0NIQVJTID0ge1xuICBET1RfTElURVJBTCxcbiAgUExVU19MSVRFUkFMLFxuICBRTUFSS19MSVRFUkFMLFxuICBTTEFTSF9MSVRFUkFMLFxuICBPTkVfQ0hBUixcbiAgUU1BUkssXG4gIEVORF9BTkNIT1IsXG4gIERPVFNfU0xBU0gsXG4gIE5PX0RPVCxcbiAgTk9fRE9UUyxcbiAgTk9fRE9UX1NMQVNILFxuICBOT19ET1RTX1NMQVNILFxuICBRTUFSS19OT19ET1QsXG4gIFNUQVIsXG4gIFNUQVJUX0FOQ0hPUlxufTtcblxuLyoqXG4gKiBXaW5kb3dzIGdsb2IgcmVnZXhcbiAqL1xuXG5jb25zdCBXSU5ET1dTX0NIQVJTID0ge1xuICAuLi5QT1NJWF9DSEFSUyxcblxuICBTTEFTSF9MSVRFUkFMOiBgWyR7V0lOX1NMQVNIfV1gLFxuICBRTUFSSzogV0lOX05PX1NMQVNILFxuICBTVEFSOiBgJHtXSU5fTk9fU0xBU0h9Kj9gLFxuICBET1RTX1NMQVNIOiBgJHtET1RfTElURVJBTH17MSwyfSg/Olske1dJTl9TTEFTSH1dfCQpYCxcbiAgTk9fRE9UOiBgKD8hJHtET1RfTElURVJBTH0pYCxcbiAgTk9fRE9UUzogYCg/ISg/Ol58WyR7V0lOX1NMQVNIfV0pJHtET1RfTElURVJBTH17MSwyfSg/Olske1dJTl9TTEFTSH1dfCQpKWAsXG4gIE5PX0RPVF9TTEFTSDogYCg/ISR7RE9UX0xJVEVSQUx9ezAsMX0oPzpbJHtXSU5fU0xBU0h9XXwkKSlgLFxuICBOT19ET1RTX1NMQVNIOiBgKD8hJHtET1RfTElURVJBTH17MSwyfSg/Olske1dJTl9TTEFTSH1dfCQpKWAsXG4gIFFNQVJLX05PX0RPVDogYFteLiR7V0lOX1NMQVNIfV1gLFxuICBTVEFSVF9BTkNIT1I6IGAoPzpefFske1dJTl9TTEFTSH1dKWAsXG4gIEVORF9BTkNIT1I6IGAoPzpbJHtXSU5fU0xBU0h9XXwkKWBcbn07XG5cbi8qKlxuICogUE9TSVggQnJhY2tldCBSZWdleFxuICovXG5cbmNvbnN0IFBPU0lYX1JFR0VYX1NPVVJDRSA9IHtcbiAgYWxudW06ICdhLXpBLVowLTknLFxuICBhbHBoYTogJ2EtekEtWicsXG4gIGFzY2lpOiAnXFxcXHgwMC1cXFxceDdGJyxcbiAgYmxhbms6ICcgXFxcXHQnLFxuICBjbnRybDogJ1xcXFx4MDAtXFxcXHgxRlxcXFx4N0YnLFxuICBkaWdpdDogJzAtOScsXG4gIGdyYXBoOiAnXFxcXHgyMS1cXFxceDdFJyxcbiAgbG93ZXI6ICdhLXonLFxuICBwcmludDogJ1xcXFx4MjAtXFxcXHg3RSAnLFxuICBwdW5jdDogJ1xcXFwtIVwiIyQlJlxcJygpXFxcXCorLC4vOjs8PT4/QFtcXFxcXV5fYHt8fX4nLFxuICBzcGFjZTogJyBcXFxcdFxcXFxyXFxcXG5cXFxcdlxcXFxmJyxcbiAgdXBwZXI6ICdBLVonLFxuICB3b3JkOiAnQS1aYS16MC05XycsXG4gIHhkaWdpdDogJ0EtRmEtZjAtOSdcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBNQVhfTEVOR1RIOiAxMDI0ICogNjQsXG4gIFBPU0lYX1JFR0VYX1NPVVJDRSxcblxuICAvLyByZWd1bGFyIGV4cHJlc3Npb25zXG4gIFJFR0VYX0JBQ0tTTEFTSDogL1xcXFwoPyFbKis/XiR7fSh8KVtcXF1dKS9nLFxuICBSRUdFWF9OT05fU1BFQ0lBTF9DSEFSUzogL15bXkAhW1xcXS4sJCorP157fSgpfFxcXFwvXSsvLFxuICBSRUdFWF9TUEVDSUFMX0NIQVJTOiAvWy0qKz8uXiR7fSh8KVtcXF1dLyxcbiAgUkVHRVhfU1BFQ0lBTF9DSEFSU19CQUNLUkVGOiAvKFxcXFw/KSgoXFxXKShcXDMqKSkvZyxcbiAgUkVHRVhfU1BFQ0lBTF9DSEFSU19HTE9CQUw6IC8oWy0qKz8uXiR7fSh8KVtcXF1dKS9nLFxuICBSRUdFWF9SRU1PVkVfQkFDS1NMQVNIOiAvKD86XFxbLio/W15cXFxcXVxcXXxcXFxcKD89LikpL2csXG5cbiAgLy8gUmVwbGFjZSBnbG9icyB3aXRoIGVxdWl2YWxlbnQgcGF0dGVybnMgdG8gcmVkdWNlIHBhcnNpbmcgdGltZS5cbiAgUkVQTEFDRU1FTlRTOiB7XG4gICAgJyoqKic6ICcqJyxcbiAgICAnKiovKionOiAnKionLFxuICAgICcqKi8qKi8qKic6ICcqKidcbiAgfSxcblxuICAvLyBEaWdpdHNcbiAgQ0hBUl8wOiA0OCwgLyogMCAqL1xuICBDSEFSXzk6IDU3LCAvKiA5ICovXG5cbiAgLy8gQWxwaGFiZXQgY2hhcnMuXG4gIENIQVJfVVBQRVJDQVNFX0E6IDY1LCAvKiBBICovXG4gIENIQVJfTE9XRVJDQVNFX0E6IDk3LCAvKiBhICovXG4gIENIQVJfVVBQRVJDQVNFX1o6IDkwLCAvKiBaICovXG4gIENIQVJfTE9XRVJDQVNFX1o6IDEyMiwgLyogeiAqL1xuXG4gIENIQVJfTEVGVF9QQVJFTlRIRVNFUzogNDAsIC8qICggKi9cbiAgQ0hBUl9SSUdIVF9QQVJFTlRIRVNFUzogNDEsIC8qICkgKi9cblxuICBDSEFSX0FTVEVSSVNLOiA0MiwgLyogKiAqL1xuXG4gIC8vIE5vbi1hbHBoYWJldGljIGNoYXJzLlxuICBDSEFSX0FNUEVSU0FORDogMzgsIC8qICYgKi9cbiAgQ0hBUl9BVDogNjQsIC8qIEAgKi9cbiAgQ0hBUl9CQUNLV0FSRF9TTEFTSDogOTIsIC8qIFxcICovXG4gIENIQVJfQ0FSUklBR0VfUkVUVVJOOiAxMywgLyogXFxyICovXG4gIENIQVJfQ0lSQ1VNRkxFWF9BQ0NFTlQ6IDk0LCAvKiBeICovXG4gIENIQVJfQ09MT046IDU4LCAvKiA6ICovXG4gIENIQVJfQ09NTUE6IDQ0LCAvKiAsICovXG4gIENIQVJfRE9UOiA0NiwgLyogLiAqL1xuICBDSEFSX0RPVUJMRV9RVU9URTogMzQsIC8qIFwiICovXG4gIENIQVJfRVFVQUw6IDYxLCAvKiA9ICovXG4gIENIQVJfRVhDTEFNQVRJT05fTUFSSzogMzMsIC8qICEgKi9cbiAgQ0hBUl9GT1JNX0ZFRUQ6IDEyLCAvKiBcXGYgKi9cbiAgQ0hBUl9GT1JXQVJEX1NMQVNIOiA0NywgLyogLyAqL1xuICBDSEFSX0dSQVZFX0FDQ0VOVDogOTYsIC8qIGAgKi9cbiAgQ0hBUl9IQVNIOiAzNSwgLyogIyAqL1xuICBDSEFSX0hZUEhFTl9NSU5VUzogNDUsIC8qIC0gKi9cbiAgQ0hBUl9MRUZUX0FOR0xFX0JSQUNLRVQ6IDYwLCAvKiA8ICovXG4gIENIQVJfTEVGVF9DVVJMWV9CUkFDRTogMTIzLCAvKiB7ICovXG4gIENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVDogOTEsIC8qIFsgKi9cbiAgQ0hBUl9MSU5FX0ZFRUQ6IDEwLCAvKiBcXG4gKi9cbiAgQ0hBUl9OT19CUkVBS19TUEFDRTogMTYwLCAvKiBcXHUwMEEwICovXG4gIENIQVJfUEVSQ0VOVDogMzcsIC8qICUgKi9cbiAgQ0hBUl9QTFVTOiA0MywgLyogKyAqL1xuICBDSEFSX1FVRVNUSU9OX01BUks6IDYzLCAvKiA/ICovXG4gIENIQVJfUklHSFRfQU5HTEVfQlJBQ0tFVDogNjIsIC8qID4gKi9cbiAgQ0hBUl9SSUdIVF9DVVJMWV9CUkFDRTogMTI1LCAvKiB9ICovXG4gIENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVQ6IDkzLCAvKiBdICovXG4gIENIQVJfU0VNSUNPTE9OOiA1OSwgLyogOyAqL1xuICBDSEFSX1NJTkdMRV9RVU9URTogMzksIC8qICcgKi9cbiAgQ0hBUl9TUEFDRTogMzIsIC8qICAgKi9cbiAgQ0hBUl9UQUI6IDksIC8qIFxcdCAqL1xuICBDSEFSX1VOREVSU0NPUkU6IDk1LCAvKiBfICovXG4gIENIQVJfVkVSVElDQUxfTElORTogMTI0LCAvKiB8ICovXG4gIENIQVJfWkVST19XSURUSF9OT0JSRUFLX1NQQUNFOiA2NTI3OSwgLyogXFx1RkVGRiAqL1xuXG4gIFNFUDogcGF0aC5zZXAsXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBFWFRHTE9CX0NIQVJTXG4gICAqL1xuXG4gIGV4dGdsb2JDaGFycyhjaGFycykge1xuICAgIHJldHVybiB7XG4gICAgICAnISc6IHsgdHlwZTogJ25lZ2F0ZScsIG9wZW46ICcoPzooPyEoPzonLCBjbG9zZTogYCkpJHtjaGFycy5TVEFSfSlgIH0sXG4gICAgICAnPyc6IHsgdHlwZTogJ3FtYXJrJywgb3BlbjogJyg/OicsIGNsb3NlOiAnKT8nIH0sXG4gICAgICAnKyc6IHsgdHlwZTogJ3BsdXMnLCBvcGVuOiAnKD86JywgY2xvc2U6ICcpKycgfSxcbiAgICAgICcqJzogeyB0eXBlOiAnc3RhcicsIG9wZW46ICcoPzonLCBjbG9zZTogJykqJyB9LFxuICAgICAgJ0AnOiB7IHR5cGU6ICdhdCcsIG9wZW46ICcoPzonLCBjbG9zZTogJyknIH1cbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGUgR0xPQl9DSEFSU1xuICAgKi9cblxuICBnbG9iQ2hhcnMod2luMzIpIHtcbiAgICByZXR1cm4gd2luMzIgPT09IHRydWUgPyBXSU5ET1dTX0NIQVJTIDogUE9TSVhfQ0hBUlM7XG4gIH1cbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3Qgd2luMzIgPSBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInO1xuY29uc3Qge1xuICBSRUdFWF9CQUNLU0xBU0gsXG4gIFJFR0VYX1JFTU9WRV9CQUNLU0xBU0gsXG4gIFJFR0VYX1NQRUNJQUxfQ0hBUlMsXG4gIFJFR0VYX1NQRUNJQUxfQ0hBUlNfR0xPQkFMXG59ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuZXhwb3J0cy5pc09iamVjdCA9IHZhbCA9PiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodmFsKTtcbmV4cG9ydHMuaGFzUmVnZXhDaGFycyA9IHN0ciA9PiBSRUdFWF9TUEVDSUFMX0NIQVJTLnRlc3Qoc3RyKTtcbmV4cG9ydHMuaXNSZWdleENoYXIgPSBzdHIgPT4gc3RyLmxlbmd0aCA9PT0gMSAmJiBleHBvcnRzLmhhc1JlZ2V4Q2hhcnMoc3RyKTtcbmV4cG9ydHMuZXNjYXBlUmVnZXggPSBzdHIgPT4gc3RyLnJlcGxhY2UoUkVHRVhfU1BFQ0lBTF9DSEFSU19HTE9CQUwsICdcXFxcJDEnKTtcbmV4cG9ydHMudG9Qb3NpeFNsYXNoZXMgPSBzdHIgPT4gc3RyLnJlcGxhY2UoUkVHRVhfQkFDS1NMQVNILCAnLycpO1xuXG5leHBvcnRzLnJlbW92ZUJhY2tzbGFzaGVzID0gc3RyID0+IHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKFJFR0VYX1JFTU9WRV9CQUNLU0xBU0gsIG1hdGNoID0+IHtcbiAgICByZXR1cm4gbWF0Y2ggPT09ICdcXFxcJyA/ICcnIDogbWF0Y2g7XG4gIH0pO1xufTtcblxuZXhwb3J0cy5zdXBwb3J0c0xvb2tiZWhpbmRzID0gKCkgPT4ge1xuICBjb25zdCBzZWdzID0gcHJvY2Vzcy52ZXJzaW9uLnNsaWNlKDEpLnNwbGl0KCcuJykubWFwKE51bWJlcik7XG4gIGlmIChzZWdzLmxlbmd0aCA9PT0gMyAmJiBzZWdzWzBdID49IDkgfHwgKHNlZ3NbMF0gPT09IDggJiYgc2Vnc1sxXSA+PSAxMCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5leHBvcnRzLmlzV2luZG93cyA9IG9wdGlvbnMgPT4ge1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy53aW5kb3dzID09PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4gb3B0aW9ucy53aW5kb3dzO1xuICB9XG4gIHJldHVybiB3aW4zMiA9PT0gdHJ1ZSB8fCBwYXRoLnNlcCA9PT0gJ1xcXFwnO1xufTtcblxuZXhwb3J0cy5lc2NhcGVMYXN0ID0gKGlucHV0LCBjaGFyLCBsYXN0SWR4KSA9PiB7XG4gIGNvbnN0IGlkeCA9IGlucHV0Lmxhc3RJbmRleE9mKGNoYXIsIGxhc3RJZHgpO1xuICBpZiAoaWR4ID09PSAtMSkgcmV0dXJuIGlucHV0O1xuICBpZiAoaW5wdXRbaWR4IC0gMV0gPT09ICdcXFxcJykgcmV0dXJuIGV4cG9ydHMuZXNjYXBlTGFzdChpbnB1dCwgY2hhciwgaWR4IC0gMSk7XG4gIHJldHVybiBgJHtpbnB1dC5zbGljZSgwLCBpZHgpfVxcXFwke2lucHV0LnNsaWNlKGlkeCl9YDtcbn07XG5cbmV4cG9ydHMucmVtb3ZlUHJlZml4ID0gKGlucHV0LCBzdGF0ZSA9IHt9KSA9PiB7XG4gIGxldCBvdXRwdXQgPSBpbnB1dDtcbiAgaWYgKG91dHB1dC5zdGFydHNXaXRoKCcuLycpKSB7XG4gICAgb3V0cHV0ID0gb3V0cHV0LnNsaWNlKDIpO1xuICAgIHN0YXRlLnByZWZpeCA9ICcuLyc7XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbmV4cG9ydHMud3JhcE91dHB1dCA9IChpbnB1dCwgc3RhdGUgPSB7fSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IHByZXBlbmQgPSBvcHRpb25zLmNvbnRhaW5zID8gJycgOiAnXic7XG4gIGNvbnN0IGFwcGVuZCA9IG9wdGlvbnMuY29udGFpbnMgPyAnJyA6ICckJztcblxuICBsZXQgb3V0cHV0ID0gYCR7cHJlcGVuZH0oPzoke2lucHV0fSkke2FwcGVuZH1gO1xuICBpZiAoc3RhdGUubmVnYXRlZCA9PT0gdHJ1ZSkge1xuICAgIG91dHB1dCA9IGAoPzpeKD8hJHtvdXRwdXR9KS4qJClgO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5jb25zdCB7XG4gIENIQVJfQVNURVJJU0ssICAgICAgICAgICAgIC8qICogKi9cbiAgQ0hBUl9BVCwgICAgICAgICAgICAgICAgICAgLyogQCAqL1xuICBDSEFSX0JBQ0tXQVJEX1NMQVNILCAgICAgICAvKiBcXCAqL1xuICBDSEFSX0NPTU1BLCAgICAgICAgICAgICAgICAvKiAsICovXG4gIENIQVJfRE9ULCAgICAgICAgICAgICAgICAgIC8qIC4gKi9cbiAgQ0hBUl9FWENMQU1BVElPTl9NQVJLLCAgICAgLyogISAqL1xuICBDSEFSX0ZPUldBUkRfU0xBU0gsICAgICAgICAvKiAvICovXG4gIENIQVJfTEVGVF9DVVJMWV9CUkFDRSwgICAgIC8qIHsgKi9cbiAgQ0hBUl9MRUZUX1BBUkVOVEhFU0VTLCAgICAgLyogKCAqL1xuICBDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVQsICAvKiBbICovXG4gIENIQVJfUExVUywgICAgICAgICAgICAgICAgIC8qICsgKi9cbiAgQ0hBUl9RVUVTVElPTl9NQVJLLCAgICAgICAgLyogPyAqL1xuICBDSEFSX1JJR0hUX0NVUkxZX0JSQUNFLCAgICAvKiB9ICovXG4gIENIQVJfUklHSFRfUEFSRU5USEVTRVMsICAgIC8qICkgKi9cbiAgQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVCAgLyogXSAqL1xufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbmNvbnN0IGlzUGF0aFNlcGFyYXRvciA9IGNvZGUgPT4ge1xuICByZXR1cm4gY29kZSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIIHx8IGNvZGUgPT09IENIQVJfQkFDS1dBUkRfU0xBU0g7XG59O1xuXG5jb25zdCBkZXB0aCA9IHRva2VuID0+IHtcbiAgaWYgKHRva2VuLmlzUHJlZml4ICE9PSB0cnVlKSB7XG4gICAgdG9rZW4uZGVwdGggPSB0b2tlbi5pc0dsb2JzdGFyID8gSW5maW5pdHkgOiAxO1xuICB9XG59O1xuXG4vKipcbiAqIFF1aWNrbHkgc2NhbnMgYSBnbG9iIHBhdHRlcm4gYW5kIHJldHVybnMgYW4gb2JqZWN0IHdpdGggYSBoYW5kZnVsIG9mXG4gKiB1c2VmdWwgcHJvcGVydGllcywgbGlrZSBgaXNHbG9iYCwgYHBhdGhgICh0aGUgbGVhZGluZyBub24tZ2xvYiwgaWYgaXQgZXhpc3RzKSxcbiAqIGBnbG9iYCAodGhlIGFjdHVhbCBwYXR0ZXJuKSwgYG5lZ2F0ZWRgICh0cnVlIGlmIHRoZSBwYXRoIHN0YXJ0cyB3aXRoIGAhYCBidXQgbm90XG4gKiB3aXRoIGAhKGApIGFuZCBgbmVnYXRlZEV4dGdsb2JgICh0cnVlIGlmIHRoZSBwYXRoIHN0YXJ0cyB3aXRoIGAhKGApLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBwbSA9IHJlcXVpcmUoJ3BpY29tYXRjaCcpO1xuICogY29uc29sZS5sb2cocG0uc2NhbignZm9vL2Jhci8qLmpzJykpO1xuICogeyBpc0dsb2I6IHRydWUsIGlucHV0OiAnZm9vL2Jhci8qLmpzJywgYmFzZTogJ2Zvby9iYXInLCBnbG9iOiAnKi5qcycgfVxuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHN0cmBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0b2tlbnMgYW5kIHJlZ2V4IHNvdXJjZSBzdHJpbmcuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmNvbnN0IHNjYW4gPSAoaW5wdXQsIG9wdGlvbnMpID0+IHtcbiAgY29uc3Qgb3B0cyA9IG9wdGlvbnMgfHwge307XG5cbiAgY29uc3QgbGVuZ3RoID0gaW5wdXQubGVuZ3RoIC0gMTtcbiAgY29uc3Qgc2NhblRvRW5kID0gb3B0cy5wYXJ0cyA9PT0gdHJ1ZSB8fCBvcHRzLnNjYW5Ub0VuZCA9PT0gdHJ1ZTtcbiAgY29uc3Qgc2xhc2hlcyA9IFtdO1xuICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgY29uc3QgcGFydHMgPSBbXTtcblxuICBsZXQgc3RyID0gaW5wdXQ7XG4gIGxldCBpbmRleCA9IC0xO1xuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgbGFzdEluZGV4ID0gMDtcbiAgbGV0IGlzQnJhY2UgPSBmYWxzZTtcbiAgbGV0IGlzQnJhY2tldCA9IGZhbHNlO1xuICBsZXQgaXNHbG9iID0gZmFsc2U7XG4gIGxldCBpc0V4dGdsb2IgPSBmYWxzZTtcbiAgbGV0IGlzR2xvYnN0YXIgPSBmYWxzZTtcbiAgbGV0IGJyYWNlRXNjYXBlZCA9IGZhbHNlO1xuICBsZXQgYmFja3NsYXNoZXMgPSBmYWxzZTtcbiAgbGV0IG5lZ2F0ZWQgPSBmYWxzZTtcbiAgbGV0IG5lZ2F0ZWRFeHRnbG9iID0gZmFsc2U7XG4gIGxldCBmaW5pc2hlZCA9IGZhbHNlO1xuICBsZXQgYnJhY2VzID0gMDtcbiAgbGV0IHByZXY7XG4gIGxldCBjb2RlO1xuICBsZXQgdG9rZW4gPSB7IHZhbHVlOiAnJywgZGVwdGg6IDAsIGlzR2xvYjogZmFsc2UgfTtcblxuICBjb25zdCBlb3MgPSAoKSA9PiBpbmRleCA+PSBsZW5ndGg7XG4gIGNvbnN0IHBlZWsgPSAoKSA9PiBzdHIuY2hhckNvZGVBdChpbmRleCArIDEpO1xuICBjb25zdCBhZHZhbmNlID0gKCkgPT4ge1xuICAgIHByZXYgPSBjb2RlO1xuICAgIHJldHVybiBzdHIuY2hhckNvZGVBdCgrK2luZGV4KTtcbiAgfTtcblxuICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICBjb2RlID0gYWR2YW5jZSgpO1xuICAgIGxldCBuZXh0O1xuXG4gICAgaWYgKGNvZGUgPT09IENIQVJfQkFDS1dBUkRfU0xBU0gpIHtcbiAgICAgIGJhY2tzbGFzaGVzID0gdG9rZW4uYmFja3NsYXNoZXMgPSB0cnVlO1xuICAgICAgY29kZSA9IGFkdmFuY2UoKTtcblxuICAgICAgaWYgKGNvZGUgPT09IENIQVJfTEVGVF9DVVJMWV9CUkFDRSkge1xuICAgICAgICBicmFjZUVzY2FwZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGJyYWNlRXNjYXBlZCA9PT0gdHJ1ZSB8fCBjb2RlID09PSBDSEFSX0xFRlRfQ1VSTFlfQlJBQ0UpIHtcbiAgICAgIGJyYWNlcysrO1xuXG4gICAgICB3aGlsZSAoZW9zKCkgIT09IHRydWUgJiYgKGNvZGUgPSBhZHZhbmNlKCkpKSB7XG4gICAgICAgIGlmIChjb2RlID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7XG4gICAgICAgICAgYmFja3NsYXNoZXMgPSB0b2tlbi5iYWNrc2xhc2hlcyA9IHRydWU7XG4gICAgICAgICAgYWR2YW5jZSgpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvZGUgPT09IENIQVJfTEVGVF9DVVJMWV9CUkFDRSkge1xuICAgICAgICAgIGJyYWNlcysrO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJyYWNlRXNjYXBlZCAhPT0gdHJ1ZSAmJiBjb2RlID09PSBDSEFSX0RPVCAmJiAoY29kZSA9IGFkdmFuY2UoKSkgPT09IENIQVJfRE9UKSB7XG4gICAgICAgICAgaXNCcmFjZSA9IHRva2VuLmlzQnJhY2UgPSB0cnVlO1xuICAgICAgICAgIGlzR2xvYiA9IHRva2VuLmlzR2xvYiA9IHRydWU7XG4gICAgICAgICAgZmluaXNoZWQgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKHNjYW5Ub0VuZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYnJhY2VFc2NhcGVkICE9PSB0cnVlICYmIGNvZGUgPT09IENIQVJfQ09NTUEpIHtcbiAgICAgICAgICBpc0JyYWNlID0gdG9rZW4uaXNCcmFjZSA9IHRydWU7XG4gICAgICAgICAgaXNHbG9iID0gdG9rZW4uaXNHbG9iID0gdHJ1ZTtcbiAgICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG5cbiAgICAgICAgICBpZiAoc2NhblRvRW5kID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb2RlID09PSBDSEFSX1JJR0hUX0NVUkxZX0JSQUNFKSB7XG4gICAgICAgICAgYnJhY2VzLS07XG5cbiAgICAgICAgICBpZiAoYnJhY2VzID09PSAwKSB7XG4gICAgICAgICAgICBicmFjZUVzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlzQnJhY2UgPSB0b2tlbi5pc0JyYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2NhblRvRW5kID09PSB0cnVlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIKSB7XG4gICAgICBzbGFzaGVzLnB1c2goaW5kZXgpO1xuICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgdG9rZW4gPSB7IHZhbHVlOiAnJywgZGVwdGg6IDAsIGlzR2xvYjogZmFsc2UgfTtcblxuICAgICAgaWYgKGZpbmlzaGVkID09PSB0cnVlKSBjb250aW51ZTtcbiAgICAgIGlmIChwcmV2ID09PSBDSEFSX0RPVCAmJiBpbmRleCA9PT0gKHN0YXJ0ICsgMSkpIHtcbiAgICAgICAgc3RhcnQgKz0gMjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGxhc3RJbmRleCA9IGluZGV4ICsgMTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChvcHRzLm5vZXh0ICE9PSB0cnVlKSB7XG4gICAgICBjb25zdCBpc0V4dGdsb2JDaGFyID0gY29kZSA9PT0gQ0hBUl9QTFVTXG4gICAgICAgIHx8IGNvZGUgPT09IENIQVJfQVRcbiAgICAgICAgfHwgY29kZSA9PT0gQ0hBUl9BU1RFUklTS1xuICAgICAgICB8fCBjb2RlID09PSBDSEFSX1FVRVNUSU9OX01BUktcbiAgICAgICAgfHwgY29kZSA9PT0gQ0hBUl9FWENMQU1BVElPTl9NQVJLO1xuXG4gICAgICBpZiAoaXNFeHRnbG9iQ2hhciA9PT0gdHJ1ZSAmJiBwZWVrKCkgPT09IENIQVJfTEVGVF9QQVJFTlRIRVNFUykge1xuICAgICAgICBpc0dsb2IgPSB0b2tlbi5pc0dsb2IgPSB0cnVlO1xuICAgICAgICBpc0V4dGdsb2IgPSB0b2tlbi5pc0V4dGdsb2IgPSB0cnVlO1xuICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgICAgIGlmIChjb2RlID09PSBDSEFSX0VYQ0xBTUFUSU9OX01BUksgJiYgaW5kZXggPT09IHN0YXJ0KSB7XG4gICAgICAgICAgbmVnYXRlZEV4dGdsb2IgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNjYW5Ub0VuZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHdoaWxlIChlb3MoKSAhPT0gdHJ1ZSAmJiAoY29kZSA9IGFkdmFuY2UoKSkpIHtcbiAgICAgICAgICAgIGlmIChjb2RlID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7XG4gICAgICAgICAgICAgIGJhY2tzbGFzaGVzID0gdG9rZW4uYmFja3NsYXNoZXMgPSB0cnVlO1xuICAgICAgICAgICAgICBjb2RlID0gYWR2YW5jZSgpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvZGUgPT09IENIQVJfUklHSFRfUEFSRU5USEVTRVMpIHtcbiAgICAgICAgICAgICAgaXNHbG9iID0gdG9rZW4uaXNHbG9iID0gdHJ1ZTtcbiAgICAgICAgICAgICAgZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IENIQVJfQVNURVJJU0spIHtcbiAgICAgIGlmIChwcmV2ID09PSBDSEFSX0FTVEVSSVNLKSBpc0dsb2JzdGFyID0gdG9rZW4uaXNHbG9ic3RhciA9IHRydWU7XG4gICAgICBpc0dsb2IgPSB0b2tlbi5pc0dsb2IgPSB0cnVlO1xuICAgICAgZmluaXNoZWQgPSB0cnVlO1xuXG4gICAgICBpZiAoc2NhblRvRW5kID09PSB0cnVlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IENIQVJfUVVFU1RJT05fTUFSSykge1xuICAgICAgaXNHbG9iID0gdG9rZW4uaXNHbG9iID0gdHJ1ZTtcbiAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcblxuICAgICAgaWYgKHNjYW5Ub0VuZCA9PT0gdHJ1ZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChjb2RlID09PSBDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVQpIHtcbiAgICAgIHdoaWxlIChlb3MoKSAhPT0gdHJ1ZSAmJiAobmV4dCA9IGFkdmFuY2UoKSkpIHtcbiAgICAgICAgaWYgKG5leHQgPT09IENIQVJfQkFDS1dBUkRfU0xBU0gpIHtcbiAgICAgICAgICBiYWNrc2xhc2hlcyA9IHRva2VuLmJhY2tzbGFzaGVzID0gdHJ1ZTtcbiAgICAgICAgICBhZHZhbmNlKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV4dCA9PT0gQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVCkge1xuICAgICAgICAgIGlzQnJhY2tldCA9IHRva2VuLmlzQnJhY2tldCA9IHRydWU7XG4gICAgICAgICAgaXNHbG9iID0gdG9rZW4uaXNHbG9iID0gdHJ1ZTtcbiAgICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNjYW5Ub0VuZCA9PT0gdHJ1ZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMubm9uZWdhdGUgIT09IHRydWUgJiYgY29kZSA9PT0gQ0hBUl9FWENMQU1BVElPTl9NQVJLICYmIGluZGV4ID09PSBzdGFydCkge1xuICAgICAgbmVnYXRlZCA9IHRva2VuLm5lZ2F0ZWQgPSB0cnVlO1xuICAgICAgc3RhcnQrKztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChvcHRzLm5vcGFyZW4gIT09IHRydWUgJiYgY29kZSA9PT0gQ0hBUl9MRUZUX1BBUkVOVEhFU0VTKSB7XG4gICAgICBpc0dsb2IgPSB0b2tlbi5pc0dsb2IgPSB0cnVlO1xuXG4gICAgICBpZiAoc2NhblRvRW5kID09PSB0cnVlKSB7XG4gICAgICAgIHdoaWxlIChlb3MoKSAhPT0gdHJ1ZSAmJiAoY29kZSA9IGFkdmFuY2UoKSkpIHtcbiAgICAgICAgICBpZiAoY29kZSA9PT0gQ0hBUl9MRUZUX1BBUkVOVEhFU0VTKSB7XG4gICAgICAgICAgICBiYWNrc2xhc2hlcyA9IHRva2VuLmJhY2tzbGFzaGVzID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvZGUgPSBhZHZhbmNlKCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY29kZSA9PT0gQ0hBUl9SSUdIVF9QQVJFTlRIRVNFUykge1xuICAgICAgICAgICAgZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGlzR2xvYiA9PT0gdHJ1ZSkge1xuICAgICAgZmluaXNoZWQgPSB0cnVlO1xuXG4gICAgICBpZiAoc2NhblRvRW5kID09PSB0cnVlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAob3B0cy5ub2V4dCA9PT0gdHJ1ZSkge1xuICAgIGlzRXh0Z2xvYiA9IGZhbHNlO1xuICAgIGlzR2xvYiA9IGZhbHNlO1xuICB9XG5cbiAgbGV0IGJhc2UgPSBzdHI7XG4gIGxldCBwcmVmaXggPSAnJztcbiAgbGV0IGdsb2IgPSAnJztcblxuICBpZiAoc3RhcnQgPiAwKSB7XG4gICAgcHJlZml4ID0gc3RyLnNsaWNlKDAsIHN0YXJ0KTtcbiAgICBzdHIgPSBzdHIuc2xpY2Uoc3RhcnQpO1xuICAgIGxhc3RJbmRleCAtPSBzdGFydDtcbiAgfVxuXG4gIGlmIChiYXNlICYmIGlzR2xvYiA9PT0gdHJ1ZSAmJiBsYXN0SW5kZXggPiAwKSB7XG4gICAgYmFzZSA9IHN0ci5zbGljZSgwLCBsYXN0SW5kZXgpO1xuICAgIGdsb2IgPSBzdHIuc2xpY2UobGFzdEluZGV4KTtcbiAgfSBlbHNlIGlmIChpc0dsb2IgPT09IHRydWUpIHtcbiAgICBiYXNlID0gJyc7XG4gICAgZ2xvYiA9IHN0cjtcbiAgfSBlbHNlIHtcbiAgICBiYXNlID0gc3RyO1xuICB9XG5cbiAgaWYgKGJhc2UgJiYgYmFzZSAhPT0gJycgJiYgYmFzZSAhPT0gJy8nICYmIGJhc2UgIT09IHN0cikge1xuICAgIGlmIChpc1BhdGhTZXBhcmF0b3IoYmFzZS5jaGFyQ29kZUF0KGJhc2UubGVuZ3RoIC0gMSkpKSB7XG4gICAgICBiYXNlID0gYmFzZS5zbGljZSgwLCAtMSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdHMudW5lc2NhcGUgPT09IHRydWUpIHtcbiAgICBpZiAoZ2xvYikgZ2xvYiA9IHV0aWxzLnJlbW92ZUJhY2tzbGFzaGVzKGdsb2IpO1xuXG4gICAgaWYgKGJhc2UgJiYgYmFja3NsYXNoZXMgPT09IHRydWUpIHtcbiAgICAgIGJhc2UgPSB1dGlscy5yZW1vdmVCYWNrc2xhc2hlcyhiYXNlKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBzdGF0ZSA9IHtcbiAgICBwcmVmaXgsXG4gICAgaW5wdXQsXG4gICAgc3RhcnQsXG4gICAgYmFzZSxcbiAgICBnbG9iLFxuICAgIGlzQnJhY2UsXG4gICAgaXNCcmFja2V0LFxuICAgIGlzR2xvYixcbiAgICBpc0V4dGdsb2IsXG4gICAgaXNHbG9ic3RhcixcbiAgICBuZWdhdGVkLFxuICAgIG5lZ2F0ZWRFeHRnbG9iXG4gIH07XG5cbiAgaWYgKG9wdHMudG9rZW5zID09PSB0cnVlKSB7XG4gICAgc3RhdGUubWF4RGVwdGggPSAwO1xuICAgIGlmICghaXNQYXRoU2VwYXJhdG9yKGNvZGUpKSB7XG4gICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgfVxuICAgIHN0YXRlLnRva2VucyA9IHRva2VucztcbiAgfVxuXG4gIGlmIChvcHRzLnBhcnRzID09PSB0cnVlIHx8IG9wdHMudG9rZW5zID09PSB0cnVlKSB7XG4gICAgbGV0IHByZXZJbmRleDtcblxuICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHNsYXNoZXMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgY29uc3QgbiA9IHByZXZJbmRleCA/IHByZXZJbmRleCArIDEgOiBzdGFydDtcbiAgICAgIGNvbnN0IGkgPSBzbGFzaGVzW2lkeF07XG4gICAgICBjb25zdCB2YWx1ZSA9IGlucHV0LnNsaWNlKG4sIGkpO1xuICAgICAgaWYgKG9wdHMudG9rZW5zKSB7XG4gICAgICAgIGlmIChpZHggPT09IDAgJiYgc3RhcnQgIT09IDApIHtcbiAgICAgICAgICB0b2tlbnNbaWR4XS5pc1ByZWZpeCA9IHRydWU7XG4gICAgICAgICAgdG9rZW5zW2lkeF0udmFsdWUgPSBwcmVmaXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9rZW5zW2lkeF0udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBkZXB0aCh0b2tlbnNbaWR4XSk7XG4gICAgICAgIHN0YXRlLm1heERlcHRoICs9IHRva2Vuc1tpZHhdLmRlcHRoO1xuICAgICAgfVxuICAgICAgaWYgKGlkeCAhPT0gMCB8fCB2YWx1ZSAhPT0gJycpIHtcbiAgICAgICAgcGFydHMucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBwcmV2SW5kZXggPSBpO1xuICAgIH1cblxuICAgIGlmIChwcmV2SW5kZXggJiYgcHJldkluZGV4ICsgMSA8IGlucHV0Lmxlbmd0aCkge1xuICAgICAgY29uc3QgdmFsdWUgPSBpbnB1dC5zbGljZShwcmV2SW5kZXggKyAxKTtcbiAgICAgIHBhcnRzLnB1c2godmFsdWUpO1xuXG4gICAgICBpZiAob3B0cy50b2tlbnMpIHtcbiAgICAgICAgdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBkZXB0aCh0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgc3RhdGUubWF4RGVwdGggKz0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXS5kZXB0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0ZS5zbGFzaGVzID0gc2xhc2hlcztcbiAgICBzdGF0ZS5wYXJ0cyA9IHBhcnRzO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzY2FuO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG5cbmNvbnN0IHtcbiAgTUFYX0xFTkdUSCxcbiAgUE9TSVhfUkVHRVhfU09VUkNFLFxuICBSRUdFWF9OT05fU1BFQ0lBTF9DSEFSUyxcbiAgUkVHRVhfU1BFQ0lBTF9DSEFSU19CQUNLUkVGLFxuICBSRVBMQUNFTUVOVFNcbn0gPSBjb25zdGFudHM7XG5cbi8qKlxuICogSGVscGVyc1xuICovXG5cbmNvbnN0IGV4cGFuZFJhbmdlID0gKGFyZ3MsIG9wdGlvbnMpID0+IHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zLmV4cGFuZFJhbmdlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuZXhwYW5kUmFuZ2UoLi4uYXJncywgb3B0aW9ucyk7XG4gIH1cblxuICBhcmdzLnNvcnQoKTtcbiAgY29uc3QgdmFsdWUgPSBgWyR7YXJncy5qb2luKCctJyl9XWA7XG5cbiAgdHJ5IHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3ICovXG4gICAgbmV3IFJlZ0V4cCh2YWx1ZSk7XG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgcmV0dXJuIGFyZ3MubWFwKHYgPT4gdXRpbHMuZXNjYXBlUmVnZXgodikpLmpvaW4oJy4uJyk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59O1xuXG4vKipcbiAqIENyZWF0ZSB0aGUgbWVzc2FnZSBmb3IgYSBzeW50YXggZXJyb3JcbiAqL1xuXG5jb25zdCBzeW50YXhFcnJvciA9ICh0eXBlLCBjaGFyKSA9PiB7XG4gIHJldHVybiBgTWlzc2luZyAke3R5cGV9OiBcIiR7Y2hhcn1cIiAtIHVzZSBcIlxcXFxcXFxcJHtjaGFyfVwiIHRvIG1hdGNoIGxpdGVyYWwgY2hhcmFjdGVyc2A7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBpbnB1dCBzdHJpbmcuXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuY29uc3QgcGFyc2UgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHtcbiAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhIHN0cmluZycpO1xuICB9XG5cbiAgaW5wdXQgPSBSRVBMQUNFTUVOVFNbaW5wdXRdIHx8IGlucHV0O1xuXG4gIGNvbnN0IG9wdHMgPSB7IC4uLm9wdGlvbnMgfTtcbiAgY29uc3QgbWF4ID0gdHlwZW9mIG9wdHMubWF4TGVuZ3RoID09PSAnbnVtYmVyJyA/IE1hdGgubWluKE1BWF9MRU5HVEgsIG9wdHMubWF4TGVuZ3RoKSA6IE1BWF9MRU5HVEg7XG5cbiAgbGV0IGxlbiA9IGlucHV0Lmxlbmd0aDtcbiAgaWYgKGxlbiA+IG1heCkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgSW5wdXQgbGVuZ3RoOiAke2xlbn0sIGV4Y2VlZHMgbWF4aW11bSBhbGxvd2VkIGxlbmd0aDogJHttYXh9YCk7XG4gIH1cblxuICBjb25zdCBib3MgPSB7IHR5cGU6ICdib3MnLCB2YWx1ZTogJycsIG91dHB1dDogb3B0cy5wcmVwZW5kIHx8ICcnIH07XG4gIGNvbnN0IHRva2VucyA9IFtib3NdO1xuXG4gIGNvbnN0IGNhcHR1cmUgPSBvcHRzLmNhcHR1cmUgPyAnJyA6ICc/Oic7XG4gIGNvbnN0IHdpbjMyID0gdXRpbHMuaXNXaW5kb3dzKG9wdGlvbnMpO1xuXG4gIC8vIGNyZWF0ZSBjb25zdGFudHMgYmFzZWQgb24gcGxhdGZvcm0sIGZvciB3aW5kb3dzIG9yIHBvc2l4XG4gIGNvbnN0IFBMQVRGT1JNX0NIQVJTID0gY29uc3RhbnRzLmdsb2JDaGFycyh3aW4zMik7XG4gIGNvbnN0IEVYVEdMT0JfQ0hBUlMgPSBjb25zdGFudHMuZXh0Z2xvYkNoYXJzKFBMQVRGT1JNX0NIQVJTKTtcblxuICBjb25zdCB7XG4gICAgRE9UX0xJVEVSQUwsXG4gICAgUExVU19MSVRFUkFMLFxuICAgIFNMQVNIX0xJVEVSQUwsXG4gICAgT05FX0NIQVIsXG4gICAgRE9UU19TTEFTSCxcbiAgICBOT19ET1QsXG4gICAgTk9fRE9UX1NMQVNILFxuICAgIE5PX0RPVFNfU0xBU0gsXG4gICAgUU1BUkssXG4gICAgUU1BUktfTk9fRE9ULFxuICAgIFNUQVIsXG4gICAgU1RBUlRfQU5DSE9SXG4gIH0gPSBQTEFURk9STV9DSEFSUztcblxuICBjb25zdCBnbG9ic3RhciA9IG9wdHMgPT4ge1xuICAgIHJldHVybiBgKCR7Y2FwdHVyZX0oPzooPyEke1NUQVJUX0FOQ0hPUn0ke29wdHMuZG90ID8gRE9UU19TTEFTSCA6IERPVF9MSVRFUkFMfSkuKSo/KWA7XG4gIH07XG5cbiAgY29uc3Qgbm9kb3QgPSBvcHRzLmRvdCA/ICcnIDogTk9fRE9UO1xuICBjb25zdCBxbWFya05vRG90ID0gb3B0cy5kb3QgPyBRTUFSSyA6IFFNQVJLX05PX0RPVDtcbiAgbGV0IHN0YXIgPSBvcHRzLmJhc2ggPT09IHRydWUgPyBnbG9ic3RhcihvcHRzKSA6IFNUQVI7XG5cbiAgaWYgKG9wdHMuY2FwdHVyZSkge1xuICAgIHN0YXIgPSBgKCR7c3Rhcn0pYDtcbiAgfVxuXG4gIC8vIG1pbmltYXRjaCBvcHRpb25zIHN1cHBvcnRcbiAgaWYgKHR5cGVvZiBvcHRzLm5vZXh0ID09PSAnYm9vbGVhbicpIHtcbiAgICBvcHRzLm5vZXh0Z2xvYiA9IG9wdHMubm9leHQ7XG4gIH1cblxuICBjb25zdCBzdGF0ZSA9IHtcbiAgICBpbnB1dCxcbiAgICBpbmRleDogLTEsXG4gICAgc3RhcnQ6IDAsXG4gICAgZG90OiBvcHRzLmRvdCA9PT0gdHJ1ZSxcbiAgICBjb25zdW1lZDogJycsXG4gICAgb3V0cHV0OiAnJyxcbiAgICBwcmVmaXg6ICcnLFxuICAgIGJhY2t0cmFjazogZmFsc2UsXG4gICAgbmVnYXRlZDogZmFsc2UsXG4gICAgYnJhY2tldHM6IDAsXG4gICAgYnJhY2VzOiAwLFxuICAgIHBhcmVuczogMCxcbiAgICBxdW90ZXM6IDAsXG4gICAgZ2xvYnN0YXI6IGZhbHNlLFxuICAgIHRva2Vuc1xuICB9O1xuXG4gIGlucHV0ID0gdXRpbHMucmVtb3ZlUHJlZml4KGlucHV0LCBzdGF0ZSk7XG4gIGxlbiA9IGlucHV0Lmxlbmd0aDtcblxuICBjb25zdCBleHRnbG9icyA9IFtdO1xuICBjb25zdCBicmFjZXMgPSBbXTtcbiAgY29uc3Qgc3RhY2sgPSBbXTtcbiAgbGV0IHByZXYgPSBib3M7XG4gIGxldCB2YWx1ZTtcblxuICAvKipcbiAgICogVG9rZW5pemluZyBoZWxwZXJzXG4gICAqL1xuXG4gIGNvbnN0IGVvcyA9ICgpID0+IHN0YXRlLmluZGV4ID09PSBsZW4gLSAxO1xuICBjb25zdCBwZWVrID0gc3RhdGUucGVlayA9IChuID0gMSkgPT4gaW5wdXRbc3RhdGUuaW5kZXggKyBuXTtcbiAgY29uc3QgYWR2YW5jZSA9IHN0YXRlLmFkdmFuY2UgPSAoKSA9PiBpbnB1dFsrK3N0YXRlLmluZGV4XSB8fCAnJztcbiAgY29uc3QgcmVtYWluaW5nID0gKCkgPT4gaW5wdXQuc2xpY2Uoc3RhdGUuaW5kZXggKyAxKTtcbiAgY29uc3QgY29uc3VtZSA9ICh2YWx1ZSA9ICcnLCBudW0gPSAwKSA9PiB7XG4gICAgc3RhdGUuY29uc3VtZWQgKz0gdmFsdWU7XG4gICAgc3RhdGUuaW5kZXggKz0gbnVtO1xuICB9O1xuXG4gIGNvbnN0IGFwcGVuZCA9IHRva2VuID0+IHtcbiAgICBzdGF0ZS5vdXRwdXQgKz0gdG9rZW4ub3V0cHV0ICE9IG51bGwgPyB0b2tlbi5vdXRwdXQgOiB0b2tlbi52YWx1ZTtcbiAgICBjb25zdW1lKHRva2VuLnZhbHVlKTtcbiAgfTtcblxuICBjb25zdCBuZWdhdGUgPSAoKSA9PiB7XG4gICAgbGV0IGNvdW50ID0gMTtcblxuICAgIHdoaWxlIChwZWVrKCkgPT09ICchJyAmJiAocGVlaygyKSAhPT0gJygnIHx8IHBlZWsoMykgPT09ICc/JykpIHtcbiAgICAgIGFkdmFuY2UoKTtcbiAgICAgIHN0YXRlLnN0YXJ0Kys7XG4gICAgICBjb3VudCsrO1xuICAgIH1cblxuICAgIGlmIChjb3VudCAlIDIgPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzdGF0ZS5uZWdhdGVkID0gdHJ1ZTtcbiAgICBzdGF0ZS5zdGFydCsrO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIGNvbnN0IGluY3JlbWVudCA9IHR5cGUgPT4ge1xuICAgIHN0YXRlW3R5cGVdKys7XG4gICAgc3RhY2sucHVzaCh0eXBlKTtcbiAgfTtcblxuICBjb25zdCBkZWNyZW1lbnQgPSB0eXBlID0+IHtcbiAgICBzdGF0ZVt0eXBlXS0tO1xuICAgIHN0YWNrLnBvcCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQdXNoIHRva2VucyBvbnRvIHRoZSB0b2tlbnMgYXJyYXkuIFRoaXMgaGVscGVyIHNwZWVkcyB1cFxuICAgKiB0b2tlbml6aW5nIGJ5IDEpIGhlbHBpbmcgdXMgYXZvaWQgYmFja3RyYWNraW5nIGFzIG11Y2ggYXMgcG9zc2libGUsXG4gICAqIGFuZCAyKSBoZWxwaW5nIHVzIGF2b2lkIGNyZWF0aW5nIGV4dHJhIHRva2VucyB3aGVuIGNvbnNlY3V0aXZlXG4gICAqIGNoYXJhY3RlcnMgYXJlIHBsYWluIHRleHQuIFRoaXMgaW1wcm92ZXMgcGVyZm9ybWFuY2UgYW5kIHNpbXBsaWZpZXNcbiAgICogbG9va2JlaGluZHMuXG4gICAqL1xuXG4gIGNvbnN0IHB1c2ggPSB0b2sgPT4ge1xuICAgIGlmIChwcmV2LnR5cGUgPT09ICdnbG9ic3RhcicpIHtcbiAgICAgIGNvbnN0IGlzQnJhY2UgPSBzdGF0ZS5icmFjZXMgPiAwICYmICh0b2sudHlwZSA9PT0gJ2NvbW1hJyB8fCB0b2sudHlwZSA9PT0gJ2JyYWNlJyk7XG4gICAgICBjb25zdCBpc0V4dGdsb2IgPSB0b2suZXh0Z2xvYiA9PT0gdHJ1ZSB8fCAoZXh0Z2xvYnMubGVuZ3RoICYmICh0b2sudHlwZSA9PT0gJ3BpcGUnIHx8IHRvay50eXBlID09PSAncGFyZW4nKSk7XG5cbiAgICAgIGlmICh0b2sudHlwZSAhPT0gJ3NsYXNoJyAmJiB0b2sudHlwZSAhPT0gJ3BhcmVuJyAmJiAhaXNCcmFjZSAmJiAhaXNFeHRnbG9iKSB7XG4gICAgICAgIHN0YXRlLm91dHB1dCA9IHN0YXRlLm91dHB1dC5zbGljZSgwLCAtcHJldi5vdXRwdXQubGVuZ3RoKTtcbiAgICAgICAgcHJldi50eXBlID0gJ3N0YXInO1xuICAgICAgICBwcmV2LnZhbHVlID0gJyonO1xuICAgICAgICBwcmV2Lm91dHB1dCA9IHN0YXI7XG4gICAgICAgIHN0YXRlLm91dHB1dCArPSBwcmV2Lm91dHB1dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZXh0Z2xvYnMubGVuZ3RoICYmIHRvay50eXBlICE9PSAncGFyZW4nKSB7XG4gICAgICBleHRnbG9ic1tleHRnbG9icy5sZW5ndGggLSAxXS5pbm5lciArPSB0b2sudmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKHRvay52YWx1ZSB8fCB0b2sub3V0cHV0KSBhcHBlbmQodG9rKTtcbiAgICBpZiAocHJldiAmJiBwcmV2LnR5cGUgPT09ICd0ZXh0JyAmJiB0b2sudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICBwcmV2LnZhbHVlICs9IHRvay52YWx1ZTtcbiAgICAgIHByZXYub3V0cHV0ID0gKHByZXYub3V0cHV0IHx8ICcnKSArIHRvay52YWx1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0b2sucHJldiA9IHByZXY7XG4gICAgdG9rZW5zLnB1c2godG9rKTtcbiAgICBwcmV2ID0gdG9rO1xuICB9O1xuXG4gIGNvbnN0IGV4dGdsb2JPcGVuID0gKHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgY29uc3QgdG9rZW4gPSB7IC4uLkVYVEdMT0JfQ0hBUlNbdmFsdWVdLCBjb25kaXRpb25zOiAxLCBpbm5lcjogJycgfTtcblxuICAgIHRva2VuLnByZXYgPSBwcmV2O1xuICAgIHRva2VuLnBhcmVucyA9IHN0YXRlLnBhcmVucztcbiAgICB0b2tlbi5vdXRwdXQgPSBzdGF0ZS5vdXRwdXQ7XG4gICAgY29uc3Qgb3V0cHV0ID0gKG9wdHMuY2FwdHVyZSA/ICcoJyA6ICcnKSArIHRva2VuLm9wZW47XG5cbiAgICBpbmNyZW1lbnQoJ3BhcmVucycpO1xuICAgIHB1c2goeyB0eXBlLCB2YWx1ZSwgb3V0cHV0OiBzdGF0ZS5vdXRwdXQgPyAnJyA6IE9ORV9DSEFSIH0pO1xuICAgIHB1c2goeyB0eXBlOiAncGFyZW4nLCBleHRnbG9iOiB0cnVlLCB2YWx1ZTogYWR2YW5jZSgpLCBvdXRwdXQgfSk7XG4gICAgZXh0Z2xvYnMucHVzaCh0b2tlbik7XG4gIH07XG5cbiAgY29uc3QgZXh0Z2xvYkNsb3NlID0gdG9rZW4gPT4ge1xuICAgIGxldCBvdXRwdXQgPSB0b2tlbi5jbG9zZSArIChvcHRzLmNhcHR1cmUgPyAnKScgOiAnJyk7XG4gICAgbGV0IHJlc3Q7XG5cbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ25lZ2F0ZScpIHtcbiAgICAgIGxldCBleHRnbG9iU3RhciA9IHN0YXI7XG5cbiAgICAgIGlmICh0b2tlbi5pbm5lciAmJiB0b2tlbi5pbm5lci5sZW5ndGggPiAxICYmIHRva2VuLmlubmVyLmluY2x1ZGVzKCcvJykpIHtcbiAgICAgICAgZXh0Z2xvYlN0YXIgPSBnbG9ic3RhcihvcHRzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGV4dGdsb2JTdGFyICE9PSBzdGFyIHx8IGVvcygpIHx8IC9eXFwpKyQvLnRlc3QocmVtYWluaW5nKCkpKSB7XG4gICAgICAgIG91dHB1dCA9IHRva2VuLmNsb3NlID0gYCkkKSkke2V4dGdsb2JTdGFyfWA7XG4gICAgICB9XG5cbiAgICAgIGlmICh0b2tlbi5pbm5lci5pbmNsdWRlcygnKicpICYmIChyZXN0ID0gcmVtYWluaW5nKCkpICYmIC9eXFwuW15cXFxcLy5dKyQvLnRlc3QocmVzdCkpIHtcbiAgICAgICAgb3V0cHV0ID0gdG9rZW4uY2xvc2UgPSBgKSR7cmVzdH0pJHtleHRnbG9iU3Rhcn0pYDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuLnByZXYudHlwZSA9PT0gJ2JvcycpIHtcbiAgICAgICAgc3RhdGUubmVnYXRlZEV4dGdsb2IgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHB1c2goeyB0eXBlOiAncGFyZW4nLCBleHRnbG9iOiB0cnVlLCB2YWx1ZSwgb3V0cHV0IH0pO1xuICAgIGRlY3JlbWVudCgncGFyZW5zJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZhc3QgcGF0aHNcbiAgICovXG5cbiAgaWYgKG9wdHMuZmFzdHBhdGhzICE9PSBmYWxzZSAmJiAhLyheWyohXXxbLygpW1xcXXt9XCJdKS8udGVzdChpbnB1dCkpIHtcbiAgICBsZXQgYmFja3NsYXNoZXMgPSBmYWxzZTtcblxuICAgIGxldCBvdXRwdXQgPSBpbnB1dC5yZXBsYWNlKFJFR0VYX1NQRUNJQUxfQ0hBUlNfQkFDS1JFRiwgKG0sIGVzYywgY2hhcnMsIGZpcnN0LCByZXN0LCBpbmRleCkgPT4ge1xuICAgICAgaWYgKGZpcnN0ID09PSAnXFxcXCcpIHtcbiAgICAgICAgYmFja3NsYXNoZXMgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZpcnN0ID09PSAnPycpIHtcbiAgICAgICAgaWYgKGVzYykge1xuICAgICAgICAgIHJldHVybiBlc2MgKyBmaXJzdCArIChyZXN0ID8gUU1BUksucmVwZWF0KHJlc3QubGVuZ3RoKSA6ICcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gcW1hcmtOb0RvdCArIChyZXN0ID8gUU1BUksucmVwZWF0KHJlc3QubGVuZ3RoKSA6ICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUU1BUksucmVwZWF0KGNoYXJzLmxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmaXJzdCA9PT0gJy4nKSB7XG4gICAgICAgIHJldHVybiBET1RfTElURVJBTC5yZXBlYXQoY2hhcnMubGVuZ3RoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZpcnN0ID09PSAnKicpIHtcbiAgICAgICAgaWYgKGVzYykge1xuICAgICAgICAgIHJldHVybiBlc2MgKyBmaXJzdCArIChyZXN0ID8gc3RhciA6ICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlc2MgPyBtIDogYFxcXFwke219YDtcbiAgICB9KTtcblxuICAgIGlmIChiYWNrc2xhc2hlcyA9PT0gdHJ1ZSkge1xuICAgICAgaWYgKG9wdHMudW5lc2NhcGUgPT09IHRydWUpIHtcbiAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2UoL1xcXFwvZywgJycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2UoL1xcXFwrL2csIG0gPT4ge1xuICAgICAgICAgIHJldHVybiBtLmxlbmd0aCAlIDIgPT09IDAgPyAnXFxcXFxcXFwnIDogKG0gPyAnXFxcXCcgOiAnJyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvdXRwdXQgPT09IGlucHV0ICYmIG9wdHMuY29udGFpbnMgPT09IHRydWUpIHtcbiAgICAgIHN0YXRlLm91dHB1dCA9IGlucHV0O1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cblxuICAgIHN0YXRlLm91dHB1dCA9IHV0aWxzLndyYXBPdXRwdXQob3V0cHV0LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRva2VuaXplIGlucHV0IHVudGlsIHdlIHJlYWNoIGVuZC1vZi1zdHJpbmdcbiAgICovXG5cbiAgd2hpbGUgKCFlb3MoKSkge1xuICAgIHZhbHVlID0gYWR2YW5jZSgpO1xuXG4gICAgaWYgKHZhbHVlID09PSAnXFx1MDAwMCcpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVzY2FwZWQgY2hhcmFjdGVyc1xuICAgICAqL1xuXG4gICAgaWYgKHZhbHVlID09PSAnXFxcXCcpIHtcbiAgICAgIGNvbnN0IG5leHQgPSBwZWVrKCk7XG5cbiAgICAgIGlmIChuZXh0ID09PSAnLycgJiYgb3B0cy5iYXNoICE9PSB0cnVlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV4dCA9PT0gJy4nIHx8IG5leHQgPT09ICc7Jykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFuZXh0KSB7XG4gICAgICAgIHZhbHVlICs9ICdcXFxcJztcbiAgICAgICAgcHVzaCh7IHR5cGU6ICd0ZXh0JywgdmFsdWUgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBjb2xsYXBzZSBzbGFzaGVzIHRvIHJlZHVjZSBwb3RlbnRpYWwgZm9yIGV4cGxvaXRzXG4gICAgICBjb25zdCBtYXRjaCA9IC9eXFxcXCsvLmV4ZWMocmVtYWluaW5nKCkpO1xuICAgICAgbGV0IHNsYXNoZXMgPSAwO1xuXG4gICAgICBpZiAobWF0Y2ggJiYgbWF0Y2hbMF0ubGVuZ3RoID4gMikge1xuICAgICAgICBzbGFzaGVzID0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICBzdGF0ZS5pbmRleCArPSBzbGFzaGVzO1xuICAgICAgICBpZiAoc2xhc2hlcyAlIDIgIT09IDApIHtcbiAgICAgICAgICB2YWx1ZSArPSAnXFxcXCc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9wdHMudW5lc2NhcGUgPT09IHRydWUpIHtcbiAgICAgICAgdmFsdWUgPSBhZHZhbmNlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSArPSBhZHZhbmNlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZS5icmFja2V0cyA9PT0gMCkge1xuICAgICAgICBwdXNoKHsgdHlwZTogJ3RleHQnLCB2YWx1ZSB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgd2UncmUgaW5zaWRlIGEgcmVnZXggY2hhcmFjdGVyIGNsYXNzLCBjb250aW51ZVxuICAgICAqIHVudGlsIHdlIHJlYWNoIHRoZSBjbG9zaW5nIGJyYWNrZXQuXG4gICAgICovXG5cbiAgICBpZiAoc3RhdGUuYnJhY2tldHMgPiAwICYmICh2YWx1ZSAhPT0gJ10nIHx8IHByZXYudmFsdWUgPT09ICdbJyB8fCBwcmV2LnZhbHVlID09PSAnW14nKSkge1xuICAgICAgaWYgKG9wdHMucG9zaXggIT09IGZhbHNlICYmIHZhbHVlID09PSAnOicpIHtcbiAgICAgICAgY29uc3QgaW5uZXIgPSBwcmV2LnZhbHVlLnNsaWNlKDEpO1xuICAgICAgICBpZiAoaW5uZXIuaW5jbHVkZXMoJ1snKSkge1xuICAgICAgICAgIHByZXYucG9zaXggPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKGlubmVyLmluY2x1ZGVzKCc6JykpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeCA9IHByZXYudmFsdWUubGFzdEluZGV4T2YoJ1snKTtcbiAgICAgICAgICAgIGNvbnN0IHByZSA9IHByZXYudmFsdWUuc2xpY2UoMCwgaWR4KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3QgPSBwcmV2LnZhbHVlLnNsaWNlKGlkeCArIDIpO1xuICAgICAgICAgICAgY29uc3QgcG9zaXggPSBQT1NJWF9SRUdFWF9TT1VSQ0VbcmVzdF07XG4gICAgICAgICAgICBpZiAocG9zaXgpIHtcbiAgICAgICAgICAgICAgcHJldi52YWx1ZSA9IHByZSArIHBvc2l4O1xuICAgICAgICAgICAgICBzdGF0ZS5iYWNrdHJhY2sgPSB0cnVlO1xuICAgICAgICAgICAgICBhZHZhbmNlKCk7XG5cbiAgICAgICAgICAgICAgaWYgKCFib3Mub3V0cHV0ICYmIHRva2Vucy5pbmRleE9mKHByZXYpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgYm9zLm91dHB1dCA9IE9ORV9DSEFSO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoKHZhbHVlID09PSAnWycgJiYgcGVlaygpICE9PSAnOicpIHx8ICh2YWx1ZSA9PT0gJy0nICYmIHBlZWsoKSA9PT0gJ10nKSkge1xuICAgICAgICB2YWx1ZSA9IGBcXFxcJHt2YWx1ZX1gO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUgPT09ICddJyAmJiAocHJldi52YWx1ZSA9PT0gJ1snIHx8IHByZXYudmFsdWUgPT09ICdbXicpKSB7XG4gICAgICAgIHZhbHVlID0gYFxcXFwke3ZhbHVlfWA7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRzLnBvc2l4ID09PSB0cnVlICYmIHZhbHVlID09PSAnIScgJiYgcHJldi52YWx1ZSA9PT0gJ1snKSB7XG4gICAgICAgIHZhbHVlID0gJ14nO1xuICAgICAgfVxuXG4gICAgICBwcmV2LnZhbHVlICs9IHZhbHVlO1xuICAgICAgYXBwZW5kKHsgdmFsdWUgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiB3ZSdyZSBpbnNpZGUgYSBxdW90ZWQgc3RyaW5nLCBjb250aW51ZVxuICAgICAqIHVudGlsIHdlIHJlYWNoIHRoZSBjbG9zaW5nIGRvdWJsZSBxdW90ZS5cbiAgICAgKi9cblxuICAgIGlmIChzdGF0ZS5xdW90ZXMgPT09IDEgJiYgdmFsdWUgIT09ICdcIicpIHtcbiAgICAgIHZhbHVlID0gdXRpbHMuZXNjYXBlUmVnZXgodmFsdWUpO1xuICAgICAgcHJldi52YWx1ZSArPSB2YWx1ZTtcbiAgICAgIGFwcGVuZCh7IHZhbHVlIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRG91YmxlIHF1b3Rlc1xuICAgICAqL1xuXG4gICAgaWYgKHZhbHVlID09PSAnXCInKSB7XG4gICAgICBzdGF0ZS5xdW90ZXMgPSBzdGF0ZS5xdW90ZXMgPT09IDEgPyAwIDogMTtcbiAgICAgIGlmIChvcHRzLmtlZXBRdW90ZXMgPT09IHRydWUpIHtcbiAgICAgICAgcHVzaCh7IHR5cGU6ICd0ZXh0JywgdmFsdWUgfSk7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJlbnRoZXNlc1xuICAgICAqL1xuXG4gICAgaWYgKHZhbHVlID09PSAnKCcpIHtcbiAgICAgIGluY3JlbWVudCgncGFyZW5zJyk7XG4gICAgICBwdXNoKHsgdHlwZTogJ3BhcmVuJywgdmFsdWUgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgPT09ICcpJykge1xuICAgICAgaWYgKHN0YXRlLnBhcmVucyA9PT0gMCAmJiBvcHRzLnN0cmljdEJyYWNrZXRzID09PSB0cnVlKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcignb3BlbmluZycsICcoJykpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBleHRnbG9iID0gZXh0Z2xvYnNbZXh0Z2xvYnMubGVuZ3RoIC0gMV07XG4gICAgICBpZiAoZXh0Z2xvYiAmJiBzdGF0ZS5wYXJlbnMgPT09IGV4dGdsb2IucGFyZW5zICsgMSkge1xuICAgICAgICBleHRnbG9iQ2xvc2UoZXh0Z2xvYnMucG9wKCkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcHVzaCh7IHR5cGU6ICdwYXJlbicsIHZhbHVlLCBvdXRwdXQ6IHN0YXRlLnBhcmVucyA/ICcpJyA6ICdcXFxcKScgfSk7XG4gICAgICBkZWNyZW1lbnQoJ3BhcmVucycpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3F1YXJlIGJyYWNrZXRzXG4gICAgICovXG5cbiAgICBpZiAodmFsdWUgPT09ICdbJykge1xuICAgICAgaWYgKG9wdHMubm9icmFja2V0ID09PSB0cnVlIHx8ICFyZW1haW5pbmcoKS5pbmNsdWRlcygnXScpKSB7XG4gICAgICAgIGlmIChvcHRzLm5vYnJhY2tldCAhPT0gdHJ1ZSAmJiBvcHRzLnN0cmljdEJyYWNrZXRzID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKCdjbG9zaW5nJywgJ10nKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSA9IGBcXFxcJHt2YWx1ZX1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5jcmVtZW50KCdicmFja2V0cycpO1xuICAgICAgfVxuXG4gICAgICBwdXNoKHsgdHlwZTogJ2JyYWNrZXQnLCB2YWx1ZSB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSA9PT0gJ10nKSB7XG4gICAgICBpZiAob3B0cy5ub2JyYWNrZXQgPT09IHRydWUgfHwgKHByZXYgJiYgcHJldi50eXBlID09PSAnYnJhY2tldCcgJiYgcHJldi52YWx1ZS5sZW5ndGggPT09IDEpKSB7XG4gICAgICAgIHB1c2goeyB0eXBlOiAndGV4dCcsIHZhbHVlLCBvdXRwdXQ6IGBcXFxcJHt2YWx1ZX1gIH0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlLmJyYWNrZXRzID09PSAwKSB7XG4gICAgICAgIGlmIChvcHRzLnN0cmljdEJyYWNrZXRzID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKCdvcGVuaW5nJywgJ1snKSk7XG4gICAgICAgIH1cblxuICAgICAgICBwdXNoKHsgdHlwZTogJ3RleHQnLCB2YWx1ZSwgb3V0cHV0OiBgXFxcXCR7dmFsdWV9YCB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGRlY3JlbWVudCgnYnJhY2tldHMnKTtcblxuICAgICAgY29uc3QgcHJldlZhbHVlID0gcHJldi52YWx1ZS5zbGljZSgxKTtcbiAgICAgIGlmIChwcmV2LnBvc2l4ICE9PSB0cnVlICYmIHByZXZWYWx1ZVswXSA9PT0gJ14nICYmICFwcmV2VmFsdWUuaW5jbHVkZXMoJy8nKSkge1xuICAgICAgICB2YWx1ZSA9IGAvJHt2YWx1ZX1gO1xuICAgICAgfVxuXG4gICAgICBwcmV2LnZhbHVlICs9IHZhbHVlO1xuICAgICAgYXBwZW5kKHsgdmFsdWUgfSk7XG5cbiAgICAgIC8vIHdoZW4gbGl0ZXJhbCBicmFja2V0cyBhcmUgZXhwbGljaXRseSBkaXNhYmxlZFxuICAgICAgLy8gYXNzdW1lIHdlIHNob3VsZCBtYXRjaCB3aXRoIGEgcmVnZXggY2hhcmFjdGVyIGNsYXNzXG4gICAgICBpZiAob3B0cy5saXRlcmFsQnJhY2tldHMgPT09IGZhbHNlIHx8IHV0aWxzLmhhc1JlZ2V4Q2hhcnMocHJldlZhbHVlKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZXNjYXBlZCA9IHV0aWxzLmVzY2FwZVJlZ2V4KHByZXYudmFsdWUpO1xuICAgICAgc3RhdGUub3V0cHV0ID0gc3RhdGUub3V0cHV0LnNsaWNlKDAsIC1wcmV2LnZhbHVlLmxlbmd0aCk7XG5cbiAgICAgIC8vIHdoZW4gbGl0ZXJhbCBicmFja2V0cyBhcmUgZXhwbGljaXRseSBlbmFibGVkXG4gICAgICAvLyBhc3N1bWUgd2Ugc2hvdWxkIGVzY2FwZSB0aGUgYnJhY2tldHMgdG8gbWF0Y2ggbGl0ZXJhbCBjaGFyYWN0ZXJzXG4gICAgICBpZiAob3B0cy5saXRlcmFsQnJhY2tldHMgPT09IHRydWUpIHtcbiAgICAgICAgc3RhdGUub3V0cHV0ICs9IGVzY2FwZWQ7XG4gICAgICAgIHByZXYudmFsdWUgPSBlc2NhcGVkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gd2hlbiB0aGUgdXNlciBzcGVjaWZpZXMgbm90aGluZywgdHJ5IHRvIG1hdGNoIGJvdGhcbiAgICAgIHByZXYudmFsdWUgPSBgKCR7Y2FwdHVyZX0ke2VzY2FwZWR9fCR7cHJldi52YWx1ZX0pYDtcbiAgICAgIHN0YXRlLm91dHB1dCArPSBwcmV2LnZhbHVlO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQnJhY2VzXG4gICAgICovXG5cbiAgICBpZiAodmFsdWUgPT09ICd7JyAmJiBvcHRzLm5vYnJhY2UgIT09IHRydWUpIHtcbiAgICAgIGluY3JlbWVudCgnYnJhY2VzJyk7XG5cbiAgICAgIGNvbnN0IG9wZW4gPSB7XG4gICAgICAgIHR5cGU6ICdicmFjZScsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBvdXRwdXQ6ICcoJyxcbiAgICAgICAgb3V0cHV0SW5kZXg6IHN0YXRlLm91dHB1dC5sZW5ndGgsXG4gICAgICAgIHRva2Vuc0luZGV4OiBzdGF0ZS50b2tlbnMubGVuZ3RoXG4gICAgICB9O1xuXG4gICAgICBicmFjZXMucHVzaChvcGVuKTtcbiAgICAgIHB1c2gob3Blbik7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgPT09ICd9Jykge1xuICAgICAgY29uc3QgYnJhY2UgPSBicmFjZXNbYnJhY2VzLmxlbmd0aCAtIDFdO1xuXG4gICAgICBpZiAob3B0cy5ub2JyYWNlID09PSB0cnVlIHx8ICFicmFjZSkge1xuICAgICAgICBwdXNoKHsgdHlwZTogJ3RleHQnLCB2YWx1ZSwgb3V0cHV0OiB2YWx1ZSB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGxldCBvdXRwdXQgPSAnKSc7XG5cbiAgICAgIGlmIChicmFjZS5kb3RzID09PSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IHRva2Vucy5zbGljZSgpO1xuICAgICAgICBjb25zdCByYW5nZSA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBhcnIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0b2tlbnMucG9wKCk7XG4gICAgICAgICAgaWYgKGFycltpXS50eXBlID09PSAnYnJhY2UnKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGFycltpXS50eXBlICE9PSAnZG90cycpIHtcbiAgICAgICAgICAgIHJhbmdlLnVuc2hpZnQoYXJyW2ldLnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvdXRwdXQgPSBleHBhbmRSYW5nZShyYW5nZSwgb3B0cyk7XG4gICAgICAgIHN0YXRlLmJhY2t0cmFjayA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChicmFjZS5jb21tYSAhPT0gdHJ1ZSAmJiBicmFjZS5kb3RzICE9PSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IG91dCA9IHN0YXRlLm91dHB1dC5zbGljZSgwLCBicmFjZS5vdXRwdXRJbmRleCk7XG4gICAgICAgIGNvbnN0IHRva3MgPSBzdGF0ZS50b2tlbnMuc2xpY2UoYnJhY2UudG9rZW5zSW5kZXgpO1xuICAgICAgICBicmFjZS52YWx1ZSA9IGJyYWNlLm91dHB1dCA9ICdcXFxceyc7XG4gICAgICAgIHZhbHVlID0gb3V0cHV0ID0gJ1xcXFx9JztcbiAgICAgICAgc3RhdGUub3V0cHV0ID0gb3V0O1xuICAgICAgICBmb3IgKGNvbnN0IHQgb2YgdG9rcykge1xuICAgICAgICAgIHN0YXRlLm91dHB1dCArPSAodC5vdXRwdXQgfHwgdC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcHVzaCh7IHR5cGU6ICdicmFjZScsIHZhbHVlLCBvdXRwdXQgfSk7XG4gICAgICBkZWNyZW1lbnQoJ2JyYWNlcycpO1xuICAgICAgYnJhY2VzLnBvcCgpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGlwZXNcbiAgICAgKi9cblxuICAgIGlmICh2YWx1ZSA9PT0gJ3wnKSB7XG4gICAgICBpZiAoZXh0Z2xvYnMubGVuZ3RoID4gMCkge1xuICAgICAgICBleHRnbG9ic1tleHRnbG9icy5sZW5ndGggLSAxXS5jb25kaXRpb25zKys7XG4gICAgICB9XG4gICAgICBwdXNoKHsgdHlwZTogJ3RleHQnLCB2YWx1ZSB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbW1hc1xuICAgICAqL1xuXG4gICAgaWYgKHZhbHVlID09PSAnLCcpIHtcbiAgICAgIGxldCBvdXRwdXQgPSB2YWx1ZTtcblxuICAgICAgY29uc3QgYnJhY2UgPSBicmFjZXNbYnJhY2VzLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGJyYWNlICYmIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSAnYnJhY2VzJykge1xuICAgICAgICBicmFjZS5jb21tYSA9IHRydWU7XG4gICAgICAgIG91dHB1dCA9ICd8JztcbiAgICAgIH1cblxuICAgICAgcHVzaCh7IHR5cGU6ICdjb21tYScsIHZhbHVlLCBvdXRwdXQgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTbGFzaGVzXG4gICAgICovXG5cbiAgICBpZiAodmFsdWUgPT09ICcvJykge1xuICAgICAgLy8gaWYgdGhlIGJlZ2lubmluZyBvZiB0aGUgZ2xvYiBpcyBcIi4vXCIsIGFkdmFuY2UgdGhlIHN0YXJ0XG4gICAgICAvLyB0byB0aGUgY3VycmVudCBpbmRleCwgYW5kIGRvbid0IGFkZCB0aGUgXCIuL1wiIGNoYXJhY3RlcnNcbiAgICAgIC8vIHRvIHRoZSBzdGF0ZS4gVGhpcyBncmVhdGx5IHNpbXBsaWZpZXMgbG9va2JlaGluZHMgd2hlblxuICAgICAgLy8gY2hlY2tpbmcgZm9yIEJPUyBjaGFyYWN0ZXJzIGxpa2UgXCIhXCIgYW5kIFwiLlwiIChub3QgXCIuL1wiKVxuICAgICAgaWYgKHByZXYudHlwZSA9PT0gJ2RvdCcgJiYgc3RhdGUuaW5kZXggPT09IHN0YXRlLnN0YXJ0ICsgMSkge1xuICAgICAgICBzdGF0ZS5zdGFydCA9IHN0YXRlLmluZGV4ICsgMTtcbiAgICAgICAgc3RhdGUuY29uc3VtZWQgPSAnJztcbiAgICAgICAgc3RhdGUub3V0cHV0ID0gJyc7XG4gICAgICAgIHRva2Vucy5wb3AoKTtcbiAgICAgICAgcHJldiA9IGJvczsgLy8gcmVzZXQgXCJwcmV2XCIgdG8gdGhlIGZpcnN0IHRva2VuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBwdXNoKHsgdHlwZTogJ3NsYXNoJywgdmFsdWUsIG91dHB1dDogU0xBU0hfTElURVJBTCB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERvdHNcbiAgICAgKi9cblxuICAgIGlmICh2YWx1ZSA9PT0gJy4nKSB7XG4gICAgICBpZiAoc3RhdGUuYnJhY2VzID4gMCAmJiBwcmV2LnR5cGUgPT09ICdkb3QnKSB7XG4gICAgICAgIGlmIChwcmV2LnZhbHVlID09PSAnLicpIHByZXYub3V0cHV0ID0gRE9UX0xJVEVSQUw7XG4gICAgICAgIGNvbnN0IGJyYWNlID0gYnJhY2VzW2JyYWNlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgcHJldi50eXBlID0gJ2RvdHMnO1xuICAgICAgICBwcmV2Lm91dHB1dCArPSB2YWx1ZTtcbiAgICAgICAgcHJldi52YWx1ZSArPSB2YWx1ZTtcbiAgICAgICAgYnJhY2UuZG90cyA9IHRydWU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoKHN0YXRlLmJyYWNlcyArIHN0YXRlLnBhcmVucykgPT09IDAgJiYgcHJldi50eXBlICE9PSAnYm9zJyAmJiBwcmV2LnR5cGUgIT09ICdzbGFzaCcpIHtcbiAgICAgICAgcHVzaCh7IHR5cGU6ICd0ZXh0JywgdmFsdWUsIG91dHB1dDogRE9UX0xJVEVSQUwgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBwdXNoKHsgdHlwZTogJ2RvdCcsIHZhbHVlLCBvdXRwdXQ6IERPVF9MSVRFUkFMIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUXVlc3Rpb24gbWFya3NcbiAgICAgKi9cblxuICAgIGlmICh2YWx1ZSA9PT0gJz8nKSB7XG4gICAgICBjb25zdCBpc0dyb3VwID0gcHJldiAmJiBwcmV2LnZhbHVlID09PSAnKCc7XG4gICAgICBpZiAoIWlzR3JvdXAgJiYgb3B0cy5ub2V4dGdsb2IgIT09IHRydWUgJiYgcGVlaygpID09PSAnKCcgJiYgcGVlaygyKSAhPT0gJz8nKSB7XG4gICAgICAgIGV4dGdsb2JPcGVuKCdxbWFyaycsIHZhbHVlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcmV2ICYmIHByZXYudHlwZSA9PT0gJ3BhcmVuJykge1xuICAgICAgICBjb25zdCBuZXh0ID0gcGVlaygpO1xuICAgICAgICBsZXQgb3V0cHV0ID0gdmFsdWU7XG5cbiAgICAgICAgaWYgKG5leHQgPT09ICc8JyAmJiAhdXRpbHMuc3VwcG9ydHNMb29rYmVoaW5kcygpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb2RlLmpzIHYxMCBvciBoaWdoZXIgaXMgcmVxdWlyZWQgZm9yIHJlZ2V4IGxvb2tiZWhpbmRzJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKHByZXYudmFsdWUgPT09ICcoJyAmJiAhL1shPTw6XS8udGVzdChuZXh0KSkgfHwgKG5leHQgPT09ICc8JyAmJiAhLzwoWyE9XXxcXHcrPikvLnRlc3QocmVtYWluaW5nKCkpKSkge1xuICAgICAgICAgIG91dHB1dCA9IGBcXFxcJHt2YWx1ZX1gO1xuICAgICAgICB9XG5cbiAgICAgICAgcHVzaCh7IHR5cGU6ICd0ZXh0JywgdmFsdWUsIG91dHB1dCB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRzLmRvdCAhPT0gdHJ1ZSAmJiAocHJldi50eXBlID09PSAnc2xhc2gnIHx8IHByZXYudHlwZSA9PT0gJ2JvcycpKSB7XG4gICAgICAgIHB1c2goeyB0eXBlOiAncW1hcmsnLCB2YWx1ZSwgb3V0cHV0OiBRTUFSS19OT19ET1QgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBwdXNoKHsgdHlwZTogJ3FtYXJrJywgdmFsdWUsIG91dHB1dDogUU1BUksgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGNsYW1hdGlvblxuICAgICAqL1xuXG4gICAgaWYgKHZhbHVlID09PSAnIScpIHtcbiAgICAgIGlmIChvcHRzLm5vZXh0Z2xvYiAhPT0gdHJ1ZSAmJiBwZWVrKCkgPT09ICcoJykge1xuICAgICAgICBpZiAocGVlaygyKSAhPT0gJz8nIHx8ICEvWyE9PDpdLy50ZXN0KHBlZWsoMykpKSB7XG4gICAgICAgICAgZXh0Z2xvYk9wZW4oJ25lZ2F0ZScsIHZhbHVlKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3B0cy5ub25lZ2F0ZSAhPT0gdHJ1ZSAmJiBzdGF0ZS5pbmRleCA9PT0gMCkge1xuICAgICAgICBuZWdhdGUoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGx1c1xuICAgICAqL1xuXG4gICAgaWYgKHZhbHVlID09PSAnKycpIHtcbiAgICAgIGlmIChvcHRzLm5vZXh0Z2xvYiAhPT0gdHJ1ZSAmJiBwZWVrKCkgPT09ICcoJyAmJiBwZWVrKDIpICE9PSAnPycpIHtcbiAgICAgICAgZXh0Z2xvYk9wZW4oJ3BsdXMnLCB2YWx1ZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoKHByZXYgJiYgcHJldi52YWx1ZSA9PT0gJygnKSB8fCBvcHRzLnJlZ2V4ID09PSBmYWxzZSkge1xuICAgICAgICBwdXNoKHsgdHlwZTogJ3BsdXMnLCB2YWx1ZSwgb3V0cHV0OiBQTFVTX0xJVEVSQUwgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoKHByZXYgJiYgKHByZXYudHlwZSA9PT0gJ2JyYWNrZXQnIHx8IHByZXYudHlwZSA9PT0gJ3BhcmVuJyB8fCBwcmV2LnR5cGUgPT09ICdicmFjZScpKSB8fCBzdGF0ZS5wYXJlbnMgPiAwKSB7XG4gICAgICAgIHB1c2goeyB0eXBlOiAncGx1cycsIHZhbHVlIH0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcHVzaCh7IHR5cGU6ICdwbHVzJywgdmFsdWU6IFBMVVNfTElURVJBTCB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBsYWluIHRleHRcbiAgICAgKi9cblxuICAgIGlmICh2YWx1ZSA9PT0gJ0AnKSB7XG4gICAgICBpZiAob3B0cy5ub2V4dGdsb2IgIT09IHRydWUgJiYgcGVlaygpID09PSAnKCcgJiYgcGVlaygyKSAhPT0gJz8nKSB7XG4gICAgICAgIHB1c2goeyB0eXBlOiAnYXQnLCBleHRnbG9iOiB0cnVlLCB2YWx1ZSwgb3V0cHV0OiAnJyB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHB1c2goeyB0eXBlOiAndGV4dCcsIHZhbHVlIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGxhaW4gdGV4dFxuICAgICAqL1xuXG4gICAgaWYgKHZhbHVlICE9PSAnKicpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gJyQnIHx8IHZhbHVlID09PSAnXicpIHtcbiAgICAgICAgdmFsdWUgPSBgXFxcXCR7dmFsdWV9YDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbWF0Y2ggPSBSRUdFWF9OT05fU1BFQ0lBTF9DSEFSUy5leGVjKHJlbWFpbmluZygpKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICB2YWx1ZSArPSBtYXRjaFswXTtcbiAgICAgICAgc3RhdGUuaW5kZXggKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBwdXNoKHsgdHlwZTogJ3RleHQnLCB2YWx1ZSB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0YXJzXG4gICAgICovXG5cbiAgICBpZiAocHJldiAmJiAocHJldi50eXBlID09PSAnZ2xvYnN0YXInIHx8IHByZXYuc3RhciA9PT0gdHJ1ZSkpIHtcbiAgICAgIHByZXYudHlwZSA9ICdzdGFyJztcbiAgICAgIHByZXYuc3RhciA9IHRydWU7XG4gICAgICBwcmV2LnZhbHVlICs9IHZhbHVlO1xuICAgICAgcHJldi5vdXRwdXQgPSBzdGFyO1xuICAgICAgc3RhdGUuYmFja3RyYWNrID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmdsb2JzdGFyID0gdHJ1ZTtcbiAgICAgIGNvbnN1bWUodmFsdWUpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgbGV0IHJlc3QgPSByZW1haW5pbmcoKTtcbiAgICBpZiAob3B0cy5ub2V4dGdsb2IgIT09IHRydWUgJiYgL15cXChbXj9dLy50ZXN0KHJlc3QpKSB7XG4gICAgICBleHRnbG9iT3Blbignc3RhcicsIHZhbHVlKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChwcmV2LnR5cGUgPT09ICdzdGFyJykge1xuICAgICAgaWYgKG9wdHMubm9nbG9ic3RhciA9PT0gdHJ1ZSkge1xuICAgICAgICBjb25zdW1lKHZhbHVlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHByaW9yID0gcHJldi5wcmV2O1xuICAgICAgY29uc3QgYmVmb3JlID0gcHJpb3IucHJldjtcbiAgICAgIGNvbnN0IGlzU3RhcnQgPSBwcmlvci50eXBlID09PSAnc2xhc2gnIHx8IHByaW9yLnR5cGUgPT09ICdib3MnO1xuICAgICAgY29uc3QgYWZ0ZXJTdGFyID0gYmVmb3JlICYmIChiZWZvcmUudHlwZSA9PT0gJ3N0YXInIHx8IGJlZm9yZS50eXBlID09PSAnZ2xvYnN0YXInKTtcblxuICAgICAgaWYgKG9wdHMuYmFzaCA9PT0gdHJ1ZSAmJiAoIWlzU3RhcnQgfHwgKHJlc3RbMF0gJiYgcmVzdFswXSAhPT0gJy8nKSkpIHtcbiAgICAgICAgcHVzaCh7IHR5cGU6ICdzdGFyJywgdmFsdWUsIG91dHB1dDogJycgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpc0JyYWNlID0gc3RhdGUuYnJhY2VzID4gMCAmJiAocHJpb3IudHlwZSA9PT0gJ2NvbW1hJyB8fCBwcmlvci50eXBlID09PSAnYnJhY2UnKTtcbiAgICAgIGNvbnN0IGlzRXh0Z2xvYiA9IGV4dGdsb2JzLmxlbmd0aCAmJiAocHJpb3IudHlwZSA9PT0gJ3BpcGUnIHx8IHByaW9yLnR5cGUgPT09ICdwYXJlbicpO1xuICAgICAgaWYgKCFpc1N0YXJ0ICYmIHByaW9yLnR5cGUgIT09ICdwYXJlbicgJiYgIWlzQnJhY2UgJiYgIWlzRXh0Z2xvYikge1xuICAgICAgICBwdXNoKHsgdHlwZTogJ3N0YXInLCB2YWx1ZSwgb3V0cHV0OiAnJyB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHN0cmlwIGNvbnNlY3V0aXZlIGAvKiovYFxuICAgICAgd2hpbGUgKHJlc3Quc2xpY2UoMCwgMykgPT09ICcvKionKSB7XG4gICAgICAgIGNvbnN0IGFmdGVyID0gaW5wdXRbc3RhdGUuaW5kZXggKyA0XTtcbiAgICAgICAgaWYgKGFmdGVyICYmIGFmdGVyICE9PSAnLycpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXN0ID0gcmVzdC5zbGljZSgzKTtcbiAgICAgICAgY29uc3VtZSgnLyoqJywgMyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcmlvci50eXBlID09PSAnYm9zJyAmJiBlb3MoKSkge1xuICAgICAgICBwcmV2LnR5cGUgPSAnZ2xvYnN0YXInO1xuICAgICAgICBwcmV2LnZhbHVlICs9IHZhbHVlO1xuICAgICAgICBwcmV2Lm91dHB1dCA9IGdsb2JzdGFyKG9wdHMpO1xuICAgICAgICBzdGF0ZS5vdXRwdXQgPSBwcmV2Lm91dHB1dDtcbiAgICAgICAgc3RhdGUuZ2xvYnN0YXIgPSB0cnVlO1xuICAgICAgICBjb25zdW1lKHZhbHVlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcmlvci50eXBlID09PSAnc2xhc2gnICYmIHByaW9yLnByZXYudHlwZSAhPT0gJ2JvcycgJiYgIWFmdGVyU3RhciAmJiBlb3MoKSkge1xuICAgICAgICBzdGF0ZS5vdXRwdXQgPSBzdGF0ZS5vdXRwdXQuc2xpY2UoMCwgLShwcmlvci5vdXRwdXQgKyBwcmV2Lm91dHB1dCkubGVuZ3RoKTtcbiAgICAgICAgcHJpb3Iub3V0cHV0ID0gYCg/OiR7cHJpb3Iub3V0cHV0fWA7XG5cbiAgICAgICAgcHJldi50eXBlID0gJ2dsb2JzdGFyJztcbiAgICAgICAgcHJldi5vdXRwdXQgPSBnbG9ic3RhcihvcHRzKSArIChvcHRzLnN0cmljdFNsYXNoZXMgPyAnKScgOiAnfCQpJyk7XG4gICAgICAgIHByZXYudmFsdWUgKz0gdmFsdWU7XG4gICAgICAgIHN0YXRlLmdsb2JzdGFyID0gdHJ1ZTtcbiAgICAgICAgc3RhdGUub3V0cHV0ICs9IHByaW9yLm91dHB1dCArIHByZXYub3V0cHV0O1xuICAgICAgICBjb25zdW1lKHZhbHVlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcmlvci50eXBlID09PSAnc2xhc2gnICYmIHByaW9yLnByZXYudHlwZSAhPT0gJ2JvcycgJiYgcmVzdFswXSA9PT0gJy8nKSB7XG4gICAgICAgIGNvbnN0IGVuZCA9IHJlc3RbMV0gIT09IHZvaWQgMCA/ICd8JCcgOiAnJztcblxuICAgICAgICBzdGF0ZS5vdXRwdXQgPSBzdGF0ZS5vdXRwdXQuc2xpY2UoMCwgLShwcmlvci5vdXRwdXQgKyBwcmV2Lm91dHB1dCkubGVuZ3RoKTtcbiAgICAgICAgcHJpb3Iub3V0cHV0ID0gYCg/OiR7cHJpb3Iub3V0cHV0fWA7XG5cbiAgICAgICAgcHJldi50eXBlID0gJ2dsb2JzdGFyJztcbiAgICAgICAgcHJldi5vdXRwdXQgPSBgJHtnbG9ic3RhcihvcHRzKX0ke1NMQVNIX0xJVEVSQUx9fCR7U0xBU0hfTElURVJBTH0ke2VuZH0pYDtcbiAgICAgICAgcHJldi52YWx1ZSArPSB2YWx1ZTtcblxuICAgICAgICBzdGF0ZS5vdXRwdXQgKz0gcHJpb3Iub3V0cHV0ICsgcHJldi5vdXRwdXQ7XG4gICAgICAgIHN0YXRlLmdsb2JzdGFyID0gdHJ1ZTtcblxuICAgICAgICBjb25zdW1lKHZhbHVlICsgYWR2YW5jZSgpKTtcblxuICAgICAgICBwdXNoKHsgdHlwZTogJ3NsYXNoJywgdmFsdWU6ICcvJywgb3V0cHV0OiAnJyB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcmlvci50eXBlID09PSAnYm9zJyAmJiByZXN0WzBdID09PSAnLycpIHtcbiAgICAgICAgcHJldi50eXBlID0gJ2dsb2JzdGFyJztcbiAgICAgICAgcHJldi52YWx1ZSArPSB2YWx1ZTtcbiAgICAgICAgcHJldi5vdXRwdXQgPSBgKD86Xnwke1NMQVNIX0xJVEVSQUx9fCR7Z2xvYnN0YXIob3B0cyl9JHtTTEFTSF9MSVRFUkFMfSlgO1xuICAgICAgICBzdGF0ZS5vdXRwdXQgPSBwcmV2Lm91dHB1dDtcbiAgICAgICAgc3RhdGUuZ2xvYnN0YXIgPSB0cnVlO1xuICAgICAgICBjb25zdW1lKHZhbHVlICsgYWR2YW5jZSgpKTtcbiAgICAgICAgcHVzaCh7IHR5cGU6ICdzbGFzaCcsIHZhbHVlOiAnLycsIG91dHB1dDogJycgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyByZW1vdmUgc2luZ2xlIHN0YXIgZnJvbSBvdXRwdXRcbiAgICAgIHN0YXRlLm91dHB1dCA9IHN0YXRlLm91dHB1dC5zbGljZSgwLCAtcHJldi5vdXRwdXQubGVuZ3RoKTtcblxuICAgICAgLy8gcmVzZXQgcHJldmlvdXMgdG9rZW4gdG8gZ2xvYnN0YXJcbiAgICAgIHByZXYudHlwZSA9ICdnbG9ic3Rhcic7XG4gICAgICBwcmV2Lm91dHB1dCA9IGdsb2JzdGFyKG9wdHMpO1xuICAgICAgcHJldi52YWx1ZSArPSB2YWx1ZTtcblxuICAgICAgLy8gcmVzZXQgb3V0cHV0IHdpdGggZ2xvYnN0YXJcbiAgICAgIHN0YXRlLm91dHB1dCArPSBwcmV2Lm91dHB1dDtcbiAgICAgIHN0YXRlLmdsb2JzdGFyID0gdHJ1ZTtcbiAgICAgIGNvbnN1bWUodmFsdWUpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgdG9rZW4gPSB7IHR5cGU6ICdzdGFyJywgdmFsdWUsIG91dHB1dDogc3RhciB9O1xuXG4gICAgaWYgKG9wdHMuYmFzaCA9PT0gdHJ1ZSkge1xuICAgICAgdG9rZW4ub3V0cHV0ID0gJy4qPyc7XG4gICAgICBpZiAocHJldi50eXBlID09PSAnYm9zJyB8fCBwcmV2LnR5cGUgPT09ICdzbGFzaCcpIHtcbiAgICAgICAgdG9rZW4ub3V0cHV0ID0gbm9kb3QgKyB0b2tlbi5vdXRwdXQ7XG4gICAgICB9XG4gICAgICBwdXNoKHRva2VuKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChwcmV2ICYmIChwcmV2LnR5cGUgPT09ICdicmFja2V0JyB8fCBwcmV2LnR5cGUgPT09ICdwYXJlbicpICYmIG9wdHMucmVnZXggPT09IHRydWUpIHtcbiAgICAgIHRva2VuLm91dHB1dCA9IHZhbHVlO1xuICAgICAgcHVzaCh0b2tlbik7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuaW5kZXggPT09IHN0YXRlLnN0YXJ0IHx8IHByZXYudHlwZSA9PT0gJ3NsYXNoJyB8fCBwcmV2LnR5cGUgPT09ICdkb3QnKSB7XG4gICAgICBpZiAocHJldi50eXBlID09PSAnZG90Jykge1xuICAgICAgICBzdGF0ZS5vdXRwdXQgKz0gTk9fRE9UX1NMQVNIO1xuICAgICAgICBwcmV2Lm91dHB1dCArPSBOT19ET1RfU0xBU0g7XG5cbiAgICAgIH0gZWxzZSBpZiAob3B0cy5kb3QgPT09IHRydWUpIHtcbiAgICAgICAgc3RhdGUub3V0cHV0ICs9IE5PX0RPVFNfU0xBU0g7XG4gICAgICAgIHByZXYub3V0cHV0ICs9IE5PX0RPVFNfU0xBU0g7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLm91dHB1dCArPSBub2RvdDtcbiAgICAgICAgcHJldi5vdXRwdXQgKz0gbm9kb3Q7XG4gICAgICB9XG5cbiAgICAgIGlmIChwZWVrKCkgIT09ICcqJykge1xuICAgICAgICBzdGF0ZS5vdXRwdXQgKz0gT05FX0NIQVI7XG4gICAgICAgIHByZXYub3V0cHV0ICs9IE9ORV9DSEFSO1xuICAgICAgfVxuICAgIH1cblxuICAgIHB1c2godG9rZW4pO1xuICB9XG5cbiAgd2hpbGUgKHN0YXRlLmJyYWNrZXRzID4gMCkge1xuICAgIGlmIChvcHRzLnN0cmljdEJyYWNrZXRzID09PSB0cnVlKSB0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoJ2Nsb3NpbmcnLCAnXScpKTtcbiAgICBzdGF0ZS5vdXRwdXQgPSB1dGlscy5lc2NhcGVMYXN0KHN0YXRlLm91dHB1dCwgJ1snKTtcbiAgICBkZWNyZW1lbnQoJ2JyYWNrZXRzJyk7XG4gIH1cblxuICB3aGlsZSAoc3RhdGUucGFyZW5zID4gMCkge1xuICAgIGlmIChvcHRzLnN0cmljdEJyYWNrZXRzID09PSB0cnVlKSB0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoJ2Nsb3NpbmcnLCAnKScpKTtcbiAgICBzdGF0ZS5vdXRwdXQgPSB1dGlscy5lc2NhcGVMYXN0KHN0YXRlLm91dHB1dCwgJygnKTtcbiAgICBkZWNyZW1lbnQoJ3BhcmVucycpO1xuICB9XG5cbiAgd2hpbGUgKHN0YXRlLmJyYWNlcyA+IDApIHtcbiAgICBpZiAob3B0cy5zdHJpY3RCcmFja2V0cyA9PT0gdHJ1ZSkgdGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKCdjbG9zaW5nJywgJ30nKSk7XG4gICAgc3RhdGUub3V0cHV0ID0gdXRpbHMuZXNjYXBlTGFzdChzdGF0ZS5vdXRwdXQsICd7Jyk7XG4gICAgZGVjcmVtZW50KCdicmFjZXMnKTtcbiAgfVxuXG4gIGlmIChvcHRzLnN0cmljdFNsYXNoZXMgIT09IHRydWUgJiYgKHByZXYudHlwZSA9PT0gJ3N0YXInIHx8IHByZXYudHlwZSA9PT0gJ2JyYWNrZXQnKSkge1xuICAgIHB1c2goeyB0eXBlOiAnbWF5YmVfc2xhc2gnLCB2YWx1ZTogJycsIG91dHB1dDogYCR7U0xBU0hfTElURVJBTH0/YCB9KTtcbiAgfVxuXG4gIC8vIHJlYnVpbGQgdGhlIG91dHB1dCBpZiB3ZSBoYWQgdG8gYmFja3RyYWNrIGF0IGFueSBwb2ludFxuICBpZiAoc3RhdGUuYmFja3RyYWNrID09PSB0cnVlKSB7XG4gICAgc3RhdGUub3V0cHV0ID0gJyc7XG5cbiAgICBmb3IgKGNvbnN0IHRva2VuIG9mIHN0YXRlLnRva2Vucykge1xuICAgICAgc3RhdGUub3V0cHV0ICs9IHRva2VuLm91dHB1dCAhPSBudWxsID8gdG9rZW4ub3V0cHV0IDogdG9rZW4udmFsdWU7XG5cbiAgICAgIGlmICh0b2tlbi5zdWZmaXgpIHtcbiAgICAgICAgc3RhdGUub3V0cHV0ICs9IHRva2VuLnN1ZmZpeDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RhdGU7XG59O1xuXG4vKipcbiAqIEZhc3QgcGF0aHMgZm9yIGNyZWF0aW5nIHJlZ3VsYXIgZXhwcmVzc2lvbnMgZm9yIGNvbW1vbiBnbG9iIHBhdHRlcm5zLlxuICogVGhpcyBjYW4gc2lnbmlmaWNhbnRseSBzcGVlZCB1cCBwcm9jZXNzaW5nIGFuZCBoYXMgdmVyeSBsaXR0bGUgZG93bnNpZGVcbiAqIGltcGFjdCB3aGVuIG5vbmUgb2YgdGhlIGZhc3QgcGF0aHMgbWF0Y2guXG4gKi9cblxucGFyc2UuZmFzdHBhdGhzID0gKGlucHV0LCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IG9wdHMgPSB7IC4uLm9wdGlvbnMgfTtcbiAgY29uc3QgbWF4ID0gdHlwZW9mIG9wdHMubWF4TGVuZ3RoID09PSAnbnVtYmVyJyA/IE1hdGgubWluKE1BWF9MRU5HVEgsIG9wdHMubWF4TGVuZ3RoKSA6IE1BWF9MRU5HVEg7XG4gIGNvbnN0IGxlbiA9IGlucHV0Lmxlbmd0aDtcbiAgaWYgKGxlbiA+IG1heCkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgSW5wdXQgbGVuZ3RoOiAke2xlbn0sIGV4Y2VlZHMgbWF4aW11bSBhbGxvd2VkIGxlbmd0aDogJHttYXh9YCk7XG4gIH1cblxuICBpbnB1dCA9IFJFUExBQ0VNRU5UU1tpbnB1dF0gfHwgaW5wdXQ7XG4gIGNvbnN0IHdpbjMyID0gdXRpbHMuaXNXaW5kb3dzKG9wdGlvbnMpO1xuXG4gIC8vIGNyZWF0ZSBjb25zdGFudHMgYmFzZWQgb24gcGxhdGZvcm0sIGZvciB3aW5kb3dzIG9yIHBvc2l4XG4gIGNvbnN0IHtcbiAgICBET1RfTElURVJBTCxcbiAgICBTTEFTSF9MSVRFUkFMLFxuICAgIE9ORV9DSEFSLFxuICAgIERPVFNfU0xBU0gsXG4gICAgTk9fRE9ULFxuICAgIE5PX0RPVFMsXG4gICAgTk9fRE9UU19TTEFTSCxcbiAgICBTVEFSLFxuICAgIFNUQVJUX0FOQ0hPUlxuICB9ID0gY29uc3RhbnRzLmdsb2JDaGFycyh3aW4zMik7XG5cbiAgY29uc3Qgbm9kb3QgPSBvcHRzLmRvdCA/IE5PX0RPVFMgOiBOT19ET1Q7XG4gIGNvbnN0IHNsYXNoRG90ID0gb3B0cy5kb3QgPyBOT19ET1RTX1NMQVNIIDogTk9fRE9UO1xuICBjb25zdCBjYXB0dXJlID0gb3B0cy5jYXB0dXJlID8gJycgOiAnPzonO1xuICBjb25zdCBzdGF0ZSA9IHsgbmVnYXRlZDogZmFsc2UsIHByZWZpeDogJycgfTtcbiAgbGV0IHN0YXIgPSBvcHRzLmJhc2ggPT09IHRydWUgPyAnLio/JyA6IFNUQVI7XG5cbiAgaWYgKG9wdHMuY2FwdHVyZSkge1xuICAgIHN0YXIgPSBgKCR7c3Rhcn0pYDtcbiAgfVxuXG4gIGNvbnN0IGdsb2JzdGFyID0gb3B0cyA9PiB7XG4gICAgaWYgKG9wdHMubm9nbG9ic3RhciA9PT0gdHJ1ZSkgcmV0dXJuIHN0YXI7XG4gICAgcmV0dXJuIGAoJHtjYXB0dXJlfSg/Oig/ISR7U1RBUlRfQU5DSE9SfSR7b3B0cy5kb3QgPyBET1RTX1NMQVNIIDogRE9UX0xJVEVSQUx9KS4pKj8pYDtcbiAgfTtcblxuICBjb25zdCBjcmVhdGUgPSBzdHIgPT4ge1xuICAgIHN3aXRjaCAoc3RyKSB7XG4gICAgICBjYXNlICcqJzpcbiAgICAgICAgcmV0dXJuIGAke25vZG90fSR7T05FX0NIQVJ9JHtzdGFyfWA7XG5cbiAgICAgIGNhc2UgJy4qJzpcbiAgICAgICAgcmV0dXJuIGAke0RPVF9MSVRFUkFMfSR7T05FX0NIQVJ9JHtzdGFyfWA7XG5cbiAgICAgIGNhc2UgJyouKic6XG4gICAgICAgIHJldHVybiBgJHtub2RvdH0ke3N0YXJ9JHtET1RfTElURVJBTH0ke09ORV9DSEFSfSR7c3Rhcn1gO1xuXG4gICAgICBjYXNlICcqLyonOlxuICAgICAgICByZXR1cm4gYCR7bm9kb3R9JHtzdGFyfSR7U0xBU0hfTElURVJBTH0ke09ORV9DSEFSfSR7c2xhc2hEb3R9JHtzdGFyfWA7XG5cbiAgICAgIGNhc2UgJyoqJzpcbiAgICAgICAgcmV0dXJuIG5vZG90ICsgZ2xvYnN0YXIob3B0cyk7XG5cbiAgICAgIGNhc2UgJyoqLyonOlxuICAgICAgICByZXR1cm4gYCg/OiR7bm9kb3R9JHtnbG9ic3RhcihvcHRzKX0ke1NMQVNIX0xJVEVSQUx9KT8ke3NsYXNoRG90fSR7T05FX0NIQVJ9JHtzdGFyfWA7XG5cbiAgICAgIGNhc2UgJyoqLyouKic6XG4gICAgICAgIHJldHVybiBgKD86JHtub2RvdH0ke2dsb2JzdGFyKG9wdHMpfSR7U0xBU0hfTElURVJBTH0pPyR7c2xhc2hEb3R9JHtzdGFyfSR7RE9UX0xJVEVSQUx9JHtPTkVfQ0hBUn0ke3N0YXJ9YDtcblxuICAgICAgY2FzZSAnKiovLionOlxuICAgICAgICByZXR1cm4gYCg/OiR7bm9kb3R9JHtnbG9ic3RhcihvcHRzKX0ke1NMQVNIX0xJVEVSQUx9KT8ke0RPVF9MSVRFUkFMfSR7T05FX0NIQVJ9JHtzdGFyfWA7XG5cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSAvXiguKj8pXFwuKFxcdyspJC8uZXhlYyhzdHIpO1xuICAgICAgICBpZiAoIW1hdGNoKSByZXR1cm47XG5cbiAgICAgICAgY29uc3Qgc291cmNlID0gY3JlYXRlKG1hdGNoWzFdKTtcbiAgICAgICAgaWYgKCFzb3VyY2UpIHJldHVybjtcblxuICAgICAgICByZXR1cm4gc291cmNlICsgRE9UX0xJVEVSQUwgKyBtYXRjaFsyXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgY29uc3Qgb3V0cHV0ID0gdXRpbHMucmVtb3ZlUHJlZml4KGlucHV0LCBzdGF0ZSk7XG4gIGxldCBzb3VyY2UgPSBjcmVhdGUob3V0cHV0KTtcblxuICBpZiAoc291cmNlICYmIG9wdHMuc3RyaWN0U2xhc2hlcyAhPT0gdHJ1ZSkge1xuICAgIHNvdXJjZSArPSBgJHtTTEFTSF9MSVRFUkFMfT9gO1xuICB9XG5cbiAgcmV0dXJuIHNvdXJjZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2U7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3Qgc2NhbiA9IHJlcXVpcmUoJy4vc2NhbicpO1xuY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5jb25zdCBpc09iamVjdCA9IHZhbCA9PiB2YWwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodmFsKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0Y2hlciBmdW5jdGlvbiBmcm9tIG9uZSBvciBtb3JlIGdsb2IgcGF0dGVybnMuIFRoZVxuICogcmV0dXJuZWQgZnVuY3Rpb24gdGFrZXMgYSBzdHJpbmcgdG8gbWF0Y2ggYXMgaXRzIGZpcnN0IGFyZ3VtZW50LFxuICogYW5kIHJldHVybnMgdHJ1ZSBpZiB0aGUgc3RyaW5nIGlzIGEgbWF0Y2guIFRoZSByZXR1cm5lZCBtYXRjaGVyXG4gKiBmdW5jdGlvbiBhbHNvIHRha2VzIGEgYm9vbGVhbiBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRoYXQsIHdoZW4gdHJ1ZSxcbiAqIHJldHVybnMgYW4gb2JqZWN0IHdpdGggYWRkaXRpb25hbCBpbmZvcm1hdGlvbi5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgcGljb21hdGNoID0gcmVxdWlyZSgncGljb21hdGNoJyk7XG4gKiAvLyBwaWNvbWF0Y2goZ2xvYlssIG9wdGlvbnNdKTtcbiAqXG4gKiBjb25zdCBpc01hdGNoID0gcGljb21hdGNoKCcqLiEoKmEpJyk7XG4gKiBjb25zb2xlLmxvZyhpc01hdGNoKCdhLmEnKSk7IC8vPT4gZmFsc2VcbiAqIGNvbnNvbGUubG9nKGlzTWF0Y2goJ2EuYicpKTsgLy89PiB0cnVlXG4gKiBgYGBcbiAqIEBuYW1lIHBpY29tYXRjaFxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGBnbG9ic2AgT25lIG9yIG1vcmUgZ2xvYiBwYXR0ZXJucy5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtGdW5jdGlvbj19IFJldHVybnMgYSBtYXRjaGVyIGZ1bmN0aW9uLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5jb25zdCBwaWNvbWF0Y2ggPSAoZ2xvYiwgb3B0aW9ucywgcmV0dXJuU3RhdGUgPSBmYWxzZSkgPT4ge1xuICBpZiAoQXJyYXkuaXNBcnJheShnbG9iKSkge1xuICAgIGNvbnN0IGZucyA9IGdsb2IubWFwKGlucHV0ID0+IHBpY29tYXRjaChpbnB1dCwgb3B0aW9ucywgcmV0dXJuU3RhdGUpKTtcbiAgICBjb25zdCBhcnJheU1hdGNoZXIgPSBzdHIgPT4ge1xuICAgICAgZm9yIChjb25zdCBpc01hdGNoIG9mIGZucykge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGlzTWF0Y2goc3RyKTtcbiAgICAgICAgaWYgKHN0YXRlKSByZXR1cm4gc3RhdGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICByZXR1cm4gYXJyYXlNYXRjaGVyO1xuICB9XG5cbiAgY29uc3QgaXNTdGF0ZSA9IGlzT2JqZWN0KGdsb2IpICYmIGdsb2IudG9rZW5zICYmIGdsb2IuaW5wdXQ7XG5cbiAgaWYgKGdsb2IgPT09ICcnIHx8ICh0eXBlb2YgZ2xvYiAhPT0gJ3N0cmluZycgJiYgIWlzU3RhdGUpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgcGF0dGVybiB0byBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgfVxuXG4gIGNvbnN0IG9wdHMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBwb3NpeCA9IHV0aWxzLmlzV2luZG93cyhvcHRpb25zKTtcbiAgY29uc3QgcmVnZXggPSBpc1N0YXRlXG4gICAgPyBwaWNvbWF0Y2guY29tcGlsZVJlKGdsb2IsIG9wdGlvbnMpXG4gICAgOiBwaWNvbWF0Y2gubWFrZVJlKGdsb2IsIG9wdGlvbnMsIGZhbHNlLCB0cnVlKTtcblxuICBjb25zdCBzdGF0ZSA9IHJlZ2V4LnN0YXRlO1xuICBkZWxldGUgcmVnZXguc3RhdGU7XG5cbiAgbGV0IGlzSWdub3JlZCA9ICgpID0+IGZhbHNlO1xuICBpZiAob3B0cy5pZ25vcmUpIHtcbiAgICBjb25zdCBpZ25vcmVPcHRzID0geyAuLi5vcHRpb25zLCBpZ25vcmU6IG51bGwsIG9uTWF0Y2g6IG51bGwsIG9uUmVzdWx0OiBudWxsIH07XG4gICAgaXNJZ25vcmVkID0gcGljb21hdGNoKG9wdHMuaWdub3JlLCBpZ25vcmVPcHRzLCByZXR1cm5TdGF0ZSk7XG4gIH1cblxuICBjb25zdCBtYXRjaGVyID0gKGlucHV0LCByZXR1cm5PYmplY3QgPSBmYWxzZSkgPT4ge1xuICAgIGNvbnN0IHsgaXNNYXRjaCwgbWF0Y2gsIG91dHB1dCB9ID0gcGljb21hdGNoLnRlc3QoaW5wdXQsIHJlZ2V4LCBvcHRpb25zLCB7IGdsb2IsIHBvc2l4IH0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IHsgZ2xvYiwgc3RhdGUsIHJlZ2V4LCBwb3NpeCwgaW5wdXQsIG91dHB1dCwgbWF0Y2gsIGlzTWF0Y2ggfTtcblxuICAgIGlmICh0eXBlb2Ygb3B0cy5vblJlc3VsdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb3B0cy5vblJlc3VsdChyZXN1bHQpO1xuICAgIH1cblxuICAgIGlmIChpc01hdGNoID09PSBmYWxzZSkge1xuICAgICAgcmVzdWx0LmlzTWF0Y2ggPSBmYWxzZTtcbiAgICAgIHJldHVybiByZXR1cm5PYmplY3QgPyByZXN1bHQgOiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoaXNJZ25vcmVkKGlucHV0KSkge1xuICAgICAgaWYgKHR5cGVvZiBvcHRzLm9uSWdub3JlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9wdHMub25JZ25vcmUocmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5pc01hdGNoID0gZmFsc2U7XG4gICAgICByZXR1cm4gcmV0dXJuT2JqZWN0ID8gcmVzdWx0IDogZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRzLm9uTWF0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9wdHMub25NYXRjaChyZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuT2JqZWN0ID8gcmVzdWx0IDogdHJ1ZTtcbiAgfTtcblxuICBpZiAocmV0dXJuU3RhdGUpIHtcbiAgICBtYXRjaGVyLnN0YXRlID0gc3RhdGU7XG4gIH1cblxuICByZXR1cm4gbWF0Y2hlcjtcbn07XG5cbi8qKlxuICogVGVzdCBgaW5wdXRgIHdpdGggdGhlIGdpdmVuIGByZWdleGAuIFRoaXMgaXMgdXNlZCBieSB0aGUgbWFpblxuICogYHBpY29tYXRjaCgpYCBmdW5jdGlvbiB0byB0ZXN0IHRoZSBpbnB1dCBzdHJpbmcuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IHBpY29tYXRjaCA9IHJlcXVpcmUoJ3BpY29tYXRjaCcpO1xuICogLy8gcGljb21hdGNoLnRlc3QoaW5wdXQsIHJlZ2V4Wywgb3B0aW9uc10pO1xuICpcbiAqIGNvbnNvbGUubG9nKHBpY29tYXRjaC50ZXN0KCdmb28vYmFyJywgL14oPzooW14vXSo/KVxcLyhbXi9dKj8pKSQvKSk7XG4gKiAvLyB7IGlzTWF0Y2g6IHRydWUsIG1hdGNoOiBbICdmb28vJywgJ2ZvbycsICdiYXInIF0sIG91dHB1dDogJ2Zvby9iYXInIH1cbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBpbnB1dGAgU3RyaW5nIHRvIHRlc3QuXG4gKiBAcGFyYW0ge1JlZ0V4cH0gYHJlZ2V4YFxuICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIG1hdGNoaW5nIGluZm8uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnBpY29tYXRjaC50ZXN0ID0gKGlucHV0LCByZWdleCwgb3B0aW9ucywgeyBnbG9iLCBwb3NpeCB9ID0ge30pID0+IHtcbiAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBpbnB1dCB0byBiZSBhIHN0cmluZycpO1xuICB9XG5cbiAgaWYgKGlucHV0ID09PSAnJykge1xuICAgIHJldHVybiB7IGlzTWF0Y2g6IGZhbHNlLCBvdXRwdXQ6ICcnIH07XG4gIH1cblxuICBjb25zdCBvcHRzID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgZm9ybWF0ID0gb3B0cy5mb3JtYXQgfHwgKHBvc2l4ID8gdXRpbHMudG9Qb3NpeFNsYXNoZXMgOiBudWxsKTtcbiAgbGV0IG1hdGNoID0gaW5wdXQgPT09IGdsb2I7XG4gIGxldCBvdXRwdXQgPSAobWF0Y2ggJiYgZm9ybWF0KSA/IGZvcm1hdChpbnB1dCkgOiBpbnB1dDtcblxuICBpZiAobWF0Y2ggPT09IGZhbHNlKSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0ID8gZm9ybWF0KGlucHV0KSA6IGlucHV0O1xuICAgIG1hdGNoID0gb3V0cHV0ID09PSBnbG9iO1xuICB9XG5cbiAgaWYgKG1hdGNoID09PSBmYWxzZSB8fCBvcHRzLmNhcHR1cmUgPT09IHRydWUpIHtcbiAgICBpZiAob3B0cy5tYXRjaEJhc2UgPT09IHRydWUgfHwgb3B0cy5iYXNlbmFtZSA9PT0gdHJ1ZSkge1xuICAgICAgbWF0Y2ggPSBwaWNvbWF0Y2gubWF0Y2hCYXNlKGlucHV0LCByZWdleCwgb3B0aW9ucywgcG9zaXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXRjaCA9IHJlZ2V4LmV4ZWMob3V0cHV0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4geyBpc01hdGNoOiBCb29sZWFuKG1hdGNoKSwgbWF0Y2gsIG91dHB1dCB9O1xufTtcblxuLyoqXG4gKiBNYXRjaCB0aGUgYmFzZW5hbWUgb2YgYSBmaWxlcGF0aC5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgcGljb21hdGNoID0gcmVxdWlyZSgncGljb21hdGNoJyk7XG4gKiAvLyBwaWNvbWF0Y2gubWF0Y2hCYXNlKGlucHV0LCBnbG9iWywgb3B0aW9uc10pO1xuICogY29uc29sZS5sb2cocGljb21hdGNoLm1hdGNoQmFzZSgnZm9vL2Jhci5qcycsICcqLmpzJyk7IC8vIHRydWVcbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBpbnB1dGAgU3RyaW5nIHRvIHRlc3QuXG4gKiBAcGFyYW0ge1JlZ0V4cHxTdHJpbmd9IGBnbG9iYCBHbG9iIHBhdHRlcm4gb3IgcmVnZXggY3JlYXRlZCBieSBbLm1ha2VSZV0oI21ha2VSZSkuXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5waWNvbWF0Y2gubWF0Y2hCYXNlID0gKGlucHV0LCBnbG9iLCBvcHRpb25zLCBwb3NpeCA9IHV0aWxzLmlzV2luZG93cyhvcHRpb25zKSkgPT4ge1xuICBjb25zdCByZWdleCA9IGdsb2IgaW5zdGFuY2VvZiBSZWdFeHAgPyBnbG9iIDogcGljb21hdGNoLm1ha2VSZShnbG9iLCBvcHRpb25zKTtcbiAgcmV0dXJuIHJlZ2V4LnRlc3QocGF0aC5iYXNlbmFtZShpbnB1dCkpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgKiphbnkqKiBvZiB0aGUgZ2l2ZW4gZ2xvYiBgcGF0dGVybnNgIG1hdGNoIHRoZSBzcGVjaWZpZWQgYHN0cmluZ2AuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IHBpY29tYXRjaCA9IHJlcXVpcmUoJ3BpY29tYXRjaCcpO1xuICogLy8gcGljb21hdGNoLmlzTWF0Y2goc3RyaW5nLCBwYXR0ZXJuc1ssIG9wdGlvbnNdKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhwaWNvbWF0Y2guaXNNYXRjaCgnYS5hJywgWydiLionLCAnKi5hJ10pKTsgLy89PiB0cnVlXG4gKiBjb25zb2xlLmxvZyhwaWNvbWF0Y2guaXNNYXRjaCgnYS5hJywgJ2IuKicpKTsgLy89PiBmYWxzZVxuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gc3RyIFRoZSBzdHJpbmcgdG8gdGVzdC5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBwYXR0ZXJucyBPbmUgb3IgbW9yZSBnbG9iIHBhdHRlcm5zIHRvIHVzZSBmb3IgbWF0Y2hpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFNlZSBhdmFpbGFibGUgW29wdGlvbnNdKCNvcHRpb25zKS5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBhbnkgcGF0dGVybnMgbWF0Y2ggYHN0cmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxucGljb21hdGNoLmlzTWF0Y2ggPSAoc3RyLCBwYXR0ZXJucywgb3B0aW9ucykgPT4gcGljb21hdGNoKHBhdHRlcm5zLCBvcHRpb25zKShzdHIpO1xuXG4vKipcbiAqIFBhcnNlIGEgZ2xvYiBwYXR0ZXJuIHRvIGNyZWF0ZSB0aGUgc291cmNlIHN0cmluZyBmb3IgYSByZWd1bGFyXG4gKiBleHByZXNzaW9uLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBwaWNvbWF0Y2ggPSByZXF1aXJlKCdwaWNvbWF0Y2gnKTtcbiAqIGNvbnN0IHJlc3VsdCA9IHBpY29tYXRjaC5wYXJzZShwYXR0ZXJuWywgb3B0aW9uc10pO1xuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHBhdHRlcm5gXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IHdpdGggdXNlZnVsIHByb3BlcnRpZXMgYW5kIG91dHB1dCB0byBiZSB1c2VkIGFzIGEgcmVnZXggc291cmNlIHN0cmluZy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucGljb21hdGNoLnBhcnNlID0gKHBhdHRlcm4sIG9wdGlvbnMpID0+IHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0dGVybikpIHJldHVybiBwYXR0ZXJuLm1hcChwID0+IHBpY29tYXRjaC5wYXJzZShwLCBvcHRpb25zKSk7XG4gIHJldHVybiBwYXJzZShwYXR0ZXJuLCB7IC4uLm9wdGlvbnMsIGZhc3RwYXRoczogZmFsc2UgfSk7XG59O1xuXG4vKipcbiAqIFNjYW4gYSBnbG9iIHBhdHRlcm4gdG8gc2VwYXJhdGUgdGhlIHBhdHRlcm4gaW50byBzZWdtZW50cy5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgcGljb21hdGNoID0gcmVxdWlyZSgncGljb21hdGNoJyk7XG4gKiAvLyBwaWNvbWF0Y2guc2NhbihpbnB1dFssIG9wdGlvbnNdKTtcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBwaWNvbWF0Y2guc2NhbignIS4vZm9vLyouanMnKTtcbiAqIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiB7IHByZWZpeDogJyEuLycsXG4gKiAgIGlucHV0OiAnIS4vZm9vLyouanMnLFxuICogICBzdGFydDogMyxcbiAqICAgYmFzZTogJ2ZvbycsXG4gKiAgIGdsb2I6ICcqLmpzJyxcbiAqICAgaXNCcmFjZTogZmFsc2UsXG4gKiAgIGlzQnJhY2tldDogZmFsc2UsXG4gKiAgIGlzR2xvYjogdHJ1ZSxcbiAqICAgaXNFeHRnbG9iOiBmYWxzZSxcbiAqICAgaXNHbG9ic3RhcjogZmFsc2UsXG4gKiAgIG5lZ2F0ZWQ6IHRydWUgfVxuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYGlucHV0YCBHbG9iIHBhdHRlcm4gdG8gc2Nhbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3Qgd2l0aFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5waWNvbWF0Y2guc2NhbiA9IChpbnB1dCwgb3B0aW9ucykgPT4gc2NhbihpbnB1dCwgb3B0aW9ucyk7XG5cbi8qKlxuICogQ29tcGlsZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBmcm9tIHRoZSBgc3RhdGVgIG9iamVjdCByZXR1cm5lZCBieSB0aGVcbiAqIFtwYXJzZSgpXSgjcGFyc2UpIG1ldGhvZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYHN0YXRlYFxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYFxuICogQHBhcmFtIHtCb29sZWFufSBgcmV0dXJuT3V0cHV0YCBJbnRlbmRlZCBmb3IgaW1wbGVtZW50b3JzLCB0aGlzIGFyZ3VtZW50IGFsbG93cyB5b3UgdG8gcmV0dXJuIHRoZSByYXcgb3V0cHV0IGZyb20gdGhlIHBhcnNlci5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYHJldHVyblN0YXRlYCBBZGRzIHRoZSBzdGF0ZSB0byBhIGBzdGF0ZWAgcHJvcGVydHkgb24gdGhlIHJldHVybmVkIHJlZ2V4LiBVc2VmdWwgZm9yIGltcGxlbWVudG9ycyBhbmQgZGVidWdnaW5nLlxuICogQHJldHVybiB7UmVnRXhwfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5waWNvbWF0Y2guY29tcGlsZVJlID0gKHN0YXRlLCBvcHRpb25zLCByZXR1cm5PdXRwdXQgPSBmYWxzZSwgcmV0dXJuU3RhdGUgPSBmYWxzZSkgPT4ge1xuICBpZiAocmV0dXJuT3V0cHV0ID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHN0YXRlLm91dHB1dDtcbiAgfVxuXG4gIGNvbnN0IG9wdHMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBwcmVwZW5kID0gb3B0cy5jb250YWlucyA/ICcnIDogJ14nO1xuICBjb25zdCBhcHBlbmQgPSBvcHRzLmNvbnRhaW5zID8gJycgOiAnJCc7XG5cbiAgbGV0IHNvdXJjZSA9IGAke3ByZXBlbmR9KD86JHtzdGF0ZS5vdXRwdXR9KSR7YXBwZW5kfWA7XG4gIGlmIChzdGF0ZSAmJiBzdGF0ZS5uZWdhdGVkID09PSB0cnVlKSB7XG4gICAgc291cmNlID0gYF4oPyEke3NvdXJjZX0pLiokYDtcbiAgfVxuXG4gIGNvbnN0IHJlZ2V4ID0gcGljb21hdGNoLnRvUmVnZXgoc291cmNlLCBvcHRpb25zKTtcbiAgaWYgKHJldHVyblN0YXRlID09PSB0cnVlKSB7XG4gICAgcmVnZXguc3RhdGUgPSBzdGF0ZTtcbiAgfVxuXG4gIHJldHVybiByZWdleDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgcmVndWxhciBleHByZXNzaW9uIGZyb20gYSBwYXJzZWQgZ2xvYiBwYXR0ZXJuLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBwaWNvbWF0Y2ggPSByZXF1aXJlKCdwaWNvbWF0Y2gnKTtcbiAqIGNvbnN0IHN0YXRlID0gcGljb21hdGNoLnBhcnNlKCcqLmpzJyk7XG4gKiAvLyBwaWNvbWF0Y2guY29tcGlsZVJlKHN0YXRlWywgb3B0aW9uc10pO1xuICpcbiAqIGNvbnNvbGUubG9nKHBpY29tYXRjaC5jb21waWxlUmUoc3RhdGUpKTtcbiAqIC8vPT4gL14oPzooPyFcXC4pKD89LilbXi9dKj9cXC5qcykkL1xuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHN0YXRlYCBUaGUgb2JqZWN0IHJldHVybmVkIGZyb20gdGhlIGAucGFyc2VgIG1ldGhvZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYHJldHVybk91dHB1dGAgSW1wbGVtZW50b3JzIG1heSB1c2UgdGhpcyBhcmd1bWVudCB0byByZXR1cm4gdGhlIGNvbXBpbGVkIG91dHB1dCwgaW5zdGVhZCBvZiBhIHJlZ3VsYXIgZXhwcmVzc2lvbi4gVGhpcyBpcyBub3QgZXhwb3NlZCBvbiB0aGUgb3B0aW9ucyB0byBwcmV2ZW50IGVuZC11c2VycyBmcm9tIG11dGF0aW5nIHRoZSByZXN1bHQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGByZXR1cm5TdGF0ZWAgSW1wbGVtZW50b3JzIG1heSB1c2UgdGhpcyBhcmd1bWVudCB0byByZXR1cm4gdGhlIHN0YXRlIGZyb20gdGhlIHBhcnNlZCBnbG9iIHdpdGggdGhlIHJldHVybmVkIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqIEByZXR1cm4ge1JlZ0V4cH0gUmV0dXJucyBhIHJlZ2V4IGNyZWF0ZWQgZnJvbSB0aGUgZ2l2ZW4gcGF0dGVybi5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucGljb21hdGNoLm1ha2VSZSA9IChpbnB1dCwgb3B0aW9ucyA9IHt9LCByZXR1cm5PdXRwdXQgPSBmYWxzZSwgcmV0dXJuU3RhdGUgPSBmYWxzZSkgPT4ge1xuICBpZiAoIWlucHV0IHx8IHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgfVxuXG4gIGxldCBwYXJzZWQgPSB7IG5lZ2F0ZWQ6IGZhbHNlLCBmYXN0cGF0aHM6IHRydWUgfTtcblxuICBpZiAob3B0aW9ucy5mYXN0cGF0aHMgIT09IGZhbHNlICYmIChpbnB1dFswXSA9PT0gJy4nIHx8IGlucHV0WzBdID09PSAnKicpKSB7XG4gICAgcGFyc2VkLm91dHB1dCA9IHBhcnNlLmZhc3RwYXRocyhpbnB1dCwgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAoIXBhcnNlZC5vdXRwdXQpIHtcbiAgICBwYXJzZWQgPSBwYXJzZShpbnB1dCwgb3B0aW9ucyk7XG4gIH1cblxuICByZXR1cm4gcGljb21hdGNoLmNvbXBpbGVSZShwYXJzZWQsIG9wdGlvbnMsIHJldHVybk91dHB1dCwgcmV0dXJuU3RhdGUpO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSByZWd1bGFyIGV4cHJlc3Npb24gZnJvbSB0aGUgZ2l2ZW4gcmVnZXggc291cmNlIHN0cmluZy5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgcGljb21hdGNoID0gcmVxdWlyZSgncGljb21hdGNoJyk7XG4gKiAvLyBwaWNvbWF0Y2gudG9SZWdleChzb3VyY2VbLCBvcHRpb25zXSk7XG4gKlxuICogY29uc3QgeyBvdXRwdXQgfSA9IHBpY29tYXRjaC5wYXJzZSgnKi5qcycpO1xuICogY29uc29sZS5sb2cocGljb21hdGNoLnRvUmVnZXgob3V0cHV0KSk7XG4gKiAvLz0+IC9eKD86KD8hXFwuKSg/PS4pW14vXSo/XFwuanMpJC9cbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBzb3VyY2VgIFJlZ3VsYXIgZXhwcmVzc2lvbiBzb3VyY2Ugc3RyaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYFxuICogQHJldHVybiB7UmVnRXhwfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5waWNvbWF0Y2gudG9SZWdleCA9IChzb3VyY2UsIG9wdGlvbnMpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBvcHRzID0gb3B0aW9ucyB8fCB7fTtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChzb3VyY2UsIG9wdHMuZmxhZ3MgfHwgKG9wdHMubm9jYXNlID8gJ2knIDogJycpKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5kZWJ1ZyA9PT0gdHJ1ZSkgdGhyb3cgZXJyO1xuICAgIHJldHVybiAvJF4vO1xuICB9XG59O1xuXG4vKipcbiAqIFBpY29tYXRjaCBjb25zdGFudHMuXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxucGljb21hdGNoLmNvbnN0YW50cyA9IGNvbnN0YW50cztcblxuLyoqXG4gKiBFeHBvc2UgXCJwaWNvbWF0Y2hcIlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gcGljb21hdGNoO1xuIiwgIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9waWNvbWF0Y2gnKTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCBicmFjZXMgPSByZXF1aXJlKCdicmFjZXMnKTtcbmNvbnN0IHBpY29tYXRjaCA9IHJlcXVpcmUoJ3BpY29tYXRjaCcpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCdwaWNvbWF0Y2gvbGliL3V0aWxzJyk7XG5jb25zdCBpc0VtcHR5U3RyaW5nID0gdmFsID0+IHZhbCA9PT0gJycgfHwgdmFsID09PSAnLi8nO1xuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2Ygc3RyaW5ncyB0aGF0IG1hdGNoIG9uZSBvciBtb3JlIGdsb2IgcGF0dGVybnMuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IG1tID0gcmVxdWlyZSgnbWljcm9tYXRjaCcpO1xuICogLy8gbW0obGlzdCwgcGF0dGVybnNbLCBvcHRpb25zXSk7XG4gKlxuICogY29uc29sZS5sb2cobW0oWydhLmpzJywgJ2EudHh0J10sIFsnKi5qcyddKSk7XG4gKiAvLz0+IFsgJ2EuanMnIF1cbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXk8c3RyaW5nPn0gYGxpc3RgIExpc3Qgb2Ygc3RyaW5ncyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5PHN0cmluZz59IGBwYXR0ZXJuc2AgT25lIG9yIG1vcmUgZ2xvYiBwYXR0ZXJucyB0byB1c2UgZm9yIG1hdGNoaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYCBTZWUgYXZhaWxhYmxlIFtvcHRpb25zXSgjb3B0aW9ucylcbiAqIEByZXR1cm4ge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIG1hdGNoZXNcbiAqIEBzdW1tYXJ5IGZhbHNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmNvbnN0IG1pY3JvbWF0Y2ggPSAobGlzdCwgcGF0dGVybnMsIG9wdGlvbnMpID0+IHtcbiAgcGF0dGVybnMgPSBbXS5jb25jYXQocGF0dGVybnMpO1xuICBsaXN0ID0gW10uY29uY2F0KGxpc3QpO1xuXG4gIGxldCBvbWl0ID0gbmV3IFNldCgpO1xuICBsZXQga2VlcCA9IG5ldyBTZXQoKTtcbiAgbGV0IGl0ZW1zID0gbmV3IFNldCgpO1xuICBsZXQgbmVnYXRpdmVzID0gMDtcblxuICBsZXQgb25SZXN1bHQgPSBzdGF0ZSA9PiB7XG4gICAgaXRlbXMuYWRkKHN0YXRlLm91dHB1dCk7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5vblJlc3VsdCkge1xuICAgICAgb3B0aW9ucy5vblJlc3VsdChzdGF0ZSk7XG4gICAgfVxuICB9O1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0dGVybnMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgaXNNYXRjaCA9IHBpY29tYXRjaChTdHJpbmcocGF0dGVybnNbaV0pLCB7IC4uLm9wdGlvbnMsIG9uUmVzdWx0IH0sIHRydWUpO1xuICAgIGxldCBuZWdhdGVkID0gaXNNYXRjaC5zdGF0ZS5uZWdhdGVkIHx8IGlzTWF0Y2guc3RhdGUubmVnYXRlZEV4dGdsb2I7XG4gICAgaWYgKG5lZ2F0ZWQpIG5lZ2F0aXZlcysrO1xuXG4gICAgZm9yIChsZXQgaXRlbSBvZiBsaXN0KSB7XG4gICAgICBsZXQgbWF0Y2hlZCA9IGlzTWF0Y2goaXRlbSwgdHJ1ZSk7XG5cbiAgICAgIGxldCBtYXRjaCA9IG5lZ2F0ZWQgPyAhbWF0Y2hlZC5pc01hdGNoIDogbWF0Y2hlZC5pc01hdGNoO1xuICAgICAgaWYgKCFtYXRjaCkgY29udGludWU7XG5cbiAgICAgIGlmIChuZWdhdGVkKSB7XG4gICAgICAgIG9taXQuYWRkKG1hdGNoZWQub3V0cHV0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9taXQuZGVsZXRlKG1hdGNoZWQub3V0cHV0KTtcbiAgICAgICAga2VlcC5hZGQobWF0Y2hlZC5vdXRwdXQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxldCByZXN1bHQgPSBuZWdhdGl2ZXMgPT09IHBhdHRlcm5zLmxlbmd0aCA/IFsuLi5pdGVtc10gOiBbLi4ua2VlcF07XG4gIGxldCBtYXRjaGVzID0gcmVzdWx0LmZpbHRlcihpdGVtID0+ICFvbWl0LmhhcyhpdGVtKSk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgbWF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAob3B0aW9ucy5mYWlsZ2xvYiA9PT0gdHJ1ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBtYXRjaGVzIGZvdW5kIGZvciBcIiR7cGF0dGVybnMuam9pbignLCAnKX1cImApO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLm5vbnVsbCA9PT0gdHJ1ZSB8fCBvcHRpb25zLm51bGxnbG9iID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy51bmVzY2FwZSA/IHBhdHRlcm5zLm1hcChwID0+IHAucmVwbGFjZSgvXFxcXC9nLCAnJykpIDogcGF0dGVybnM7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1hdGNoZXM7XG59O1xuXG4vKipcbiAqIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gKi9cblxubWljcm9tYXRjaC5tYXRjaCA9IG1pY3JvbWF0Y2g7XG5cbi8qKlxuICogUmV0dXJucyBhIG1hdGNoZXIgZnVuY3Rpb24gZnJvbSB0aGUgZ2l2ZW4gZ2xvYiBgcGF0dGVybmAgYW5kIGBvcHRpb25zYC5cbiAqIFRoZSByZXR1cm5lZCBmdW5jdGlvbiB0YWtlcyBhIHN0cmluZyB0byBtYXRjaCBhcyBpdHMgb25seSBhcmd1bWVudCBhbmQgcmV0dXJuc1xuICogdHJ1ZSBpZiB0aGUgc3RyaW5nIGlzIGEgbWF0Y2guXG4gKlxuICogYGBganNcbiAqIGNvbnN0IG1tID0gcmVxdWlyZSgnbWljcm9tYXRjaCcpO1xuICogLy8gbW0ubWF0Y2hlcihwYXR0ZXJuWywgb3B0aW9uc10pO1xuICpcbiAqIGNvbnN0IGlzTWF0Y2ggPSBtbS5tYXRjaGVyKCcqLiEoKmEpJyk7XG4gKiBjb25zb2xlLmxvZyhpc01hdGNoKCdhLmEnKSk7IC8vPT4gZmFsc2VcbiAqIGNvbnNvbGUubG9nKGlzTWF0Y2goJ2EuYicpKTsgLy89PiB0cnVlXG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmAgR2xvYiBwYXR0ZXJuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gUmV0dXJucyBhIG1hdGNoZXIgZnVuY3Rpb24uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1pY3JvbWF0Y2gubWF0Y2hlciA9IChwYXR0ZXJuLCBvcHRpb25zKSA9PiBwaWNvbWF0Y2gocGF0dGVybiwgb3B0aW9ucyk7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmICoqYW55Kiogb2YgdGhlIGdpdmVuIGdsb2IgYHBhdHRlcm5zYCBtYXRjaCB0aGUgc3BlY2lmaWVkIGBzdHJpbmdgLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBtbSA9IHJlcXVpcmUoJ21pY3JvbWF0Y2gnKTtcbiAqIC8vIG1tLmlzTWF0Y2goc3RyaW5nLCBwYXR0ZXJuc1ssIG9wdGlvbnNdKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhtbS5pc01hdGNoKCdhLmEnLCBbJ2IuKicsICcqLmEnXSkpOyAvLz0+IHRydWVcbiAqIGNvbnNvbGUubG9nKG1tLmlzTWF0Y2goJ2EuYScsICdiLionKSk7IC8vPT4gZmFsc2VcbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBzdHJgIFRoZSBzdHJpbmcgdG8gdGVzdC5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBgcGF0dGVybnNgIE9uZSBvciBtb3JlIGdsb2IgcGF0dGVybnMgdG8gdXNlIGZvciBtYXRjaGluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgW29wdGlvbnNdYCBTZWUgYXZhaWxhYmxlIFtvcHRpb25zXSgjb3B0aW9ucykuXG4gKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgYW55IHBhdHRlcm5zIG1hdGNoIGBzdHJgXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1pY3JvbWF0Y2guaXNNYXRjaCA9IChzdHIsIHBhdHRlcm5zLCBvcHRpb25zKSA9PiBwaWNvbWF0Y2gocGF0dGVybnMsIG9wdGlvbnMpKHN0cik7XG5cbi8qKlxuICogQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAqL1xuXG5taWNyb21hdGNoLmFueSA9IG1pY3JvbWF0Y2guaXNNYXRjaDtcblxuLyoqXG4gKiBSZXR1cm5zIGEgbGlzdCBvZiBzdHJpbmdzIHRoYXQgXyoqZG8gbm90IG1hdGNoIGFueSoqXyBvZiB0aGUgZ2l2ZW4gYHBhdHRlcm5zYC5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgbW0gPSByZXF1aXJlKCdtaWNyb21hdGNoJyk7XG4gKiAvLyBtbS5ub3QobGlzdCwgcGF0dGVybnNbLCBvcHRpb25zXSk7XG4gKlxuICogY29uc29sZS5sb2cobW0ubm90KFsnYS5hJywgJ2IuYicsICdjLmMnXSwgJyouYScpKTtcbiAqIC8vPT4gWydiLmInLCAnYy5jJ11cbiAqIGBgYFxuICogQHBhcmFtIHtBcnJheX0gYGxpc3RgIEFycmF5IG9mIHN0cmluZ3MgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gYHBhdHRlcm5zYCBPbmUgb3IgbW9yZSBnbG9iIHBhdHRlcm4gdG8gdXNlIGZvciBtYXRjaGluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2AgU2VlIGF2YWlsYWJsZSBbb3B0aW9uc10oI29wdGlvbnMpIGZvciBjaGFuZ2luZyBob3cgbWF0Y2hlcyBhcmUgcGVyZm9ybWVkXG4gKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBzdHJpbmdzIHRoYXQgKipkbyBub3QgbWF0Y2gqKiB0aGUgZ2l2ZW4gcGF0dGVybnMuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1pY3JvbWF0Y2gubm90ID0gKGxpc3QsIHBhdHRlcm5zLCBvcHRpb25zID0ge30pID0+IHtcbiAgcGF0dGVybnMgPSBbXS5jb25jYXQocGF0dGVybnMpLm1hcChTdHJpbmcpO1xuICBsZXQgcmVzdWx0ID0gbmV3IFNldCgpO1xuICBsZXQgaXRlbXMgPSBbXTtcblxuICBsZXQgb25SZXN1bHQgPSBzdGF0ZSA9PiB7XG4gICAgaWYgKG9wdGlvbnMub25SZXN1bHQpIG9wdGlvbnMub25SZXN1bHQoc3RhdGUpO1xuICAgIGl0ZW1zLnB1c2goc3RhdGUub3V0cHV0KTtcbiAgfTtcblxuICBsZXQgbWF0Y2hlcyA9IG1pY3JvbWF0Y2gobGlzdCwgcGF0dGVybnMsIHsgLi4ub3B0aW9ucywgb25SZXN1bHQgfSk7XG5cbiAgZm9yIChsZXQgaXRlbSBvZiBpdGVtcykge1xuICAgIGlmICghbWF0Y2hlcy5pbmNsdWRlcyhpdGVtKSkge1xuICAgICAgcmVzdWx0LmFkZChpdGVtKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFsuLi5yZXN1bHRdO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGBzdHJpbmdgIGNvbnRhaW5zIHRoZSBnaXZlbiBwYXR0ZXJuLiBTaW1pbGFyXG4gKiB0byBbLmlzTWF0Y2hdKCNpc01hdGNoKSBidXQgdGhlIHBhdHRlcm4gY2FuIG1hdGNoIGFueSBwYXJ0IG9mIHRoZSBzdHJpbmcuXG4gKlxuICogYGBganNcbiAqIHZhciBtbSA9IHJlcXVpcmUoJ21pY3JvbWF0Y2gnKTtcbiAqIC8vIG1tLmNvbnRhaW5zKHN0cmluZywgcGF0dGVyblssIG9wdGlvbnNdKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhtbS5jb250YWlucygnYWEvYmIvY2MnLCAnKmInKSk7XG4gKiAvLz0+IHRydWVcbiAqIGNvbnNvbGUubG9nKG1tLmNvbnRhaW5zKCdhYS9iYi9jYycsICcqZCcpKTtcbiAqIC8vPT4gZmFsc2VcbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBzdHJgIFRoZSBzdHJpbmcgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gYHBhdHRlcm5zYCBHbG9iIHBhdHRlcm4gdG8gdXNlIGZvciBtYXRjaGluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2AgU2VlIGF2YWlsYWJsZSBbb3B0aW9uc10oI29wdGlvbnMpIGZvciBjaGFuZ2luZyBob3cgbWF0Y2hlcyBhcmUgcGVyZm9ybWVkXG4gKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgYW55IG9mIHRoZSBwYXR0ZXJucyBtYXRjaGVzIGFueSBwYXJ0IG9mIGBzdHJgLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5taWNyb21hdGNoLmNvbnRhaW5zID0gKHN0ciwgcGF0dGVybiwgb3B0aW9ucykgPT4ge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBhIHN0cmluZzogXCIke3V0aWwuaW5zcGVjdChzdHIpfVwiYCk7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShwYXR0ZXJuKSkge1xuICAgIHJldHVybiBwYXR0ZXJuLnNvbWUocCA9PiBtaWNyb21hdGNoLmNvbnRhaW5zKHN0ciwgcCwgb3B0aW9ucykpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgIGlmIChpc0VtcHR5U3RyaW5nKHN0cikgfHwgaXNFbXB0eVN0cmluZyhwYXR0ZXJuKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzdHIuaW5jbHVkZXMocGF0dGVybikgfHwgKHN0ci5zdGFydHNXaXRoKCcuLycpICYmIHN0ci5zbGljZSgyKS5pbmNsdWRlcyhwYXR0ZXJuKSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtaWNyb21hdGNoLmlzTWF0Y2goc3RyLCBwYXR0ZXJuLCB7IC4uLm9wdGlvbnMsIGNvbnRhaW5zOiB0cnVlIH0pO1xufTtcblxuLyoqXG4gKiBGaWx0ZXIgdGhlIGtleXMgb2YgdGhlIGdpdmVuIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBgZ2xvYmAgcGF0dGVyblxuICogYW5kIGBvcHRpb25zYC4gRG9lcyBub3QgYXR0ZW1wdCB0byBtYXRjaCBuZXN0ZWQga2V5cy4gSWYgeW91IG5lZWQgdGhpcyBmZWF0dXJlLFxuICogdXNlIFtnbG9iLW9iamVjdF1bXSBpbnN0ZWFkLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBtbSA9IHJlcXVpcmUoJ21pY3JvbWF0Y2gnKTtcbiAqIC8vIG1tLm1hdGNoS2V5cyhvYmplY3QsIHBhdHRlcm5zWywgb3B0aW9uc10pO1xuICpcbiAqIGNvbnN0IG9iaiA9IHsgYWE6ICdhJywgYWI6ICdiJywgYWM6ICdjJyB9O1xuICogY29uc29sZS5sb2cobW0ubWF0Y2hLZXlzKG9iaiwgJypiJykpO1xuICogLy89PiB7IGFiOiAnYicgfVxuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdH0gYG9iamVjdGAgVGhlIG9iamVjdCB3aXRoIGtleXMgdG8gZmlsdGVyLlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGBwYXR0ZXJuc2AgT25lIG9yIG1vcmUgZ2xvYiBwYXR0ZXJucyB0byB1c2UgZm9yIG1hdGNoaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYCBTZWUgYXZhaWxhYmxlIFtvcHRpb25zXSgjb3B0aW9ucykgZm9yIGNoYW5naW5nIGhvdyBtYXRjaGVzIGFyZSBwZXJmb3JtZWRcbiAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBvbmx5IGtleXMgdGhhdCBtYXRjaCB0aGUgZ2l2ZW4gcGF0dGVybnMuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1pY3JvbWF0Y2gubWF0Y2hLZXlzID0gKG9iaiwgcGF0dGVybnMsIG9wdGlvbnMpID0+IHtcbiAgaWYgKCF1dGlscy5pc09iamVjdChvYmopKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCcpO1xuICB9XG4gIGxldCBrZXlzID0gbWljcm9tYXRjaChPYmplY3Qua2V5cyhvYmopLCBwYXR0ZXJucywgb3B0aW9ucyk7XG4gIGxldCByZXMgPSB7fTtcbiAgZm9yIChsZXQga2V5IG9mIGtleXMpIHJlc1trZXldID0gb2JqW2tleV07XG4gIHJldHVybiByZXM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBzb21lIG9mIHRoZSBzdHJpbmdzIGluIHRoZSBnaXZlbiBgbGlzdGAgbWF0Y2ggYW55IG9mIHRoZSBnaXZlbiBnbG9iIGBwYXR0ZXJuc2AuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IG1tID0gcmVxdWlyZSgnbWljcm9tYXRjaCcpO1xuICogLy8gbW0uc29tZShsaXN0LCBwYXR0ZXJuc1ssIG9wdGlvbnNdKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhtbS5zb21lKFsnZm9vLmpzJywgJ2Jhci5qcyddLCBbJyouanMnLCAnIWZvby5qcyddKSk7XG4gKiAvLyB0cnVlXG4gKiBjb25zb2xlLmxvZyhtbS5zb21lKFsnZm9vLmpzJ10sIFsnKi5qcycsICchZm9vLmpzJ10pKTtcbiAqIC8vIGZhbHNlXG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBgbGlzdGAgVGhlIHN0cmluZyBvciBhcnJheSBvZiBzdHJpbmdzIHRvIHRlc3QuIFJldHVybnMgYXMgc29vbiBhcyB0aGUgZmlyc3QgbWF0Y2ggaXMgZm91bmQuXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gYHBhdHRlcm5zYCBPbmUgb3IgbW9yZSBnbG9iIHBhdHRlcm5zIHRvIHVzZSBmb3IgbWF0Y2hpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgIFNlZSBhdmFpbGFibGUgW29wdGlvbnNdKCNvcHRpb25zKSBmb3IgY2hhbmdpbmcgaG93IG1hdGNoZXMgYXJlIHBlcmZvcm1lZFxuICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGFueSBgcGF0dGVybnNgIG1hdGNoZXMgYW55IG9mIHRoZSBzdHJpbmdzIGluIGBsaXN0YFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5taWNyb21hdGNoLnNvbWUgPSAobGlzdCwgcGF0dGVybnMsIG9wdGlvbnMpID0+IHtcbiAgbGV0IGl0ZW1zID0gW10uY29uY2F0KGxpc3QpO1xuXG4gIGZvciAobGV0IHBhdHRlcm4gb2YgW10uY29uY2F0KHBhdHRlcm5zKSkge1xuICAgIGxldCBpc01hdGNoID0gcGljb21hdGNoKFN0cmluZyhwYXR0ZXJuKSwgb3B0aW9ucyk7XG4gICAgaWYgKGl0ZW1zLnNvbWUoaXRlbSA9PiBpc01hdGNoKGl0ZW0pKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGV2ZXJ5IHN0cmluZyBpbiB0aGUgZ2l2ZW4gYGxpc3RgIG1hdGNoZXNcbiAqIGFueSBvZiB0aGUgZ2l2ZW4gZ2xvYiBgcGF0dGVybnNgLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBtbSA9IHJlcXVpcmUoJ21pY3JvbWF0Y2gnKTtcbiAqIC8vIG1tLmV2ZXJ5KGxpc3QsIHBhdHRlcm5zWywgb3B0aW9uc10pO1xuICpcbiAqIGNvbnNvbGUubG9nKG1tLmV2ZXJ5KCdmb28uanMnLCBbJ2Zvby5qcyddKSk7XG4gKiAvLyB0cnVlXG4gKiBjb25zb2xlLmxvZyhtbS5ldmVyeShbJ2Zvby5qcycsICdiYXIuanMnXSwgWycqLmpzJ10pKTtcbiAqIC8vIHRydWVcbiAqIGNvbnNvbGUubG9nKG1tLmV2ZXJ5KFsnZm9vLmpzJywgJ2Jhci5qcyddLCBbJyouanMnLCAnIWZvby5qcyddKSk7XG4gKiAvLyBmYWxzZVxuICogY29uc29sZS5sb2cobW0uZXZlcnkoWydmb28uanMnXSwgWycqLmpzJywgJyFmb28uanMnXSkpO1xuICogLy8gZmFsc2VcbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGBsaXN0YCBUaGUgc3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3MgdG8gdGVzdC5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBgcGF0dGVybnNgIE9uZSBvciBtb3JlIGdsb2IgcGF0dGVybnMgdG8gdXNlIGZvciBtYXRjaGluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2AgU2VlIGF2YWlsYWJsZSBbb3B0aW9uc10oI29wdGlvbnMpIGZvciBjaGFuZ2luZyBob3cgbWF0Y2hlcyBhcmUgcGVyZm9ybWVkXG4gKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgYWxsIGBwYXR0ZXJuc2AgbWF0Y2hlcyBhbGwgb2YgdGhlIHN0cmluZ3MgaW4gYGxpc3RgXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1pY3JvbWF0Y2guZXZlcnkgPSAobGlzdCwgcGF0dGVybnMsIG9wdGlvbnMpID0+IHtcbiAgbGV0IGl0ZW1zID0gW10uY29uY2F0KGxpc3QpO1xuXG4gIGZvciAobGV0IHBhdHRlcm4gb2YgW10uY29uY2F0KHBhdHRlcm5zKSkge1xuICAgIGxldCBpc01hdGNoID0gcGljb21hdGNoKFN0cmluZyhwYXR0ZXJuKSwgb3B0aW9ucyk7XG4gICAgaWYgKCFpdGVtcy5ldmVyeShpdGVtID0+IGlzTWF0Y2goaXRlbSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgKiphbGwqKiBvZiB0aGUgZ2l2ZW4gYHBhdHRlcm5zYCBtYXRjaFxuICogdGhlIHNwZWNpZmllZCBzdHJpbmcuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IG1tID0gcmVxdWlyZSgnbWljcm9tYXRjaCcpO1xuICogLy8gbW0uYWxsKHN0cmluZywgcGF0dGVybnNbLCBvcHRpb25zXSk7XG4gKlxuICogY29uc29sZS5sb2cobW0uYWxsKCdmb28uanMnLCBbJ2Zvby5qcyddKSk7XG4gKiAvLyB0cnVlXG4gKlxuICogY29uc29sZS5sb2cobW0uYWxsKCdmb28uanMnLCBbJyouanMnLCAnIWZvby5qcyddKSk7XG4gKiAvLyBmYWxzZVxuICpcbiAqIGNvbnNvbGUubG9nKG1tLmFsbCgnZm9vLmpzJywgWycqLmpzJywgJ2Zvby5qcyddKSk7XG4gKiAvLyB0cnVlXG4gKlxuICogY29uc29sZS5sb2cobW0uYWxsKCdmb28uanMnLCBbJyouanMnLCAnZionLCAnKm8qJywgJypvLmpzJ10pKTtcbiAqIC8vIHRydWVcbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGBzdHJgIFRoZSBzdHJpbmcgdG8gdGVzdC5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBgcGF0dGVybnNgIE9uZSBvciBtb3JlIGdsb2IgcGF0dGVybnMgdG8gdXNlIGZvciBtYXRjaGluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2AgU2VlIGF2YWlsYWJsZSBbb3B0aW9uc10oI29wdGlvbnMpIGZvciBjaGFuZ2luZyBob3cgbWF0Y2hlcyBhcmUgcGVyZm9ybWVkXG4gKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgYW55IHBhdHRlcm5zIG1hdGNoIGBzdHJgXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1pY3JvbWF0Y2guYWxsID0gKHN0ciwgcGF0dGVybnMsIG9wdGlvbnMpID0+IHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgYSBzdHJpbmc6IFwiJHt1dGlsLmluc3BlY3Qoc3RyKX1cImApO1xuICB9XG5cbiAgcmV0dXJuIFtdLmNvbmNhdChwYXR0ZXJucykuZXZlcnkocCA9PiBwaWNvbWF0Y2gocCwgb3B0aW9ucykoc3RyKSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgbWF0Y2hlcyBjYXB0dXJlZCBieSBgcGF0dGVybmAgaW4gYHN0cmluZywgb3IgYG51bGxgIGlmIHRoZSBwYXR0ZXJuIGRpZCBub3QgbWF0Y2guXG4gKlxuICogYGBganNcbiAqIGNvbnN0IG1tID0gcmVxdWlyZSgnbWljcm9tYXRjaCcpO1xuICogLy8gbW0uY2FwdHVyZShwYXR0ZXJuLCBzdHJpbmdbLCBvcHRpb25zXSk7XG4gKlxuICogY29uc29sZS5sb2cobW0uY2FwdHVyZSgndGVzdC8qLmpzJywgJ3Rlc3QvZm9vLmpzJykpO1xuICogLy89PiBbJ2ZvbyddXG4gKiBjb25zb2xlLmxvZyhtbS5jYXB0dXJlKCd0ZXN0LyouanMnLCAnZm9vL2Jhci5jc3MnKSk7XG4gKiAvLz0+IG51bGxcbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBnbG9iYCBHbG9iIHBhdHRlcm4gdG8gdXNlIGZvciBtYXRjaGluZy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBgaW5wdXRgIFN0cmluZyB0byBtYXRjaFxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYCBTZWUgYXZhaWxhYmxlIFtvcHRpb25zXSgjb3B0aW9ucykgZm9yIGNoYW5naW5nIGhvdyBtYXRjaGVzIGFyZSBwZXJmb3JtZWRcbiAqIEByZXR1cm4ge0FycmF5fG51bGx9IFJldHVybnMgYW4gYXJyYXkgb2YgY2FwdHVyZXMgaWYgdGhlIGlucHV0IG1hdGNoZXMgdGhlIGdsb2IgcGF0dGVybiwgb3RoZXJ3aXNlIGBudWxsYC5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubWljcm9tYXRjaC5jYXB0dXJlID0gKGdsb2IsIGlucHV0LCBvcHRpb25zKSA9PiB7XG4gIGxldCBwb3NpeCA9IHV0aWxzLmlzV2luZG93cyhvcHRpb25zKTtcbiAgbGV0IHJlZ2V4ID0gcGljb21hdGNoLm1ha2VSZShTdHJpbmcoZ2xvYiksIHsgLi4ub3B0aW9ucywgY2FwdHVyZTogdHJ1ZSB9KTtcbiAgbGV0IG1hdGNoID0gcmVnZXguZXhlYyhwb3NpeCA/IHV0aWxzLnRvUG9zaXhTbGFzaGVzKGlucHV0KSA6IGlucHV0KTtcblxuICBpZiAobWF0Y2gpIHtcbiAgICByZXR1cm4gbWF0Y2guc2xpY2UoMSkubWFwKHYgPT4gdiA9PT0gdm9pZCAwID8gJycgOiB2KTtcbiAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGUgYSByZWd1bGFyIGV4cHJlc3Npb24gZnJvbSB0aGUgZ2l2ZW4gZ2xvYiBgcGF0dGVybmAuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IG1tID0gcmVxdWlyZSgnbWljcm9tYXRjaCcpO1xuICogLy8gbW0ubWFrZVJlKHBhdHRlcm5bLCBvcHRpb25zXSk7XG4gKlxuICogY29uc29sZS5sb2cobW0ubWFrZVJlKCcqLmpzJykpO1xuICogLy89PiAvXig/OihcXC5bXFxcXFxcL10pPyg/IVxcLikoPz0uKVteXFwvXSo/XFwuanMpJC9cbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBwYXR0ZXJuYCBBIGdsb2IgcGF0dGVybiB0byBjb252ZXJ0IHRvIHJlZ2V4LlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYFxuICogQHJldHVybiB7UmVnRXhwfSBSZXR1cm5zIGEgcmVnZXggY3JlYXRlZCBmcm9tIHRoZSBnaXZlbiBwYXR0ZXJuLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5taWNyb21hdGNoLm1ha2VSZSA9ICguLi5hcmdzKSA9PiBwaWNvbWF0Y2gubWFrZVJlKC4uLmFyZ3MpO1xuXG4vKipcbiAqIFNjYW4gYSBnbG9iIHBhdHRlcm4gdG8gc2VwYXJhdGUgdGhlIHBhdHRlcm4gaW50byBzZWdtZW50cy4gVXNlZFxuICogYnkgdGhlIFtzcGxpdF0oI3NwbGl0KSBtZXRob2QuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IG1tID0gcmVxdWlyZSgnbWljcm9tYXRjaCcpO1xuICogY29uc3Qgc3RhdGUgPSBtbS5zY2FuKHBhdHRlcm5bLCBvcHRpb25zXSk7XG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3Qgd2l0aFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5taWNyb21hdGNoLnNjYW4gPSAoLi4uYXJncykgPT4gcGljb21hdGNoLnNjYW4oLi4uYXJncyk7XG5cbi8qKlxuICogUGFyc2UgYSBnbG9iIHBhdHRlcm4gdG8gY3JlYXRlIHRoZSBzb3VyY2Ugc3RyaW5nIGZvciBhIHJlZ3VsYXJcbiAqIGV4cHJlc3Npb24uXG4gKlxuICogYGBganNcbiAqIGNvbnN0IG1tID0gcmVxdWlyZSgnbWljcm9tYXRjaCcpO1xuICogY29uc3Qgc3RhdGUgPSBtbShwYXR0ZXJuWywgb3B0aW9uc10pO1xuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYGdsb2JgXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IHdpdGggdXNlZnVsIHByb3BlcnRpZXMgYW5kIG91dHB1dCB0byBiZSB1c2VkIGFzIHJlZ2V4IHNvdXJjZSBzdHJpbmcuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1pY3JvbWF0Y2gucGFyc2UgPSAocGF0dGVybnMsIG9wdGlvbnMpID0+IHtcbiAgbGV0IHJlcyA9IFtdO1xuICBmb3IgKGxldCBwYXR0ZXJuIG9mIFtdLmNvbmNhdChwYXR0ZXJucyB8fCBbXSkpIHtcbiAgICBmb3IgKGxldCBzdHIgb2YgYnJhY2VzKFN0cmluZyhwYXR0ZXJuKSwgb3B0aW9ucykpIHtcbiAgICAgIHJlcy5wdXNoKHBpY29tYXRjaC5wYXJzZShzdHIsIG9wdGlvbnMpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5cbi8qKlxuICogUHJvY2VzcyB0aGUgZ2l2ZW4gYnJhY2UgYHBhdHRlcm5gLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCB7IGJyYWNlcyB9ID0gcmVxdWlyZSgnbWljcm9tYXRjaCcpO1xuICogY29uc29sZS5sb2coYnJhY2VzKCdmb28ve2EsYixjfS9iYXInKSk7XG4gKiAvLz0+IFsgJ2Zvby8oYXxifGMpL2JhcicgXVxuICpcbiAqIGNvbnNvbGUubG9nKGJyYWNlcygnZm9vL3thLGIsY30vYmFyJywgeyBleHBhbmQ6IHRydWUgfSkpO1xuICogLy89PiBbICdmb28vYS9iYXInLCAnZm9vL2IvYmFyJywgJ2Zvby9jL2JhcicgXVxuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHBhdHRlcm5gIFN0cmluZyB3aXRoIGJyYWNlIHBhdHRlcm4gdG8gcHJvY2Vzcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2AgQW55IFtvcHRpb25zXSgjb3B0aW9ucykgdG8gY2hhbmdlIGhvdyBleHBhbnNpb24gaXMgcGVyZm9ybWVkLiBTZWUgdGhlIFticmFjZXNdW10gbGlicmFyeSBmb3IgYWxsIGF2YWlsYWJsZSBvcHRpb25zLlxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1pY3JvbWF0Y2guYnJhY2VzID0gKHBhdHRlcm4sIG9wdGlvbnMpID0+IHtcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBzdHJpbmcnKTtcbiAgaWYgKChvcHRpb25zICYmIG9wdGlvbnMubm9icmFjZSA9PT0gdHJ1ZSkgfHwgIS9cXHsuKlxcfS8udGVzdChwYXR0ZXJuKSkge1xuICAgIHJldHVybiBbcGF0dGVybl07XG4gIH1cbiAgcmV0dXJuIGJyYWNlcyhwYXR0ZXJuLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogRXhwYW5kIGJyYWNlc1xuICovXG5cbm1pY3JvbWF0Y2guYnJhY2VFeHBhbmQgPSAocGF0dGVybiwgb3B0aW9ucykgPT4ge1xuICBpZiAodHlwZW9mIHBhdHRlcm4gIT09ICdzdHJpbmcnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhIHN0cmluZycpO1xuICByZXR1cm4gbWljcm9tYXRjaC5icmFjZXMocGF0dGVybiwgeyAuLi5vcHRpb25zLCBleHBhbmQ6IHRydWUgfSk7XG59O1xuXG4vKipcbiAqIEV4cG9zZSBtaWNyb21hdGNoXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBtaWNyb21hdGNoO1xuIiwgImltcG9ydCB7IFBsdWdpbiB9IGZyb20gJ29ic2lkaWFuJztcclxuXHJcbi8vIEludGVybmFsIGltcG9ydHNcclxuaW1wb3J0IHsgVG9waWNMaW5raW5nU2V0dGluZ3MsIFRvcGljTGlua2luZ1NldHRpbmdUYWIsIERFRkFVTFRfU0VUVElOR1MgfSBmcm9tICcuL3NldHRpbmdzJztcclxuaW1wb3J0IHsgUERGQ29udGVudEV4dHJhY3RvciB9IGZyb20gJy4vcGRmJztcclxuaW1wb3J0IHsgQm9va21hcmtDb250ZW50RXh0cmFjdG9yIH0gZnJvbSAnLi9ib29rbWFyayc7XHJcbmltcG9ydCB7IFRvcGljTGlua2VyIH0gZnJvbSAnLi90b3BpYyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUb3BpY0xpbmtpbmdQbHVnaW4gZXh0ZW5kcyBQbHVnaW4ge1xyXG4gICAgc2V0dGluZ3M6IFRvcGljTGlua2luZ1NldHRpbmdzO1xyXG5cclxuICAgIGFzeW5jIG9ubG9hZCgpIHtcclxuICAgICAgICBhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpO1xyXG5cclxuICAgICAgICAvLyBUaGlzIGFkZHMgYSBzdGF0dXMgYmFyIGl0ZW0gdG8gdGhlIGJvdHRvbSBvZiB0aGUgYXBwLiBEb2VzIG5vdCB3b3JrIG9uIG1vYmlsZSBhcHBzLlxyXG4gICAgICAgIGNvbnN0IHN0YXR1c0Jhckl0ZW1FbCA9IHRoaXMuYWRkU3RhdHVzQmFySXRlbSgpO1xyXG5cclxuICAgICAgICAvLyBUaGlzIGNvbW1hbmQgZXh0cmFjdHMgUERGcyB0byBNYXJrZG93blxyXG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZCh7XHJcbiAgICAgICAgICAgIGlkOiAnZXh0cmFjdC1tZC1mcm9tLXBkZnMtY29tbWFuZCcsXHJcbiAgICAgICAgICAgIG5hbWU6ICdFeHRyYWN0IE1hcmtkb3duIGZyb20gUERGcycsXHJcbiAgICAgICAgICAgIGhvdGtleXM6IFt7IG1vZGlmaWVyczogW1wiTW9kXCIsIFwiU2hpZnRcIl0sIGtleTogXCJhXCIgfV0sXHJcbiAgICAgICAgICAgIGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgeyB2YXVsdCB9ID0gdGhpcy5hcHA7XHJcblxyXG4gICAgICAgICAgICAgICAgbmV3IFBERkNvbnRlbnRFeHRyYWN0b3IoKS5leHRyYWN0KHZhdWx0LCB0aGlzLnNldHRpbmdzLCBzdGF0dXNCYXJJdGVtRWwpO1xyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoe1xyXG4gICAgICAgICAgICBpZDogJ2V4dHJhY3QtbWQtZnJvbS1ib29rbWFya3MtY29tbWFuZCcsXHJcbiAgICAgICAgICAgIG5hbWU6ICdFeHRyYWN0IE1hcmtkb3duIGZyb20gQm9va21hcmtzJyxcclxuICAgICAgICAgICAgY2FsbGJhY2s6IGFzeW5jICgpID0+IHtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHZhdWx0IH0gPSB0aGlzLmFwcDtcclxuXHJcbiAgICAgICAgICAgICAgICBuZXcgQm9va21hcmtDb250ZW50RXh0cmFjdG9yKCkuZXh0cmFjdCh2YXVsdCwgdGhpcy5zZXR0aW5ncywgc3RhdHVzQmFySXRlbUVsKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gR2VuZXJhdGVzIHRvcGljcyBhbmQgbGlua3MgdG8gYXNzb2NpYXRlZCBkb2N1bWVudHNcclxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoe1xyXG4gICAgICAgICAgICBpZDogJ2xpbmstdG9waWNzLWNvbW1hbmQnLFxyXG4gICAgICAgICAgICBuYW1lOiAnTGluayBUb3BpY3MnLFxyXG4gICAgICAgICAgICBjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xyXG5cclxuICAgICAgICAgICAgICAgIG5ldyBUb3BpY0xpbmtlcigpLmxpbmsodGhpcy5hcHAsIHRoaXMuc2V0dGluZ3MsIHN0YXR1c0Jhckl0ZW1FbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gVGhpcyBhZGRzIGEgc2V0dGluZ3MgdGFiIHNvIHRoZSB1c2VyIGNhbiBjb25maWd1cmUgdmFyaW91cyBhc3BlY3RzIG9mIHRoZSBwbHVnaW5cclxuICAgICAgICB0aGlzLmFkZFNldHRpbmdUYWIobmV3IFRvcGljTGlua2luZ1NldHRpbmdUYWIodGhpcy5hcHAsIHRoaXMpKTtcclxuXHJcblx0fVxyXG5cclxuICAgIG9udW5sb2FkKCkge1xyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcclxuICAgICAgICB0aGlzLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9TRVRUSU5HUywgYXdhaXQgdGhpcy5sb2FkRGF0YSgpKTtcclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBzYXZlU2V0dGluZ3MoKSB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5zYXZlRGF0YSh0aGlzLnNldHRpbmdzKTtcclxuICAgIH1cclxufVxyXG5cclxuIiwgImltcG9ydCB7XG4gICAgQXBwLFxuICAgIFBsdWdpblNldHRpbmdUYWIsXG4gICAgU2V0dGluZyxcbiAgfSBmcm9tICdvYnNpZGlhbic7XG4gIFxuaW1wb3J0IFRvcGljTGlua2luZ1BsdWdpbiBmcm9tICcuL21haW4nO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRvcGljTGlua2luZ1NldHRpbmdzIHtcbiAgICBnZW5lcmF0ZWRQYXRoOiBzdHJpbmc7XG4gICAgcGRmUGF0aDogc3RyaW5nO1xuICAgIHBkZk92ZXJ3cml0ZTogYm9vbGVhbjtcbiAgICBwZGZFeHRyYWN0RmlsZU51bWJlckxpbWl0OiBudW1iZXI7XG4gICAgcGRmRXh0cmFjdEZpbGVTaXplTGltaXQ6IG51bWJlcjtcbiAgICBwZGZFeHRyYWN0Q2h1bmtJZkZpbGVFeGNlZWRzTGltaXQ6IGJvb2xlYW47XG4gICAgYm9va21hcmtQYXRoOiBzdHJpbmc7XG4gICAgYm9va21hcmtPdmVyd3JpdGU6IGJvb2xlYW47XG4gICAgdG9waWNQYXRoUGF0dGVybjogc3RyaW5nO1xuICAgIHRvcGljU2VhcmNoUGF0dGVybjogc3RyaW5nO1xuICAgIHRvcGljVGFnUGF0dGVybjogc3RyaW5nO1xuICAgIG51bVRvcGljczogbnVtYmVyO1xuICAgIG51bVdvcmRzOiBudW1iZXI7XG4gICAgc3RlbW1pbmc6IGJvb2xlYW47XG4gICAgdG9waWNUaHJlc2hvbGQ6IG51bWJlcjtcbiAgICBmaXhlZFdvcmRMZW5ndGg6IG51bWJlcjtcbiAgICBwZXJjZW50YWdlVGV4dFRvU2NhbjogbnVtYmVyO1xuICAgIHdvcmRTZWxlY3Rpb25SYW5kb206IGJvb2xlYW47XG4gICAgdG9waWNJbmNsdWRlUGF0dGVybjogYm9vbGVhbjtcbiAgICB0b3BpY0luY2x1ZGVUaW1lc3RhbXA6IGJvb2xlYW47XG4gICAgbGRhSXRlcmF0aW9uczogbnVtYmVyO1xuICAgIGxkYUJ1cm5JbjogbnVtYmVyO1xuICAgIGxkYVRoaW46IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfU0VUVElOR1M6IFRvcGljTGlua2luZ1NldHRpbmdzID0ge1xuICAgIGdlbmVyYXRlZFBhdGg6ICdHZW5lcmF0ZWQvJyxcbiAgICBwZGZQYXRoOiAnUERGcy8nLFxuICAgIHBkZk92ZXJ3cml0ZTogZmFsc2UsXG4gICAgcGRmRXh0cmFjdEZpbGVOdW1iZXJMaW1pdDogMCxcbiAgICBwZGZFeHRyYWN0RmlsZVNpemVMaW1pdDogNTAwMCxcbiAgICBwZGZFeHRyYWN0Q2h1bmtJZkZpbGVFeGNlZWRzTGltaXQ6IHRydWUsXG4gICAgYm9va21hcmtQYXRoOiAnQm9va21hcmtzLycsXG4gICAgYm9va21hcmtPdmVyd3JpdGU6IGZhbHNlLFxuICAgIHRvcGljUGF0aFBhdHRlcm46ICdHZW5lcmF0ZWQvJyxcbiAgICB0b3BpY1NlYXJjaFBhdHRlcm46ICcnLFxuICAgIHRvcGljVGFnUGF0dGVybjogJycsXG4gICAgbnVtVG9waWNzOiA1LFxuICAgIG51bVdvcmRzOiA1LFxuICAgIHN0ZW1taW5nOiBmYWxzZSxcbiAgICB0b3BpY1RocmVzaG9sZDogMC41LFxuICAgIGZpeGVkV29yZExlbmd0aDogMTAwMCxcbiAgICBwZXJjZW50YWdlVGV4dFRvU2NhbjogNSxcbiAgICB3b3JkU2VsZWN0aW9uUmFuZG9tOiB0cnVlLFxuICAgIHRvcGljSW5jbHVkZVBhdHRlcm46IGZhbHNlLFxuICAgIHRvcGljSW5jbHVkZVRpbWVzdGFtcDogZmFsc2UsXG4gICAgbGRhSXRlcmF0aW9uczogMTAwMCxcbiAgICBsZGFCdXJuSW46IDEwMCxcbiAgICBsZGFUaGluOiAxMFxufVxuXG5leHBvcnQgY2xhc3MgVG9waWNMaW5raW5nU2V0dGluZ1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xuICAgIHBsdWdpbjogVG9waWNMaW5raW5nUGx1Z2luO1xuXG4gICAgY29uc3RydWN0b3IoYXBwOiBBcHAsIHBsdWdpbjogVG9waWNMaW5raW5nUGx1Z2luKSB7XG4gICAgICAgIHN1cGVyKGFwcCwgcGx1Z2luKTtcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XG4gICAgfVxuXG4gICAgZGlzcGxheSgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgeyBjb250YWluZXJFbCB9ID0gdGhpcztcblxuICAgICAgICBjb250YWluZXJFbC5lbXB0eSgpO1xuXG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ1RvcGljIExpbmsgUGx1Z2luJyB9KTtcblxuICAgICAgICBjb250YWluZXJFbC5jcmVhdGVFbCgnaDMnLCB7IHRleHQ6ICdHZW5lcmFsJyB9KTtcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnR2VuZXJhdGVkIGZpbGVzJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdXaGVyZSB0byBvdXRwdXQgZ2VuZXJhdGVkIGZpbGVzJylcbiAgICAgICAgICAgIC5hZGRUZXh0KCh0ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgdGV4dC5zZXRQbGFjZWhvbGRlcignR2VuZXJhdGVkLycpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5nZW5lcmF0ZWRQYXRoLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmdlbmVyYXRlZFBhdGggPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMycsIHsgdGV4dDogJ1BERiBFeHRyYWN0aW9uIFNldHRpbmdzJyB9KTtcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnUERGIGZpbGVzJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdXaGVyZSB0byBmaW5kIFBERiBmaWxlcycpXG4gICAgICAgICAgICAuYWRkVGV4dCgodGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgIHRleHQuc2V0UGxhY2Vob2xkZXIoJ1BERnMvJylcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnBkZlBhdGgudG9TdHJpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MucGRmUGF0aCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ092ZXJ3cml0ZScpXG4gICAgICAgICAgICAuc2V0RGVzYygnT3ZlcndyaXRlIE1hcmtkb3duIGZpbGUgaWYgaXQgYWxyZWFkeSBleGlzdHMnKVxuICAgICAgICAgICAgLmFkZFRvZ2dsZSgodG9nZ2xlKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gdG9nZ2xlLmlucHV0RWwuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcImJvb2xlYW5cIik7XG4gICAgICAgICAgICAgICAgdG9nZ2xlLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnBkZk92ZXJ3cml0ZSlcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MucGRmT3ZlcndyaXRlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnTGltaXQgZmlsZSBudW1iZXInKVxuICAgICAgICAgICAgLnNldERlc2MoJ0VudGVyIHRoZSBudW1iZXIgb2YgZmlsZXMgdG8gbGltaXQgUERGIGV4dHJhY3Rpb24gKHVzZSB3aGVuIFxcJ1BERiBPdmVyd3JpdGVcXCcgaXMgZmFsc2UpLiBcXCcwXFwnIG1lYW5zIG5vIGxpbWl0LicpXG4gICAgICAgICAgICAuYWRkVGV4dCgodGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgIHRleHQuaW5wdXRFbC5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwibnVtYmVyXCIpO1xuICAgICAgICAgICAgICAgIHRleHQuc2V0UGxhY2Vob2xkZXIoJzAtMTAwJylcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnBkZkV4dHJhY3RGaWxlTnVtYmVyTGltaXQudG9TdHJpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSA6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MucGRmRXh0cmFjdEZpbGVOdW1iZXJMaW1pdCA9IE1hdGgubWluKE1hdGgubWF4KHBhcnNlSW50KHZhbHVlKSwgMCksIDEwMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ0xpbWl0IGZpbGUgc2l6ZScpXG4gICAgICAgICAgICAuc2V0RGVzYygnRW50ZXIgdGhlIG1heGltdW0gZmlsZSBzaXplIChpbiBLQikgdG8gcHJvY2VzcyAoMCBtZWFucyBhbnkgc2l6ZSkuJylcbiAgICAgICAgICAgIC5hZGRUZXh0KCh0ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgdGV4dC5pbnB1dEVsLnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJudW1iZXJcIik7XG4gICAgICAgICAgICAgICAgdGV4dC5zZXRQbGFjZWhvbGRlcignMC0xMDAwMDAnKVxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MucGRmRXh0cmFjdEZpbGVTaXplTGltaXQudG9TdHJpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSA6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MucGRmRXh0cmFjdEZpbGVTaXplTGltaXQgPSBNYXRoLm1pbihNYXRoLm1heChwYXJzZUludCh2YWx1ZSksIDApLCAxMDAwMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ0NodW5rIGZpbGUgaWYgc2l6ZSBleGNlZWRzIGxpbWl0JylcbiAgICAgICAgICAgIC5zZXREZXNjKCdDaHVua3MsIG9yIGJyZWFrcyBkb3duIHRoZSByZXN1bHRpbmcgZmlsZSBpZiBpdCBleGNlZWRzICpMaW1pdCBmaWxlIHNpemUqLicpXG4gICAgICAgICAgICAuYWRkVG9nZ2xlKCh0b2dnbGUpID0+IHtcbiAgICAgICAgICAgICAgICAvLyB0b2dnbGUuaW5wdXRFbC5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwiYm9vbGVhblwiKTtcbiAgICAgICAgICAgICAgICB0b2dnbGUuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MucGRmRXh0cmFjdENodW5rSWZGaWxlRXhjZWVkc0xpbWl0KVxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5wZGZFeHRyYWN0Q2h1bmtJZkZpbGVFeGNlZWRzTGltaXQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMycsIHsgdGV4dDogJ0Jvb2ttYXJrIEV4dHJhY3Rpb24gU2V0dGluZ3MnIH0pO1xuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdCb29rbWFyayBmaWxlcycpXG4gICAgICAgICAgICAuc2V0RGVzYygnV2hlcmUgdG8gZmluZCBCb29rbWFyayBmaWxlcycpXG4gICAgICAgICAgICAuYWRkVGV4dCgodGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgIHRleHQuc2V0UGxhY2Vob2xkZXIoJ0Jvb2ttYXJrcy8nKVxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuYm9va21hcmtQYXRoLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmJvb2ttYXJrUGF0aCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ092ZXJ3cml0ZScpXG4gICAgICAgICAgICAuc2V0RGVzYygnT3ZlcndyaXRlIE1hcmtkb3duIGZpbGUgaWYgaXQgYWxyZWFkeSBleGlzdHMnKVxuICAgICAgICAgICAgLmFkZFRvZ2dsZSgodG9nZ2xlKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gdG9nZ2xlLmlucHV0RWwuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcImJvb2xlYW5cIik7XG4gICAgICAgICAgICAgICAgdG9nZ2xlLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmJvb2ttYXJrT3ZlcndyaXRlKVxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5ib29rbWFya092ZXJ3cml0ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgY29udGFpbmVyRWwuY3JlYXRlRWwoJ2gzJywgeyB0ZXh0OiAnVG9waWMgTGlua2luZyBTZXR0aW5ncycgfSk7XG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoNCcsIHsgdGV4dDogJ0dlbmVyYWwgUGFyYW1ldGVycycgfSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnTnVtYmVyIG9mIHRvcGljcycpXG4gICAgICAgICAgICAuc2V0RGVzYygnRW50ZXIgdGhlIG51bWJlciBvZiB0b3BpY3MgdG8gZ2VuZXJhdGUuJylcbiAgICAgICAgICAgIC5hZGRUZXh0KCh0ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgdGV4dC5pbnB1dEVsLnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJudW1iZXJcIik7XG4gICAgICAgICAgICAgICAgdGV4dC5zZXRQbGFjZWhvbGRlcignMS0xMCcpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5udW1Ub3BpY3MudG9TdHJpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MubnVtVG9waWNzID0gTWF0aC5taW4oTWF0aC5tYXgocGFyc2VJbnQodmFsdWUpLCAxKSwgMTApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ051bWJlciBvZiB3b3JkcycpXG4gICAgICAgICAgICAuc2V0RGVzYygnRW50ZXIgdGhlIG51bWJlciBvZiB3b3JkcyBwZXIgdG9waWMgdG8gY2FwdHVyZS4nKVxuICAgICAgICAgICAgLmFkZFRleHQoKHRleHQpID0+IHtcbiAgICAgICAgICAgICAgICB0ZXh0LmlucHV0RWwuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcIm51bWJlclwiKTtcbiAgICAgICAgICAgICAgICB0ZXh0LnNldFBsYWNlaG9sZGVyKCcxLTIwJylcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLm51bVdvcmRzLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLm51bVdvcmRzID0gTWF0aC5taW4oTWF0aC5tYXgocGFyc2VJbnQodmFsdWUpLCAxKSwgMjApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ1N0ZW1taW5nJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdTZWxlY3Qgd2hldGhlciB0b2tlbnMgc2hvdWxkIGJlIHN0ZW1tZWQgYmVmb3JlIGFuYWx5c2lzLicpXG4gICAgICAgICAgICAuYWRkVG9nZ2xlKCh0b2dnbGUpID0+IHtcbiAgICAgICAgICAgICAgICB0b2dnbGUuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3Muc3RlbW1pbmcpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnN0ZW1taW5nID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnVG9waWMgdGhyZXNob2xkJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdFbnRlciB0aGUgdGhyZXNob2xkIChiZXR3ZWVuIDAgYW5kIDEpIGZvciBhIGRvY3VtZW50IHRvIGJlIHJlbGV2YW50IHRvIGEgdG9waWMnKVxuICAgICAgICAgICAgLmFkZFRleHQoKHRleHQpID0+IHtcbiAgICAgICAgICAgICAgICB0ZXh0LmlucHV0RWwuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcIm51bWJlclwiKTtcbiAgICAgICAgICAgICAgICB0ZXh0LnNldFBsYWNlaG9sZGVyKCcwLjAtMS4wJylcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnRvcGljVGhyZXNob2xkLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnRvcGljVGhyZXNob2xkID0gTWF0aC5taW4oTWF0aC5tYXgocGFyc2VGbG9hdCh2YWx1ZSksIDApLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoNCcsIHsgdGV4dDogJ0NvbmRpdGlvbnMnIH0pO1xuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdUb3BjIGV4dHJhY3Rpb24gZmlsZSBtYXRjaCcpXG4gICAgICAgICAgICAuc2V0RGVzYygnRW50ZXIgYSBwYXR0ZXJuIHRvIG1hdGNoIE1hcmtkb3duIGZpbGVzIGZvciB0b3BpYyBleHRyYWN0aW9uLicpXG4gICAgICAgICAgICAuYWRkVGV4dCgodGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgIHRleHQuc2V0UGxhY2Vob2xkZXIoJ0dlbmVyYXRlZC8nKVxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MudG9waWNQYXRoUGF0dGVybi50b1N0cmluZygpKVxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy50b3BpY1BhdGhQYXR0ZXJuID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnVG9wYyBleHRyYWN0aW9uIHNlYXJjaCBtYXRjaCcpXG4gICAgICAgICAgICAuc2V0RGVzYygnRW50ZXIgYSBzZWFyY2ggZXhwcmVzc2lvbiB0aGF0IGZpbGVzIG11c3QgY29udGFpbiB0byBiZSBpbmNsdWRlZCBpbiB0b3BpYyBleHRyYWN0aW9uLicpXG4gICAgICAgICAgICAuYWRkVGV4dCgodGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgIHRleHQuc2V0UGxhY2Vob2xkZXIoJycpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy50b3BpY1NlYXJjaFBhdHRlcm4udG9TdHJpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MudG9waWNTZWFyY2hQYXR0ZXJuID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnVG9wYyBleHRyYWN0aW9uIHRhZyBtYXRjaCcpXG4gICAgICAgICAgICAuc2V0RGVzYygnRW50ZXIgYSBzZXJpZXMgb2YgdGFncyAoaW4gdGhlIGZvcm1hdCBcIiNmYXNoaW9uICNwaG90b2dyYXBoeVwiKSB3aGljaCBtdXN0IGJlIGluY2x1ZGVkIGF0IGxlYXN0IG9uY2UgaW4gbWF0Y2hpbmcgZmlsZXMuJylcbiAgICAgICAgICAgIC5hZGRUZXh0KCh0ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgdGV4dC5zZXRQbGFjZWhvbGRlcignJylcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnRvcGljVGFnUGF0dGVybi50b1N0cmluZygpKVxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy50b3BpY1RhZ1BhdHRlcm4gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoNCcsIHsgdGV4dDogJ1NvdXJjZSBUZXh0IEZpbHRlcmluZycgfSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnRml4ZWQgbnVtYmVyIG9mIHdvcmRzJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdFbnRlciB0aGUgbnVtYmVyIG9mIHdvcmRzIHRvIGV4dHJhY3QgZnJvbSB0aGUgdGV4dC4gT3ZlcnJpZGVzIFxcJ1BlcmNlbnRhZ2Ugb2YgVG90YWwgVGV4dFxcJyBiZWxvdy4nKVxuICAgICAgICAgICAgLmFkZFRleHQoKHRleHQpID0+IHtcbiAgICAgICAgICAgICAgICB0ZXh0LmlucHV0RWwuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcIm51bWJlclwiKTtcbiAgICAgICAgICAgICAgICB0ZXh0LnNldFBsYWNlaG9sZGVyKCcwLTUwMDAnKVxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuZml4ZWRXb3JkTGVuZ3RoLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmZpeGVkV29yZExlbmd0aCA9IE1hdGgubWluKE1hdGgubWF4KHBhcnNlSW50KHZhbHVlKSwgMCksIDUwMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ1BlcmNlbnRhZ2Ugb2YgdG90YWwgdGV4dCcpXG4gICAgICAgICAgICAuc2V0RGVzYygnRW50ZXIgdGhlIHBlcmNlbnRhZ2Ugb2YgdGhlIHRvdGFsIHRleHQgdG8gc2Nhbi4gJylcbiAgICAgICAgICAgIC5hZGRUZXh0KCh0ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgdGV4dC5pbnB1dEVsLnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJudW1iZXJcIik7XG4gICAgICAgICAgICAgICAgdGV4dC5zZXRQbGFjZWhvbGRlcignMS0xMDAnKVxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MucGVyY2VudGFnZVRleHRUb1NjYW4udG9TdHJpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MucGVyY2VudGFnZVRleHRUb1NjYW4gPSBNYXRoLm1pbihNYXRoLm1heChwYXJzZUludCh2YWx1ZSksIDEpLCAxMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ1JhbmRvbWlzZSB0ZXh0JylcbiAgICAgICAgICAgIC5zZXREZXNjKCdTZWxlY3Qgd2hldGhlciB0aGUgdGV4dCBzZWxlY3Rpb24gc2hvdWxkIGJlIHJhbmRvbWlzZWQgKFwiZmFsc2VcIiBtZWFucyB0aGUgdGV4dCBpcyBzY2FubmVkIGZyb20gdGhlIGJlZ2lubmluZykuJylcbiAgICAgICAgICAgIC5hZGRUb2dnbGUoKHRvZ2dsZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRvZ2dsZS5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy53b3JkU2VsZWN0aW9uUmFuZG9tKVxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy53b3JkU2VsZWN0aW9uUmFuZG9tID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBjb250YWluZXJFbC5jcmVhdGVFbCgnaDQnLCB7IHRleHQ6ICdUb3BpYyBGb2xkZXIgTmFtaW5nJyB9KTtcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnVG9waWMgZm9sZGVyIHBhdHRlcm4nKVxuICAgICAgICAgICAgLnNldERlc2MoJ1NlbGVjdCB3aGV0aGVyIHRoZSB0b3BpYyBmb2xkZXIgc2hvdWxkIGluY2x1ZGUgdGhlIE1hcmtkb3duIHNlYXJjaCBwYXR0ZXJuLicpXG4gICAgICAgICAgICAuYWRkVG9nZ2xlKCh0b2dnbGUpID0+IHtcbiAgICAgICAgICAgICAgICB0b2dnbGUuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MudG9waWNJbmNsdWRlUGF0dGVybilcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MudG9waWNJbmNsdWRlUGF0dGVybiA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ1RvcGljIGZvbGRlciB0aW1lc3RhbXAnKVxuICAgICAgICAgICAgLnNldERlc2MoJ1NlbGVjdCB3aGV0aGVyIHRoZSB0b3BpYyBmb2xkZXIgc2hvdWxkIGhhdmUgYSB0aW1lc3RhbXAgaW5jbHVkZWQgKG5vdGUgdGhpcyBjYW4gbGVhZCB0byBhIGxhcmdlIG51bWJlciBvZiBcIlRvcGljLVlZWVlNTVNTaGhtbXNzXCIgZm9sZGVycykuJylcbiAgICAgICAgICAgIC5hZGRUb2dnbGUoKHRvZ2dsZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRvZ2dsZS5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy50b3BpY0luY2x1ZGVUaW1lc3RhbXApXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnRvcGljSW5jbHVkZVRpbWVzdGFtcCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgY29udGFpbmVyRWwuY3JlYXRlRWwoJ2g0JywgeyB0ZXh0OiAnTERBIChMYXRlbnQgRGlyaWNoZXQgQWxsb2NhdGlvbikgUGFyYW1ldGVycycgfSk7XG4gICAgICAgIC8vIEluY2x1ZGUgdGhpczogaHR0cHM6Ly9naXRodWIuY29tL3N0ZGxpYi1qcy9ubHAtbGRhXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ0xEQSBpdGVyYXRpb25zJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdFbnRlciB0aGUgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gZml0IHRoZSBMREEgbW9kZWwnKVxuICAgICAgICAgICAgLmFkZFRleHQoKHRleHQpID0+IHtcbiAgICAgICAgICAgICAgICB0ZXh0LmlucHV0RWwuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcIm51bWJlclwiKTtcbiAgICAgICAgICAgICAgICB0ZXh0LnNldFBsYWNlaG9sZGVyKCcxMDAtNTAwMCcpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5sZGFJdGVyYXRpb25zLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmxkYUl0ZXJhdGlvbnMgPSBNYXRoLm1pbihNYXRoLm1heChwYXJzZUludCh2YWx1ZSksIDEwMCksIDUwMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ0xEQSBidXJuIGluJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdFbnRlciB0aGUgbnVtYmVyIG9mIGVzdGltYXRlcyB0byBkaXNjYXJkIGF0IHRoZSBmaXJzdCBpdGVyYXRpb24nKVxuICAgICAgICAgICAgLmFkZFRleHQoKHRleHQpID0+IHtcbiAgICAgICAgICAgICAgICB0ZXh0LmlucHV0RWwuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcIm51bWJlclwiKTtcbiAgICAgICAgICAgICAgICB0ZXh0LnNldFBsYWNlaG9sZGVyKCcxMC01MDAnKVxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MubGRhQnVybkluLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmxkYUJ1cm5JbiA9IE1hdGgubWluKE1hdGgubWF4KHBhcnNlSW50KHZhbHVlKSwgMTApLCA1MDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ0xEQSB0aGluJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdFbnRlciB0aGUgbnVtYmVyIG9mIGVzdGltYXRlcyB0byBkaXNjYXJkIGF0IGV2ZXJ5IG90aGVyIGl0ZXJhdGlvbicpXG4gICAgICAgICAgICAuYWRkVGV4dCgodGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgIHRleHQuaW5wdXRFbC5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwibnVtYmVyXCIpO1xuICAgICAgICAgICAgICAgIHRleHQuc2V0UGxhY2Vob2xkZXIoJzEtMTAwJylcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmxkYVRoaW4udG9TdHJpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MubGRhVGhpbiA9IE1hdGgubWluKE1hdGgubWF4KHBhcnNlSW50KHZhbHVlKSwgMSksIDEwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG59IiwgImltcG9ydCB7IFxuICAgIFZhdWx0LCBcbiAgICBURmlsZSwgXG4gICAgbm9ybWFsaXplUGF0aCxcbiAgICBsb2FkUGRmSnMgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBUb3BpY0xpbmtpbmdTZXR0aW5ncyB9IGZyb20gJy4vc2V0dGluZ3MnO1xuXG5cbmV4cG9ydCBjbGFzcyBQREZDb250ZW50RXh0cmFjdG9yIHtcbiAgICBwZGZqczogYW55O1xuICAgIGdlbmVyYXRlZFBhdGg6IHN0cmluZztcbiAgICBwZGZQYXRoOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB0ZXh0IGZyb20gYSBQREYgZmlsZS5cbiAgICAgKi9cbiAgICBnZXRDb250ZW50ID0gYXN5bmMgKHZhdWx0OiBWYXVsdCwgZmlsZSA6IFRGaWxlLCBjb3VudGVyIDogbnVtYmVyKSA9PiB7XG5cbiAgICAgICAgY29uc3QgcGFnZXMgOiBhbnlbXSA9IFtdO1xuICAgICAgICB0cnkge1xuXG4gICAgICAgICAgICBjb25zdCBidWZmZXIgPSBhd2FpdCB2YXVsdC5yZWFkQmluYXJ5KGZpbGUpO1xuICAgICAgICAgICAgY29uc3QgcGRmID0gYXdhaXQgdGhpcy5wZGZqcy5nZXREb2N1bWVudChidWZmZXIpLnByb21pc2U7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgTG9hZGluZyBmaWxlIG51bSAke2NvdW50ZXJ9IGF0ICR7ZmlsZS5iYXNlbmFtZX0sIHdpdGg6ICR7cGRmLm51bVBhZ2VzfSBwYWdlcyBhbmQgc2l6ZTogJHtmaWxlLnN0YXQuc2l6ZSAvIDEwMDB9S0IuYCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBkZi5udW1QYWdlczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFnZSA9IGF3YWl0IHBkZi5nZXRQYWdlKGkgKyAxKTtcbiAgICAgICAgICAgICAgICAvLyBjb25zdCB0ZXh0ID0gYXdhaXQgcGFnZS5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHRDb250ZW50ID0gYXdhaXQgcGFnZS5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wZXJhdG9ycyA9IGF3YWl0IHBhZ2UuZ2V0T3BlcmF0b3JMaXN0KCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqcyA9IHBhZ2UuY29tbW9uT2Jqcy5fb2JqcztcbiAgICBcbiAgICAgICAgICAgICAgICBwYWdlcy5wdXNoKCB7IHRleHRDb250ZW50OiB0ZXh0Q29udGVudCwgY29tbW9uT2Jqczogb2JqcyB9ICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYEVycm9yICR7ZXJyfSBsb2FkaW5nICR7ZmlsZS5wYXRofS5gKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYWdlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHBhcnRzIG9mIHRoZSBwYXRoIGJldHdlZW4gYW4gb2Zmc2V0IGFuZCB0aGUgZmlsZSBuYW1lLlxuICAgICAqIChlLmcuIFBERnMvcGF0aC90by9maWxlLnBkZiAtPiBwYXRoL3RvLylcbiAgICAgKiBAcGFyYW0gZmlsZSBcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IFxuICAgICAqIEByZXR1cm5zIFxuICAgICAqL1xuICAgIHN1YlBhdGhGYWN0b3J5ID0gKGZpbGUgOiBURmlsZSwgb2Zmc2V0IDogbnVtYmVyKSA9PiB7XG4gICAgICAgIGlmIChmaWxlLnBhdGgubGVuZ3RoID4gb2Zmc2V0ICYmIGZpbGUucGF0aC5sYXN0SW5kZXhPZignLycpID4gLTEpXG4gICAgICAgICAgICByZXR1cm4gZmlsZS5wYXRoLnN1YnN0cmluZygwLCBmaWxlLnBhdGgubGFzdEluZGV4T2YoJy8nKSArIDEpLnN1YnN0cmluZyhvZmZzZXQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE1ha2VzIGEgc2V0IG9mIGZvbGRlcnMgdW5kZXIgdGhlICdHZW5lcmF0ZWQvJyBmb2xkZXIsIGJhc2VkIG9uIHRoZSBmaWxlIG5hbWUuXG4gICAgICogQHBhcmFtIGZpbGVcbiAgICAgKi9cbiAgICBtYWtlU3ViRm9sZGVycyA9ICh2YXVsdDogVmF1bHQsIGZpbGVzIDogQXJyYXk8VEZpbGU+KSA9PiB7XG4gICAgICAgIGZpbGVzLm1hcChhc3luYyAoZmlsZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3ViUGF0aCA9IHRoaXMuc3ViUGF0aEZhY3RvcnkoZmlsZSwgdGhpcy5wZGZQYXRoLmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoc3ViUGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZm9sZGVyTG9jID0gbm9ybWFsaXplUGF0aChgJHt0aGlzLmdlbmVyYXRlZFBhdGh9JHtzdWJQYXRofWApO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB2YXVsdC5jcmVhdGVGb2xkZXIoZm9sZGVyTG9jKTtcbiAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHsgLy8gSWdub3JlIGVycm9ycyBoZXJlIC0gbm8gd2F5IG9mIHRlc3RpbmcgZm9yIGV4aXN0aW5nIGZpbGVzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgXG4gICAgLyoqXG4gICAgICogVGFrZW4gKGFuZCBpbnZlcnRlZCkgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83MDMzNjM5L3NwbGl0LWxhcmdlLXN0cmluZy1pbi1uLXNpemUtY2h1bmtzLWluLWphdmFzY3JpcHQvMjkyMDI3NjAjMjkyMDI3NjBcbiAgICAgKiBAcGFyYW0gc3RyXG4gICAgICogQHBhcmFtIHNpemUgXG4gICAgICogQHJldHVybnMgXG4gICAgICovXG4gICAgY2h1bmtTdWJzdHJpbmcgPSAoc3RyIDogc3RyaW5nLCBudW0gOiBudW1iZXIpID0+IHtcbiAgICAgICAgY29uc3Qgc2l6ZUNodW5rcyA9IE1hdGguY2VpbChzdHIubGVuZ3RoIC8gbnVtKTtcbiAgICAgICAgY29uc3QgY2h1bmtzID0gbmV3IEFycmF5KG51bSk7XG4gICAgICAgIFxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbyA9IDA7IGkgPCBudW07ICsraSwgbyArPSBzaXplQ2h1bmtzKSB7XG4gICAgICAgICAgICBjaHVua3NbaV0gPSBzdHIuc3Vic3RyaW5nKG8sIG8rc2l6ZUNodW5rcyk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBjaHVua3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvY2Vzc2VzcyBhIHNpbmdsZSBQREYgZmlsZSwgYnkgcGFnZSBhbmQgaXRlbSwgYW5kIGV4dHJhY3RzIE1hcmtkb3duIHRleHQgYmFzZWQgb24gYSBzZXJpZXMgb2YgYmFzaWMgaGV1cmlzdGljcy5cbiAgICAgKiBAcGFyYW0gZmlsZSBcbiAgICAgKiBAcGFyYW0gZmlsZUNvdW50ZXIgXG4gICAgICovXG4gICAgcHJvY2Vzc1BERiA9IGFzeW5jICh2YXVsdDogVmF1bHQsIHNldHRpbmdzOiBUb3BpY0xpbmtpbmdTZXR0aW5ncywgZmlsZSA6IFRGaWxlLCBmaWxlQ291bnRlciA6IG51bWJlcikgPT4ge1xuICAgICAgICBjb25zdCBwYWdlczogQXJyYXk8YW55PiA9IGF3YWl0IHRoaXMuZ2V0Q29udGVudCh2YXVsdCwgZmlsZSwgZmlsZUNvdW50ZXIpO1xuXG4gICAgICAgIGNvbnN0IHN1YlBhdGggPSB0aGlzLnN1YlBhdGhGYWN0b3J5KGZpbGUsIHRoaXMucGRmUGF0aC5sZW5ndGgpO1xuICAgICAgICBsZXQgbWluSCA9IC0xLCBtYXhIID0gLTEsIHRvdGFsSCA9IDAsIGNvdW50ZXJIID0gMCwgbWVhbkggPSAwO1xuICAgICAgICBwYWdlcy5mb3JFYWNoKCAocGFnZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGV4dENvbnRlbnQgPSBwYWdlLnRleHRDb250ZW50O1xuICAgICAgICAgICAgY29uc3QgY29tbW9uT2JqYSA9IHBhZ2UuY29tbW9uT2JqcztcbiAgICAgICAgICAgIHRleHRDb250ZW50Lml0ZW1zLmZvckVhY2goKGl0ZW06YW55KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzdHIsIGhlaWdodCB9ID0gaXRlbTtcbiAgICAgICAgICAgICAgICBpZiAoc3RyLnRyaW0oKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoZWlnaHQgPiBtYXhIKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4SCA9IGhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhlaWdodCA8IG1pbkggfHwgbWluSCA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbkggPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHRvdGFsSCArPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJIKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lYW5IID0gdG90YWxIIC8gY291bnRlckg7XG4gICAgICAgIGNvbnN0IG1hcmtkb3duU3RyaW5ncyA6IHN0cmluZ1tdID0gW107XG4gICAgICAgIGxldCBjb3VudGVyID0gMDtcbiAgICAgICAgbGV0IHN0ckwgPSAnJywgd2lkdGhMID0gMCwgaGVpZ2h0TCA9IDAsIHRyYW5zZm9ybUwgOiBzdHJpbmdbXSA9IFtdLCBmb250TmFtZUwgPSAnJywgaGFzRU9MTCA9IGZhbHNlO1xuICAgICAgICBsZXQgbGVmdE1hcmdpbkwgPSAwO1xuICAgICAgICBsZXQgeUNvb3JkTCA9IDAsIHlDb29yZExMID0gMDtcbiAgICAgICAgbGV0IHN0ckxMID0gJycsIHdpZHRoTEwgPSAwLCBoZWlnaHRMTCA9IDAsIHRyYW5zZm9ybUxMIDogc3RyaW5nW10gPSBbXSwgZm9udE5hbWVMTCA9ICcnLCBoYXNFT0xMTCA9IGZhbHNlO1xuICAgICAgICBsZXQgcGFnZUNvdW50ZXIgPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcGFnZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBhZ2UgPSBwYWdlc1tqXTtcbiAgICAgICAgICAgIGNvbnN0IHRleHRDb250ZW50ID0gcGFnZS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgIGNvbnN0IGNvbW1vbk9ianMgPSBwYWdlLmNvbW1vbk9ianM7XG5cbiAgICAgICAgICAgIGxldCBpbkNvZGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBuZXdMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBibG9ja3F1b3RlID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIE1ha2UgdGhpcyBhIHBhcmFtZXRlciBwZXJoYXBzXG4gICAgICAgICAgICBjb25zdCB0cmVhdEVPTGFzTmV3TGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgXG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dENvbnRlbnQuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gdGV4dENvbnRlbnQuaXRlbXNbaV07XG4gICAgICAgICAgICAgICAgbGV0IG1hcmtkb3duVGV4dCA9ICcnO1xuICAgICAgICAgICAgICAgIGxldCB7IHN0ciB9ID0gaXRlbTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRpciwgd2lkdGgsIGhlaWdodCwgdHJhbnNmb3JtLCBmb250TmFtZSwgaGFzRU9MIH0gPSBpdGVtO1xuICAgICAgICAgICAgICAgIGxldCBsZWZ0TWFyZ2luID0gcGFyc2VGbG9hdCh0cmFuc2Zvcm1bNF0pO1xuICAgICAgICAgICAgICAgIGxldCB5Q29vcmQgPSBwYXJzZUZsb2F0KHRyYW5zZm9ybVs1XSk7XG4gICAgICAgICAgICAgICAgbGV0IGl0YWxpY2lzZWQgPSBmYWxzZSwgYm9sZGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29uc3QgZm9udCA9IGNvbW1vbk9ianNbZm9udE5hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChmb250KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvbnREYXRhTmFtZSA9IGZvbnQuZGF0YS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBpdGFsaWNpc2VkID0gZm9udERhdGFOYW1lLmluZGV4T2YoJ0l0YWxpYycpID4gLTE7XG4gICAgICAgICAgICAgICAgICAgIGJvbGRlZCA9IGZvbnREYXRhTmFtZS5pbmRleE9mKCdCb2xkJykgPiAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbGVhZGluZ1NwYWNlID0gc3RyLnN0YXJ0c1dpdGgoJyAnKSA/ICcgJyA6ICcnO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYWlsaW5nU3BhY2UgPSBzdHIuZW5kc1dpdGgoJyAnKSA/ICcgJyA6ICcnO1xuICAgICAgICAgICAgICAgIGlmIChpdGFsaWNpc2VkICYmIHN0ci50cmltKCkubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gYCoke3N0ci50cmltKCl9KiR7dHJhaWxpbmdTcGFjZX1gO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJvbGRlZCAmJiBzdHIudHJpbSgpLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgICAgIHN0ciA9IGAqKiR7c3RyLnRyaW0oKX0qKiR7dHJhaWxpbmdTcGFjZX1gO1xuXG4gICAgICAgICAgICAgICAgbGV0IHlEaWZmID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgeURpZmYyID0gMDtcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNmb3JtTC5sZW5ndGggPiAwKSBcbiAgICAgICAgICAgICAgICAgICAgeURpZmYgPSB5Q29vcmRMIC0geUNvb3JkO1xuICAgICAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1MTC5sZW5ndGggPiAwKSBcbiAgICAgICAgICAgICAgICAgICAgeURpZmYyID0geUNvb3JkTEwgLSB5Q29vcmQ7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGEgY2hhbmdlIGluIGhlaWdodCwgYSBuZXcgbGluZSBhbmQgYW4gaW5kZW50YXRpb24sIHRyZWF0IGFzIGEgYmxvY2txdW90ZVxuICAgICAgICAgICAgICAgIGlmIChoZWlnaHQgPiAwICYmIGhlaWdodCA8IG1lYW5IICYmIGkgPiAwICYmIGxlZnRNYXJnaW4gPiBsZWZ0TWFyZ2luTCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaWZmSCA9IGhlaWdodCAvIG1lYW5IIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0VPTEwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaWZmSCA8IC0wLjIgJiYgIWJsb2NrcXVvdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3F1b3RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrZG93blRleHQgKz0gYFxcblxcbj4gYDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBUcmVhdCBhcyBhIGZvb3Rub3RlIHN1YnNjcmlwdCwgaWYgdGhpcyBpcyBub3QgdGhlIGZpcnN0IGxpbmUgKGluIHdoaWNoIGNhc2UgaXQncyBsaWtlbHkgYSBjb250aW51YXRpb24pXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFibG9ja3F1b3RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgPSBgJHtsZWFkaW5nU3BhY2V9WyR7c3RyLnRyaW0oKX1dJHt0cmFpbGluZ1NwYWNlfWA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYmxvY2txdW90ZSAmJiBzdHIudHJpbSgpLmxlbmd0aCA+IDAgJiYgc3RyTC50cmltKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrcXVvdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgbWFya2Rvd25UZXh0ICs9IGBcXG5cXG5gO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFJ1bGVzIGZvciBoYW5kbGluZyAnY29kZSctbGlrZSBzdHJpbmdzLiBUaGUgbWFpbiBwdXJwb3NlIGhlcmUgaXMgdG8gZXNjYXBlIGxpbmstbGlrZSBzeW50YXggKCdbWycsICddXScpXG4gICAgICAgICAgICAgICAgaWYgKChzdHIuaW5kZXhPZignLy89PicpID09IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgc3RyLmluZGV4T2YoJz0+JykgPT0gMCB8fFxuICAgICAgICAgICAgICAgICAgICBzdHIuaW5kZXhPZignPj4nKSA9PSAwKSAmJiAhaW5Db2RlICYmIG5ld0xpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFya2Rvd25UZXh0ICs9ICdgJyArIHN0cjtcbiAgICAgICAgICAgICAgICAgICAgaW5Db2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbmV3TGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBOb24tbmV3bGluZSBjb25kaXRpb25zXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RyTC50cmltKCkgIT0gJycgJiYgaGFzRU9MTCAmJiBoZWlnaHRMID09IGhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbGFzdCBjaGFyYWN0ZXIgd2FzIGEgaHlwaGVuLCByZW1vdmUgaXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0ckwuZW5kc1dpdGgoJy0nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlcyBoeXBoZW5zIC0gdGhpcyBpcyBub3QgdXN1YWxseSB0aGUgcmlnaHQgYmVoYXZpb3VyIHRob3VnaFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFya2Rvd25TdHJpbmdzW2NvdW50ZXJdID0gc3RyTC5zdWJzdHJpbmcoMCwgc3RyTC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIGFzc3VtZSBhIG5ldyBsaW5lXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFibG9ja3F1b3RlICYmIE1hdGguZmxvb3Iod2lkdGhMKSAhPSBNYXRoLmZsb29yKHdpZHRoKSAmJiBcbiAgICAgICAgICAgICAgICAgICAgICAgICgodHJlYXRFT0xhc05ld0xpbmUgJiYgaGFzRU9MKSB8fCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ckwuc3Vic3RyaW5nKHN0ckwubGVuZ3RoIC0gMSkubWF0Y2goL1tcXHV7MjAxOX0/LjotXS91KSAhPSBudWxsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9yIHRoZSB2ZXJ5IGxhc3QgbGluZSAoaS5lLiBpbmRpY2F0ZWQgYnkgdGhlIGN1cnJlbnQgY291bnRlciBiZWluZyB0aGUgZmlyc3QgbGluZSBvZiBhIG5ldyBwYWdlKSwgZG8gbm90IGFkZCBuZXcgbGluZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9ja3F1b3RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya2Rvd25TdHJpbmdzW2NvdW50ZXIgLSAxXSA9IG1hcmtkb3duU3RyaW5nc1tjb3VudGVyIC0gMV0gKyAnXFxuJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGluZXMgPSBNYXRoLmZsb29yKHlEaWZmICAvIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmVQYWRkaW5nID0gJ1xcbicucmVwZWF0KGxpbmVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbGluZSBpcyBpbmRlbnRlZCwgYWRkIGFub3RoZXIgbGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lcyA+IDAgJiYgbGVmdE1hcmdpbiA+IGxlZnRNYXJnaW5MKSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZVBhZGRpbmcgKz0gJ1xcbic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya2Rvd25TdHJpbmdzW2NvdW50ZXIgLSAxXSA9IG1hcmtkb3duU3RyaW5nc1tjb3VudGVyIC0gMV0gKyBsaW5lUGFkZGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGluQ29kZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgZG8gbm90IGNyZWF0ZSBhIG5ldyBsaW5lLiBKdXN0IGFwcGVuZCB0aGUgdGV4dCwgd2l0aCBhIHRyYWlsaW5nIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFya2Rvd25TdHJpbmdzW2NvdW50ZXIgLSAxXSA9IHN0ckwgKyAoc3RyTC5lbmRzV2l0aChcIiBcIikgPyBcIlwiIDogXCIgXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1hcmtkb3duVGV4dCArPSBzdHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEluIHRoaXMgKGRlZmF1bHQpIGNhc2Ugd2UgYXNzdW1lIGEgbmV3IGxpbmVcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgSW4gQ2FzZSAxOiBcbiAgICAgICAgICAgICAgICAgICAgIC0gdHdvIGl0ZW1zIGJhY2sgaGFzIHRleHQgYXQgYSBjZXJ0YWluIHkgY29vcmRpbmF0ZVxuICAgICAgICAgICAgICAgICAgICAgLSBvbmUgbGluZSBiYWNrIGhhcyBhIHplcm8tbGVuZ3RoIHN0cmluZywgYW5kIGlzIGFuIEVPTCBtYXJrZXJcbiAgICAgICAgICAgICAgICAgICAgIC0gdGhpcyBsaW5lIGhhcyBhIHkgY29vcmRpbmF0ZSB0aGF0IGlzIGdyZWF0ZXIgdGhhbiB0d2ljZSB0aGUgY3VycmVudCBsaW5lIGhlaWdodCBhcGFydCBmcm9tIHRoZSBwcmV2aW91cyB0ZXh0IGNvb3JkaW5hdGVcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNFT0xMICYmIHN0ckwudHJpbSgpID09PSBcIlwiICYmIHlEaWZmMiA+IGhlaWdodCAqIDIpIHsgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gTWF0aC5mbG9vcih5RGlmZjIgIC8gaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVQYWRkaW5nID0gJ1xcbicucmVwZWF0KGxpbmVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtkb3duU3RyaW5nc1tjb3VudGVyIC0gMl0gPSBtYXJrZG93blN0cmluZ3NbY291bnRlciAtIDJdICsgKGluQ29kZSA/IFwiYFwiIDogXCJcIikgKyBsaW5lUGFkZGluZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICBJbiBDYXNlIDI6IFxuICAgICAgICAgICAgICAgICAgICAgLSB0d28gaXRlbXMgYmFjayBoYXMgdGV4dCBhdCBhIGNlcnRhaW4geSBjb29yZGluYXRlXG4gICAgICAgICAgICAgICAgICAgICAtIG9uZSBsaW5lIGJhY2sgaGFzIGEgemVyby1sZW5ndGggc3RyaW5nLCBhbmQgaXMgYW4gRU9MIG1hcmtlclxuICAgICAgICAgICAgICAgICAgICAgLSB0aGlzIGxpbmUgaGFzIGEgeSBjb29yZGluYXRlIHRoYXQgaXMgZ3JlYXRlciB0aGFuIHR3aWNlIHRoZSBjdXJyZW50IGxpbmUgaGVpZ2h0IGFwYXJ0IGZyb20gdGhlIHByZXZpb3VzIHRleHQgY29vcmRpbmF0ZVxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaGFzRU9MTCAmJiBzdHJMLnRyaW0oKSA9PT0gXCJcIiAmJiB5RGlmZiA+IGhlaWdodCkgeyAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGluZXMgPSBNYXRoLmZsb29yKHlEaWZmICAvIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5lUGFkZGluZyA9ICdcXG4nICsgJ1xcbicucmVwZWF0KGxpbmVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtkb3duU3RyaW5nc1tjb3VudGVyIC0gMV0gPSBtYXJrZG93blN0cmluZ3NbY291bnRlciAtIDFdICsgKGluQ29kZSA/IFwiYFwiIDogXCJcIikgKyBsaW5lUGFkZGluZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICBDYXNlIDM6IE5ldyBwYWdlIC0gYWRkIGEgdHJhaWxpbmcgc3BhY2UgdG8gdGhlIGxhc3QgbGluZVxuICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJrZG93blN0cmluZ3NbY291bnRlciAtIDFdID0gc3RyTCArIChzdHJMLmVuZHNXaXRoKFwiIFwiKSA/IFwiXCIgOiBcIiBcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpbkNvZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgbmV3TGluZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVHJlYXQgYXMgYSBoZWFkaW5nLCBhbmQgY2FsY3VsYXRlIHRoZSBoZWFkaW5nIHNpemUgYnkgdGhlIGhlaWdodCBvZiB0aGUgbGluZVxuICAgICAgICAgICAgICAgICAgICBsZXQgaGVhZGluZyA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaGVhZGluZ1BhZGRpbmcgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhlaWdodCA+IG1lYW5IKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkaWZmSCA9IGhlaWdodCAvIG1lYW5IIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRpbmdTaXplID0gTWF0aC5jZWlsKDAuNSAvIGRpZmZIKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoZWFkaW5nU2l6ZSA8PSA2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGluZyA9IFwiI1wiLnJlcGVhdChoZWFkaW5nU2l6ZSkgKyAnICc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGluZ1BhZGRpbmcgPSBcIlxcblwiLnJlcGVhdCg3IC0gaGVhZGluZ1NpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBtYXJrZG93blRleHQgKz0gaGVhZGluZ1BhZGRpbmc7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtkb3duVGV4dCArPSBoZWFkaW5nO1xuICAgICAgICAgICAgICAgICAgICBtYXJrZG93blRleHQgKz0gc3RyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEltcG9ydGFudCEgRXNjYXBlIGFsbCBkb3VibGUgYnJhY2tldHMsIGFuZCBkb3VibGUgc3BhY2VzIHdpdGggc2luZ2xlIHNwYWNlc1xuICAgICAgICAgICAgICAgIG1hcmtkb3duVGV4dCA9IG1hcmtkb3duVGV4dC5yZXBsYWNlQWxsKCdbWycsIGBcXFxcW1xcXFxbYCkucmVwbGFjZUFsbCgnICAnLCAnICcpO1xuICAgICAgICAgICAgICAgIGNvdW50ZXIrKztcbiAgICAgICAgICAgICAgICBtYXJrZG93blN0cmluZ3MucHVzaChtYXJrZG93blRleHQpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29weSBzZWNvbmQgbGFzdCBsaW5lXG4gICAgICAgICAgICAgICAgc3RyTEwgPSBzdHJMO1xuICAgICAgICAgICAgICAgIHdpZHRoTEwgPSB3aWR0aEw7XG4gICAgICAgICAgICAgICAgaGVpZ2h0TEwgPSBoZWlnaHRMO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybUxMID0gdHJhbnNmb3JtTDtcbiAgICAgICAgICAgICAgICBmb250TmFtZUxMID0gZm9udE5hbWVMO1xuICAgICAgICAgICAgICAgIGhhc0VPTExMID0gaGFzRU9MTDtcbiAgICAgICAgICAgICAgICB5Q29vcmRMTCA9IHlDb29yZEw7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY3VycmVudCBpdGVtIGlzIG9uIHRoZSBzYW1lIGxpbmUsIGRvbid0IHVwZGF0ZSB0aGUgbGVmdCBtYXJnaW4gdmFsdWVcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNmb3JtWzVdICE9PSB0cmFuc2Zvcm1MWzVdICYmIHN0ciAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGxlZnRNYXJnaW5MID0gbGVmdE1hcmdpbjtcblxuICAgICAgICAgICAgICAgIC8vIENvcHkgbGFzdCBsaW5lXG4gICAgICAgICAgICAgICAgc3RyTCA9IG1hcmtkb3duVGV4dDtcbiAgICAgICAgICAgICAgICB3aWR0aEwgPSB3aWR0aDtcbiAgICAgICAgICAgICAgICBoZWlnaHRMID0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybUwgPSB0cmFuc2Zvcm07XG4gICAgICAgICAgICAgICAgZm9udE5hbWVMID0gZm9udE5hbWU7XG4gICAgICAgICAgICAgICAgaGFzRU9MTCA9IGhhc0VPTDtcbiAgICAgICAgICAgICAgICB5Q29vcmRMID0geUNvb3JkO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYWdlQ291bnRlcisrO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG1hcmtkb3duQ29udGVudHMgPSBtYXJrZG93blN0cmluZ3Muam9pbignJyk7XG4gICAgICAgIG1hcmtkb3duQ29udGVudHMgPSBgU291cmNlIGZpbGU6IFtbJHtmaWxlLnBhdGh9XV1cXG5cXG4ke21hcmtkb3duQ29udGVudHN9YDtcblxuICAgICAgICBjb25zdCBmaWxlTmFtZTogc3RyaW5nID0gbm9ybWFsaXplUGF0aChgJHt0aGlzLmdlbmVyYXRlZFBhdGh9JHtzdWJQYXRofSR7ZmlsZS5iYXNlbmFtZX0ubWRgKTtcbiAgICAgICAgY29uc3QgYnl0ZUxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKG1hcmtkb3duQ29udGVudHMsICd1dGYtOCcpO1xuICAgICAgICBjb25zdCBrYiA9IE1hdGguY2VpbChieXRlTGVuZ3RoIC8gMTAyNCk7XG4gICAgICAgIGlmIChrYiA+IHNldHRpbmdzLnBkZkV4dHJhY3RGaWxlU2l6ZUxpbWl0ICYmIHNldHRpbmdzLnBkZkV4dHJhY3RGaWxlU2l6ZUxpbWl0ID4gMCAmJiBzZXR0aW5ncy5wZGZFeHRyYWN0Q2h1bmtJZkZpbGVFeGNlZWRzTGltaXQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIGNodW5rIHNpemUgYXBwcm94aW1hdGVseSBoYWxmIHRoZSBtYXhpbXVtIHNpemVcbiAgICAgICAgICAgIGNvbnN0IGNodW5rTnVtID0gTWF0aC5jZWlsKGJ5dGVMZW5ndGggLyAoc2V0dGluZ3MucGRmRXh0cmFjdEZpbGVTaXplTGltaXQgKiAxMDI0ICogMC41KSk7XG4gICAgICAgICAgICAvLyBTcGxpdCB0aGUgY29udGVudHMgaW50byBhcHByb3hpbWF0ZWx5IGVxdWFsIHNlZ21lbnRzXG4gICAgICAgICAgICBjb25zdCBzZWdtZW50cyA9IHRoaXMuY2h1bmtTdWJzdHJpbmcobWFya2Rvd25Db250ZW50cywgY2h1bmtOdW0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlZ21lbnRQYXRoID0gbm9ybWFsaXplUGF0aChgJHt0aGlzLmdlbmVyYXRlZFBhdGh9JHtzdWJQYXRofSR7ZmlsZS5iYXNlbmFtZX1fJHtpKzF9Lm1kYCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3U2VnbWVudEZpbGUgPSA8VEZpbGU+IHZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChzZWdtZW50UGF0aCk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1NlZ21lbnRGaWxlICE9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB2YXVsdC5tb2RpZnkobmV3U2VnbWVudEZpbGUsIHNlZ21lbnRzW2ldKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHZhdWx0LmNyZWF0ZShzZWdtZW50UGF0aCwgc2VnbWVudHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbmV3RmlsZSA9IDxURmlsZT4gdmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGZpbGVOYW1lKTtcbiAgICAgICAgICAgIGlmIChuZXdGaWxlICE9PSBudWxsKVxuICAgICAgICAgICAgICAgIGF3YWl0IHZhdWx0Lm1vZGlmeShuZXdGaWxlLCBtYXJrZG93bkNvbnRlbnRzKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBhd2FpdCB2YXVsdC5jcmVhdGUoZmlsZU5hbWUsIG1hcmtkb3duQ29udGVudHMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBcbiAgICBhc3luYyBleHRyYWN0KHZhdWx0OiBWYXVsdCwgc2V0dGluZ3M6IFRvcGljTGlua2luZ1NldHRpbmdzLCBzdGF0dXNCYXJJdGVtRWw6IEhUTUxFbGVtZW50KSB7XG4gICAgICAgIFxuICAgICAgICAvLyBMb2FkIFBkZkpzXG5cdFx0dGhpcy5wZGZqcyA9IGF3YWl0IGxvYWRQZGZKcygpO1xuICAgICAgICBcbiAgICAgICAgc3RhdHVzQmFySXRlbUVsLnNldFRleHQoYEV4dHJhY3RpbmcgTWFya2Rvd24gdGV4dCBmcm9tIFBERiBmaWxlcy4uLmApO1xuXG4gICAgICAgIHRoaXMuZ2VuZXJhdGVkUGF0aCA9IHNldHRpbmdzLmdlbmVyYXRlZFBhdGg7XG4gICAgICAgIHRoaXMucGRmUGF0aCA9IHNldHRpbmdzLnBkZlBhdGg7XG4gICAgICAgIGNvbnN0IGZpbGVOdW1iZXJMaW1pdCA9IHNldHRpbmdzLnBkZkV4dHJhY3RGaWxlTnVtYmVyTGltaXQ7XG4gICAgICAgIGNvbnN0IGZpbGVTaXplTGltaXQgPSBzZXR0aW5ncy5wZGZFeHRyYWN0RmlsZVNpemVMaW1pdDtcbiAgICAgICAgY29uc3QgY2h1bmtJZkZpbGVFeGNlZWRzTGltaXQgPSBzZXR0aW5ncy5wZGZFeHRyYWN0Q2h1bmtJZkZpbGVFeGNlZWRzTGltaXQ7XG4gICAgICAgIGNvbnN0IHBkZk92ZXJ3cml0ZSA9IHNldHRpbmdzLnBkZk92ZXJ3cml0ZSA9PT0gdHJ1ZTtcbiAgICAgICAgY29uc29sZS5sb2coYEZpbGUgbnVtYmVyIGxpbWl0OiAke2ZpbGVOdW1iZXJMaW1pdH1gKTtcbiAgICAgICAgY29uc29sZS5sb2coYEZpbGUgc2l6ZSBsaW1pdDogJHtmaWxlU2l6ZUxpbWl0fWApO1xuICAgICAgICBjb25zb2xlLmxvZyhgQ2h1bmsgaWYgZmlsZSBleGNlZWRzIGxpbWl0OiAke2NodW5rSWZGaWxlRXhjZWVkc0xpbWl0fWApO1xuICAgICAgICBjb25zb2xlLmxvZyhgT3ZlcndyaXRlIGV4aXNpbmcgZmlsZXM6ICR7cGRmT3ZlcndyaXRlfWApO1xuXG4gICAgICAgIC8vIE9idGFpbiBhIHNldCBvZiBQREYgZmlsZXMgLSBkb24ndCBpbmNsdWRlIHRob3NlIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gZ2VuZXJhdGVkXG4gICAgICAgIGxldCBmaWxlczogVEZpbGVbXSA9IHZhdWx0LmdldEZpbGVzKCkuZmlsdGVyKChmaWxlKSA9PiB7XG4gICAgICAgICAgICBsZXQgbWF0Y2hlcyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGZpbGUuZXh0ZW5zaW9uID09PSAncGRmJyAmJiBmaWxlLnBhdGguaW5kZXhPZih0aGlzLnBkZlBhdGgpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2h1bmtJZkZpbGVFeGNlZWRzTGltaXQgPT09IGZhbHNlICYmIGZpbGVTaXplTGltaXQgPiAwICYmIGZpbGUuc3RhdC5zaXplICogMTAyNCA+IGZpbGVTaXplTGltaXQpXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghcGRmT3ZlcndyaXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1YlBhdGggPSB0aGlzLnN1YlBhdGhGYWN0b3J5KGZpbGUsIHRoaXMucGRmUGF0aC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWRGaWxlID0gbm9ybWFsaXplUGF0aChgJHt0aGlzLmdlbmVyYXRlZFBhdGh9JHtzdWJQYXRofSR7ZmlsZS5iYXNlbmFtZX0ubWRgKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1kVmVyc2lvbiA9IHZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChtZEZpbGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWRWZXJzaW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2h1bmtJZkZpbGVFeGNlZWRzTGltaXQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAybmQgY2hlY2sgLSBmb3IgbGFyZ2UgZmlsZXMgdGhhdCBtYXkgaGF2ZSBiZWVuIGNodW5rZWQgZG93blxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1kRmlsZSA9IG5vcm1hbGl6ZVBhdGgoYCR7dGhpcy5nZW5lcmF0ZWRQYXRofSR7c3ViUGF0aH0ke2ZpbGUuYmFzZW5hbWV9XzEubWRgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZFZlcnNpb24gPSB2YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgobWRGaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWRWZXJzaW9uID09PSBudWxsKSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZmlsZU51bWJlckxpbWl0ID4gMClcbiAgICAgICAgICAgIGZpbGVzID0gZmlsZXMuc2xpY2UoMCwgZmlsZU51bWJlckxpbWl0KTtcblxuXG4gICAgICAgIHRoaXMubWFrZVN1YkZvbGRlcnModmF1bHQsIGZpbGVzKTtcblxuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICBmb3IgKGxldCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnByb2Nlc3NQREYodmF1bHQsIHNldHRpbmdzLCBmaWxlLCBpbmRleCsrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXR1c0Jhckl0ZW1FbC5zZXRUZXh0KCdBbGwgZG9uZSEnKTtcblxuICAgIH1cblxufSIsICJpbXBvcnQgeyBcbiAgICBWYXVsdCwgXG4gICAgVEZpbGUsIFxuXHRyZXF1ZXN0LFxuICAgIGh0bWxUb01hcmtkb3duLFxuICAgIG5vcm1hbGl6ZVBhdGh9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IFRvcGljTGlua2luZ1NldHRpbmdzIH0gZnJvbSAnLi9zZXR0aW5ncyc7XG5cbmV4cG9ydCBjbGFzcyBCb29rbWFya0NvbnRlbnRFeHRyYWN0b3Ige1xuICAgIGdlbmVyYXRlZFBhdGg6IHN0cmluZztcbiAgICBib29rbWFya1BhdGg6IHN0cmluZztcblxuICAgIGFzeW5jIGRlbGV0ZUJvb2ttYXJrcyh2YXVsdDogVmF1bHQpIHtcbiAgICAgICAgY29uc3QgZmlsZXNUb0RlbGV0ZTogVEZpbGVbXSA9IHZhdWx0LmdldEZpbGVzKCkuXG4gICAgICAgICAgICBmaWx0ZXIoKGZpbGUgOiBURmlsZSkgPT4gZmlsZS5wYXRoLmluZGV4T2Yobm9ybWFsaXplUGF0aChgJHt0aGlzLmdlbmVyYXRlZFBhdGh9JHt0aGlzLmJvb2ttYXJrUGF0aH1gKSkgPiAtMSAmJiBmaWxlLmV4dGVuc2lvbiA9PT0gJ21kJyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsZXNUb0RlbGV0ZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGF3YWl0IHZhdWx0LmRlbGV0ZShmaWxlc1RvRGVsZXRlW2ldKTsgICAgICAgIFxuICAgIH1cblxuICAgIGFzeW5jIGV4dHJhY3QodmF1bHQ6IFZhdWx0LCBzZXR0aW5nczogVG9waWNMaW5raW5nU2V0dGluZ3MsIHN0YXR1c0Jhckl0ZW1FbDogSFRNTEVsZW1lbnQpIHtcbiAgICBcbiAgICAgICAgdGhpcy5nZW5lcmF0ZWRQYXRoID0gc2V0dGluZ3MuZ2VuZXJhdGVkUGF0aDtcbiAgICAgICAgdGhpcy5ib29rbWFya1BhdGggPSBzZXR0aW5ncy5ib29rbWFya1BhdGg7XG5cbiAgICAgICAgc3RhdHVzQmFySXRlbUVsLnNldFRleHQoJ1JldHJpZXZpbmcgd2ViIGNvbnRlbnQgYXMgbWFya2Rvd24uLi4nKTtcblxuICAgICAgICAvLyBJZiBvdmVyd3JpdGUgaXMgZW5hYmxlZCwgZGVsZXRlIGFsbCBleGlzdGluZyBtYXJrZG93biBmaWxlc1xuICAgICAgICBpZiAoc2V0dGluZ3MuYm9va21hcmtPdmVyd3JpdGUpIFxuICAgICAgICAgICAgdGhpcy5kZWxldGVCb29rbWFya3ModmF1bHQpO1xuXG4gICAgICAgIC8vIEdldCBhbGwgZmlsZXMgaW4gdGhlIHZhdWx0XG4gICAgICAgIGNvbnN0IGZpbGVzIDogVEZpbGVbXSA9IHZhdWx0LmdldE1hcmtkb3duRmlsZXMoKS5maWx0ZXIoKGZpbGUgOiBURmlsZSkgPT4gZmlsZS5wYXRoLmluZGV4T2YodGhpcy5ib29rbWFya1BhdGgpID09PSAwKTtcbiAgICAgICAgY29uc3QgZmlsZUNvbnRlbnRzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgICAgICAgICBmaWxlQ29udGVudHMucHVzaChhd2FpdCB2YXVsdC5jYWNoZWRSZWFkKGZpbGUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGNvbnRlbnRzIG9mIGZpbGVDb250ZW50cykge1xuICAgICAgICAgICAgbGV0IGxpbmtzOiBzdHJpbmdbXSA9IGNvbnRlbnRzLm1hdGNoKC9odHRwcyo6XFwvXFwvW14gKV0qL2cpO1xuICAgICAgICAgICAgaWYgKGxpbmtzICE9IG51bGwpIHtcblxuICAgICAgICAgICAgICAgIC8vIEV4dHJhY3Qgb25seSB2YWxpZCBNYXJrZG93bi1hYmxlIGxpbmtzXG4gICAgICAgICAgICAgICAgbGlua3MgPSBsaW5rcy5maWx0ZXIobGluayA9PiAhbGluay5lbmRzV2l0aCgnLnBkZicpICYmICFsaW5rLmVuZHNXaXRoKCcuanBnJykpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlua3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGluayA9IGxpbmtzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldHJpZXZlIHRoZSBjb250ZW50cyBvZiB0aGUgbGlua1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaHRtbENvbnRlbnRzID0gYXdhaXQgcmVxdWVzdCh7dXJsOiBsaW5rfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIHRpdGxlLCBhbmQgb3ZlcnJpZGUgaWYgbm90IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0aXRsZSA6IHN0cmluZyA9IGxpbms7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaHRtbENvbnRlbnRzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0aXRsZU1hdGNoID0gaHRtbENvbnRlbnRzLm1hdGNoKC88dGl0bGU+KFtePF0qKTxcXC90aXRsZT4vaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpdGxlTWF0Y2ggIT09IG51bGwgJiYgdGl0bGVNYXRjaC5sZW5ndGggPiAxICYmIHRpdGxlTWF0Y2hbMV0gIT09ICcnKSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGUgPSB0aXRsZU1hdGNoWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgSFRUUCBlcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aXRsZS5pbmRleE9mKCc0MCcpID09PSAwIHx8IHRpdGxlLmluZGV4T2YoJzUwJykgPT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgcHVuY3R1YXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlID0gdGl0bGUudHJpbSgpLnJlcGxhY2UoL1tcXHUyMDAwLVxcdTIwNkZcXHUyRTAwLVxcdTJFN0ZcXFxcJyFcIiMkJSYoKSorLC4vOjs8PT4/QFtcXF1eYHt8fX5cdTAwQjddL2csICctJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyBoeXBoZW5zXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGl0bGUuaW5kZXhPZignLScpID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlID0gdGl0bGUuc3Vic3RyaW5nKDEpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBMaW1pdCBmaWxlIG5hbWUgbGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZSA9IHRpdGxlLnN1YnN0cmluZygwLCA1MCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gTWFya2Rvd24gYW5kIGFkZCBsaW5rXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWQgPSBodG1sVG9NYXJrZG93bihodG1sQ29udGVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWQgPSBgJHtsaW5rfVxcblxcbiR7bWR9YDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBmaWxlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWxlTmFtZTogc3RyaW5nID0gbm9ybWFsaXplUGF0aChgJHt0aGlzLmdlbmVyYXRlZFBhdGh9JHt0aGlzLmJvb2ttYXJrUGF0aH0ke3RpdGxlfS5tZGApO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsZSA9IDxURmlsZT4gdmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGZpbGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWxlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmJvb2ttYXJrT3ZlcndyaXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXVsdC5tb2RpZnkoZmlsZSwgbWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXVsdC5jcmVhdGUoZmlsZU5hbWUsIG1kKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3RhdHVzQmFySXRlbUVsLnNldFRleHQoJ0FsbCBkb25lIScpO1xuICAgIH1cbn0gIiwgImltcG9ydCB7IFxuICAgIEFwcCwgXG4gICAgVEZpbGUsXG4gICAgcHJlcGFyZVNpbXBsZVNlYXJjaCxcbiAgICBnZXRBbGxUYWdzLCBcbiAgICBub3JtYWxpemVQYXRoLFxuXHRtb21lbnQgfSBmcm9tICdvYnNpZGlhbic7XG5cbi8vIEZvciBMREFcbmltcG9ydCByb3VuZG4gZnJvbSAnQHN0ZGxpYi9tYXRoLWJhc2Utc3BlY2lhbC1yb3VuZG4nO1xuaW1wb3J0IHN0b3B3b3JkcyBmcm9tICdAc3RkbGliL2RhdGFzZXRzLXN0b3B3b3Jkcy1lbic7XG5pbXBvcnQgbGRhIGZyb20gJ0BzdGRsaWIvbmxwLWxkYSc7XG5pbXBvcnQgcG9ydGVyU3RlbW1lciBmcm9tICAnQHN0ZGxpYi9ubHAtcG9ydGVyLXN0ZW1tZXInIDtcblxuLy8gRm9yIEZpbGUgbWF0Y2hpbmdcbmltcG9ydCBtaWNyb21hdGNoIGZyb20gJ21pY3JvbWF0Y2gnO1xuXG5pbXBvcnQgeyBUb3BpY0xpbmtpbmdTZXR0aW5ncyB9IGZyb20gJy4vc2V0dGluZ3MnO1xuXG5leHBvcnQgY2xhc3MgVG9waWNMaW5rZXIge1xuXG4gICAgYXN5bmMgbGluayhhcHA6IEFwcCwgc2V0dGluZ3M6IFRvcGljTGlua2luZ1NldHRpbmdzLCBzdGF0dXNCYXJJdGVtRWw6IEhUTUxFbGVtZW50KSB7XG5cbiAgICAgICAgY29uc3QgeyB2YXVsdCB9ID0gYXBwO1xuXG4gICAgICAgIGNvbnN0IHRvcGljUGF0aFBhdHRlcm4gPSBzZXR0aW5ncy50b3BpY1BhdGhQYXR0ZXJuO1xuICAgICAgICBjb25zdCB0b3BpY1NlYXJjaFBhdHRlcm4gPSBzZXR0aW5ncy50b3BpY1NlYXJjaFBhdHRlcm47XG4gICAgICAgIGNvbnN0IHRvcGljVGFnUGF0dGVybiA9IHNldHRpbmdzLnRvcGljVGFnUGF0dGVybjtcblxuICAgICAgICBjb25zb2xlLmxvZyhgTnVtYmVyIG9mIHRvcGljczogJHtzZXR0aW5ncy5udW1Ub3BpY3N9YCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBOdW1iZXIgb2Ygd29yZHM6ICR7c2V0dGluZ3MubnVtV29yZHN9YCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBUb3BpYyB0aHJlc2hvbGQ6ICR7c2V0dGluZ3MudG9waWNUaHJlc2hvbGR9YCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBQZXJjZW50YWdlIG9mIHRleHQ6ICR7c2V0dGluZ3MucGVyY2VudGFnZVRleHRUb1NjYW59YCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBUb3BpYyBmaWxlIHBhdHRlcm46ICR7dG9waWNQYXRoUGF0dGVybn1gKTtcbiAgICAgICAgY29uc29sZS5sb2coYFRvcGljIHNlYXJjaCBwYXR0ZXJuOiAke3RvcGljU2VhcmNoUGF0dGVybn1gKTtcbiAgICAgICAgY29uc29sZS5sb2coYFRvcGljIHRhZyBwYXR0ZXJuOiAke3RvcGljVGFnUGF0dGVybn1gKTtcbiAgICAgICAgY29uc29sZS5sb2coYEZpeGVkIHdvcmQgbGVuZ3RoOiAke3NldHRpbmdzLmZpeGVkV29yZExlbmd0aH1gKTtcbiAgICAgICAgY29uc29sZS5sb2coYFRleHQgcGVyY2VudGFnZTogJHtzZXR0aW5ncy5wZXJjZW50YWdlVGV4dFRvU2Nhbn1gKTtcbiAgICAgICAgY29uc29sZS5sb2coYFdvcmQgc2VsZWN0aW9uOiAke3NldHRpbmdzLndvcmRTZWxlY3Rpb25SYW5kb219YCk7XG5cbiAgICAgICAgc3RhdHVzQmFySXRlbUVsLnNldFRleHQoYEV4dHJhY3RpbmcgTWFya2Rvd24gZmlsZSBjb250ZW50cyBhdCAke3NldHRpbmdzLnBlcmNlbnRhZ2VUZXh0VG9TY2FufSUuLi5gKTtcblxuICAgICAgICBsZXQgZmlsZXM6IFRGaWxlW10gPSB2YXVsdC5nZXRNYXJrZG93bkZpbGVzKCkuZmlsdGVyKChmaWxlKSA9PiBtaWNyb21hdGNoKFtmaWxlLnBhdGhdLCBbJyonICsgdG9waWNQYXRoUGF0dGVybiArICcqJ10pLmxlbmd0aCA+IDApO1xuXG4gICAgICAgIC8vIEFkZCBzZWFyY2ggY29uZGl0aW9uIGhlcmVcbiAgICAgICAgaWYgKHRvcGljU2VhcmNoUGF0dGVybiAmJiB0b3BpY1NlYXJjaFBhdHRlcm4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gUHJlcGFyZSBxdWVyeVxuICAgICAgICAgICBjb25zdCB0b3BpY1NlYXJjaEZ1bmMgPSBwcmVwYXJlU2ltcGxlU2VhcmNoKHRvcGljU2VhcmNoUGF0dGVybik7XG5cbiAgICAgICAgICAgIC8vIFNlYXJjaCB0aHJvdWdoIGVhY2ggbWF0Y2hpbmcgZmlsZVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0aW5nRmlsZXM6IFRGaWxlW10gPSBbXTtcbiAgICAgICAgICAgIC8vIGxldCByZXN1bHRzOiBhbnlbXSA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBmaWxlc1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlQ29udGVudHMgPSBhd2FpdCB2YXVsdC5jYWNoZWRSZWFkKGZpbGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRvcGljU2VhcmNoRnVuYyhmaWxlQ29udGVudHMpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0aW5nRmlsZXMucHVzaChmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc3QgeyBzY29yZSwgbWF0Y2hlcyB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAvLyByZXN1bHRzLnB1c2goe2ZpbGU6IGZpbGUuYmFzZW5hbWUsIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbGVzID0gcmVzdWx0aW5nRmlsZXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9waWNUYWdQYXR0ZXJuICYmIHRvcGljVGFnUGF0dGVybi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBBc3N1bWUgdGFnIHBhdHRlcm4gaXMgZm9ybWF0dGVkIGxpa2U6ICcjZmFzaGlvbiAjcGhvdG9ncmFwaHknXG4gICAgICAgICAgICBjb25zdCB0b3BpY1RhZ3MgOiBzdHJpbmdbXSA9IHRvcGljVGFnUGF0dGVybi5zcGxpdCgnICcpO1xuXG4gICAgICAgICAgICAvLyBTZWFyY2ggdGhyb3VnaCBlYWNoIG1hdGNoaW5nIGZpbGVcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdGluZ0ZpbGVzOiBURmlsZVtdID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZSA9IGZpbGVzW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNtID0gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGZpbGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhZ3MgOiBzdHJpbmdbXSA9IGdldEFsbFRhZ3MoY20pO1xuICAgICAgICAgICAgICAgIGlmICh0YWdzICYmIHRhZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0YWdzLmZvckVhY2godGFnID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b3BpY1RhZ3MuaW5kZXhPZih0YWcpID49IDApIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdGluZ0ZpbGVzLnB1c2goZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbGVzID0gcmVzdWx0aW5nRmlsZXM7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHN0YXR1c0Jhckl0ZW1FbC5zZXRUZXh0KCdObyBNYXJrZG93biBmaWxlcyBmb3VuZCEnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdldCBQREYgbmFtZXMgZm9yIGxhdGVyIG1hdGNoaW5nXG4gICAgICAgIGNvbnN0IHBkZk5hbWVzID0gdmF1bHQuZ2V0RmlsZXMoKS5maWx0ZXIoZmlsZSA9PiB7IHJldHVybiBmaWxlLmV4dGVuc2lvbiA9PT0gJ3BkZicgfSkubWFwKGZpbGUgPT4gZmlsZS5iYXNlbmFtZSk7XG4gICAgICAgIC8vIFRPRE86IEFkZCB3ZWJsaW5rcyBoZXJlLi4uXG5cbiAgICAgICAgLy8gQWRkIHN0b3Agd29yZHNcbiAgICAgICAgY29uc3Qgd29yZHMgOiBzdHJpbmdbXSA9IHN0b3B3b3JkcygpO1xuICAgICAgICBjb25zdCB3b3JkUmVnZXhlcyA6IFJlZ0V4cFtdID0gd29yZHMubWFwKHdvcmQgPT4geyByZXR1cm4gbmV3IFJlZ0V4cCgnXFxcXGInICsgd29yZCArICdcXFxcYicsICdnaScpOyB9KTtcblxuICAgICAgICAvLyBBZGQgb3RoZXIgc3RvcCB3b3Jkc1xuICAgICAgICBjb25zdCBleHRlbmRlZFN0b3BzID0gWydcdTAwQTknLCAnbnVsbCcsICdvYmonLCAncGcnLCAnZGUnLCAnZXQnLCAnbGEnLCAnbGUnLCAnZWwnLCAncXVlJywgJ2RvbnQnLCAnZmxvdHIyJywgJ21wZycsICdpYmlkJywgJ3Bkc2VzJywgJ1x1MDBFMCcsICdlbicsICdsZXMnLCAnZGVzJywgJ3F1aScsICdkdSddO1xuICAgICAgICBleHRlbmRlZFN0b3BzLmZvckVhY2god29yZCA9PiB7IHdvcmRSZWdleGVzLnB1c2gobmV3IFJlZ0V4cCgnXFxcXGInICsgd29yZCArICdcXFxcYicsICdnaScpKSB9KTtcblxuICAgICAgICAvLyBSZXRyaWV2ZSBhbGwgZmlsZSBjb250ZW50c1xuICAgICAgICBjb25zdCBmaWxlQ29udGVudHM6IHN0cmluZ1tdID0gW107XG4gICAgICAgIGZvciAobGV0IGZpbGUgb2YgZmlsZXMpIHtcbiAgICAgICAgICAgIGZpbGVDb250ZW50cy5wdXNoKGF3YWl0IHZhdWx0LmNhY2hlZFJlYWQoZmlsZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHJvZHVjZSB3b3JkIHNlcXVlbmNlcyBmb3Igc2V0IHRleHQgYW1vdW50cywgd2l0aG91dCBzdG9wd29yZHMgb3IgcHVuY3R1YXRpb24uXG4gICAgICAgIGNvbnN0IGRvY3VtZW50czogc3RyaW5nW10gPSBmaWxlQ29udGVudHMubWFwKChkb2N1bWVudCkgPT4ge1xuXG4gICAgICAgICAgICAvLyBIYW5kbGUgZml4ZWQgbnVtYmVyIG9mIHdvcmRzXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuZml4ZWRXb3JkTGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvdGFsV29yZHMgPSBkb2N1bWVudC5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHdvcmRMZW5ndGggPSB0b3RhbFdvcmRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb25zdCBzY2FuRW5kID0gKHdvcmRMZW5ndGggPiBzZXR0aW5ncy5maXhlZFdvcmRMZW5ndGgpID8gc2V0dGluZ3MuZml4ZWRXb3JkTGVuZ3RoIDogd29yZExlbmd0aDtcbiAgICAgICAgICAgICAgICBsZXQgc2NhblN0YXJ0ID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3Mud29yZFNlbGVjdGlvblJhbmRvbSlcbiAgICAgICAgICAgICAgICAgICAgc2NhblN0YXJ0ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKHdvcmRMZW5ndGggLSBzY2FuRW5kKSk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQgPSB0b3RhbFdvcmRzLnNsaWNlKHNjYW5TdGFydCwgc2NhblN0YXJ0ICsgc2NhbkVuZCkuam9pbignICcpO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzZXR0aW5ncy5wZXJjZW50YWdlVGV4dFRvU2NhbiA+IDAgJiYgc2V0dGluZ3MucGVyY2VudGFnZVRleHRUb1NjYW4gPCAxMDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzY2FuRW5kID0gZG9jdW1lbnQubGVuZ3RoICogKHNldHRpbmdzLnBlcmNlbnRhZ2VUZXh0VG9TY2FuIC8gMTAwKTtcbiAgICAgICAgICAgICAgICBsZXQgc2NhblN0YXJ0ID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3Mud29yZFNlbGVjdGlvblJhbmRvbSlcbiAgICAgICAgICAgICAgICAgICAgc2NhblN0YXJ0ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKDEwMCAtIHNjYW5FbmQpKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudCA9IGRvY3VtZW50LnN1YnN0cmluZyhzY2FuU3RhcnQsIHNjYW5FbmQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkb2N1bWVudCA9IGRvY3VtZW50LnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvW1xcdTIwMDAtXFx1MjA2RlxcdTJFMDAtXFx1MkU3RlxcXFwnIVwiIyQlJigpKissXFwtLi86Ozw9Pj9AW1xcXV5fYHt8fX5dL2csICcnKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXGJcXGR7MSx9XFxiL2csICcnKTtcbiAgICAgICAgICAgIHdvcmRSZWdleGVzLmZvckVhY2god29yZCA9PiB7IGRvY3VtZW50ID0gZG9jdW1lbnQucmVwbGFjZSh3b3JkLCAnJykgfSk7XG4gICAgICAgICAgICBkb2N1bWVudCA9IGRvY3VtZW50LnJlcGxhY2UoL1xcc3syLH0vZywgJyAnKTtcblxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLnN0ZW1taW5nKVxuICAgICAgICAgICAgICAgIGRvY3VtZW50ID0gZG9jdW1lbnQuc3BsaXQoJyAnKS5tYXAod29yZCA9PiBwb3J0ZXJTdGVtbWVyKHdvcmQpKS5qb2luKCcgJyk7XG5cbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC50cmltKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIERvIHRoZSBMREEgbW9kZWwgZml0dGluZ1xuICAgICAgICBjb25zdCBudW1Ub3BpY3MgPSBzZXR0aW5ncy5udW1Ub3BpY3M7XG4gICAgICAgIGNvbnN0IG51bVdvcmRzID0gc2V0dGluZ3MubnVtV29yZHM7XG4gICAgICAgIGNvbnN0IHRocmVzaG9sZCA9IHNldHRpbmdzLnRvcGljVGhyZXNob2xkO1xuICAgICAgICBjb25zdCBpdGVyYXRpb25zID0gc2V0dGluZ3MubGRhSXRlcmF0aW9ucztcbiAgICAgICAgY29uc3QgYnVybmluID0gc2V0dGluZ3MubGRhQnVybkluO1xuICAgICAgICBjb25zdCB0aGluID0gc2V0dGluZ3MubGRhVGhpbjtcblxuICAgICAgICBzdGF0dXNCYXJJdGVtRWwuc2V0VGV4dCgnRmluZGluZyAnICsgbnVtVG9waWNzICsgJyB0b3BpY3MgdG8gbWVldCAnICsgdGhyZXNob2xkICsgJy4uLicpO1xuXG4gICAgICAgIGNvbnN0IGxkYU1vZGVsIDogYW55ID0gbGRhKGRvY3VtZW50cywgbnVtVG9waWNzKTtcbiAgICAgICAgbGRhTW9kZWwuZml0KGl0ZXJhdGlvbnMsIGJ1cm5pbiwgdGhpbik7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGFuIGFycmF5IG9mIHRvcGljcyB3aXRoIGxpbmtzIHRvIGRvY3VtZW50cyB0aGF0IG1lZXQgdGhlIHRocmVzaG9sZFxuICAgICAgICBjb25zdCB0b3BpY0RvY3MgPSBuZXcgQXJyYXkobnVtVG9waWNzKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBudW1Ub3BpY3M7IGorKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkb2N1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzY29yZSA9IHJvdW5kbihsZGFNb2RlbC5hdmdUaGV0YS5nZXQoaSwgaiksIC0zKTtcbiAgICAgICAgICAgICAgICBpZiAoc2NvcmUgPiB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvcGljRG9jc1tqXSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9waWNEb2NzW2pdID0gW107XG4gICAgICAgICAgICAgICAgICAgIHRvcGljRG9jc1tqXS5wdXNoKHsgZG9jOiBmaWxlc1tpXS5iYXNlbmFtZSwgc2NvcmU6IHNjb3JlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdlbmVyYXRlIHRoZSBsaXN0IG9mIHRvcGljIHN0cmluZ3NcbiAgICAgICAgY29uc3QgdG9waWNTdHJpbmdzID0gW107XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtVG9waWNzOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRlcm1zIDogQXJyYXk8YW55PiA9IGxkYU1vZGVsLmdldFRlcm1zKGosIG51bVdvcmRzKTtcbiAgICAgICAgICAgIGNvbnN0IHRvcGljU3RyaW5nID0gYFRvcGljICR7aiArIDF9IC0gJHt0ZXJtcy5tYXAoKHQgOiBhbnkpID0+IHQud29yZCkuam9pbignLScpfWA7XG4gICAgICAgICAgICB0b3BpY1N0cmluZ3MucHVzaCh0b3BpY1N0cmluZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0dXNCYXJJdGVtRWwuc2V0VGV4dChgQ3JlYXRpbmcgdG9waWMgZmlsZXMgd2l0aCAke251bVdvcmRzfSBwZXIgdG9waWMuLi5gKTtcblxuXG4gICAgICAgIGxldCB0b3BpY0RpciA9IGBUb3BpY3NgO1xuICAgICAgICBpZiAoc2V0dGluZ3MudG9waWNJbmNsdWRlUGF0dGVybilcbiAgICAgICAgICAgIHRvcGljRGlyICs9IGAtJHt0b3BpY1BhdGhQYXR0ZXJuLnJlcGxhY2UoL1sqLy4gXS9nLCAnLScpfS0ke3RvcGljU2VhcmNoUGF0dGVybi5yZXBsYWNlKC9bKi8uIF0vZywgJy0nKX1gO1xuICAgICAgICBpZiAoc2V0dGluZ3MudG9waWNJbmNsdWRlVGltZXN0YW1wKVxuICAgICAgICAgICAgdG9waWNEaXIgKz0gYC0ke21vbWVudCgpLmZvcm1hdCgnWVlZWU1NRERoaG1tc3MnKX1gO1xuICAgICAgICB0b3BpY0RpciA9IHRvcGljRGlyLnJlcGxhY2UoLy0tLywgJy0nKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHZhdWx0LmNyZWF0ZUZvbGRlcihub3JtYWxpemVQYXRoKHRvcGljRGlyKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gQWxyZWFkeSBleGlzdHM/IGNvbnRpbnVlIG9uXG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgdGhlIHRvcGljIGZpbGVzXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtVG9waWNzOyBqKyspIHtcblxuICAgICAgICAgICAgY29uc3QgdGVybXMgPSBsZGFNb2RlbC5nZXRUZXJtcyhqLCBudW1Xb3Jkcyk7XG4gICAgICAgICAgICAvLyBObyBhc3NvY2lhdGVkIHRlcm1zIC0gbW92ZSBvblxuICAgICAgICAgICAgaWYgKHRlcm1zWzBdLndvcmQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgY29uc3QgZmlsZU5hbWU6IHN0cmluZyA9IG5vcm1hbGl6ZVBhdGgoYCR7dG9waWNEaXJ9LyR7dG9waWNTdHJpbmdzW2pdfS5tZGApO1xuXG4gICAgICAgICAgICBsZXQgZmlsZVRleHQgPSBgIyBUb3BpYyAke2ogKyAxfVxcblxcbmA7XG4gICAgICAgICAgICBmaWxlVGV4dCArPSBgUmV0dXJuIHRvIFtbVG9waWMgSW5kZXhdXVxcblxcbmA7XG4gICAgICAgICAgICAvLyBmaWxlVGV4dCArPSBgUmV0dXJuIHRvIFtbJHt0b3BpY0Rpcn0vVG9waWMgSW5kZXhdXVxcblxcbmA7XG4gICAgICAgICAgICBmaWxlVGV4dCArPSAnIyMgS2V5d29yZHMgXFxuXFxuJztcblxuICAgICAgICAgICAgZmlsZVRleHQgKz0gJyMjIyMgVGFncyBcXG5cXG4nO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHRlcm1zLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB3b3JkIH0gPSB0ZXJtc1trXTtcbiAgICAgICAgICAgICAgICBmaWxlVGV4dCArPSBgIyR7d29yZH0gYDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmlsZVRleHQgKz0gJ1xcblxcbiMjIyMgVG9waWMtV29yZCBSZWxldmFuY2UgXFxuXFxuJztcblxuICAgICAgICAgICAgZmlsZVRleHQgKz0gYHwgJHsnV29yZCcucGFkRW5kKDIwKX0gfCBQcm9iYWJpbGl0eSAgfFxcbmBcbiAgICAgICAgICAgIGZpbGVUZXh0ICs9IGB8IDokeyctJy5yZXBlYXQoMTkpfSB8ICR7Jy0nLnJlcGVhdCgxMSl9OiB8XFxuYFxuICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCB0ZXJtcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgd29yZCwgcHJvYiB9ID0gdGVybXNba107XG4gICAgICAgICAgICAgICAgZmlsZVRleHQgKz0gYHwgJHsoJyoqJyt3b3JkKycqKicpLnBhZEVuZCgyMCl9IHwgJHtwcm9iLnRvUHJlY2lzaW9uKDIpLnBhZEVuZCgxMSl9IHxcXG5gO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmaWxlVGV4dCArPSBgXFxuXFxuYDtcblxuICAgICAgICAgICAgZmlsZVRleHQgKz0gYCMjIExpbmtzIFxcblxcbmA7XG4gICAgICAgICAgICBjb25zdCB0aGlzVG9waWNEb2NzID0gdG9waWNEb2NzW2pdO1xuICAgICAgICAgICAgaWYgKHRoaXNUb3BpY0RvY3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXNUb3BpY0RvY3Muc29ydCgodGQxIDogYW55LCB0ZDIgOiBhbnkpID0+IHsgcmV0dXJuICh0ZDEuc2NvcmUgPiB0ZDIuc2NvcmUgPyAtMSA6ICh0ZDEuc2NvcmUgPCB0ZDIuc2NvcmUgPyAxIDogMCkpIH0pXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCB0aGlzVG9waWNEb2NzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZG9jLCBzY29yZSB9ID0gdGhpc1RvcGljRG9jc1trXTtcbiAgICAgICAgICAgICAgICAgICAgZmlsZVRleHQgKz0gYCAtIFtbJHtkb2N9XV0gW3JlbGV2YW5jZTogJHtzY29yZS50b1ByZWNpc2lvbigyKX1dYDtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGNoZWNrcyBmb3Igc291cmNlIG9mIHRleHQuIEhhcmQtY29kZWQgdG8gUERGIGZvciBub3dcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBkZk5hbWVzLmluZGV4T2YoZG9jKSA+IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZVRleHQgKz0gYCAoW1ske2RvY30ucGRmfFBERl1dKWA7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVUZXh0ICs9IGBcXG5gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlID0gPFRGaWxlPiB2YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoZmlsZU5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChmaWxlICE9PSB1bmRlZmluZWQgJiYgZmlsZSAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgdmF1bHQubW9kaWZ5KGZpbGUsIGZpbGVUZXh0KTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHZhdWx0LmNyZWF0ZShmaWxlTmFtZSwgZmlsZVRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgdGhlIGluZGV4IGZpbGVcbiAgICAgICAgY29uc3QgdG9waWNGaWxlTmFtZTogc3RyaW5nID0gbm9ybWFsaXplUGF0aChgJHt0b3BpY0Rpcn0vVG9waWMgSW5kZXgubWRgKTtcbiAgICAgICAgbGV0IHRvcGljRmlsZVRleHQgPSBgIyBUb3BpYyBJbmRleFxcblxcbmA7XG4gICAgICAgIHRvcGljRmlsZVRleHQgKz0gYFJlc3VsdHMgYmFzZWQgb24gc2Nhbm5pbmcgZmlsZXMgdGhhdCBtYXRjaCBmaWxlIHBhdGggJyoke3RvcGljUGF0aFBhdHRlcm59KicsIHNlYXJjaCBwYXR0ZXJuICcqJHt0b3BpY1NlYXJjaFBhdHRlcm59KiBhbmQgdGFncyAnKiR7dG9waWNUYWdQYXR0ZXJufSonLlxcblxcbmA7XG4gICAgICAgIHRvcGljRmlsZVRleHQgKz0gYCMjIFRvcGljcyBcXG5cXG5gO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bVRvcGljczsgaisrKSB7XG4gICAgICAgICAgICB0b3BpY0ZpbGVUZXh0ICs9IGAgLSBbWyR7dG9waWNTdHJpbmdzW2pdfV1dXFxuYDtcbiAgICAgICAgICAgIC8vIHRvcGljRmlsZVRleHQgKz0gYCAtIFtbJHt0b3BpY0Rpcn0vJHt0b3BpY1N0cmluZ3Nbal19XV1cXG5gO1xuICAgICAgICB9XG4gICAgICAgIHRvcGljRmlsZVRleHQgKz0gYFxcbiMjIFJlYWRpbmcgTGlzdFxcblxcbmA7XG4gICAgICAgIHRvcGljRmlsZVRleHQgKz0gYCoqTm90ZToqKiB0byByZXRhaW4gdGhpcyBsaXN0LCBjb3B5IHRvIGFub3RoZXIgbG9jYXRpb24gb3IgY2hlY2sgdGhlICdUb3BpYyBGb2xkZXIgVGltZXN0YW1wJyBvcHRpb24gdW5kZXIgJ1NldHRpbmdzJy5cXG5cXG5gO1xuXG4gICAgICAgIGNvbnN0IGZpbGVOYW1lcyA9IGZpbGVzLm1hcChmaWxlID0+IGZpbGUuYmFzZW5hbWUpLnNvcnQoKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBmaWxlTmFtZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHRvcGljRmlsZVRleHQgKz0gYC0gWyBdIFtbJHtmaWxlTmFtZXNbal19XV1cXG5gO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdG9waWNGaWxlID0gPFRGaWxlPiB2YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgodG9waWNGaWxlTmFtZSk7XG4gICAgICAgIGlmICh0b3BpY0ZpbGUgIT09IHVuZGVmaW5lZCAmJiB0b3BpY0ZpbGUgIT09IG51bGwpXG4gICAgICAgICAgICB2YXVsdC5tb2RpZnkodG9waWNGaWxlLCB0b3BpY0ZpbGVUZXh0KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdmF1bHQuY3JlYXRlKHRvcGljRmlsZU5hbWUsIHRvcGljRmlsZVRleHQpO1xuXG4gICAgICAgIHN0YXR1c0Jhckl0ZW1FbC5zZXRUZXh0KGBBbGwgZG9uZSFgKTtcbiAgICB9XG59Il0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQWtCQTtBQWtCQSxtQkFBZ0IsR0FBSTtBQUNuQixhQUFTLE1BQU07QUFBQTtBQU1oQixZQUFPLFVBQVU7QUFBQTtBQUFBOzs7QUMzQ2pCO0FBQUE7QUFrQkE7QUFtQkEsUUFBSSxRQUFRO0FBS1osWUFBTyxVQUFVO0FBQUE7QUFBQTs7O0FDMUNqQjtBQUFBO0FBa0JBO0FBZ0NBLFFBQUksZUFBZSxPQUFPO0FBSzFCLFlBQU8sVUFBVTtBQUFBO0FBQUE7OztBQ3ZEakI7QUFBQTtBQWtCQTtBQUlBLFlBQU8sVUFBVTtBQUFBO0FBQUE7OztBQ3RCakI7QUFBQTtBQWtCQTtBQWdCQSxRQUFJLFVBQVM7QUFLYixZQUFPLFVBQVU7QUFBQTtBQUFBOzs7QUN2Q2pCO0FBQUE7QUFrQkE7QUFlQSxRQUFJLFVBQVM7QUFxQmIsUUFBSSxlQUFlLFFBQU87QUFLMUIsWUFBTyxVQUFVO0FBQUE7QUFBQTs7O0FDM0RqQjtBQUFBO0FBa0JBO0FBSUEsUUFBSSxPQUFPO0FBQ1gsUUFBSSxPQUFPO0FBMkJYLHdCQUFxQixHQUFJO0FBQ3hCLGFBQVEsTUFBTSxRQUFRLE1BQU07QUFBQTtBQU03QixZQUFPLFVBQVU7QUFBQTtBQUFBOzs7QUN6RGpCO0FBQUE7QUFrQkE7QUF5QkEsUUFBSSxhQUFhO0FBS2pCLFlBQU8sVUFBVTtBQUFBO0FBQUE7OztBQ2hEakI7QUFBQTtBQWtCQTtBQTBCQSxRQUFJLFFBQVEsS0FBSztBQUtqQixZQUFPLFVBQVU7QUFBQTtBQUFBOzs7QUNqRGpCO0FBQUE7QUFrQkE7QUF5QkEsUUFBSSxRQUFRO0FBS1osWUFBTyxVQUFVO0FBQUE7QUFBQTs7O0FDaERqQjtBQUFBO0FBa0JBO0FBSUEsUUFBSSxRQUFRO0FBbUJaLHVCQUFvQixHQUFJO0FBQ3ZCLGFBQVEsTUFBTSxPQUFPO0FBQUE7QUFN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
